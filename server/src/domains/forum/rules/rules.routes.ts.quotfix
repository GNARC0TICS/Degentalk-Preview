import { userService } from '@core/services/user.service';
/**
 * Forum Rules Routes
 *
 * Defines API routes for forum rules and user agreements to those rules.
 */

import { Router } from 'express';
import type { Request, Response } from 'express';
import { db } from '@db';
import { count, desc, eq, and, like, sql, inArray } from 'drizzle-orm';
import {
	forumRules,
	userRulesAgreements,
	contentEditStatusEnum,
	type ForumRule,
	type UserRulesAgreement,
	type User
} from '@schema';
import crypto from 'crypto';
import { z } from 'zod';
import { isAuthenticated } from '../../auth/middleware/auth.middleware';
import { storage } from '../../../../storage';
import { asyncHandler } from '@core/errors'; // Assuming asyncHandler is in core errors
import { getUserIdFromRequest } from '@server-utils/auth';
import { 
	sendSuccessResponse,
	sendErrorResponse
} from '@core/utils/transformer.helpers';
import { logger } from '@core/logger";

const router = Router();

// Get all published forum rules
router.get(
	'/',
	asyncHandler(async (req: Request, res: Response) => {
		try {
			const { section, status } = req.query;

			// Build query conditionally based on request
			let query = db.select().from(forumRules);

			// Filter by status (default to 'published' if not specified)
			const ruleStatus = (status as string) || 'published';
			if (ruleStatus && ruleStatus in contentEditStatusEnum.enumValues) {
				query = query.where(eq(forumRules.status, ruleStatus as any));
			}

			// Filter by section if provided
			if (section) {
				query = query.where(eq(forumRules.section, section as string));
			}

			// Execute query and sort by position
			const rules = await query.orderBy(forumRules.position);

			res.status(200);
			return sendSuccessResponse(res, {
				rules,
				count: rules.length
			});
		} catch (error) {
			logger.error('Error fetching forum rules:', error);
			return sendErrorResponse(res, 'Failed to fetch forum rules', 500);
		}
	})
);

// Get a specific rule
router.get(
	'/:id',
	asyncHandler(async (req: Request, res: Response) => {
		try {
			const ruleId = req.params.id;
			if (!ruleId || typeof ruleId !== 'string') {
				return sendErrorResponse(res, 'Invalid rule ID', 400);
			}

			const rule = await storage.getForumRule(ruleId);

			if (!rule) {
				return sendErrorResponse(res, 'Rule not found', 404);
			}

			// Only allow published rules to be viewed, unless the user is an admin
			if (
				rule.status !== 'published' &&
				(!userService.getUserFromRequest(req) ||
					(userService.getUserFromRequest(req) as any).role !== 'admin')
			) {
				// Fixed isAdmin check
				return sendErrorResponse(res, 'This rule is not published', 403);
			}

			res.status(200);
			return sendSuccessResponse(res, rule);
		} catch (error) {
			logger.error('Error fetching forum rule:', error);
			return sendErrorResponse(res, 'Failed to fetch forum rule', 500);
		}
	})
);

// Get user agreements (requires authentication)
router.get(
	'/user-agreements',
	asyncHandler(async (req: Request, res: Response) => {
		if (!req.isAuthenticated() || !userService.getUserFromRequest(req)) {
			return sendErrorResponse(res, 'Authentication required', 401);
		}

		try {
			const userId = getUserIdFromRequest(req);
			if (userId === undefined) {
				// This case should ideally be caught by !req.isAuthenticated() already,
				// but as a safeguard if req.user exists but ID doesn't.
				return sendErrorResponse(res, 'User ID not found after authentication', 401);
			}

			// Get all user rule agreements
			const agreements = await db
				.select()
				.from(userRulesAgreements)
				.where(eq(userRulesAgreements.userId, userId))
				.orderBy(desc(userRulesAgreements.agreedAt));

			// Get all published rules
			const rules = await db.select().from(forumRules).where(eq(forumRules.status, 'published'));

			// Find which rules require agreement
			const requiredRules = rules.filter((rule: ForumRule) => rule.isRequired);

			// Check which required rules have been agreed to
			const agreedRequiredRuleIds = agreements
				.filter((agreement: UserRulesAgreement) => {
					const rule = rules.find((r: ForumRule) => r.id === agreement.ruleId);
					return rule && rule.isRequired;
				})
				.map((agreement: UserRulesAgreement) => agreement.ruleId);

			const allRequiredRulesAgreed = requiredRules.every((rule: ForumRule) =>
				agreedRequiredRuleIds.includes(rule.id)
			);

			res.status(200);
			return sendSuccessResponse(res, {
				agreements,
				requiredRules,
				allRequiredRulesAgreed,
				requiresAction: !allRequiredRulesAgreed
			});
		} catch (error) {
			logger.error('Error fetching user rule agreements:', error);
			return sendErrorResponse(res, 'Failed to fetch user rule agreements', 500);
		}
	})
);

// Agree to rules (requires authentication)
router.post(
	'/agree',
	asyncHandler(async (req: Request, res: Response) => {
		if (!req.isAuthenticated() || !userService.getUserFromRequest(req)) {
			return sendErrorResponse(res, 'Authentication required', 401);
		}

		// Validate request body using Zod
		const agreeSchema = z.object({
			ruleIds: z.array(z.string().uuid('Invalid ruleId format'))
		});

		const parsed = agreeSchema.safeParse(req.body);
		if (!parsed.success) {
			return sendErrorResponse(res, 'Invalid request body', 400, {
				details: parsed.error.issues
			});
		}

		const { ruleIds } = parsed.data;

		try {
			const userId = getUserIdFromRequest(req);
			if (userId === undefined) {
				// This case should ideally be caught by !req.isAuthenticated() already.
				return sendErrorResponse(res, 'User ID not found after authentication', 401);
			}

			// Get rules
			const rules = await db
				.select()
				.from(forumRules)
				.where(and(inArray(forumRules.id, ruleIds), eq(forumRules.status, 'published')));

			if (rules.length !== ruleIds.length) {
				return sendErrorResponse(res, 'One or more rules not found or not published', 404);
			}

			// Get existing agreements
			const existingAgreements = await db
				.select()
				.from(userRulesAgreements)
				.where(
					and(eq(userRulesAgreements.userId, userId), inArray(userRulesAgreements.ruleId, ruleIds))
				);

			// Create map of existing agreements for faster lookup
			const existingAgreementMap = new Map<number, UserRulesAgreement>();
			existingAgreements.forEach((agreement: UserRulesAgreement) => {
				existingAgreementMap.set(agreement.ruleId, agreement);
			});

			// Process each rule agreement
			for (const rule of rules) {
				const existingAgreement = existingAgreementMap.get(rule.id);

				// If agreement already exists and hash is the same, skip
				if (existingAgreement && existingAgreement.versionHash === rule.versionHash) {
					continue;
				}

				// If agreement exists but hash is different (rule was updated), update the agreement
				if (existingAgreement) {
					await db
						.update(userRulesAgreements)
						.set({
							versionHash: rule.versionHash,
							agreedAt: new Date()
						})
						.where(
							and(
								eq(userRulesAgreements.userId, existingAgreement.userId),
								eq(userRulesAgreements.ruleId, existingAgreement.ruleId)
							)
						);

					// Also update the rule's lastAgreedVersionHash if not already set
					if (!rule.lastAgreedVersionHash) {
						await db
							.update(forumRules)
							.set({ lastAgreedVersionHash: rule.versionHash })
							.where(eq(forumRules.id, rule.id));
					}
				}
				// If no agreement exists, create a new one
				else {
					await db.insert(userRulesAgreements).values({
						userId,
						ruleId: rule.id,
						versionHash: rule.versionHash,
						agreedAt: new Date()
					});

					// Also update the rule's lastAgreedVersionHash if not already set
					if (!rule.lastAgreedVersionHash) {
						await db
							.update(forumRules)
							.set({ lastAgreedVersionHash: rule.versionHash })
							.where(eq(forumRules.id, rule.id));
					}
				}
			}

			res.status(200);
			return sendSuccessResponse(res, {
				success: true,
				ruleIds
			}, 'Successfully agreed to rules');
		} catch (error) {
			logger.error('Error agreeing to rules:', error);
			return sendErrorResponse(res, 'Failed to process rule agreements', 500);
		}
	})
);

export default router;
