import { db } from '@db';
import { customEmojis, users } from '@schema';
import { and, asc, desc, eq, ilike, inArray, sql } from 'drizzle-orm';
import { logger } from '@core/logger';
import type { Id } from '@shared/types/ids';

export interface ListEmojisOptions {
	category?: string;
	type?: 'static' | 'lottie';
	unlockType?: 'free' | 'purchase' | 'path_unlock' | 'admin_grant';
	isLocked?: boolean;
	includeDeleted?: boolean;
	limit?: number;
	offset?: number;
	sortBy?: 'name' | 'createdAt' | 'category' | 'type';
	sortOrder?: 'asc' | 'desc';
}

export interface CreateEmojiData {
	name: string;
	code: string;
	type: 'static' | 'lottie';
	url: string;
	previewUrl?: string;
	category?: string;
	isLocked?: boolean;
	unlockType?: 'free' | 'purchase' | 'path_unlock' | 'admin_grant';
	priceDgt?: number;
	requiredPath?: string;
	requiredPathXP?: number;
	xpValue?: number;
	cloutValue?: number;
	createdBy?: number;
}

export interface UpdateEmojiData {
	name?: string;
	code?: string;
	type?: 'static' | 'lottie';
	url?: string;
	previewUrl?: string;
	category?: string;
	isLocked?: boolean;
	unlockType?: 'free' | 'purchase' | 'path_unlock' | 'admin_grant';
	priceDgt?: number;
	requiredPath?: string;
	requiredPathXP?: number;
	xpValue?: number;
	cloutValue?: number;
}

// Helper function to normalize field names from frontend
function normalizeEmojiData(rawData: any): CreateEmojiData {
	return {
		name: rawData.name,
		code: rawData.code,
		type: rawData.type,
		url: rawData.url,
		previewUrl: rawData.previewUrl || rawData.preview_url,
		category: rawData.category,
		isLocked: rawData.isLocked !== undefined ? rawData.isLocked : rawData.is_locked,
		unlockType: rawData.unlockType || rawData.unlock_type,
		priceDgt: rawData.priceDgt || rawData.price_dgt,
		requiredPath: rawData.requiredPath || rawData.required_path,
		requiredPathXP: rawData.requiredPathXP || rawData.required_path_xp,
		xpValue: rawData.xpValue || rawData.xp_value,
		cloutValue: rawData.cloutValue || rawData.clout_value,
		createdBy: rawData.createdBy || rawData.created_by
	};
}

export const emojiService = {
	/**
	 * Get all emojis with filtering and pagination
	 */
	async getAll(options: ListEmojisOptions = {}) {
		try {
			logger.info('EMOJI_SERVICE', 'Fetching emojis with options:', options);

			const {
				category,
				type,
				unlockType,
				isLocked,
				includeDeleted = false,
				limit = 50,
				offset = 0,
				sortBy = 'createdAt',
				sortOrder = 'desc'
			} = options;

			// Build WHERE conditions
			const conditions = [];

			if (!includeDeleted) {
				conditions.push(eq(customEmojis.isDeleted, false));
			}

			if (category) {
				conditions.push(eq(customEmojis.category, category));
			}

			if (type) {
				conditions.push(eq(customEmojis.type, type));
			}

			if (unlockType) {
				conditions.push(eq(customEmojis.unlockType, unlockType));
			}

			if (isLocked !== undefined) {
				conditions.push(eq(customEmojis.isLocked, isLocked));
			}

			// Build ORDER BY
			const sortColumn = customEmojis[sortBy];
			const orderBy = sortOrder === 'asc' ? asc(sortColumn) : desc(sortColumn);

			// Execute query with joins to get creator info
			const emojis = await db
				.select({
					id: customEmojis.id,
					name: customEmojis.name,
					code: customEmojis.code,
					type: customEmojis.type,
					url: customEmojis.url,
					previewUrl: customEmojis.previewUrl,
					category: customEmojis.category,
					isLocked: customEmojis.isLocked,
					unlockType: customEmojis.unlockType,
					priceDgt: customEmojis.priceDgt,
					requiredPath: customEmojis.requiredPath,
					requiredPathXP: customEmojis.requiredPathXP,
					xpValue: customEmojis.xpValue,
					cloutValue: customEmojis.cloutValue,
					createdAt: customEmojis.createdAt,
					updatedAt: customEmojis.updatedAt,
					createdBy: customEmojis.createdBy,
					isDeleted: customEmojis.isDeleted,
					deletedAt: customEmojis.deletedAt,
					creatorUsername: users.username
				})
				.from(customEmojis)
				.leftJoin(users, eq(customEmojis.createdBy, users.id))
				.where(conditions.length > 0 ? and(...conditions) : undefined)
				.orderBy(orderBy)
				.limit(limit)
				.offset(offset);

			// Get total count for pagination
			const totalCountResult = await db
				.select({ count: sql<number>`count(*)` })
				.from(customEmojis)
				.where(conditions.length > 0 ? and(...conditions) : undefined);

			const totalCount = totalCountResult[0]?.count || 0;

			logger.info('EMOJI_SERVICE', `Fetched ${emojis.length} emojis (${totalCount} total)`);

			return {
				emojis,
				pagination: {
					total: totalCount,
					limit,
					offset,
					hasMore: offset + limit < totalCount
				}
			};
		} catch (error) {
			logger.error('EMOJI_SERVICE', 'Error fetching emojis:', error);
			throw error;
		}
	},

	/**
	 * Get a single emoji by ID
	 */
	async getById(id: Id<'id'>) {
		try {
			logger.info('EMOJI_SERVICE', `Fetching emoji with ID: ${id}`);

			const result = await db
				.select({
					id: customEmojis.id,
					name: customEmojis.name,
					code: customEmojis.code,
					type: customEmojis.type,
					url: customEmojis.url,
					previewUrl: customEmojis.previewUrl,
					category: customEmojis.category,
					isLocked: customEmojis.isLocked,
					unlockType: customEmojis.unlockType,
					priceDgt: customEmojis.priceDgt,
					requiredPath: customEmojis.requiredPath,
					requiredPathXP: customEmojis.requiredPathXP,
					xpValue: customEmojis.xpValue,
					cloutValue: customEmojis.cloutValue,
					createdAt: customEmojis.createdAt,
					updatedAt: customEmojis.updatedAt,
					createdBy: customEmojis.createdBy,
					isDeleted: customEmojis.isDeleted,
					deletedAt: customEmojis.deletedAt,
					creatorUsername: users.username
				})
				.from(customEmojis)
				.leftJoin(users, eq(customEmojis.createdBy, users.id))
				.where(eq(customEmojis.id, id))
				.limit(1);

			const emoji = result[0] || null;

			if (emoji) {
				logger.info('EMOJI_SERVICE', `Found emoji: ${emoji.name}`);
			} else {
				logger.warn('EMOJI_SERVICE', `Emoji with ID ${id} not found`);
			}

			return emoji;
		} catch (error) {
			logger.error('EMOJI_SERVICE', `Error fetching emoji with ID ${id}:`, error);
			throw error;
		}
	},

	/**
	 * Create a new emoji
	 */
	async create(rawEmojiData: any) {
		try {
			// Normalize field names from frontend (handle both camelCase and snake_case)
			const emojiData = normalizeEmojiData(rawEmojiData);

			logger.info('EMOJI_SERVICE', 'Creating emoji:', {
				name: emojiData.name,
				type: emojiData.type
			});

			// Check if emoji with this name or code already exists
			const existing = await db
				.select({ id: customEmojis.id, name: customEmojis.name, code: customEmojis.code })
				.from(customEmojis)
				.where(
					and(
						eq(customEmojis.isDeleted, false),
						sql`(${customEmojis.name} = ${emojiData.name} OR ${customEmojis.code} = ${emojiData.code})`
					)
				)
				.limit(1);

			if (existing.length > 0) {
				const conflict = existing[0];
				const conflictType = conflict.name === emojiData.name ? 'name' : 'code';
				throw new Error(
					`Emoji with this ${conflictType} already exists: ${conflict[conflictType]}`
				);
			}

			const result = await db
				.insert(customEmojis)
				.values({
					...emojiData,
					createdAt: new Date(),
					updatedAt: new Date()
				})
				.returning();

			const newEmoji = result[0];
			logger.info(
				'EMOJI_SERVICE',
				`Successfully created emoji: ${newEmoji.name} (ID: ${newEmoji.id})`
			);

			return newEmoji;
		} catch (error) {
			logger.error('EMOJI_SERVICE', 'Error creating emoji:', error);
			throw error;
		}
	},

	/**
	 * Update an existing emoji
	 */
	async update(id: Id<'id'>, emojiData: UpdateEmojiData) {
		try {
			logger.info('EMOJI_SERVICE', `Updating emoji with ID: ${id}`, emojiData);

			// Check if emoji exists and is not deleted
			const existing = await this.getById(id);
			if (!existing || existing.isDeleted) {
				throw new Error(`Emoji with ID ${id} not found`);
			}

			// Check for name/code conflicts if they're being updated
			if (emojiData.name || emojiData.code) {
				const conditions = [];
				if (emojiData.name) conditions.push(eq(customEmojis.name, emojiData.name));
				if (emojiData.code) conditions.push(eq(customEmojis.code, emojiData.code));

				const conflicting = await db
					.select({ id: customEmojis.id, name: customEmojis.name, code: customEmojis.code })
					.from(customEmojis)
					.where(
						and(
							eq(customEmojis.isDeleted, false),
							sql`${customEmojis.id} != ${id}`,
							sql`(${conditions.join(' OR ')})`
						)
					)
					.limit(1);

				if (conflicting.length > 0) {
					const conflict = conflicting[0];
					const conflictType = conflict.name === emojiData.name ? 'name' : 'code';
					throw new Error(
						`Another emoji already uses this ${conflictType}: ${conflict[conflictType]}`
					);
				}
			}

			const result = await db
				.update(customEmojis)
				.set({
					...emojiData,
					updatedAt: new Date()
				})
				.where(eq(customEmojis.id, id))
				.returning();

			const updatedEmoji = result[0];
			if (!updatedEmoji) {
				throw new Error(`Failed to update emoji with ID ${id}`);
			}

			logger.info('EMOJI_SERVICE', `Successfully updated emoji: ${updatedEmoji.name} (ID: ${id})`);
			return updatedEmoji;
		} catch (error) {
			logger.error('EMOJI_SERVICE', `Error updating emoji with ID ${id}:`, error);
			throw error;
		}
	},

	/**
	 * Soft delete an emoji
	 */
	async delete(id: Id<'id'>) {
		try {
			logger.info('EMOJI_SERVICE', `Deleting emoji with ID: ${id}`);

			// Check if emoji exists and is not already deleted
			const existing = await this.getById(id);
			if (!existing) {
				throw new Error(`Emoji with ID ${id} not found`);
			}
			if (existing.isDeleted) {
				throw new Error(`Emoji with ID ${id} is already deleted`);
			}

			const result = await db
				.update(customEmojis)
				.set({
					isDeleted: true,
					deletedAt: new Date(),
					updatedAt: new Date()
				})
				.where(eq(customEmojis.id, id))
				.returning();

			const deletedEmoji = result[0];
			if (!deletedEmoji) {
				throw new Error(`Failed to delete emoji with ID ${id}`);
			}

			logger.info('EMOJI_SERVICE', `Successfully deleted emoji: ${existing.name} (ID: ${id})`);
			return deletedEmoji;
		} catch (error) {
			logger.error('EMOJI_SERVICE', `Error deleting emoji with ID ${id}:`, error);
			throw error;
		}
	},

	/**
	 * Bulk delete multiple emojis
	 */
	async bulkDelete(ids: number[]) {
		try {
			logger.info('EMOJI_SERVICE', `Bulk deleting emojis with IDs: [${ids.join(', ')}]`);

			const result = await db
				.update(customEmojis)
				.set({
					isDeleted: true,
					deletedAt: new Date(),
					updatedAt: new Date()
				})
				.where(and(inArray(customEmojis.id, ids), eq(customEmojis.isDeleted, false)))
				.returning({ id: customEmojis.id, name: customEmojis.name });

			logger.info('EMOJI_SERVICE', `Successfully bulk deleted ${result.length} emojis`);
			return result;
		} catch (error) {
			logger.error('EMOJI_SERVICE', 'Error bulk deleting emojis:', error);
			throw error;
		}
	},

	/**
	 * Get unique categories
	 */
	async getCategories() {
		try {
			const result = await db
				.selectDistinct({ category: customEmojis.category })
				.from(customEmojis)
				.where(eq(customEmojis.isDeleted, false))
				.orderBy(asc(customEmojis.category));

			const categories = result.map((r) => r.category).filter(Boolean);
			logger.info('EMOJI_SERVICE', `Found ${categories.length} emoji categories`);

			return categories;
		} catch (error) {
			logger.error('EMOJI_SERVICE', 'Error fetching emoji categories:', error);
			throw error;
		}
	}
};
