import { eq, and, or, like, inArray, gte, lte, desc, asc, sql } from 'drizzle-orm';
import type { NodePgDatabase } from 'drizzle-orm/node-postgres';
import { db } from '../../../../core/db';
import {
	uiQuotes,
	uiCollections,
	uiCollectionQuotes,
	uiAnalytics,
	type UiQuote,
	type NewUiQuote,
	type UiCollection,
	type NewUiCollection
} from '@schema/admin/uiConfig';
import {
	type CreateQuoteRequest,
	type UpdateQuoteRequest,
	type QuoteFilters,
	type QuotesResponse,
	type ReorderQuotesRequest,
	type CreateCollectionRequest,
	type UpdateCollectionRequest,
	type QuoteAnalyticsRequest,
	type QuoteAnalyticsResponse,
	type BulkQuoteOperation,
	type ImportQuotesRequest,
	type ExportQuotesRequest,
	type PaginationOptions,
	type UiConfigService as IUiConfigService
} from './ui-config.types';
import { logger } from "../../../../core/logger";

export class UiConfigService implements IUiConfigService {
	/**
	 * Get quotes with filtering, pagination, and sorting
	 */
	async getQuotes(
		filters?: QuoteFilters,
		pagination: PaginationOptions = {}
	): Promise<QuotesResponse> {
		const { page = 1, limit = 50, sortBy = 'displayOrder', sortOrder = 'asc' } = pagination;
		const offset = (page - 1) * limit;

		// Build WHERE conditions
		const conditions = [];

		if (filters?.type) {
			conditions.push(inArray(uiQuotes.type, filters.type));
		}

		if (filters?.tags && filters.tags.length > 0) {
			// PostgreSQL array overlap operator
			conditions.push(sql`${uiQuotes.tags} && ${filters.tags}`);
		}

		if (filters?.intensity) {
			conditions.push(inArray(uiQuotes.intensity, filters.intensity));
		}

		if (filters?.theme) {
			conditions.push(inArray(uiQuotes.theme, filters.theme));
		}

		if (filters?.targetAudience) {
			conditions.push(inArray(uiQuotes.targetAudience, filters.targetAudience));
		}

		if (filters?.isActive !== undefined) {
			conditions.push(eq(uiQuotes.isActive, filters.isActive));
		}

		if (filters?.searchTerm) {
			const searchTerm = `%${filters.searchTerm}%`;
			conditions.push(
				or(like(uiQuotes.headline, searchTerm), like(uiQuotes.subheader, searchTerm))
			);
		}

		if (filters?.startDate) {
			conditions.push(gte(uiQuotes.createdAt, filters.startDate));
		}

		if (filters?.endDate) {
			conditions.push(lte(uiQuotes.createdAt, filters.endDate));
		}

		const whereClause = conditions.length > 0 ? and(...conditions) : undefined;

		// Get total count
		const [{ count }] = await db
			.select({ count: sql<number>`count(*)` })
			.from(uiQuotes)
			.where(whereClause);

		// Get quotes with proper sorting
		let orderByClause;
		switch (sortBy) {
			case 'displayOrder':
				orderByClause =
					sortOrder === 'desc' ? desc(uiQuotes.displayOrder) : asc(uiQuotes.displayOrder);
				break;
			case 'createdAt':
				orderByClause = sortOrder === 'desc' ? desc(uiQuotes.createdAt) : asc(uiQuotes.createdAt);
				break;
			case 'updatedAt':
				orderByClause = sortOrder === 'desc' ? desc(uiQuotes.updatedAt) : asc(uiQuotes.updatedAt);
				break;
			case 'headline':
				orderByClause = sortOrder === 'desc' ? desc(uiQuotes.headline) : asc(uiQuotes.headline);
				break;
			case 'type':
				orderByClause = sortOrder === 'desc' ? desc(uiQuotes.type) : asc(uiQuotes.type);
				break;
			case 'intensity':
				orderByClause = sortOrder === 'desc' ? desc(uiQuotes.intensity) : asc(uiQuotes.intensity);
				break;
			default:
				orderByClause = asc(uiQuotes.displayOrder);
		}

		const quotes = await db
			.select()
			.from(uiQuotes)
			.where(whereClause)
			.orderBy(orderByClause)
			.limit(limit)
			.offset(offset);

		return {
			quotes,
			total: count,
			page,
			limit,
			filters: filters || {}
		};
	}

	/**
	 * Get a single quote by ID
	 */
	async getQuoteById(id: string): Promise<UiQuote | null> {
		const [quote] = await db.select().from(uiQuotes).where(eq(uiQuotes.id, id)).limit(1);

		return quote || null;
	}

	/**
	 * Create a new quote
	 */
	async createQuote(data: CreateQuoteRequest, userId: string): Promise<UiQuote> {
		const newQuote: NewUiQuote = {
			...data,
			createdBy: userId,
			updatedAt: new Date()
		};

		const [quote] = await db.insert(uiQuotes).values(newQuote).returning();

		return quote;
	}

	/**
	 * Update an existing quote
	 */
	async updateQuote(data: UpdateQuoteRequest, userId: string): Promise<UiQuote> {
		const { id, ...updateData } = data;

		const [quote] = await db
			.update(uiQuotes)
			.set({
				...updateData,
				updatedAt: new Date()
			})
			.where(eq(uiQuotes.id, id))
			.returning();

		if (!quote) {
			throw new Error('Quote not found');
		}

		return quote;
	}

	/**
	 * Delete a quote
	 */
	async deleteQuote(id: string): Promise<boolean> {
		const result = await db.delete(uiQuotes).where(eq(uiQuotes.id, id));

		return result.rowCount > 0;
	}

	/**
	 * Reorder multiple quotes
	 */
	async reorderQuotes(data: ReorderQuotesRequest): Promise<boolean> {
		try {
			await db.transaction(async (tx: any) => {
				for (const { id, displayOrder } of data.quoteOrders) {
					await tx
						.update(uiQuotes)
						.set({
							displayOrder,
							updatedAt: new Date()
						})
						.where(eq(uiQuotes.id, id));
				}
			});
			return true;
		} catch (error) {
			logger.error('Error reordering quotes:', error);
			return false;
		}
	}

	/**
	 * Get all collections
	 */
	async getCollections(): Promise<UiCollection[]> {
		return await db
			.select()
			.from(uiCollections)
			.orderBy(desc(uiCollections.priority), asc(uiCollections.name));
	}

	/**
	 * Create a new collection
	 */
	async createCollection(data: CreateCollectionRequest, userId: string): Promise<UiCollection> {
		const newCollection: NewUiCollection = {
			...data,
			createdBy: userId
		};

		const [collection] = await db.insert(uiCollections).values(newCollection).returning();

		// If quoteIds provided, link them to the collection
		if (data.quoteIds && data.quoteIds.length > 0) {
			const collectionQuotes = data.quoteIds.map((quoteId, index) => ({
				collectionId: collection.id,
				quoteId,
				orderInCollection: index
			}));

			await db.insert(uiCollectionQuotes).values(collectionQuotes);
		}

		return collection;
	}

	/**
	 * Update a collection
	 */
	async updateCollection(data: UpdateCollectionRequest, userId: string): Promise<UiCollection> {
		const { id, quoteIds, ...updateData } = data;

		const [collection] = await db
			.update(uiCollections)
			.set({
				...updateData,
				updatedAt: new Date()
			})
			.where(eq(uiCollections.id, id))
			.returning();

		if (!collection) {
			throw new Error('Collection not found');
		}

		// Update quote associations if provided
		if (quoteIds) {
			await db.transaction(async (tx: any) => {
				// Remove existing associations
				await tx.delete(uiCollectionQuotes).where(eq(uiCollectionQuotes.collectionId, id));

				// Add new associations
				if (quoteIds.length > 0) {
					const collectionQuotes = quoteIds.map((quoteId, index) => ({
						collectionId: id,
						quoteId,
						orderInCollection: index
					}));

					await tx.insert(uiCollectionQuotes).values(collectionQuotes);
				}
			});
		}

		return collection;
	}

	/**
	 * Delete a collection
	 */
	async deleteCollection(id: string): Promise<boolean> {
		const result = await db.delete(uiCollections).where(eq(uiCollections.id, id));

		return result.rowCount > 0;
	}

	/**
	 * Track a quote event for analytics
	 */
	async trackQuoteEvent(
		quoteId: string,
		eventType: string,
		context: Record<string, any>
	): Promise<void> {
		await db.insert(uiAnalytics).values({
			quoteId,
			eventType,
			userId: context.userId || null,
			sessionId: context.sessionId || null,
			page: context.page || null,
			position: context.position || null,
			userAgent: context.userAgent || null,
			metadata: context.metadata || {}
		});

		// Update quote impression/click counters
		if (eventType === 'impression') {
			await db
				.update(uiQuotes)
				.set({
					impressions: sql`${uiQuotes.impressions} + 1`
				})
				.where(eq(uiQuotes.id, quoteId));
		} else if (eventType === 'click') {
			await db
				.update(uiQuotes)
				.set({
					clicks: sql`${uiQuotes.clicks} + 1`
				})
				.where(eq(uiQuotes.id, quoteId));
		}
	}

	/**
	 * Get analytics for quotes
	 */
	async getQuoteAnalytics(request: QuoteAnalyticsRequest): Promise<QuoteAnalyticsResponse> {
		const { quoteId, eventType, startDate, endDate, page, position } = request;

		if (!quoteId) {
			throw new Error('Quote ID is required for analytics');
		}

		// Build conditions
		const conditions = [eq(uiAnalytics.quoteId, quoteId)];

		if (eventType) {
			conditions.push(eq(uiAnalytics.eventType, eventType));
		}

		if (startDate) {
			conditions.push(gte(uiAnalytics.timestamp, startDate));
		}

		if (endDate) {
			conditions.push(lte(uiAnalytics.timestamp, endDate));
		}

		if (page) {
			conditions.push(eq(uiAnalytics.page, page));
		}

		if (position) {
			conditions.push(eq(uiAnalytics.position, position));
		}

		// Get quote data
		const quote = await this.getQuoteById(quoteId);
		if (!quote) {
			throw new Error('Quote not found');
		}

		// Calculate click-through rate
		const impressions = quote.impressions || 0;
		const clicks = quote.clicks || 0;
		const clickThroughRate = impressions > 0 ? (clicks / impressions) * 100 : 0;

		// Get top pages and positions
		const [topPages, topPositions] = await Promise.all([
			db
				.select({
					page: uiAnalytics.page,
					count: sql<number>`count(*)`
				})
				.from(uiAnalytics)
				.where(and(...conditions))
				.groupBy(uiAnalytics.page)
				.orderBy(desc(sql`count(*)`))
				.limit(10),

			db
				.select({
					position: uiAnalytics.position,
					count: sql<number>`count(*)`
				})
				.from(uiAnalytics)
				.where(and(...conditions))
				.groupBy(uiAnalytics.position)
				.orderBy(desc(sql`count(*)`))
				.limit(10)
		]);

		return {
			quoteId,
			totalImpressions: impressions,
			totalClicks: clicks,
			clickThroughRate: Math.round(clickThroughRate * 100) / 100,
			topPages: topPages.map((p: any) => ({ page: p.page || 'unknown', count: p.count })),
			topPositions: topPositions.map((p: any) => ({
				position: p.position || 'unknown',
				count: p.count
			})),
			dateRange: {
				start: startDate || new Date(0),
				end: endDate || new Date()
			}
		};
	}

	/**
	 * Bulk update quotes
	 */
	async bulkUpdateQuotes(operation: BulkQuoteOperation): Promise<boolean> {
		try {
			const { action, quoteIds, data } = operation;

			switch (action) {
				case 'activate':
					await db
						.update(uiQuotes)
						.set({
							isActive: true,
							updatedAt: new Date()
						})
						.where(inArray(uiQuotes.id, quoteIds));
					break;

				case 'deactivate':
					await db
						.update(uiQuotes)
						.set({
							isActive: false,
							updatedAt: new Date()
						})
						.where(inArray(uiQuotes.id, quoteIds));
					break;

				case 'delete':
					await db.delete(uiQuotes).where(inArray(uiQuotes.id, quoteIds));
					break;

				case 'update_tags':
				case 'update_intensity':
					if (data) {
						await db
							.update(uiQuotes)
							.set({
								...data,
								updatedAt: new Date()
							})
							.where(inArray(uiQuotes.id, quoteIds));
					}
					break;

				default:
					throw new Error(`Unknown bulk action: ${action}`);
			}

			return true;
		} catch (error) {
			logger.error('Error in bulk operation:', error);
			return false;
		}
	}

	/**
	 * Import quotes from external source
	 */
	async importQuotes(
		data: ImportQuotesRequest,
		userId: string
	): Promise<{ imported: number; skipped: number }> {
		let imported = 0;
		let skipped = 0;

		await db.transaction(async (tx: any) => {
			for (const quoteData of data.quotes) {
				try {
					// Check for duplicates if not overwriting
					if (!data.overwriteExisting) {
						const [existing] = await tx
							.select()
							.from(uiQuotes)
							.where(
								and(eq(uiQuotes.headline, quoteData.headline), eq(uiQuotes.type, quoteData.type))
							)
							.limit(1);

						if (existing) {
							skipped++;
							continue;
						}
					}

					await tx.insert(uiQuotes).values({
						...quoteData,
						createdBy: userId
					});

					imported++;
				} catch (error) {
					logger.error('Error importing quote:', error);
					skipped++;
				}
			}
		});

		return { imported, skipped };
	}

	/**
	 * Export quotes to various formats
	 */
	async exportQuotes(request: ExportQuotesRequest): Promise<Buffer | string> {
		const { filters, format = 'json', includeAnalytics = false } = request;

		const { quotes } = await this.getQuotes(filters, { limit: 10000 });

		if (format === 'json') {
			const exportData = includeAnalytics
				? await Promise.all(
						quotes.map(async (quote) => {
							const analytics = await this.getQuoteAnalytics({ quoteId: quote.id });
							return { ...quote, analytics };
						})
					)
				: quotes;

			return JSON.stringify(exportData, null, 2);
		}

		if (format === 'csv') {
			// Simple CSV implementation
			const headers = [
				'id',
				'type',
				'headline',
				'subheader',
				'tags',
				'intensity',
				'theme',
				'isActive',
				'impressions',
				'clicks',
				'createdAt'
			];

			const rows = quotes.map((quote) => [
				quote.id,
				quote.type,
				`"${quote.headline}"`,
				`"${quote.subheader || ''}"`,
				`"${quote.tags?.join(';') || ''}"`,
				quote.intensity,
				quote.theme || '',
				quote.isActive,
				quote.impressions,
				quote.clicks,
				quote.createdAt?.toISOString()
			]);

			const csv = [headers, ...rows].map((row) => row.join(',')).join('\n');

			return Buffer.from(csv, 'utf8');
		}

		throw new Error(`Unsupported export format: ${format}`);
	}
}

// Export singleton instance
export const uiConfigService = new UiConfigService();
