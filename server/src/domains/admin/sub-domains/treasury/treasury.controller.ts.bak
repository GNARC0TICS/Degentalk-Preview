import type { Request, Response } from 'express';
import { userService } from '@server/src/core/services/user.service';
import { adminTreasuryService } from './treasury.service';
import { AdminError, AdminErrorCodes } from '../../admin.errors';
import { getUserId } from '../../admin.middleware';
import { adminController } from '../../admin.controller';
import {
	TreasuryDepositSchema,
	TreasuryWithdrawalSchema,
	TreasurySettingsUpdateSchema,
	MassAirdropSchema,
	type TreasuryDepositInput,
	type TreasuryWithdrawalInput,
	type TreasurySettingsUpdateInput,
	type MassAirdropInput
} from './treasury.validators';
import { validateRequestBody } from '../../admin.validation';

export class AdminTreasuryController {
	async getDgtSupplyStats(req: Request, res: Response) {
		try {
			const stats = await adminTreasuryService.getDgtSupplyStats();
			res.json(stats);
		} catch (error) {
			if (error instanceof AdminError) {
				return res.status(error.httpStatus).json({ error: error.message, code: error.code });
			}
			res.status(500).json({ error: 'Failed to get DGT supply statistics' });
		}
	}

	async sendFromTreasury(req: Request, res: Response) {
		try {
			const data = validateRequestBody(req, res, TreasuryDepositSchema);
			if (!data) return;
			const adminId = userService.getUserFromRequest(req);
			const result = await adminTreasuryService.sendFromTreasury(data, adminId);

			await adminController.logAction(req, 'TREASURY_SEND', 'treasury', data.userId.toString(), {
				amount: data.amount,
				recipientUserId: data.userId,
				description: data.description
			});
			res.json({ message: 'DGT sent from treasury successfully', data: result });
		} catch (error) {
			if (error instanceof AdminError) {
				return res
					.status(error.httpStatus)
					.json({ error: error.message, code: error.code, details: error.details });
			}
			res.status(500).json({ error: 'Failed to send DGT from treasury' });
		}
	}

	async recoverToTreasury(req: Request, res: Response) {
		try {
			const data = validateRequestBody(req, res, TreasuryWithdrawalSchema);
			if (!data) return;
			const adminId = userService.getUserFromRequest(req);
			const result = await adminTreasuryService.recoverToTreasury(data, adminId);

			await adminController.logAction(req, 'TREASURY_RECOVER', 'treasury', data.userId.toString(), {
				amount: data.amount,
				sourceUserId: data.userId,
				description: data.description
			});
			res.json({ message: 'DGT recovered to treasury successfully', data: result });
		} catch (error) {
			if (error instanceof AdminError) {
				return res
					.status(error.httpStatus)
					.json({ error: error.message, code: error.code, details: error.details });
			}
			res.status(500).json({ error: 'Failed to recover DGT to treasury' });
		}
	}

	async massAirdrop(req: Request, res: Response) {
		try {
			const dataAirdrop = validateRequestBody(req, res, MassAirdropSchema);
			if (!dataAirdrop) return;
			const adminId = userService.getUserFromRequest(req);
			const result = await adminTreasuryService.massAirdrop(dataAirdrop, adminId);

			await adminController.logAction(req, 'TREASURY_MASS_AIRDROP', 'treasury', 'multiple_users', {
				amountPerUser: dataAirdrop.amountPerUser,
				userCount: dataAirdrop.userIds.length,
				reason: dataAirdrop.reason,
				missingUserIds: result.missingUserIds
			});
			res.json({ message: 'Mass airdrop process completed.', data: result });
		} catch (error) {
			if (error instanceof AdminError) {
				return res
					.status(error.httpStatus)
					.json({ error: error.message, code: error.code, details: error.details });
			}
			res.status(500).json({ error: 'Failed to process mass airdrop' });
		}
	}

	async getTreasurySettings(req: Request, res: Response) {
		try {
			const settings = await adminTreasuryService.getDgtEconomyParameters();
			if (!settings) {
				throw new AdminError('Treasury settings not found.', 404, AdminErrorCodes.NOT_FOUND);
			}
			res.json(settings);
		} catch (error) {
			if (error instanceof AdminError) {
				return res.status(error.httpStatus).json({ error: error.message, code: error.code });
			}
			res.status(500).json({ error: 'Failed to get treasury settings' });
		}
	}

	async updateTreasurySettings(req: Request, res: Response) {
		try {
			const dataSettings = validateRequestBody(req, res, TreasurySettingsUpdateSchema);
			if (!dataSettings) return;
			const adminId = userService.getUserFromRequest(req);
			const result = await adminTreasuryService.updateDgtEconomyParameters(dataSettings, adminId);

			await adminController.logAction(
				req,
				'TREASURY_SETTINGS_UPDATE',
				'treasury_settings',
				'general',
				{
					updatedSettings: dataSettings
				}
			);
			res.json({ message: 'Treasury settings updated successfully', data: result });
		} catch (error) {
			if (error instanceof AdminError) {
				return res
					.status(error.httpStatus)
					.json({ error: error.message, code: error.code, details: error.details });
			}
			res.status(500).json({ error: 'Failed to update treasury settings' });
		}
	}
}

export const adminTreasuryController = new AdminTreasuryController();
