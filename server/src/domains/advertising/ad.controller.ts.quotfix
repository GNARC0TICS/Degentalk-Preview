import type { Request, Response } from 'express';
import { z } from 'zod';
import { adServingService } from './ad-serving.service';
import { campaignManagementService } from './campaign-management.service';
import { adConfigurationService } from './ad-configuration.service';
import { logger } from '@core/logger";
import { sendSuccessResponse, sendErrorResponse } from "@core/utils/transformer.helpers";

// Request validation schemas
const adRequestSchema = z.object({
	placementSlug: z.string(),
	userHash: z.string().optional(),
	sessionId: z.string(),
	forumSlug: z.string().optional(),
	threadId: z.string().uuid().optional(),
	deviceInfo: z.object({
		type: z.enum(['mobile', 'desktop', 'tablet']),
		screenSize: z.string(),
		userAgent: z.string()
	}),
	geoData: z.object({
		region: z.string(),
		timezone: z.string()
	}),
	userContext: z.object({
		dgtBalanceTier: z.string().optional(),
		xpLevel: z.number().optional(),
		interestSegments: z.array(z.string()).optional(),
		activityLevel: z.string().optional()
	})
});

const createCampaignSchema = z.object({
	name: z.string().min(1).max(255),
	description: z.string().optional(),
	type: z.enum([
		'display_banner',
		'sponsored_thread',
		'forum_spotlight',
		'user_reward',
		'native_content'
	]),
	totalBudget: z.number().positive(),
	dailyBudget: z.number().positive().optional(),
	paymentMethod: z.enum(['dgt_tokens', 'usdt', 'bitcoin', 'ethereum', 'stripe']),
	pricingModel: z.enum(['CPM', 'CPC', 'CPA', 'FLAT']),
	bidAmount: z.number().positive(),
	startDate: z.string().datetime().optional(),
	endDate: z.string().datetime().optional(),
	targetingRules: z.object({}).passthrough(),
	placementRules: z.object({}).passthrough(),
	frequencyCap: z.object({}).passthrough(),
	creativeAssets: z.array(z.object({}).passthrough()),
	optimizationGoal: z.string().optional()
});

const trackingEventSchema = z.object({
	campaign: z.string().uuid(),
	placement: z.string().uuid(),
	session: z.string(),
	eventType: z.enum(['impression', 'click', 'conversion']),
	metadata: z.object({}).passthrough().optional()
});

/**
 * Ad Controller
 * Handles ad serving, campaign management, and tracking endpoints
 */
export class AdController {
	/**
	 * Serve an ad for a specific placement
	 * GET /api/ads/serve?placement=header_banner&...
	 */
	async serveAd(req: Request, res: Response): Promise<void> {
		try {
			const adRequest = adRequestSchema.parse({
				placementSlug: req.query.placement,
				userHash: req.query.userHash,
				sessionId: req.query.sessionId || req.sessionID,
				forumSlug: req.query.forumSlug,
				threadId: req.query.threadId,
				deviceInfo: {
					type: this.getDeviceType(req.headers['user-agent'] || ''),
					screenSize: req.query.screenSize || 'unknown',
					userAgent: req.headers['user-agent'] || ''
				},
				geoData: {
					region: req.query.region || 'unknown',
					timezone: req.query.timezone || 'UTC'
				},
				userContext: {
					dgtBalanceTier: req.query.dgtBalanceTier,
					xpLevel: req.query.xpLevel ? parseInt(req.query.xpLevel as string) : undefined,
					interestSegments: req.query.interestSegments
						? (req.query.interestSegments as string).split(',')
						: undefined,
					activityLevel: req.query.activityLevel
				}
			});

			const adResponse = await adServingService.serveAd(adRequest);

			if (!adResponse) {
				return res.status(204).end();
			}

			// Set caching headers for performance
			res.set({
				'Cache-Control': 'public, max-age=300', // 5 minutes
				Vary: 'User-Agent, Accept-Encoding'
			});

			sendSuccessResponse(res, adResponse);
		} catch (error) {
			logger.error('Ad serving error:', error);
			sendErrorResponse(res, 'Failed to serve ad', 500);
		}
	}

	/**
	 * Track ad events (impression, click, conversion)
	 * POST /api/ads/track/:eventType
	 */
	async trackEvent(req: Request, res: Response): Promise<void> {
		try {
			const eventType = req.params.eventType as 'impression' | 'click' | 'conversion';
			const trackingData = trackingEventSchema.parse({
				...req.body,
				eventType
			});

			// Track the event asynchronously
			// In production, this would be sent to analytics pipeline
			setTimeout(async () => {
				try {
					// TODO: Implement event tracking service
					logger.info('Tracking event:', trackingData);
				} catch (error) {
					logger.error('Failed to track event:', error);
				}
			}, 0);

			// Return quickly to avoid blocking user experience
			sendSuccessResponse(res, { success: true });
		} catch (error) {
			logger.error('Event tracking error:', error);
			sendErrorResponse(res, 'Invalid tracking data', 400);
		}
	}

	/**
	 * Create new advertising campaign
	 * POST /api/ads/campaigns
	 */
	async createCampaign(req: Request, res: Response): Promise<void> {
		try {
			// TODO: Extract user ID from JWT token
			const advertiserUserId = req.body.userId || 'user-123';

			const campaignData = createCampaignSchema.parse(req.body);

			const result = await campaignManagementService.createCampaign(advertiserUserId, {
				...campaignData,
				startDate: campaignData.startDate ? new Date(campaignData.startDate) : undefined,
				endDate: campaignData.endDate ? new Date(campaignData.endDate) : undefined
			});

			sendSuccessResponse(res, result);
		} catch (error) {
			logger.error('Campaign creation error:', error);
			sendErrorResponse(res, 'Failed to create campaign', 400);
		}
	}

	/**
	 * Get campaign details
	 * GET /api/ads/campaigns/:campaignId
	 */
	async getCampaign(req: Request, res: Response): Promise<void> {
		try {
			const { campaignId } = req.params;
			const advertiserUserId = req.body.userId || 'user-123';

			const campaign = await campaignManagementService.getCampaign(campaignId, advertiserUserId);

			sendSuccessResponse(res, campaign);
		} catch (error) {
			logger.error('Get campaign error:', error);
			sendErrorResponse(res, 'Campaign not found', 404);
		}
	}

	/**
	 * List user's campaigns
	 * GET /api/ads/campaigns
	 */
	async listCampaigns(req: Request, res: Response): Promise<void> {
		try {
			const advertiserUserId = req.body.userId || 'user-123';

			const filters = {
				status: req.query.status as string,
				type: req.query.type as string,
				limit: req.query.limit ? parseInt(req.query.limit as string) : 20,
				offset: req.query.offset ? parseInt(req.query.offset as string) : 0
			};

			const result = await campaignManagementService.listCampaigns(advertiserUserId, filters);

			sendSuccessResponse(res, result);
		} catch (error) {
			logger.error('List campaigns error:', error);
			sendErrorResponse(res, 'Failed to list campaigns', 500);
		}
	}

	/**
	 * Update campaign
	 * PUT /api/ads/campaigns/:campaignId
	 */
	async updateCampaign(req: Request, res: Response): Promise<void> {
		try {
			const { campaignId } = req.params;
			const advertiserUserId = req.body.userId || 'user-123';

			// Validate update data (subset of create schema)
			const updateData = req.body;

			const campaign = await campaignManagementService.updateCampaign(
				campaignId,
				advertiserUserId,
				updateData
			);

			sendSuccessResponse(res, campaign);
		} catch (error) {
			logger.error('Update campaign error:', error);
			sendErrorResponse(res, 'Failed to update campaign', 400);
		}
	}

	/**
	 * Delete campaign
	 * DELETE /api/ads/campaigns/:campaignId
	 */
	async deleteCampaign(req: Request, res: Response): Promise<void> {
		try {
			const { campaignId } = req.params;
			const advertiserUserId = req.body.userId || 'user-123';

			await campaignManagementService.deleteCampaign(campaignId, advertiserUserId);

			res.status(204).end();
		} catch (error) {
			logger.error('Delete campaign error:', error);
			sendErrorResponse(res, 'Failed to delete campaign', 400);
		}
	}

	/**
	 * Get campaign analytics
	 * GET /api/ads/campaigns/:campaignId/analytics
	 */
	async getCampaignAnalytics(req: Request, res: Response): Promise<void> {
		try {
			const { campaignId } = req.params;
			const { from, to } = req.query;

			const timeRange =
				from && to
					? {
							from: new Date(from as string),
							to: new Date(to as string)
						}
					: undefined;

			const analytics = await campaignManagementService.getCampaignAnalytics(campaignId, timeRange);

			sendSuccessResponse(res, analytics);
		} catch (error) {
			logger.error('Get analytics error:', error);
			sendErrorResponse(res, 'Failed to get analytics', 500);
		}
	}

	/**
	 * Get bid recommendations
	 * GET /api/ads/campaigns/:campaignId/bid-recommendations
	 */
	async getBidRecommendations(req: Request, res: Response): Promise<void> {
		try {
			const { campaignId } = req.params;

			const recommendations = await campaignManagementService.getBidRecommendations(campaignId);

			sendSuccessResponse(res, recommendations);
		} catch (error) {
			logger.error('Get bid recommendations error:', error);
			sendErrorResponse(res, 'Failed to get bid recommendations', 500);
		}
	}

	/**
	 * Optimize campaign
	 * POST /api/ads/campaigns/:campaignId/optimize
	 */
	async optimizeCampaign(req: Request, res: Response): Promise<void> {
		try {
			const { campaignId } = req.params;
			const advertiserUserId = req.body.userId || 'user-123';

			const result = await campaignManagementService.optimizeCampaign(campaignId, advertiserUserId);

			sendSuccessResponse(res, result);
		} catch (error) {
			logger.error('Optimize campaign error:', error);
			sendErrorResponse(res, 'Failed to optimize campaign', 500);
		}
	}

	/**
	 * Get available ad placements
	 * GET /api/ads/placements
	 */
	async getAvailablePlacements(req: Request, res: Response): Promise<void> {
		try {
			const filters = {
				position: req.query.position as string,
				forumZoneSlug: req.query.forumZoneSlug as string,
				forumSlug: req.query.forumSlug as string,
				isActive: req.query.isActive ? req.query.isActive === 'true' : true
			};

			const placements = await adConfigurationService.listPlacements(filters);

			// Filter out sensitive admin data for public API
			const publicPlacements = placements.map((placement) => ({
				id: placement.id,
				name: placement.name,
				slug: placement.slug,
				position: placement.position,
				dimensions: placement.dimensions,
				allowedFormats: placement.allowedFormats,
				floorPriceCpm: placement.floorPriceCpm,
				maxDailyImpressions: placement.maxDailyImpressions
			}));

			sendSuccessResponse(res, publicPlacements);
		} catch (error) {
			logger.error('Get placements error:', error);
			sendErrorResponse(res, 'Failed to get placements', 500);
		}
	}

	/**
	 * Get system configuration (public subset)
	 * GET /api/ads/config
	 */
	async getPublicConfig(req: Request, res: Response): Promise<void> {
		try {
			const config = await adConfigurationService.getSystemConfiguration();

			// Return only public configuration
			const publicConfig = {
				placements: {
					enabled: config.placements.enabled,
					approvalRequired: config.placements.approvalRequired
				},
				content: {
					cryptoContentOnly: config.content.cryptoContentOnly,
					requireDisclaimer: config.content.requireDisclaimer
				},
				targeting: {
					requireConsent: config.targeting.requireConsent
				}
			};

			sendSuccessResponse(res, publicConfig);
		} catch (error) {
			logger.error('Get config error:', error);
			sendErrorResponse(res, 'Failed to get configuration', 500);
		}
	}

	/**
	 * Helper method to detect device type from user agent
	 */
	private getDeviceType(userAgent: string): 'mobile' | 'desktop' | 'tablet' {
		const mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
		const tabletRegex = /iPad|Android(?!.*Mobile)/i;

		if (tabletRegex.test(userAgent)) {
			return 'tablet';
		} else if (mobileRegex.test(userAgent)) {
			return 'mobile';
		} else {
			return 'desktop';
		}
	}
}

export const adController = new AdController();
