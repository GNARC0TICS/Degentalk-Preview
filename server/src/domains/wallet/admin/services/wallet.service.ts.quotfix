import { db } from '@db';
import { wallets, transactions, users } from '@schema';
import { eq, sql } from 'drizzle-orm';
import type { UserId } from '@shared/types/ids';
import { logger } from '@core/logger';
import { WalletError, ErrorCodes } from '@core/errors';

export class AdminWalletService {
    /**
     * Add DGT to a user's wallet. For admin use only.
     */
    async addDgt(userId: UserId, amount: number, reason: string, metadata: Record<string, any> = {}): Promise<void> {
        if (amount <= 0) {
            throw new WalletError('Amount must be positive.', ErrorCodes.VALIDATION_ERROR);
        }

        await db.transaction(async (tx) => {
            const wallet = await tx.query.wallets.findFirst({ where: eq(wallets.userId, userId) });

            if (!wallet) {
                throw new WalletError('User wallet not found.', ErrorCodes.NOT_FOUND);
            }

            await tx.update(wallets)
                .set({ balance: sql`${wallets.balance} + ${amount}` })
                .where(eq(wallets.id, wallet.id));

            await tx.insert(transactions).values({
                userId,
                walletId: wallet.id,
                amount,
                type: 'admin_credit',
                status: 'completed',
                description: reason,
                metadata: { ...metadata, admin_action: 'addDgt' },
            });

            logger.info('AdminWalletService:addDgt', 'Successfully added DGT to user wallet', { userId, amount, reason });
        });
    }

    /**
     * Deduct DGT from a user's wallet. For admin use only.
     */
    async deductDgt(userId: UserId, amount: number, reason: string, metadata: Record<string, any> = {}): Promise<void> {
        if (amount <= 0) {
            throw new WalletError('Amount must be positive.', ErrorCodes.VALIDATION_ERROR);
        }

        await db.transaction(async (tx) => {
            const wallet = await tx.query.wallets.findFirst({ where: eq(wallets.userId, userId) });

            if (!wallet) {
                throw new WalletError('User wallet not found.', ErrorCodes.NOT_FOUND);
            }

            if (wallet.balance < amount) {
                throw new WalletError('Insufficient balance for deduction.', ErrorCodes.INSUFFICIENT_FUNDS);
            }

            await tx.update(wallets)
                .set({ balance: sql`${wallets.balance} - ${amount}` })
                .where(eq(wallets.id, wallet.id));

            await tx.insert(transactions).values({
                userId,
                walletId: wallet.id,
                amount: -amount,
                type: 'admin_debit',
                status: 'completed',
                description: reason,
                metadata: { ...metadata, admin_action: 'deductDgt' },
            });

            logger.info('AdminWalletService:deductDgt', 'Successfully deducted DGT from user wallet', { userId, amount, reason });
        });
    }

    /**
     * Get DGT analytics for admin dashboard.
     */
    async getDGTAnalytics(): Promise<any> {
        const [totalSupplyResult] = await db.select({ total: sql<number>`sum(${wallets.balance})` }).from(wallets);
        const [totalUsersResult] = await db.select({ count: sql<number>`count(*)` }).from(wallets).where(sql`${wallets.balance} > 0`);
        const [totalTransactionsResult] = await db.select({ count: sql<number>`count(*)` }).from(transactions);

        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        const [dailyVolumeResult] = await db.select({ volume: sql<number>`sum(abs(${transactions.amount}))` }).from(transactions).where(sql`${transactions.createdAt} >= ${oneDayAgo}`);

        const totalSupply = totalSupplyResult?.total || 0;
        const totalUsers = totalUsersResult?.count || 0;
        const totalTransactions = totalTransactionsResult?.count || 0;
        const dailyVolume = dailyVolumeResult?.volume || 0;
        const averageBalance = totalUsers > 0 ? totalSupply / totalUsers : 0;

        return {
            totalSupply,
            totalUsersWithDgt: totalUsers,
            totalTransactions,
            dailyVolume,
            averageBalance,
        };
    }

    /**
     * Freeze a user's wallet (prevents all operations)
     */
    async freezeWallet(userId: UserId, reason: string, metadata: Record<string, any> = {}): Promise<void> {
        await db.transaction(async (tx) => {
            const wallet = await tx.query.wallets.findFirst({ where: eq(wallets.userId, userId) });

            if (!wallet) {
                throw new WalletError('User wallet not found.', ErrorCodes.NOT_FOUND);
            }

            if (wallet.status === 'frozen') {
                throw new WalletError('Wallet is already frozen.', ErrorCodes.VALIDATION_ERROR);
            }

            await tx.update(wallets)
                .set({ status: 'frozen' })
                .where(eq(wallets.id, wallet.id));

            await tx.insert(transactions).values({
                userId,
                walletId: wallet.id,
                amount: 0,
                type: 'admin_adjust',
                status: 'completed',
                description: `Wallet frozen: ${reason}`,
                metadata: { ...metadata, admin_action: 'freezeWallet', reason },
            });

            logger.info('AdminWalletService:freezeWallet', 'Successfully froze user wallet', { userId, reason });
        });
    }

    /**
     * Unfreeze a user's wallet (restores operations)
     */
    async unfreezeWallet(userId: UserId, reason: string, metadata: Record<string, any> = {}): Promise<void> {
        await db.transaction(async (tx) => {
            const wallet = await tx.query.wallets.findFirst({ where: eq(wallets.userId, userId) });

            if (!wallet) {
                throw new WalletError('User wallet not found.', ErrorCodes.NOT_FOUND);
            }

            if (wallet.status !== 'frozen') {
                throw new WalletError('Wallet is not frozen.', ErrorCodes.VALIDATION_ERROR);
            }

            await tx.update(wallets)
                .set({ status: 'active' })
                .where(eq(wallets.id, wallet.id));

            await tx.insert(transactions).values({
                userId,
                walletId: wallet.id,
                amount: 0,
                type: 'admin_adjust',
                status: 'completed',
                description: `Wallet unfrozen: ${reason}`,
                metadata: { ...metadata, admin_action: 'unfreezeWallet', reason },
            });

            logger.info('AdminWalletService:unfreezeWallet', 'Successfully unfroze user wallet', { userId, reason });
        });
    }
}

export const adminWalletService = new AdminWalletService(); 