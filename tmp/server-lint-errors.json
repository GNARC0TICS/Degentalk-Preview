[{"filePath":"/Users/gnarcotic/Degentalk/server/config/loadEnv.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_next' is defined but never used.","line":118,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":118,"endColumn":71}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file server/index.ts\n * @description Main entry point for the Degentalk backend server.\n *\n * @purpose Initializes and starts the Express application, sets up middleware,\n *          registers API routes, handles database migrations/seeding (in dev),\n *          integrates Vite for development or serves static assets in production,\n *          and starts scheduled tasks.\n *\n * @dependencies\n *   - `express`: Web framework.\n *   - `./config/loadEnv`: For loading environment variables.\n *   - `./routes`: For API route registration.\n *   - `./vite`: For Vite HMR and middleware integration.\n *   - `./utils/task-scheduler`: For running background tasks.\n *   - `../scripts/db/*`: Various database seeding and migration scripts.\n *\n * @environment\n *   - `NODE_ENV`: ('development' or 'production') Controls behavior like seeding and Vite integration.\n *   - `PORT`: Port number for the server to listen on.\n *   - `DATABASE_PROVIDER`: ('sqlite' or 'postgresql') Determines migration logic.\n *   - `DATABASE_URL`: Connection string for the database.\n *   - `QUICK_MODE`: ('true' or 'false') If true, skips seeding in development.\n *\n * @important_notes\n *   - Environment variables MUST be loaded first via `import './config/loadEnv';`.\n *   - Seeding and some migrations are conditional based on `NODE_ENV` and `DATABASE_PROVIDER`.\n *   - Error handling middleware is the last `app.use()` call before server start.\n *\n * @status Reviewed – Awaiting Final Approval | 2025-06-02\n * @last_reviewed 2025-06-02 by Cline\n * @owner Backend Team (TODO: Confirm owner)\n */\nimport './config/loadEnv'; // Ensures environment variables are loaded first\n\n// All other imports follow\nimport express, { type Request, type Response, type NextFunction } from 'express';\nimport { registerRoutes } from './routes';\nimport { setupVite, serveStatic } from './vite'; // Removed 'log' from here\nimport { runScheduledTasks } from './utils/task-scheduler';\nimport { seedDevUser } from './utils/seed-dev-user';\nimport { traceMiddleware } from './src/middleware/trace.middleware'; // Import new traceMiddleware\n// Dynamic imports for seed scripts to avoid path resolution issues at startup\nimport { initEventNotificationListener } from './src/domains/notifications/event-notification-listener';\nimport './src/core/background-processor';\nimport { logger } from \"./src/core/logger\";\n\n// Startup logging helper\nconst startupLog = (message: string, type: 'info' | 'success' | 'error' | 'warning' = 'info') => {\n\tconst prefix = {\n\t\tinfo: '🔧',\n\t\tsuccess: '✅',\n\t\terror: '❌',\n\t\twarning: '⚠️'\n\t}[type];\n\tlogger.info('BACKEND', message, { type, prefix });\n};\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\n// Use the new traceMiddleware for request logging\napp.use(traceMiddleware);\n\n(async () => {\n\ttry {\n\t\tstartupLog(`Starting Degentalk Backend Server...`);\n\t\tstartupLog(`Environment: ${process.env.NODE_ENV || 'development'}`);\n\t\tstartupLog(\n\t\t\t`Database: ${process.env.DATABASE_PROVIDER || 'sqlite'} (${\n\t\t\t\tprocess.env.DATABASE_URL || 'db/dev.db'\n\t\t\t})`\n\t\t);\n\n\t\t// Run Drizzle migrations for PostgreSQL\n\t\tif (\n\t\t\tprocess.env.DATABASE_PROVIDER === 'postgresql' ||\n\t\t\tprocess.env.DATABASE_PROVIDER === 'postgres'\n\t\t) {\n\t\t\tstartupLog('Using PostgreSQL - skipping SQLite table creation script');\n\t\t} else {\n\t\t\tstartupLog('Running database migrations...');\n\t\t\tconst { createMissingTables } = await import('../scripts/db/create-missing-tables');\n\t\t\tawait createMissingTables();\n\t\t\tstartupLog('Database migrations complete.', 'success');\n\t\t}\n\n\t\tif (process.env.NODE_ENV === 'development' && process.env.QUICK_MODE !== 'true') {\n\t\t\t// Seed DevUser for development\n\t\t\tstartupLog('Seeding development user...');\n\t\t\tawait seedDevUser();\n\n\t\t\t// Run all other seed scripts in development\n\t\t\tstartupLog('Running seed scripts in development mode...');\n\t\t\ttry {\n\t\t\t\tconst { seedXpActions } = await import('../scripts/db/seed-xp-actions');\n\t\t\t\tconst { seedDefaultLevels } = await import('../scripts/db/seed-default-levels');\n\t\t\t\tconst { seedEconomySettings } = await import('../scripts/db/seed-economy-settings');\n\t\t\t\tconst { seedForumsFromConfig } = await import('../scripts/seed/seedForumsFromConfig');\n\t\t\t\t\n\t\t\t\tawait seedXpActions();\n\t\t\t\tawait seedDefaultLevels();\n\t\t\t\tawait seedEconomySettings();\n\t\t\t\t// Seed zones & forums using config-driven seeder\n\t\t\t\tawait seedForumsFromConfig();\n\t\t\t\tstartupLog('All seed scripts completed successfully.', 'success');\n\t\t\t} catch (seedError) {\n\t\t\t\tstartupLog(`Error during seeding: ${seedError}`, 'error');\n\t\t\t\t// Log the error but continue server startup\n\t\t\t}\n\t\t} else if (process.env.QUICK_MODE === 'true') {\n\t\t\tstartupLog('Quick mode enabled - skipping seed scripts', 'warning');\n\t\t}\n\n\t\tconst server = await registerRoutes(app);\n\n\t\tapp.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n\t\t\tconst status = err.status || err.statusCode || 500;\n\t\t\tconst message = err.message || 'Internal Server Error';\n\n\t\t\tstartupLog(`Express error handler caught: ${err.message}`, 'error');\n\t\t\tif (err.stack) {\n\t\t\t\tlogger.error(err.stack);\n\t\t\t}\n\n\t\t\tres.status(status).json({ message });\n\t\t});\n\n\t\t// Setup vite or serve static files\n\t\tif (process.env.NODE_ENV === 'production') {\n\t\t\tawait serveStatic(app);\n\t\t} else {\n\t\t\tawait setupVite(app, server);\n\t\t}\n\n\t\t// Initialize event notification listener\n\t\tstartupLog('Initializing event notification listener...');\n\t\tinitEventNotificationListener();\n\t\tstartupLog('Event notification listener initialized.', 'success');\n\n\t\t// Achievement background processor is auto-started via import\n\t\tstartupLog('Achievement background processor started.', 'success');\n\n\t\t// Start the server\n\t\tconst port = process.env.PORT ? parseInt(process.env.PORT) : 5001;\n\t\tstartupLog(`Starting server on port ${port}...`);\n\n\t\tserver.on('error', (error: any) => {\n\t\t\tif (error.code === 'EADDRINUSE') {\n\t\t\t\tstartupLog(\n\t\t\t\t\t`Port ${port} is already in use. Another process might be running on this port.`,\n\t\t\t\t\t'error'\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tstartupLog(`Server error: ${error}`, 'error');\n\t\t\t}\n\t\t\tprocess.exit(1);\n\t\t});\n\n\t\tserver.on('listening', () => {\n\t\t\tstartupLog(`Backend API running on http://localhost:${port}`, 'success');\n\n\t\t\t// Run scheduled tasks on server start and then every 5 minutes\n\t\t\tstartupLog('Initializing scheduled tasks...');\n\t\t\trunScheduledTasks();\n\n\t\t\t// Set up scheduled tasks to run every 5 minutes\n\t\t\tsetInterval(\n\t\t\t\t() => {\n\t\t\t\t\trunScheduledTasks();\n\t\t\t\t},\n\t\t\t\t5 * 60 * 1000\n\t\t\t);\n\n\t\t\tstartupLog('Server initialization complete!', 'success');\n\t\t});\n\n\t\tserver.listen({\n\t\t\tport,\n\t\t\thost: '0.0.0.0'\n\t\t});\n\t} catch (error) {\n\t\tstartupLog(`Failed to start server: ${error}`, 'error');\n\t\tprocess.exit(1);\n\t}\n})();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/20250510_create_xp_adjustment_logs.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpAdjustmentLogs' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '../src/core/db';\nimport { xpAdjustmentLogs } from \"../../shared/schema\";\nimport { sql } from \"drizzle-orm\";\nimport { logger } from \"../src/core/logger\";\n\nexport async function up() {\n  logger.info('Running migration: Create XP adjustment logs table');\n\n  await db.execute(sql`\n    CREATE TABLE IF NOT EXISTS xp_adjustment_logs (\n      id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n      user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n      admin_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE SET NULL,\n      adjustment_type VARCHAR(20) NOT NULL,\n      amount INTEGER NOT NULL,\n      reason TEXT NOT NULL,\n      old_xp INTEGER NOT NULL,\n      new_xp INTEGER NOT NULL,\n      created_at TIMESTAMP NOT NULL DEFAULT NOW()\n    );\n    \n    CREATE INDEX IF NOT EXISTS idx_xp_adjustment_logs_user_id ON xp_adjustment_logs(user_id);\n    CREATE INDEX IF NOT EXISTS idx_xp_adjustment_logs_admin_id ON xp_adjustment_logs(admin_id);\n    CREATE INDEX IF NOT EXISTS idx_xp_adjustment_logs_created_at ON xp_adjustment_logs(created_at);\n  `);\n}\n\nexport async function down() {\n  logger.info('Reverting migration: Create XP adjustment logs table');\n  \n  await db.execute(sql`\n    DROP TABLE IF EXISTS xp_adjustment_logs;\n  `);\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/20250512_create_xp_action_logs.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpActionLogs' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { sql } from \"drizzle-orm\";\nimport { db } from '../src/core/db';\nimport { xpActionLogs } from \"../../shared/schema\";\nimport { logger } from \"../src/core/logger\";\n\nexport async function up() {\n  logger.info('Running migration: Create XP action logs tables');\n\n  await db.execute(sql`\n    -- Create the xp_action_logs table for tracking all XP awards from actions\n    CREATE TABLE IF NOT EXISTS xp_action_logs (\n      id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n      user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n      action TEXT NOT NULL,\n      amount INTEGER NOT NULL,\n      metadata JSONB,\n      created_at TIMESTAMP NOT NULL DEFAULT NOW()\n    );\n    \n    -- Create indexes for xp_action_logs\n    CREATE INDEX IF NOT EXISTS idx_xp_action_logs_user_id ON xp_action_logs(user_id);\n    CREATE INDEX IF NOT EXISTS idx_xp_action_logs_action ON xp_action_logs(action);\n    CREATE INDEX IF NOT EXISTS idx_xp_action_logs_created_at ON xp_action_logs(created_at);\n    \n    -- Create the xp_action_limits table for tracking rate limits and cooldowns\n    CREATE TABLE IF NOT EXISTS xp_action_limits (\n      id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n      user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n      action TEXT NOT NULL,\n      count INTEGER NOT NULL DEFAULT 1,\n      last_awarded TIMESTAMP NOT NULL DEFAULT NOW(),\n      day_started_at TIMESTAMP NOT NULL DEFAULT NOW()\n    );\n    \n    -- Create indexes for xp_action_limits\n    CREATE INDEX IF NOT EXISTS idx_xp_action_limits_user_id ON xp_action_limits(user_id);\n    CREATE INDEX IF NOT EXISTS idx_xp_action_limits_user_action ON xp_action_limits(user_id, action);\n    \n    -- Create unique constraint to ensure one record per user/action combination\n    CREATE UNIQUE INDEX IF NOT EXISTS idx_xp_action_limits_unique ON xp_action_limits(user_id, action);\n  `);\n}\n\nexport async function down() {\n  logger.info('Reverting migration: Create XP action logs tables');\n  \n  await db.execute(sql`\n    DROP TABLE IF EXISTS xp_action_limits;\n    DROP TABLE IF EXISTS xp_action_logs;\n  `);\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/20250513_create_xp_action_settings.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpActionSettings' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { sql } from \"drizzle-orm\";\nimport { db } from '../src/core/db';\nimport { xpActionSettings } from \"../../shared/schema\";\nimport { logger } from \"../src/core/logger\";\n\nexport async function up() {\n  logger.info('Running migration: Create XP action settings table');\n\n  await db.execute(sql`\n    -- Create the xp_action_settings table for storing configurable XP action values\n    CREATE TABLE IF NOT EXISTS xp_action_settings (\n      action TEXT PRIMARY KEY,\n      base_value INTEGER NOT NULL,\n      description TEXT NOT NULL,\n      max_per_day INTEGER,\n      cooldown_sec INTEGER,\n      enabled BOOLEAN NOT NULL DEFAULT true,\n      created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n      updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n    );\n    \n    -- Create indexes for performance\n    CREATE INDEX IF NOT EXISTS idx_xp_action_settings_enabled ON xp_action_settings(enabled);\n  `);\n}\n\nexport async function down() {\n  logger.info('Reverting migration: Create XP action settings table');\n  \n  await db.execute(sql`\n    DROP TABLE IF EXISTS xp_action_settings;\n  `);\n} ","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/20250618_add_clout_achievements.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pool' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { drizzle } from 'drizzle-orm/node-postgres';\nimport { Pool } from 'pg';\nimport { sql } from 'drizzle-orm';\nimport { logger } from '../src/core/logger';\nimport { config } from 'dotenv';\n\nconfig();\n\nconst getDb = () => {\n  const connectionString = process.env.DATABASE_URL;\n  if (!connectionString) throw new Error('DATABASE_URL env var is not set');\n  const pool = new Pool({ connectionString });\n  return { db: drizzle(pool), pool };\n};\n\nexport async function up() {\n  logger.info('🚀 Applying migration: clout_achievements & user_clout_log');\n  const { db, pool } = getDb();\n  try {\n    await db.transaction(async (tx) => {\n      // clout_achievements\n      logger.info('Creating clout_achievements table...');\n      await tx.execute(sql`\n        CREATE TABLE IF NOT EXISTS clout_achievements (\n          id SERIAL PRIMARY KEY,\n          achievement_key VARCHAR(100) UNIQUE NOT NULL,\n          name VARCHAR(255) NOT NULL,\n          description TEXT,\n          clout_reward INTEGER NOT NULL DEFAULT 0,\n          criteria_type VARCHAR(50),\n          criteria_value INTEGER,\n          enabled BOOLEAN DEFAULT TRUE,\n          icon_url VARCHAR(500),\n          created_at TIMESTAMP NOT NULL DEFAULT NOW()\n        );\n      `);\n\n      // user_clout_log\n      logger.info('Creating user_clout_log table...');\n      await tx.execute(sql`\n        CREATE TABLE IF NOT EXISTS user_clout_log (\n          id SERIAL PRIMARY KEY,\n          user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n          achievement_id INTEGER REFERENCES clout_achievements(id) ON DELETE SET NULL,\n          clout_earned INTEGER NOT NULL,\n          reason VARCHAR(255),\n          created_at TIMESTAMP NOT NULL DEFAULT NOW()\n        );\n      `);\n      await tx.execute(sql`CREATE INDEX IF NOT EXISTS idx_user_clout ON user_clout_log (user_id, created_at);`);\n\n      // Seed default achievements (optional, safe for idempotent insert)\n      logger.info('Seeding default clout achievements...');\n      await tx.execute(sql`\n        INSERT INTO clout_achievements (achievement_key, name, description, clout_reward, criteria_type, criteria_value)\n        VALUES\n          ('first_viral_thread', 'Gone Viral', 'Your thread received 100+ likes', 500, 'thread_likes', 100),\n          ('community_favorite', 'Community Favorite', 'Received 1000 total likes', 1000, 'total_likes_received', 1000),\n          ('premium_supporter', 'Premium Degen', 'Purchased premium membership', 300, 'shop_purchase', NULL)\n        ON CONFLICT (achievement_key) DO NOTHING;\n      `);\n    });\n    logger.info('✅ Migration applied: clout_achievements & user_clout_log');\n  } catch (err) {\n    logger.error('❌ Migration failed:', err);\n    logger.error('Migration failed: clout_achievements & user_clout_log', { err });\n    throw err;\n  } finally {\n    const { pool } = getDb();\n    await pool.end();\n  }\n}\n\nexport async function down() {\n  logger.info('↩️ Reverting migration: clout_achievements & user_clout_log');\n  const { db, pool } = getDb();\n  try {\n    await db.transaction(async (tx) => {\n      await tx.execute(sql`DROP TABLE IF EXISTS user_clout_log;`);\n      await tx.execute(sql`DROP TABLE IF EXISTS clout_achievements;`);\n    });\n    logger.info('✅ Reverted migration: clout_achievements & user_clout_log');\n  } catch (err) {\n    logger.error('❌ Revert failed:', err);\n    logger.error('Revert failed: clout_achievements & user_clout_log', { err });\n    throw err;\n  } finally {\n    await pool.end();\n  }\n} ","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/20250618_add_rollout_percentage_to_feature_flags.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/20250618_add_updated_by_to_site_settings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/20250618_create_xp_clout_settings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/20250624_add_visual_fields_to_levels.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pool' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":19,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pool' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":70,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":70,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { drizzle } from 'drizzle-orm/node-postgres';\nimport pgPkg from 'pg';\nimport { sql } from 'drizzle-orm';\nimport { config } from 'dotenv';\nimport { logger } from \"../src/core/logger\";\n\nconfig();\n\nconst getDb = () => {\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL env var not set');\n  }\n  const pool = new pgPkg.Pool({ connectionString: process.env.DATABASE_URL });\n  return { db: drizzle(pool), pool };\n};\n\nexport async function up() {\n  logger.info('🚀 20250624 ‑ Add visual fields to levels');\n  const { db, pool } = getDb();\n\n  try {\n    await db.transaction(async (tx) => {\n      // 1. Add new columns (NO lock by using IF NOT EXISTS)\n      await tx.execute(\n        sql`ALTER TABLE levels ADD COLUMN IF NOT EXISTS icon_url VARCHAR(255);`\n      );\n      await tx.execute(\n        sql`ALTER TABLE levels ADD COLUMN IF NOT EXISTS rarity VARCHAR(10) DEFAULT 'common';`\n      );\n      await tx.execute(\n        sql`ALTER TABLE levels ADD COLUMN IF NOT EXISTS frame_url VARCHAR(255);`\n      );\n      await tx.execute(\n        sql`ALTER TABLE levels ADD COLUMN IF NOT EXISTS color_theme VARCHAR(25);`\n      );\n      await tx.execute(\n        sql`ALTER TABLE levels ADD COLUMN IF NOT EXISTS animation_effect VARCHAR(30);`\n      );\n      await tx.execute(\n        sql`ALTER TABLE levels ADD COLUMN IF NOT EXISTS unlocks JSONB DEFAULT '{}'::jsonb NOT NULL;`\n      );\n\n      // 2. Back-fill defaults for existing rows\n      // rarity\n      await tx.execute(sql`UPDATE levels SET rarity = 'common' WHERE rarity IS NULL;`);\n\n      // unlocks already defaulted, but ensure not null\n      await tx.execute(sql`UPDATE levels SET unlocks = '{}'::jsonb WHERE unlocks IS NULL;`);\n\n      // color_theme mapping based on existing procedural colour logic\n      await tx.execute(sql`UPDATE levels SET color_theme = 'emerald' WHERE color_theme IS NULL AND level < 10;`);\n      await tx.execute(sql`UPDATE levels SET color_theme = 'cyan' WHERE color_theme IS NULL AND level >= 10 AND level < 25;`);\n      await tx.execute(sql`UPDATE levels SET color_theme = 'purple' WHERE color_theme IS NULL AND level >= 25 AND level < 50;`);\n      await tx.execute(sql`UPDATE levels SET color_theme = 'amber' WHERE color_theme IS NULL AND level >= 50;`);\n\n      // Add comment on min_xp column for future aliasing (Postgres COMMENT)\n      await tx.execute(\n        sql`COMMENT ON COLUMN levels.min_xp IS 'Total cumulative XP required to reach this level (alias xp_required planned)';`\n      );\n    });\n\n    logger.info('✅ Migration applied: visual fields added to levels');\n  } finally {\n    (await getDb()).pool.end();\n  }\n}\n\nexport async function down() {\n  logger.info('↩️  Reverting 20250624 visual fields migration');\n  const { db, pool } = getDb();\n  try {\n    await db.transaction(async (tx) => {\n      await tx.execute(sql`ALTER TABLE levels DROP COLUMN IF EXISTS unlocks;`);\n      await tx.execute(sql`ALTER TABLE levels DROP COLUMN IF EXISTS animation_effect;`);\n      await tx.execute(sql`ALTER TABLE levels DROP COLUMN IF EXISTS color_theme;`);\n      await tx.execute(sql`ALTER TABLE levels DROP COLUMN IF EXISTS frame_url;`);\n      await tx.execute(sql`ALTER TABLE levels DROP COLUMN IF EXISTS rarity;`);\n      await tx.execute(sql`ALTER TABLE levels DROP COLUMN IF EXISTS icon_url;`);\n    });\n    logger.info('✅ Reverted 20250624 migration');\n  } finally {\n    (await getDb()).pool.end();\n  }\n} ","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/20250626_extend_ui_themes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/add-daily-xp-tracking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/add-dgt-packages-table.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/add-dgt-purchase-orders-table.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'migrate' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { drizzle } from \"drizzle-orm/node-postgres\";\nimport { migrate } from \"drizzle-orm/node-postgres/migrator\";\nimport { Pool } from \"pg\";\nimport { sql } from \"drizzle-orm\";\nimport * as schema from \"../../shared/schema\";\nimport * as dotenv from \"dotenv\";\nimport { logger } from \"../src/core/logger\";\n\n// [REFAC-DGT] Custom migration script to create the dgt_purchase_orders table\n// This supplements the Drizzle SQL migrations for more complex operations\n\ndotenv.config();\n\nconst runMigration = async () => {\n  // Create a new Postgres connection pool\n  const connectionString = process.env.DATABASE_URL;\n  \n  if (!connectionString) {\n    logger.error(\"DATABASE_URL environment variable is not set\");\n    process.exit(1);\n  }\n  \n  const pool = new Pool({\n    connectionString,\n  });\n  \n  try {\n    // Create a Drizzle client instance\n    const db = drizzle(pool, { schema });\n    \n    logger.info(\"Connected to the database. Starting dgt_purchase_orders table migration...\");\n    \n    // Check if the table already exists to avoid duplicate migrations\n    const tableExists = await db.execute(sql`\n      SELECT EXISTS (\n        SELECT FROM information_schema.tables \n        WHERE table_schema = 'public'\n        AND table_name = 'dgt_purchase_orders'\n      );\n    `);\n    \n    if (tableExists.rows[0]?.exists) {\n      logger.info(\"dgt_purchase_orders table already exists. Skipping migration.\");\n      return;\n    }\n    \n    // Create the dgt_purchase_orders table using raw SQL for more control\n    await db.execute(sql`\n      CREATE TABLE IF NOT EXISTS \"dgt_purchase_orders\" (\n        \"id\" SERIAL PRIMARY KEY,\n        \"user_id\" INTEGER NOT NULL REFERENCES \"users\"(\"user_id\") ON DELETE CASCADE,\n        \"dgt_amount_requested\" BIGINT NOT NULL,\n        \"crypto_amount_expected\" DECIMAL(18, 8) NOT NULL,\n        \"crypto_currency_expected\" VARCHAR(10) NOT NULL,\n        \"ccpayment_reference\" VARCHAR(255) NOT NULL,\n        \"status\" VARCHAR(20) NOT NULL DEFAULT 'pending',\n        \"metadata\" JSONB DEFAULT '{}',\n        \"created_at\" TIMESTAMP NOT NULL DEFAULT NOW(),\n        \"updated_at\" TIMESTAMP NOT NULL DEFAULT NOW()\n      );\n      \n      CREATE INDEX \"idx_dgt_purchase_orders_user_id\" ON \"dgt_purchase_orders\"(\"user_id\");\n      CREATE INDEX \"idx_dgt_purchase_orders_status\" ON \"dgt_purchase_orders\"(\"status\");\n      CREATE INDEX \"idx_dgt_purchase_orders_ccpayment_ref\" ON \"dgt_purchase_orders\"(\"ccpayment_reference\");\n      CREATE INDEX \"idx_dgt_purchase_orders_created_at\" ON \"dgt_purchase_orders\"(\"created_at\");\n    `);\n    \n    logger.info(\"Successfully created dgt_purchase_orders table\");\n    \n  } catch (error: unknown) {\n    logger.error(\"Error executing migration:\", error);\n    process.exit(1);\n  } finally {\n    await pool.end();\n    logger.info(\"Migration complete\");\n  }\n};\n\n// Execute the migration when this file is run directly\nif (require.main === module) {\n  runMigration()\n    .catch(console.error);\n}\n\nexport { runMigration }; ","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/archive/run-tip-rain.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/migrations/xp-clout-levels-migration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'auditLogs' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":30,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'awardPathXp' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":80,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":80,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpRewards' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":81,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":81,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getRecentPosts' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":83,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":83,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getHotThreads' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":84,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":84,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getFeaturedThreads' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":85,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":85,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getPlatformStats' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":86,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":86,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getLeaderboards' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":87,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":87,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'featureThread' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":88,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'unfeatureThread' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":89,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":89,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shopItems' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":91,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":91,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'addOGDripColorItem' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":91,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":91,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'randomBytes' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":92,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":92,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":96,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":96,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eq' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":96,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":96,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":96,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":96,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAuthenticated' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":99,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":99,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAuthenticatedOptional' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":100,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":100,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdminOrModerator' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":101,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":101,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdmin' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":102,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":102,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'randomUUID' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":126,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file server/routes.ts\n * @description Centralized routing file for the Degentalk backend application.\n * @purpose Aggregates and registers all domain-specific API routes with the Express application.\n *          Also handles global middleware, authentication setup, and WebSocket server initialization.\n * @dependencies\n * - express: Web framework for Node.js.\n * - http: Node.js built-in module for creating HTTP servers.\n * - ws: WebSocket library for Node.js.\n * - storage: Local storage utility (e.g., for session store).\n * - Domain-specific routes and middleware (e.g., auth, wallet, forum, admin).\n * - Drizzle ORM for database interactions.\n * - Centralized error handlers.\n * @environment Server-side (Node.js).\n * @important_notes\n * - This file should primarily import route handlers from `src/domains/` subdirectories.\n * - Legacy routes are being deprecated and should be migrated to domain-driven structures.\n * - WebSocket server is enabled only in production to prevent development conflicts.\n * - Global error handler is registered as the final middleware.\n * @status Stable, but ongoing refactoring for route deprecation.\n * @last_reviewed 2025-06-01\n * @owner Backend Team / API Team\n */\nimport express, { type Express, type Request, type Response } from 'express';\nimport { createServer, type Server } from 'http';\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { storage } from './storage';\n// Import auth from the new domain location\nimport { setupAuthPassport, authRoutes } from './src/domains/auth';\nimport { auditLogs } from '@schema';\nimport { z } from 'zod';\nimport { registerAdminRoutes } from './src/domains/admin/admin.routes';\n// Import domain-based wallet routes\nimport walletRoutes from './src/domains/wallet/wallet.routes';\nimport tipRoutes from './src/domains/engagement/tip/tip.routes';\nimport rainRoutes from './src/domains/engagement/rain/rain.routes';\n// Import domain-based XP routes\nimport xpRoutes from './src/domains/xp/xp.routes';\n// Import domain-based treasury and shoutbox routes\nimport treasuryRoutes from './src/domains/treasury/treasury.routes';\nimport shoutboxRoutes from './src/domains/shoutbox/shoutbox.routes';\n// Import domain-based forum routes\nimport forumRoutes from './src/domains/forum/forum.routes';\nimport dictionaryRoutes from './src/domains/dictionary/dictionary.routes';\n// Import domain-based editor routes\nimport editorRoutes from './src/domains/editor/editor.routes';\n// TODO: @routeDeprecation Investigate settings.routes.ts location or remove if deprecated.\n// import settingsRoutes from './src/domains/settings/settings.routes';\n// Import domain-based profile routes\nimport profileRoutes from './src/domains/profile/profile.routes';\n// Import development routes\nimport devRoutes from './src/routes/dev.routes';\n// Import domain-based relationships routes\nimport relationshipsRoutes from './src/domains/social/relationships.routes';\n// Import domain-based whale watch routes\nimport whaleWatchRoutes from './src/domains/social/whale-watch.routes';\n// Import domain-based messaging routes\nimport messageRoutes from './src/domains/messaging/message.routes';\n// Import domain-based vault routes\nimport vaultRoutes from './src/domains/engagement/vault/vault.routes';\n// Import webhook routes\nimport ccpaymentWebhookRoutes from './src/domains/ccpayment-webhook/ccpayment-webhook.routes';\n// Import domain-based announcement routes\nimport { registerAnnouncementRoutes } from './src/domains/admin/sub-domains/announcements';\nimport featureGatesRoutes from './src/domains/feature-gates/feature-gates.routes';\n// Import domain-based notifications routes\nimport notificationRoutes from './src/domains/notifications/notification.routes';\n// Import domain-based preferences routes\nimport preferencesRoutes from './src/domains/preferences/preferences.routes';\n// Import domain-based advertising routes\nimport { adRoutes } from './src/domains/advertising/ad.routes';\n\n// REFACTORED: Using the new centralized error handlers\nimport {\n\tglobalErrorHandler\n} from './src/core/errors';\n// Legacy route imports (@pending-migration)\nimport { registerPathRoutes } from './src/domains/paths/paths.routes'; // @pending-migration → domains/paths/paths.routes.ts\n// TODO: @routeDeprecation Remove legacy dgt-purchase and ccpayment routes after migration to domain-driven routes is complete.\nimport { awardPathXp } from './utils/path-utils';\nimport { xpRewards } from '@shared/path-config';\nimport {\n\tgetRecentPosts,\n\tgetHotThreads,\n\tgetFeaturedThreads,\n\tgetPlatformStats,\n\tgetLeaderboards,\n\tfeatureThread,\n\tunfeatureThread\n} from './utils/platform-energy';\nimport { shopItems, addOGDripColorItem } from './utils/shop-utils';\nimport { randomBytes } from 'crypto';\nimport { db } from './src/core/db'; // Assuming db is now in src/core/db.ts\n// TODO: @cleanup Remove 'pool' if not used after db migration.\n// import { pool } from \"./db\";\nimport { and, eq, sql } from 'drizzle-orm';\n// Import auth middleware from the new domain location\nimport {\n\tisAuthenticated,\n\tisAuthenticatedOptional,\n\tisAdminOrModerator,\n\tisAdmin\n} from './src/domains/auth/middleware/auth.middleware';\nimport passport from 'passport';\nimport session from 'express-session';\n// Security middleware\nimport {\n\tcorsMiddleware,\n\tcsrfProtection,\n\tsecurityHeaders,\n\tcsrfTokenProvider,\n\tsecurityAuditLogger,\n\toriginValidation,\n\tdevelopmentSecurityWarning,\n\tapiResponseSecurity\n} from './src/core/middleware/security.middleware';\nimport { rateLimiters } from './src/core/services/rate-limit.service';\nimport healthCheckRouter, { requestMetricsMiddleware } from './src/core/monitoring/health-check';\nimport { auditMiddleware } from './src/core/audit/audit-logger';\n// Import logger\nimport { logger } from './src/core/logger';\n// X integration routes\nimport xAuthRoutes from './src/domains/auth/routes/xAuthRoutes';\nimport xShareRoutes from './src/domains/share/routes/xShareRoutes';\nimport rateLimit from 'express-rate-limit';\nimport { randomUUID } from 'crypto';\nimport { analyticsEvents } from '@schema/system/analyticsEvents';\nimport gamificationRoutes from './src/domains/gamification/gamification.routes';\nimport { achievementRoutes } from './src/domains/gamification/achievements';\nimport { getAuthenticatedUser } from \"@server/src/core/utils/auth.helpers\";\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n\t// ===================================================================\n\t// SECURITY MIDDLEWARE - Applied before any routes\n\t// ===================================================================\n\n\t// 1. Security headers (helmet)\n\tapp.use(securityHeaders);\n\n\t// 2. CORS protection\n\tapp.use(corsMiddleware);\n\n\t// 3. Origin validation\n\tapp.use(originValidation);\n\n\t// 4. General rate limiting\n\tapp.use('/api/', rateLimiters.general);\n\n\t// 5. Security audit logging\n\tapp.use(securityAuditLogger);\n\n\t// 6. API response security headers\n\tapp.use(apiResponseSecurity);\n\n\t// 7. Development security warnings\n\tapp.use(developmentSecurityWarning);\n\n\t// 8. Request metrics collection\n\tapp.use(requestMetricsMiddleware);\n\n\t// 9. Audit logging for security events\n\tapp.use(auditMiddleware);\n\n\t// Test endpoint (before auth setup)\n\tapp.get('/', async (req, res) => {\n\t\tres.json({ message: 'Backend working!!!' }).status(200);\n\t});\n\n\t// Add new unified content endpoint\n\tapp.get('/api/content', async (req, res) => {\n\t\ttry {\n\t\t\tconst tab = (req.query.tab as string) || 'trending';\n\t\t\tconst page = parseInt(req.query.page as string) || 1;\n\t\t\tconst limit = Math.min(parseInt(req.query.limit as string) || 20, 50); // Max 50\n\t\t\tconst forumId = req.query.forumId ? parseInt(req.query.forumId as string) : undefined;\n\t\t\tconst userId = getAuthenticatedUser(req)?.id; // From auth middleware\n\n\t\t\t// Validate tab\n\t\t\tconst validTabs = ['trending', 'recent', 'following'];\n\t\t\tif (!validTabs.includes(tab)) {\n\t\t\t\treturn res\n\t\t\t\t\t.status(400)\n\t\t\t\t\t.json({ error: 'Invalid tab. Must be one of: trending, recent, following' });\n\t\t\t}\n\n\t\t\t// Require auth for following tab\n\t\t\tif (tab === 'following' && !userId) {\n\t\t\t\treturn res.status(401).json({ error: 'Authentication required for following tab' });\n\t\t\t}\n\n\t\t\t// Import here to avoid circular dependencies\n\t\t\tconst { threadService } = await import('./src/domains/forum/services/thread.service');\n\n\t\t\t// Fetch content using the new tab-based method\n\t\t\tconst result = await threadService.fetchThreadsByTab({\n\t\t\t\ttab: tab as any,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\tforumId,\n\t\t\t\tuserId\n\t\t\t});\n\n\t\t\tres.json(result);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching content:', error);\n\t\t\tres.status(500).json({ error: 'Failed to fetch content' });\n\t\t}\n\t});\n\n\t// Add hot threads endpoint BEFORE authentication middleware (legacy support)\n\tapp.get('/api/hot-threads', async (req, res) => {\n\t\ttry {\n\t\t\tconst limit = parseInt(req.query.limit as string) || 5;\n\n\t\t\t// Import here to avoid circular dependencies\n\t\t\tconst { threadService } = await import('./src/domains/forum/services/thread.service');\n\n\t\t\t// Use the new tab-based method for consistency\n\t\t\tconst result = await threadService.fetchThreadsByTab({\n\t\t\t\ttab: 'trending',\n\t\t\t\tpage: 1,\n\t\t\t\tlimit,\n\t\t\t\tforumId: undefined,\n\t\t\t\tuserId: undefined\n\t\t\t});\n\n\t\t\t// Transform to match legacy format for backward compatibility\n\t\t\tconst hotThreads = result.items.map((thread: any) => ({\n\t\t\t\tthread_id: thread.id,\n\t\t\t\ttitle: thread.title,\n\t\t\t\tslug: thread.slug,\n\t\t\t\tpost_count: thread.postCount || 0,\n\t\t\t\tview_count: thread.viewCount || 0,\n\t\t\t\thot_score: Math.floor(Math.random() * 100) + 50, // Mock hot score for now\n\t\t\t\tcreated_at: thread.createdAt,\n\t\t\t\tlast_post_at: thread.lastPostAt || thread.createdAt,\n\t\t\t\tuser_id: thread.userId,\n\t\t\t\tusername: thread.user?.username || 'Unknown',\n\t\t\t\tavatar_url: thread.user?.avatarUrl || null,\n\t\t\t\tcategory_name: thread.category?.name || 'Unknown',\n\t\t\t\tcategory_slug: thread.category?.slug || 'unknown',\n\t\t\t\tlike_count: thread.firstPostLikeCount || 0\n\t\t\t}));\n\n\t\t\tres.json(hotThreads);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching hot threads:', error);\n\t\t\tres.status(500).json({ error: 'Failed to fetch hot threads' });\n\t\t}\n\t});\n\n\t// Set up session and authentication with new domain-based approach\n\tconst sessionSettings = setupAuthPassport(storage.sessionStore);\n\tapp.set('trust proxy', 1);\n\tapp.use(session(sessionSettings));\n\tapp.use(passport.initialize());\n\tapp.use(passport.session());\n\n\t// ===================================================================\n\t// CSRF PROTECTION - After session setup\n\t// ===================================================================\n\n\t// CSRF token provider endpoint (must be before CSRF protection)\n\tapp.use(csrfTokenProvider);\n\n\t// CSRF protection for state-changing operations\n\tapp.use('/api/', (req, res, next) => {\n\t\t// Skip CSRF for safe methods and specific endpoints\n\t\tif (req.method === 'GET' || req.method === 'HEAD' || req.method === 'OPTIONS') {\n\t\t\treturn next();\n\t\t}\n\n\t\t// Skip CSRF for webhooks and public endpoints\n\t\tif (req.path.includes('/webhook') || req.path.includes('/public')) {\n\t\t\treturn next();\n\t\t}\n\n\t\t// Apply CSRF protection\n\t\treturn csrfProtection(req, res, next);\n\t});\n\n\t// ===================================================================\n\t// SPECIFIC RATE LIMITING - Applied to sensitive endpoints\n\t// ===================================================================\n\n\t// Authentication endpoints (strict rate limiting)\n\tapp.use('/api/auth/login', rateLimiters.auth);\n\tapp.use('/api/auth/register', rateLimiters.auth);\n\tapp.use('/api/auth/password-reset', rateLimiters.passwordReset);\n\n\t// Admin endpoints (strict rate limiting)\n\tapp.use('/api/admin/', rateLimiters.admin);\n\n\t// Financial endpoints (very strict rate limiting)\n\tapp.use('/api/wallet/', rateLimiters.financial);\n\tapp.use('/api/engagement/tip/', rateLimiters.financial);\n\tapp.use('/api/engagement/rain/', rateLimiters.financial);\n\n\t// Forum posting (moderate rate limiting)\n\tapp.use('/api/forum/threads/', rateLimiters.posting);\n\tapp.use('/api/forum/posts/', rateLimiters.posting);\n\n\t// Use the domain-based auth routes\n\t/*\n\t * ---------------------------------------------------------------------------\n\t * AUTHENTICATION ROUTES\n\t * ---------------------------------------------------------------------------\n\t *  Primary Mount:\n\t *    • All authentication endpoints are now **namespaced** under `/api/auth/*`.\n\t *      Example: `/api/auth/login`, `/api/auth/register`, `/api/auth/user`, etc.\n\t *\n\t *  Compatibility Mount (temporary):\n\t *    • For legacy clients that still hit the root-level `/api/*` auth endpoints\n\t *      (e.g. `/api/login`), we re-mount the same router at `/api`.  This alias\n\t *      will be **removed after v2** once all callers have migrated.\n\t */\n\tapp.use('/api/auth', authRoutes); // ✅  NEW canonical path\n\tapp.use('/api', authRoutes); // 🕰️  Back-compat alias  (DEPRECATE IN v2)\n\t// X account OAuth routes\n\tapp.use('/api/auth/x', xAuthRoutes);\n\t// X share routes\n\tapp.use('/api/share/x', xShareRoutes);\n\n\t// Set up admin routes\n\tregisterAdminRoutes(app);\n\n\t// Set up wallet routes with domain-based approach\n\tapp.use('/api/wallet', walletRoutes);\n\n\t// Set up tip routes with domain-based approach\n\tapp.use('/api/engagement/tip', tipRoutes);\n\n\t// Set up rain routes with domain-based approach\n\tapp.use('/api/engagement/rain', rainRoutes);\n\n\t// Set up XP routes with domain-based approach\n\tapp.use('/api/xp', xpRoutes);\n\n\t// Set up treasury routes with domain-based approach\n\tapp.use('/api/treasury', treasuryRoutes);\n\n\t// Set up shoutbox routes with domain-based approach\n\tapp.use('/api/shoutbox', shoutboxRoutes);\n\tapp.use('/api/chat', shoutboxRoutes);\n\n\t// Set up forum routes with domain-based approach\n\tapp.use('/api/forum', forumRoutes);\n\n\t// Set up editor routes with domain-based approach\n\tapp.use('/api/editor', editorRoutes);\n\t// Make storage available to editor routes\n\tapp.set('storage', storage);\n\n\t// Use the domain-based preferences routes\n\tapp.use('/api/users', preferencesRoutes);\n\t// Use the domain-based notifications routes\n\tapp.use('/api/notifications', notificationRoutes);\n\n\t// Set up profile routes with domain-based approach\n\tapp.use('/api/profile', profileRoutes);\n\n\t// Set up relationships routes with domain-based approach\n\tapp.use('/api/relationships', relationshipsRoutes);\n\n\t// Set up whale watch routes with domain-based approach\n\tapp.use('/api', whaleWatchRoutes);\n\n\t// Set up development routes (dev mode only)\n\tapp.use('/api/dev', devRoutes);\n\n\t// Set up messaging routes with domain-based approach\n\tapp.use('/api/messages', messageRoutes);\n\n\t// Set up vault routes with domain-based approach\n\tapp.use('/api/vault', vaultRoutes);\n\n\t// Set up webhook routes (no auth required)\n\tapp.use('/api/webhook', ccpaymentWebhookRoutes);\n\n\t// Set up announcement routes with domain-based approach\n\tregisterAnnouncementRoutes(app); // Migrated to domains/admin/sub-domains/announcements\n\n\t// Set up feature gate routes\n\tapp.use('/api/features', featureGatesRoutes);\n\n\t// Set up advertising routes with domain-based approach\n\tapp.use('/api/ads', adRoutes);\n\n\t// Set up path specialization routes\n\tregisterPathRoutes(app); // @pending-migration\n\n\t// Set up DGT purchase routes\n\tconst dgtPurchaseRouter = express.Router();\n\t// TODO: @routeDeprecation Remove legacy dgt-purchase routes after migration to domain-driven routes is complete.\n\t// registerDgtPurchaseRoutes(dgtPurchaseRouter); // @pending-migration\n\tapp.use('/api', dgtPurchaseRouter);\n\n\t// Set up dictionary routes\n\tapp.use('/api/dictionary', dictionaryRoutes);\n\n\t// Set up gamification routes\n\tapp.use('/api/gamification', gamificationRoutes);\n\n\t// Set up achievement routes\n\tapp.use('/api/achievements', achievementRoutes);\n\n\t// Set up health check and monitoring routes\n\tapp.use('/api', healthCheckRouter);\n\n\t// ---------------------------------------------------------------------------\n\t// 📈 Public Analytics Beacon Route (rate-limited 100 req/min per IP)\n\t// ---------------------------------------------------------------------------\n\n\tconst analyticsLimiter = rateLimit({\n\t\twindowMs: 60 * 1000,\n\t\tmax: 100,\n\t\tstandardHeaders: true,\n\t\tlegacyHeaders: false\n\t});\n\n\tapp.post('/api/analytics/track', analyticsLimiter, async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst schema = z.object({\n\t\t\t\tevent: z.string().max(100),\n\t\t\t\tthreadId: z.number().int().optional(),\n\t\t\t\tdata: z.record(z.any()).optional()\n\t\t\t});\n\t\t\tconst parsed = schema.safeParse(req.body);\n\t\t\tif (!parsed.success) {\n\t\t\t\treturn res.status(400).json({ error: 'Invalid payload' });\n\t\t\t}\n\t\t\tconst { event, threadId, data } = parsed.data;\n\t\t\tawait db.insert(analyticsEvents).values({\n\t\t\t\tuserId: (req as any).user?.id ?? null,\n\t\t\t\tsessionId: req.cookies?.session_id ?? null,\n\t\t\t\ttype: event,\n\t\t\t\tdata: data ?? { threadId },\n\t\t\t\tipAddress: req.ip,\n\t\t\t\tuserAgent: req.headers['user-agent'] || null\n\t\t\t});\n\t\t\treturn res.status(204).end();\n\t\t} catch (e) {\n\t\t\tlogger.error('Analytics track error', e);\n\t\t\treturn res.status(500).json({ error: 'Failed to record analytics' });\n\t\t}\n\t});\n\n\t// Register the global error handler as the final middleware\n\tapp.use(globalErrorHandler);\n\n\tconst httpServer = createServer(app);\n\n\t// Check if we're in development mode\n\tconst IS_DEVELOPMENT = process.env.NODE_ENV !== 'production';\n\n\t// Default empty clients set\n\tconst clients = new Set<WebSocket>();\n\n\t// WebSocket server setup - only in production\n\tif (!IS_DEVELOPMENT) {\n\t\tlogger.info('🚀 Setting up WebSocket server in production mode');\n\n\t\t// Set up WebSocket server on the same HTTP server but with a distinct path\n\t\tconst wss = new WebSocketServer({ server: httpServer, path: '/ws' });\n\n\t\t// Handle WebSocket connections\n\t\twss.on('connection', (ws) => {\n\t\t\tlogger.info('WebSocket client connected');\n\t\t\tclients.add(ws);\n\n\t\t\t// Send initial message\n\t\t\tws.send(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\ttype: 'connected',\n\t\t\t\t\tmessage: 'Connected to Degentalk WebSocket'\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Handle incoming messages\n\t\t\tws.on('message', (message) => {\n\t\t\t\ttry {\n\t\t\t\t\tlogger.info('Received message:', message.toString());\n\t\t\t\t\tconst data = JSON.parse(message.toString());\n\n\t\t\t\t\t// Process different message types\n\t\t\t\t\tif (data.type === 'chat_message') {\n\t\t\t\t\t\t// Broadcast chat message to all connected clients\n\t\t\t\t\t\t// This is just the broadcast mechanism\n\t\t\t\t\t\t// Actual database persistence is handled by the HTTP API\n\t\t\t\t\t\tconst broadcastData = {\n\t\t\t\t\t\t\ttype: 'chat_update',\n\t\t\t\t\t\t\taction: 'new_message',\n\t\t\t\t\t\t\tmessage: data.message,\n\t\t\t\t\t\t\troomId: data.roomId,\n\t\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Broadcast to all connected clients\n\t\t\t\t\t\tfor (const client of clients) {\n\t\t\t\t\t\t\tif (client.readyState === WebSocket.OPEN) {\n\t\t\t\t\t\t\t\tclient.send(JSON.stringify(broadcastData));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle room change events to notify other users\n\t\t\t\t\tif (data.type === 'room_change') {\n\t\t\t\t\t\tconst broadcastData = {\n\t\t\t\t\t\t\ttype: 'room_update',\n\t\t\t\t\t\t\troomId: data.roomId,\n\t\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Broadcast room change to all connected clients\n\t\t\t\t\t\tfor (const client of clients) {\n\t\t\t\t\t\t\tif (client.readyState === WebSocket.OPEN) {\n\t\t\t\t\t\t\t\tclient.send(JSON.stringify(broadcastData));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.error('Error processing WebSocket message:', error);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Handle disconnection\n\t\t\tws.on('close', () => {\n\t\t\t\tlogger.info('WebSocket client disconnected');\n\t\t\t\tclients.delete(ws);\n\t\t\t});\n\t\t});\n\t} else {\n\t\t// In development mode, log that WebSocket is disabled\n\t\tlogger.info('⚠️ WebSocket server is DISABLED in development mode to prevent connection errors');\n\t}\n\n\t// Export the WebSocket clients set so other routes can access it\n\t// Even in development mode, we provide an empty set for compatibility\n\t(app as any).wss = { clients };\n\n\treturn httpServer;\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/services/ccpayment-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/services/path-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/services/tip-service-ccpayment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/services/xp-clout-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/services/xp-level-service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'titles' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'badges' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'avatarFrames' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getLevelForXp' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":20,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getXpForLevel' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":20,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport {\n\tusers,\n\tlevels,\n\teconomySettings,\n\tuserTitles,\n\tuserBadges,\n\ttitles,\n\tbadges,\n\tuserOwnedFrames,\n\tavatarFrames,\n\txpCloutSettings,\n\tuserRoles,\n\troles as rolesTable,\n\tforumStructure\n} from '@schema';\nimport type { UserId } from '@shared/types';\nimport { eq, sql, lte, desc, and, isNull } from 'drizzle-orm';\nimport { logger } from '../src/core/logger';\nimport { getLevelForXp, getXpForLevel } from '@shared/economy/reward-calculator';\nimport { sanitizeMultiplier } from '@shared/economy/economy.config';\nimport { TitleId, BadgeId, FrameId, ForumId } from \"@shared/types\";\n\n/**\n * XP Action types used in economySettings\n */\nexport const XP_ACTIONS = {\n\tPOST_CREATED: 'POST_CREATED',\n\tREPLY_CREATED: 'REPLY_CREATED',\n\tHELPFUL_REACTION_RECEIVED: 'HELPFUL_REACTION_RECEIVED',\n\tLIKE_REACTION_RECEIVED: 'LIKE_REACTION_RECEIVED',\n\tTIP_RECEIVED: 'TIP_RECEIVED',\n\tMOD_MARK_RECEIVED: 'MOD_MARK_RECEIVED',\n\tDAILY_XP_CAP: 'DAILY_XP_CAP',\n\tTIP_XP_PER_UNIT: 'TIP_XP_PER_UNIT',\n\tTIP_XP_MAX_PER_EVENT: 'TIP_XP_MAX_PER_EVENT',\n\t// Dictionary feature actions\n\tDICTIONARY_ENTRY_SUBMITTED: 'DICTIONARY_ENTRY_SUBMITTED',\n\tDICTIONARY_ENTRY_APPROVED: 'DICTIONARY_ENTRY_APPROVED',\n\tDICTIONARY_ENTRY_UPVOTED: 'DICTIONARY_ENTRY_UPVOTED',\n\tDICTIONARY_ENTRY_APPROVAL: 'DICTIONARY_ENTRY_APPROVAL'\n};\n\n/**\n * Service for handling XP and level progression\n */\nexport class XpLevelService {\n\tprivate db;\n\t// private walletService; // Placeholder for wallet service integration\n\n\tconstructor(drizzleInstance = db) {\n\t\tthis.db = drizzleInstance;\n\t}\n\n\t/**\n\t * Award XP to a user for a specific action\n\t * @param userId The user ID to award XP to\n\t * @param actionKey The action key from XP_ACTIONS\n\t * @param metadata Optional metadata (e.g., tip amount for TIP_RECEIVED)\n\t * @returns Object containing success info and XP awarded\n\t */\n\tasync awardXp(\n\t\tuserId: UserId,\n\t\tactionKey: string,\n\t\tmetadata?: { amount?: number }\n\t): Promise<{\n\t\tsuccess: boolean;\n\t\txpAwarded: number;\n\t\tnewTotal: number;\n\t\tlevelUp: boolean;\n\t\tnewLevel?: number;\n\t}> {\n\t\ttry {\n\t\t\t// Get base XP value for the action\n\t\t\tlet baseXp = await this.getXpValue(actionKey);\n\n\t\t\t// Special handling for tips (if applicable)\n\t\t\tif (actionKey === XP_ACTIONS.TIP_RECEIVED && metadata?.amount) {\n\t\t\t\tconst xpPerUnit = (await this.getXpValue(XP_ACTIONS.TIP_XP_PER_UNIT)) || 0;\n\t\t\t\tconst maxTipXp = (await this.getXpValue(XP_ACTIONS.TIP_XP_MAX_PER_EVENT)) || 0;\n\n\t\t\t\tbaseXp = Math.floor(metadata.amount * xpPerUnit);\n\n\t\t\t\t// Cap to maximum if defined\n\t\t\t\tif (maxTipXp > 0) {\n\t\t\t\t\tbaseXp = Math.min(baseXp, maxTipXp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply role-based XP multiplier with protection\n\t\t\tconst xpMultiplier = await this.getUserXpMultiplier(userId);\n\t\t\tbaseXp = Math.floor(baseXp * xpMultiplier);\n\n\t\t\t// If no XP to award, return early\n\t\t\tif (baseXp <= 0) {\n\t\t\t\tlogger.info('XpLevelService', `No XP to award for action ${actionKey} to user ${userId}`);\n\t\t\t\treturn { success: false, xpAwarded: 0, newTotal: 0, levelUp: false };\n\t\t\t}\n\n\t\t\t// Check daily XP cap\n\t\t\tconst { allowedXp, newDailyTotal } = await this.checkDailyXpCap(userId, baseXp);\n\n\t\t\t// If no XP allowed (hit cap), return early\n\t\t\tif (allowedXp <= 0) {\n\t\t\t\tlogger.info('XpLevelService', `User ${userId} has hit daily XP cap, no XP awarded`);\n\t\t\t\treturn { success: false, xpAwarded: 0, newTotal: 0, levelUp: false };\n\t\t\t}\n\n\t\t\t// Use a transaction to ensure data consistency\n\t\t\treturn await this.db.transaction(async (tx) => {\n\t\t\t\t// Get current user level for comparison later\n\t\t\t\tconst userResult = await tx\n\t\t\t\t\t.select({\n\t\t\t\t\t\tcurrentXp: users.xp,\n\t\t\t\t\t\tcurrentLevel: users.level\n\t\t\t\t\t})\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tif (userResult.length === 0) {\n\t\t\t\t\tlogger.warn('XpLevelService', `User ${userId} not found`);\n\t\t\t\t\treturn { success: false, xpAwarded: 0, newTotal: 0, levelUp: false };\n\t\t\t\t}\n\n\t\t\t\tconst { currentXp, currentLevel } = userResult[0];\n\t\t\t\tconst newXp = currentXp + allowedXp;\n\n\t\t\t\t// Update user XP and daily tracking\n\t\t\t\tawait tx\n\t\t\t\t\t.update(users)\n\t\t\t\t\t.set({\n\t\t\t\t\t\txp: sql`${users.xp} + ${allowedXp}`,\n\t\t\t\t\t\tdailyXpGained: newDailyTotal,\n\t\t\t\t\t\tlastXpGainDate: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\t\t// Calculate if user has leveled up\n\t\t\t\tconst targetLevelData = await tx\n\t\t\t\t\t.select({\n\t\t\t\t\t\tlevel: levels.level\n\t\t\t\t\t})\n\t\t\t\t\t.from(levels)\n\t\t\t\t\t.where(lte(levels.minXp, newXp))\n\t\t\t\t\t.orderBy(desc(levels.level))\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tconst newLevel = targetLevelData.length > 0 ? targetLevelData[0].level : 1;\n\t\t\t\tconst levelUp = newLevel > currentLevel;\n\n\t\t\t\t// If leveled up, update user's level and distribute rewards\n\t\t\t\tif (levelUp) {\n\t\t\t\t\tawait this.handleLevelUp(tx, userId, currentLevel, newLevel);\n\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t'XpLevelService',\n\t\t\t\t\t\t`User ${userId} leveled up from ${currentLevel} to ${newLevel}`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlogger.info(\n\t\t\t\t\t'XpLevelService',\n\t\t\t\t\t`Awarded ${allowedXp} XP to user ${userId} for action ${actionKey}. New total: ${newXp}`\n\t\t\t\t);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\txpAwarded: allowedXp,\n\t\t\t\t\tnewTotal: newXp,\n\t\t\t\t\tlevelUp,\n\t\t\t\t\tnewLevel: levelUp ? newLevel : undefined\n\t\t\t\t};\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error(\n\t\t\t\t'XpLevelService',\n\t\t\t\t`Error awarding XP for action ${actionKey} to user ${userId}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t\treturn { success: false, xpAwarded: 0, newTotal: 0, levelUp: false };\n\t\t}\n\t}\n\n\t/**\n\t * Fetch the XP value for a specific action from economySettings\n\t * @param actionKey The action key from XP_ACTIONS\n\t * @returns The XP value for the action, or 0 if not found\n\t */\n\tprivate async getXpValue(actionKey: string): Promise<number> {\n\t\ttry {\n\t\t\t// First try the economySettings table\n\t\t\tconst economySetting = await this.db\n\t\t\t\t.select({\n\t\t\t\t\tvalue: economySettings.value\n\t\t\t\t})\n\t\t\t\t.from(economySettings)\n\t\t\t\t.where(eq(economySettings.key, actionKey))\n\t\t\t\t.limit(1);\n\n\t\t\tif (economySetting.length > 0) {\n\t\t\t\treturn economySetting[0].value;\n\t\t\t}\n\n\t\t\t// If not found in economySettings, try xpCloutSettings\n\t\t\tconst xpCloutSetting = await this.db\n\t\t\t\t.select({\n\t\t\t\t\txpValue: xpCloutSettings.xpValue\n\t\t\t\t})\n\t\t\t\t.from(xpCloutSettings)\n\t\t\t\t.where(eq(xpCloutSettings.actionKey, actionKey))\n\t\t\t\t.limit(1);\n\n\t\t\tif (xpCloutSetting.length > 0) {\n\t\t\t\treturn xpCloutSetting[0].xpValue;\n\t\t\t}\n\n\t\t\tlogger.warn('XpLevelService', `No XP value found for action key ${actionKey}`);\n\t\t\treturn 0;\n\t\t} catch (error) {\n\t\t\tlogger.error('XpLevelService', `Error getting XP value for action ${actionKey}:`, error);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Check if the user has hit their daily XP cap and calculate allowed XP\n\t * @param userId The user ID to check\n\t * @param xpToAward The amount of XP to award\n\t * @returns Object containing allowed XP and new daily total\n\t */\n\tprivate async checkDailyXpCap(\n\t\tuserId: UserId,\n\t\txpToAward: number\n\t): Promise<{ allowedXp: number; newDailyTotal: number }> {\n\t\ttry {\n\t\t\t// Get the daily XP cap from settings\n\t\t\tconst dailyCapSetting = await this.getXpValue(XP_ACTIONS.DAILY_XP_CAP);\n\n\t\t\t// If no cap is set or it's 0, no limit applies\n\t\t\tif (!dailyCapSetting || dailyCapSetting <= 0) {\n\t\t\t\treturn { allowedXp: xpToAward, newDailyTotal: xpToAward };\n\t\t\t}\n\n\t\t\t// Get user's current daily XP gained and last gain date\n\t\t\tconst userResult = await this.db\n\t\t\t\t.select({\n\t\t\t\t\tdailyXpGained: users.dailyXpGained,\n\t\t\t\t\tlastXpGainDate: users.lastXpGainDate\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userResult.length === 0) {\n\t\t\t\tlogger.warn('XpLevelService', `User ${userId} not found when checking daily cap`);\n\t\t\t\treturn { allowedXp: 0, newDailyTotal: 0 };\n\t\t\t}\n\n\t\t\tconst { dailyXpGained, lastXpGainDate } = userResult[0];\n\n\t\t\t// Reset daily XP if it's a new day or first gain ever\n\t\t\tconst today = new Date();\n\t\t\ttoday.setHours(0, 0, 0, 0); // Start of today\n\n\t\t\tlet currentDailyXp = dailyXpGained || 0;\n\t\t\tif (!lastXpGainDate || new Date(lastXpGainDate) < today) {\n\t\t\t\tcurrentDailyXp = 0; // Reset if last gain was before today or never gained before\n\t\t\t}\n\n\t\t\t// Calculate how much XP can be awarded within the cap\n\t\t\tconst remainingCap = Math.max(0, dailyCapSetting - currentDailyXp);\n\t\t\tconst allowedXp = Math.min(xpToAward, remainingCap);\n\t\t\tconst newDailyTotal = currentDailyXp + allowedXp;\n\n\t\t\tif (allowedXp < xpToAward) {\n\t\t\t\tlogger.info(\n\t\t\t\t\t'XpLevelService',\n\t\t\t\t\t`User ${userId} hit daily XP cap. Awarded ${allowedXp}/${xpToAward} XP`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn { allowedXp, newDailyTotal };\n\t\t} catch (error) {\n\t\t\tlogger.error('XpLevelService', `Error checking daily XP cap for user ${userId}:`, error);\n\t\t\treturn { allowedXp: 0, newDailyTotal: 0 };\n\t\t}\n\t}\n\n\t/**\n\t * Handle the level up process - update user level and distribute rewards\n\t * @param tx The transaction object\n\t * @param userId The user ID that leveled up\n\t * @param currentLevel The user's current level\n\t * @param newLevel The user's new level\n\t */\n\tprivate async handleLevelUp(\n\t\ttx: any,\n\t\tuserId: UserId,\n\t\tcurrentLevel: number,\n\t\tnewLevel: number\n\t): Promise<void> {\n\t\ttry {\n\t\t\t// Update the user's level\n\t\t\tawait tx.update(users).set({ level: newLevel }).where(eq(users.id, userId));\n\n\t\t\t// Distribute rewards for each level gained\n\t\t\tfor (let level = currentLevel + 1; level <= newLevel; level++) {\n\t\t\t\tawait this.distributeRewards(tx, userId, level);\n\t\t\t}\n\n\t\t\t// In a real implementation, we might want to add a notification here\n\t\t\t// or trigger some other celebration event\n\t\t} catch (error) {\n\t\t\tlogger.error(\n\t\t\t\t'XpLevelService',\n\t\t\t\t`Error handling level up for user ${userId} from ${currentLevel} to ${newLevel}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t\tthrow error; // Re-throw to be caught by the transaction\n\t\t}\n\t}\n\n\t/**\n\t * Distribute rewards (DGT, Titles, Badges) for a specific level\n\t * @param tx The transaction object\n\t * @param userId The user ID to reward\n\t * @param level The level to distribute rewards for\n\t */\n\tprivate async distributeRewards(tx: any, userId: UserId, level: number): Promise<void> {\n\t\ttry {\n\t\t\t// Get the level data to check for rewards\n\t\t\tconst levelData = await tx\n\t\t\t\t.select({\n\t\t\t\t\trewardDgt: levels.rewardDgt,\n\t\t\t\t\trewardTitleId: levels.rewardTitleId,\n\t\t\t\t\trewardBadgeId: levels.rewardBadgeId,\n\t\t\t\t\tunlocks: levels.unlocks\n\t\t\t\t})\n\t\t\t\t.from(levels)\n\t\t\t\t.where(eq(levels.level, level))\n\t\t\t\t.limit(1);\n\n\t\t\tif (levelData.length === 0) {\n\t\t\t\tlogger.warn('XpLevelService', `No level data found for level ${level}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { rewardDgt, rewardTitleId, rewardBadgeId, unlocks } = levelData[0];\n\n\t\t\t// Award DGT if specified (would need a wallet service integration)\n\t\t\tif (rewardDgt && rewardDgt > 0) {\n\t\t\t\t// In real implementation, we'd call the wallet service here\n\t\t\t\t// await this.walletService.creditUser(userId, rewardDgt, `Level ${level} reward`);\n\n\t\t\t\tlogger.info(\n\t\t\t\t\t'XpLevelService',\n\t\t\t\t\t`DGT reward of ${rewardDgt} for level ${level} to user ${userId} (not implemented yet)`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Award Title if specified\n\t\t\tif (rewardTitleId) {\n\t\t\t\t// Add the title to the user's unlocked titles\n\t\t\t\tawait tx\n\t\t\t\t\t.insert(userTitles)\n\t\t\t\t\t.values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\ttitleId: rewardTitleId,\n\t\t\t\t\t\tawardedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.onConflictDoNothing();\n\n\t\t\t\t// Optionally set as active title if user doesn't have one set\n\t\t\t\tconst userResult = await tx\n\t\t\t\t\t.select({\n\t\t\t\t\t\tactiveTitleId: users.activeTitleId\n\t\t\t\t\t})\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tif (userResult.length > 0 && !userResult[0].activeTitleId) {\n\t\t\t\t\tawait tx.update(users).set({ activeTitleId: rewardTitleId }).where(eq(users.id, userId));\n\t\t\t\t}\n\n\t\t\t\tlogger.info(\n\t\t\t\t\t'XpLevelService',\n\t\t\t\t\t`Title ID ${rewardTitleId} awarded to user ${userId} for reaching level ${level}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Award Badge if specified\n\t\t\tif (rewardBadgeId) {\n\t\t\t\tawait tx\n\t\t\t\t\t.insert(userBadges)\n\t\t\t\t\t.values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tbadgeId: rewardBadgeId,\n\t\t\t\t\t\tawardedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.onConflictDoNothing();\n\n\t\t\t\tlogger.info(\n\t\t\t\t\t'XpLevelService',\n\t\t\t\t\t`Badge ID ${rewardBadgeId} awarded to user ${userId} for reaching level ${level}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// ──────────── New Unlocks JSON Handling ────────────\n\t\t\ttry {\n\t\t\t\tif (unlocks && typeof unlocks === 'object') {\n\t\t\t\t\t// Titles array\n\t\t\t\t\tif (Array.isArray(unlocks.titles) && unlocks.titles.length > 0) {\n\t\t\t\t\t\tawait tx\n\t\t\t\t\t\t\t.insert(userTitles)\n\t\t\t\t\t\t\t.values(\n\t\t\t\t\t\t\t\tunlocks.titles.map((titleId: TitleId) => ({\n\t\t\t\t\t\t\t\t\tuserId,\n\t\t\t\t\t\t\t\t\ttitleId,\n\t\t\t\t\t\t\t\t\tawardedAt: new Date()\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onConflictDoNothing();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Badges array\n\t\t\t\t\tif (Array.isArray(unlocks.badges) && unlocks.badges.length > 0) {\n\t\t\t\t\t\tawait tx\n\t\t\t\t\t\t\t.insert(userBadges)\n\t\t\t\t\t\t\t.values(\n\t\t\t\t\t\t\t\tunlocks.badges.map((badgeId: BadgeId) => ({\n\t\t\t\t\t\t\t\t\tuserId,\n\t\t\t\t\t\t\t\t\tbadgeId,\n\t\t\t\t\t\t\t\t\tawardedAt: new Date()\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onConflictDoNothing();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Frames array – verify frame IDs exist\n\t\t\t\t\tif (Array.isArray(unlocks.frames) && unlocks.frames.length > 0) {\n\t\t\t\t\t\tawait tx\n\t\t\t\t\t\t\t.insert(userOwnedFrames)\n\t\t\t\t\t\t\t.values(\n\t\t\t\t\t\t\t\tunlocks.frames.map((frameId: FrameId) => ({\n\t\t\t\t\t\t\t\t\tuserId,\n\t\t\t\t\t\t\t\t\tframeId,\n\t\t\t\t\t\t\t\t\tsource: 'level'\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onConflictDoNothing();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (unlockErr) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t'XpLevelService',\n\t\t\t\t\t`Error applying unlocks for level ${level} to user ${userId}:`,\n\t\t\t\t\tunlockErr\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(\n\t\t\t\t'XpLevelService',\n\t\t\t\t`Error distributing rewards for level ${level} to user ${userId}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t\tthrow error; // Re-throw to be caught by the transaction\n\t\t}\n\t}\n\n\t/**\n\t * Get a user's XP, level, and progress to next level\n\t * @param userId The user ID to get info for\n\t * @returns Object with current XP, level, next level XP, and progress percentage\n\t */\n\tasync getUserXpInfo(userId: UserId): Promise<{\n\t\tcurrentXp: number;\n\t\tcurrentLevel: number;\n\t\tnextLevelXp: number | null;\n\t\tprogressPercent: number;\n\t\tneedXp: number | null;\n\t}> {\n\t\ttry {\n\t\t\t// Get user's current XP and level\n\t\t\tconst userResult = await this.db\n\t\t\t\t.select({\n\t\t\t\t\txp: users.xp,\n\t\t\t\t\tlevel: users.level\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userResult.length === 0) {\n\t\t\t\tthrow new Error(`User ${userId} not found`);\n\t\t\t}\n\n\t\t\tconst { xp: currentXp, level: currentLevel } = userResult[0];\n\n\t\t\t// Get current level XP threshold\n\t\t\tconst currentLevelData = await this.db\n\t\t\t\t.select({\n\t\t\t\t\tminXp: levels.minXp\n\t\t\t\t})\n\t\t\t\t.from(levels)\n\t\t\t\t.where(eq(levels.level, currentLevel))\n\t\t\t\t.limit(1);\n\n\t\t\t// Get next level XP threshold\n\t\t\tconst nextLevelData = await this.db\n\t\t\t\t.select({\n\t\t\t\t\tminXp: levels.minXp\n\t\t\t\t})\n\t\t\t\t.from(levels)\n\t\t\t\t.where(eq(levels.level, currentLevel + 1))\n\t\t\t\t.limit(1);\n\n\t\t\t// If no next level defined, user is at max level\n\t\t\tif (nextLevelData.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tcurrentXp,\n\t\t\t\t\tcurrentLevel,\n\t\t\t\t\tnextLevelXp: null,\n\t\t\t\t\tprogressPercent: 100,\n\t\t\t\t\tneedXp: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst currentLevelXp = currentLevelData.length > 0 ? currentLevelData[0].minXp : 0;\n\t\t\tconst nextLevelXp = nextLevelData[0].minXp;\n\t\t\tconst xpNeeded = nextLevelXp - currentLevelXp;\n\t\t\tconst xpProgress = currentXp - currentLevelXp;\n\n\t\t\t// Calculate progress percentage (0-100)\n\t\t\tconst progressPercent = Math.min(Math.floor((xpProgress / xpNeeded) * 100), 100);\n\t\t\tconst needXp = nextLevelXp - currentXp;\n\n\t\t\treturn {\n\t\t\t\tcurrentXp,\n\t\t\t\tcurrentLevel,\n\t\t\t\tnextLevelXp,\n\t\t\t\tprogressPercent,\n\t\t\t\tneedXp\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('XpLevelService', `Error getting XP info for user ${userId}:`, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get the effective XP multiplier for a user based on their roles.\n\t * If the user has multiple roles, the highest multiplier is applied.\n\t * If the user has no roles with a multiplier > 0, a default of 1 is returned.\n\t * Now includes forum multiplier protection against stacking exploits.\n\t */\n\tprivate async getUserXpMultiplier(userId: UserId, forumId?: ForumId): Promise<number> {\n\t\ttry {\n\t\t\t// Get role multiplier\n\t\t\tconst roleMultipliers = await this.db\n\t\t\t\t.select({ multiplier: rolesTable.xpMultiplier })\n\t\t\t\t.from(userRoles)\n\t\t\t\t.innerJoin(rolesTable, eq(userRoles.roleId, rolesTable.id))\n\t\t\t\t.where(eq(userRoles.userId, userId));\n\n\t\t\tconst roleMultiplier =\n\t\t\t\troleMultipliers.length === 0\n\t\t\t\t\t? 1\n\t\t\t\t\t: Math.max(...roleMultipliers.map((r) => r.multiplier ?? 1));\n\n\t\t\t// Get forum multiplier if forumId provided\n\t\t\tlet forumMultiplier = 1;\n\t\t\tif (forumId) {\n\t\t\t\tconst [forum] = await this.db\n\t\t\t\t\t.select({ xpMultiplier: forumStructure.xpMultiplier })\n\t\t\t\t\t.from(forumStructure)\n\t\t\t\t\t.where(eq(forumStructure.id, forumId))\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tforumMultiplier = forum?.xpMultiplier ?? 1.0;\n\t\t\t}\n\n\t\t\t// Apply multiplier protection\n\t\t\tconst result = sanitizeMultiplier(roleMultiplier, forumMultiplier, {\n\t\t\t\tuserId,\n\t\t\t\tforumId\n\t\t\t});\n\n\t\t\tif (result.wasCapped) {\n\t\t\t\tlogger.warn('XpLevelService', 'XP multiplier was capped for user', {\n\t\t\t\t\tuserId,\n\t\t\t\t\tforumId,\n\t\t\t\t\troleMultiplier,\n\t\t\t\t\tforumMultiplier,\n\t\t\t\t\toriginalMultiplier: result.originalMultiplier,\n\t\t\t\t\tfinalMultiplier: result.finalMultiplier,\n\t\t\t\t\tviolations: result.violations\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn result.finalMultiplier;\n\t\t} catch (error) {\n\t\t\tlogger.error('XpLevelService', `Error fetching XP multiplier for user ${userId}:`, error);\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n\n// Export a singleton instance\nexport const xpLevelService = new XpLevelService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/app.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/config/forum.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/audit/audit-logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/background-processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/base-controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/cache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/config.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/config/environment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/db.ts","messages":[{"ruleId":"prefer-const","severity":1,"message":"'pool' is never reassigned. Use 'const' instead.","line":26,"column":1,"nodeType":"Identifier","messageId":"useConst","endLine":26,"endColumn":5},{"ruleId":"prefer-const","severity":1,"message":"'db' is never reassigned. Use 'const' instead.","line":34,"column":1,"nodeType":"Identifier","messageId":"useConst","endLine":34,"endColumn":3}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool, neonConfig } from '@neondatabase/serverless';\nimport { drizzle as drizzleNeon } from 'drizzle-orm/neon-serverless';\nimport ws from 'ws';\nimport * as schema from '@schema';\nimport { logger, LogLevel, LogAction } from './logger';\n\n// Environment variables should be loaded by the application entry point (e.g., server/index.ts)\n\nneonConfig.webSocketConstructor = ws;\n\nif (!process.env.DATABASE_URL) {\n\tthrow new Error('DATABASE_URL must be set. Did you forget to provision a database?');\n}\n\nlet db: any; // Use 'any' for now, or create a common Drizzle instance type\nlet pool: Pool | undefined; // Pool is only for Neon/Postgres\n\n// Configure pool with retry settings\nconst poolConfig = {\n\tconnectionString: process.env.DATABASE_URL,\n\tmax: 10,\n\tconnectionTimeoutMillis: 10000,\n\tretryDelay: 1000,\n\tmaxRetries: 3\n};\npool = new Pool(poolConfig);\n\n// Add connection error handling\npool.on('error', (err) => {\n\tlogger.error('DATABASE', 'Unexpected error on idle database client', err);\n\tprocess.exit(-1);\n});\n\ndb = drizzleNeon(pool, { schema });\nlogger.info('DATABASE', 'Using PostgreSQL (Neon) database provider.');\n\n// Add retry wrapper\nconst withRetry = async <T>(operation: () => Promise<T>): Promise<T> => {\n\tlet lastError;\n\tfor (let i = 0; i < 3; i++) {\n\t\ttry {\n\t\t\treturn await operation();\n\t\t} catch (error: any) {\n\t\t\tlastError = error;\n\t\t\t// Specific error code for Neon/Postgres connection issues\n\t\t\tif (error.code === '57P01') {\n\t\t\t\tlogger.warn('DATABASE', `Connection error (attempt ${i + 1}), retrying...`);\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 1000 * (i + 1)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// For other errors, throw immediately\n\t\t\tthrow error;\n\t\t}\n\t}\n\tlogger.error('DATABASE', 'Max retries reached for database operation.', lastError);\n\tthrow lastError;\n};\n\nexport { db, pool, withRetry };\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/errors.ts","messages":[{"ruleId":"@typescript-eslint/ban-types","severity":1,"message":"Don't use `Function` as a type. The `Function` type accepts any function-like value.\nIt provides no type safety when calling the function, which can be a common source of bugs.\nIt also accepts things like class declarations, which will throw at runtime as they will not be called with `new`.\nIf you are expecting the function to accept certain arguments, you should explicitly define the function shape.","line":266,"column":34,"nodeType":"Identifier","messageId":"bannedTypeMessage","endLine":266,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used.","line":291,"column":77,"nodeType":"Identifier","messageId":"unusedVar","endLine":291,"endColumn":95}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Production Error System\n *\n * Centralized error handling with structured logging, error codes,\n * and consistent API responses. Optimized for debugging and monitoring.\n */\n\nimport type { Request, Response, NextFunction } from 'express';\nimport { logger } from './logger';\nimport { getAuthenticatedUser } from \"@server/src/core/utils/auth.helpers\";\n\n// Error severity for monitoring & alerting\nexport enum ErrorSeverity {\n\tLOW = 'low',\n\tMEDIUM = 'medium',\n\tHIGH = 'high',\n\tCRITICAL = 'critical'\n}\n\n// Structured error codes with categories\nexport enum ErrorCodes {\n\t// HTTP Standard (400-499)\n\tBAD_REQUEST = 'BAD_REQUEST',\n\tUNAUTHORIZED = 'UNAUTHORIZED',\n\tFORBIDDEN = 'FORBIDDEN',\n\tNOT_FOUND = 'NOT_FOUND',\n\tCONFLICT = 'CONFLICT',\n\tVALIDATION_FAILED = 'VALIDATION_FAILED',\n\tRATE_LIMITED = 'RATE_LIMITED',\n\n\t// Business Logic (1000-1999)\n\tINSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',\n\tRESOURCE_LOCKED = 'RESOURCE_LOCKED',\n\tOPERATION_NOT_ALLOWED = 'OPERATION_NOT_ALLOWED',\n\tBUSINESS_RULE_VIOLATION = 'BUSINESS_RULE_VIOLATION',\n\n\t// Authentication (2000-2099)\n\tINVALID_CREDENTIALS = 'INVALID_CREDENTIALS',\n\tTOKEN_EXPIRED = 'TOKEN_EXPIRED',\n\tTOKEN_INVALID = 'TOKEN_INVALID',\n\tSESSION_EXPIRED = 'SESSION_EXPIRED',\n\n\t// Database (3000-3099)\n\tDB_CONNECTION_FAILED = 'DB_CONNECTION_FAILED',\n\tDB_QUERY_FAILED = 'DB_QUERY_FAILED',\n\tDB_CONSTRAINT_VIOLATION = 'DB_CONSTRAINT_VIOLATION',\n\tDB_TRANSACTION_FAILED = 'DB_TRANSACTION_FAILED',\n\n\t// External Services (4000-4099)\n\tEXTERNAL_API_ERROR = 'EXTERNAL_API_ERROR',\n\tPAYMENT_PROVIDER_ERROR = 'PAYMENT_PROVIDER_ERROR',\n\tEMAIL_SERVICE_ERROR = 'EMAIL_SERVICE_ERROR',\n\n\t// System (5000-5099)\n\tSERVER_ERROR = 'SERVER_ERROR',\n\tSERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',\n\tTIMEOUT = 'TIMEOUT',\n\tMEMORY_LIMIT = 'MEMORY_LIMIT',\n\n\t// Domain Specific\n\tWALLET_INSUFFICIENT_FUNDS = 'WALLET_INSUFFICIENT_FUNDS',\n\tWALLET_TRANSACTION_FAILED = 'WALLET_TRANSACTION_FAILED',\n\tTHREAD_LOCKED = 'THREAD_LOCKED',\n\tUSER_BANNED = 'USER_BANNED'\n}\n\n// Error context for debugging\nexport interface ErrorContext {\n\tuserId?: string;\n\trequestId?: string;\n\tuserAgent?: string;\n\tip?: string;\n\tpath?: string;\n\tmethod?: string;\n\ttimestamp?: string;\n\tstack?: string;\n}\n\n// Structured error response\nexport interface ErrorResponse {\n\tsuccess: false;\n\terror: {\n\t\tcode: ErrorCodes;\n\t\tmessage: string;\n\t\tdetails?: unknown;\n\t\trequestId?: string;\n\t\ttimestamp: string;\n\t};\n}\n\n/**\n * Enhanced base error class with monitoring integration\n */\nexport class AppError extends Error {\n\tpublic readonly timestamp: string;\n\tpublic readonly requestId?: string;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic readonly httpStatus: number = 500,\n\t\tpublic readonly code: ErrorCodes = ErrorCodes.SERVER_ERROR,\n\t\tpublic readonly severity: ErrorSeverity = ErrorSeverity.MEDIUM,\n\t\tpublic readonly details?: unknown,\n\t\tpublic readonly context?: ErrorContext\n\t) {\n\t\tsuper(message);\n\t\tthis.name = 'AppError';\n\t\tthis.timestamp = new Date().toISOString();\n\t\tthis.requestId = context?.requestId;\n\n\t\t// Maintain stack trace\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, AppError);\n\t\t}\n\t}\n\n\ttoJSON(): ErrorResponse {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: {\n\t\t\t\tcode: this.code,\n\t\t\t\tmessage: this.message,\n\t\t\t\tdetails: this.details,\n\t\t\t\trequestId: this.requestId,\n\t\t\t\ttimestamp: this.timestamp\n\t\t\t}\n\t\t};\n\t}\n}\n\n// HTTP Standard Errors\nexport class BadRequestError extends AppError {\n\tconstructor(message = 'Bad request', details?: unknown, context?: ErrorContext) {\n\t\tsuper(message, 400, ErrorCodes.BAD_REQUEST, ErrorSeverity.LOW, details, context);\n\t}\n}\n\nexport class UnauthorizedError extends AppError {\n\tconstructor(message = 'Authentication required', context?: ErrorContext) {\n\t\tsuper(message, 401, ErrorCodes.UNAUTHORIZED, ErrorSeverity.MEDIUM, undefined, context);\n\t}\n}\n\nexport class ForbiddenError extends AppError {\n\tconstructor(message = 'Access forbidden', context?: ErrorContext) {\n\t\tsuper(message, 403, ErrorCodes.FORBIDDEN, ErrorSeverity.MEDIUM, undefined, context);\n\t}\n}\n\nexport class NotFoundError extends AppError {\n\tconstructor(resource = 'Resource', context?: ErrorContext) {\n\t\tsuper(\n\t\t\t`${resource} not found`,\n\t\t\t404,\n\t\t\tErrorCodes.NOT_FOUND,\n\t\t\tErrorSeverity.LOW,\n\t\t\tundefined,\n\t\t\tcontext\n\t\t);\n\t}\n}\n\nexport class ConflictError extends AppError {\n\tconstructor(message = 'Resource conflict', details?: unknown, context?: ErrorContext) {\n\t\tsuper(message, 409, ErrorCodes.CONFLICT, ErrorSeverity.MEDIUM, details, context);\n\t}\n}\n\nexport class ValidationError extends AppError {\n\tconstructor(\n\t\tmessage = 'Validation failed',\n\t\tfield?: string,\n\t\terrors?: unknown,\n\t\tcontext?: ErrorContext\n\t) {\n\t\tsuper(\n\t\t\tmessage,\n\t\t\t400,\n\t\t\tErrorCodes.VALIDATION_FAILED,\n\t\t\tErrorSeverity.LOW,\n\t\t\t{ field, errors },\n\t\t\tcontext\n\t\t);\n\t}\n}\n\nexport class RateLimitError extends AppError {\n\tconstructor(message = 'Rate limit exceeded', retryAfter?: number, context?: ErrorContext) {\n\t\tsuper(message, 429, ErrorCodes.RATE_LIMITED, ErrorSeverity.MEDIUM, { retryAfter }, context);\n\t}\n}\n\n// Business Logic Errors\nexport class InsufficientPermissionsError extends AppError {\n\tconstructor(required: string, current?: string, context?: ErrorContext) {\n\t\tsuper(\n\t\t\t`Insufficient permissions. Required: ${required}${current ? `, Current: ${current}` : ''}`,\n\t\t\t403,\n\t\t\tErrorCodes.INSUFFICIENT_PERMISSIONS,\n\t\t\tErrorSeverity.MEDIUM,\n\t\t\t{ required, current },\n\t\t\tcontext\n\t\t);\n\t}\n}\n\nexport class BusinessRuleViolationError extends AppError {\n\tconstructor(rule: string, details?: unknown, context?: ErrorContext) {\n\t\tsuper(\n\t\t\t`Business rule violation: ${rule}`,\n\t\t\t400,\n\t\t\tErrorCodes.BUSINESS_RULE_VIOLATION,\n\t\t\tErrorSeverity.MEDIUM,\n\t\t\tdetails,\n\t\t\tcontext\n\t\t);\n\t}\n}\n\n// Database Errors\nexport class DatabaseError extends AppError {\n\tconstructor(operation: string, originalError?: Error, context?: ErrorContext) {\n\t\tsuper(\n\t\t\t`Database operation failed: ${operation}`,\n\t\t\t500,\n\t\t\tErrorCodes.DB_QUERY_FAILED,\n\t\t\tErrorSeverity.HIGH,\n\t\t\t{ operation, originalError: originalError?.message },\n\t\t\tcontext\n\t\t);\n\t}\n}\n\n// Domain Specific Errors\nexport class WalletError extends AppError {\n\tconstructor(message: string, code: ErrorCodes, details?: unknown, context?: ErrorContext) {\n\t\tsuper(message, 400, code, ErrorSeverity.MEDIUM, details, context);\n\t}\n}\n\nexport class InsufficientFundsError extends WalletError {\n\tconstructor(required: number, available: number, context?: ErrorContext) {\n\t\tsuper(\n\t\t\t`Insufficient funds. Required: ${required}, Available: ${available}`,\n\t\t\tErrorCodes.WALLET_INSUFFICIENT_FUNDS,\n\t\t\t{ required, available },\n\t\t\tcontext\n\t\t);\n\t}\n}\n\n// Error utilities\nexport function createErrorContext(req: Request): ErrorContext {\n\treturn {\n\t\tuserId: (getAuthenticatedUser(req) as any)?.id,\n\t\trequestId: req.headers['x-request-id'] as string,\n\t\tuserAgent: req.headers['user-agent'],\n\t\tip: req.ip || req.connection.remoteAddress,\n\t\tpath: req.path,\n\t\tmethod: req.method,\n\t\ttimestamp: new Date().toISOString()\n\t};\n}\n\n// Enhanced async handler with context\nexport const asyncHandler = (fn: Function) => (req: Request, res: Response, next: NextFunction) => {\n\tconst context = createErrorContext(req);\n\tPromise.resolve(fn(req, res, next)).catch((error) => {\n\t\tif (error instanceof AppError) {\n\t\t\t// Error already has context\n\t\t\tnext(error);\n\t\t} else {\n\t\t\t// Wrap unknown errors with context\n\t\t\tnext(\n\t\t\t\tnew AppError(\n\t\t\t\t\terror.message || 'Unknown error',\n\t\t\t\t\t500,\n\t\t\t\t\tErrorCodes.SERVER_ERROR,\n\t\t\t\t\tErrorSeverity.HIGH,\n\t\t\t\t\t{ originalError: error.name },\n\t\t\t\t\tcontext\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t});\n};\n\n/**\n * Production-ready global error handler with monitoring integration\n */\nexport function globalErrorHandler(err: Error, req: Request, res: Response, next: NextFunction) {\n\tconst context = createErrorContext(req);\n\tlet appError: AppError;\n\n\t// Convert to AppError if needed\n\tif (err instanceof AppError) {\n\t\tappError = err;\n\t} else {\n\t\t// Handle specific error types\n\t\tif (err.name === 'ValidationError') {\n\t\t\tappError = new ValidationError(err.message, undefined, undefined, context);\n\t\t} else if (err.name === 'CastError') {\n\t\t\tappError = new BadRequestError('Invalid ID format', { field: (err as any).path }, context);\n\t\t} else if (err.name === 'SyntaxError') {\n\t\t\tappError = new BadRequestError('Invalid JSON syntax', undefined, context);\n\t\t} else {\n\t\t\tappError = new AppError(\n\t\t\t\tprocess.env.NODE_ENV === 'production' ? 'Internal server error' : err.message,\n\t\t\t\t500,\n\t\t\t\tErrorCodes.SERVER_ERROR,\n\t\t\t\tErrorSeverity.HIGH,\n\t\t\t\tprocess.env.NODE_ENV === 'production' ? undefined : { stack: err.stack },\n\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t}\n\n\t// Structured logging with severity-based levels\n\tconst logLevel =\n\t\t{\n\t\t\t[ErrorSeverity.LOW]: 'info',\n\t\t\t[ErrorSeverity.MEDIUM]: 'warn',\n\t\t\t[ErrorSeverity.HIGH]: 'error',\n\t\t\t[ErrorSeverity.CRITICAL]: 'error'\n\t\t}[appError.severity] || 'error';\n\n\tlogger[logLevel]('REQUEST_ERROR', {\n\t\tcode: appError.code,\n\t\tmessage: appError.message,\n\t\tseverity: appError.severity,\n\t\thttpStatus: appError.httpStatus,\n\t\tcontext: appError.context,\n\t\tdetails: appError.details,\n\t\tstack: process.env.NODE_ENV !== 'production' ? err.stack : undefined\n\t});\n\n\t// Alert for critical errors (integrate with monitoring service)\n\tif (appError.severity === ErrorSeverity.CRITICAL) {\n\t\t// TODO: Integrate with alerting service (PagerDuty, Slack, etc.)\n\t\tlogger.error('CRITICAL_ERROR_ALERT', {\n\t\t\tcode: appError.code,\n\t\t\tmessage: appError.message,\n\t\t\tcontext: appError.context\n\t\t});\n\t}\n\n\t// Send structured response\n\tres.status(appError.httpStatus).json(appError.toJSON());\n}\n\n// Error factory functions for common scenarios\nexport const ErrorFactory = {\n\tnotFound: (resource: string, req?: Request) =>\n\t\tnew NotFoundError(resource, req ? createErrorContext(req) : undefined),\n\n\tunauthorized: (message?: string, req?: Request) =>\n\t\tnew UnauthorizedError(message, req ? createErrorContext(req) : undefined),\n\n\tforbidden: (required: string, current?: string, req?: Request) =>\n\t\tnew InsufficientPermissionsError(required, current, req ? createErrorContext(req) : undefined),\n\n\tvalidation: (field: string, errors: unknown, req?: Request) =>\n\t\tnew ValidationError(\n\t\t\t`Validation failed for ${field}`,\n\t\t\tfield,\n\t\t\terrors,\n\t\t\treq ? createErrorContext(req) : undefined\n\t\t),\n\n\tinsufficientFunds: (required: number, available: number, req?: Request) =>\n\t\tnew InsufficientFundsError(required, available, req ? createErrorContext(req) : undefined),\n\n\tdatabase: (operation: string, originalError?: Error, req?: Request) =>\n\t\tnew DatabaseError(operation, originalError, req ? createErrorContext(req) : undefined)\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/events/achievement-events.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/logger.ts","messages":[{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":219,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":219,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[5273,5311],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":222,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":222,"endColumn":17,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"info"},"fix":{"range":[5350,5387],"text":""},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":232,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":232,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5596,5632],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ForumFusion - Consolidated Logging System\n *\n * This is the centralized logging utility for the entire application.\n * It handles different log levels, formats, and outputs (console, file).\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { createWriteStream, WriteStream } from 'fs';\n\n// Log levels\nexport enum LogLevel {\n\tDEBUG = 'DEBUG',\n\tINFO = 'INFO',\n\tWARN = 'WARN',\n\tERROR = 'ERROR',\n\tCRITICAL = 'CRITICAL'\n}\n\n// Log action categories for better filtering and analysis\nexport enum LogAction {\n\t// System actions\n\tSYSTEM_STARTUP = 'SYSTEM_STARTUP',\n\tSYSTEM_SHUTDOWN = 'SYSTEM_SHUTDOWN',\n\tSCHEDULED_TASK = 'SCHEDULED_TASK',\n\n\t// User actions\n\tUSER_REGISTER = 'USER_REGISTER',\n\tUSER_LOGIN = 'USER_LOGIN',\n\tUSER_LOGOUT = 'USER_LOGOUT',\n\tUSER_UPDATE = 'USER_UPDATE',\n\n\t// Wallet actions\n\tWALLET_CREATE = 'WALLET_CREATE',\n\tWALLET_IMPORT = 'WALLET_IMPORT',\n\tWALLET_TRANSACTION = 'WALLET_TRANSACTION',\n\tTRANSACTION_VERIFY = 'TRANSACTION_VERIFY',\n\n\t// Vault actions\n\tVAULT_CREATE = 'VAULT_CREATE',\n\tVAULT_UNLOCK = 'VAULT_UNLOCK',\n\tVAULT_AUTO_UNLOCK = 'VAULT_AUTO_UNLOCK',\n\n\t// Forum actions\n\tTHREAD_CREATE = 'THREAD_CREATE',\n\tPOST_CREATE = 'POST_CREATE',\n\tPOST_EDIT = 'POST_EDIT',\n\tPOST_DELETE = 'POST_DELETE',\n\n\t// XP actions\n\tXP_AWARD = 'XP_AWARD',\n\tXP_ADJUSTMENT = 'XP_ADJUSTMENT',\n\tLEVEL_UP = 'LEVEL_UP',\n\n\t// API actions\n\tAPI_REQUEST = 'API_REQUEST',\n\tAPI_RESPONSE = 'API_RESPONSE',\n\tAPI_ERROR = 'API_ERROR',\n\n\t// Custom\n\tCUSTOM = 'CUSTOM'\n}\n\n// Default configuration\nconst DEFAULT_CONFIG = {\n\tconsole: process.env.NODE_ENV !== 'production',\n\tfile: process.env.NODE_ENV !== 'test',\n\tjsonOutput: process.env.NODE_ENV === 'production',\n\tfilePath: './logs',\n\tfileName: 'app.log',\n\tmaxFileSize: 10 * 1024 * 1024, // 10MB\n\tmaxFiles: 10,\n\tformatTimestamp: true,\n\tminLevel: process.env.NODE_ENV === 'production' ? LogLevel.INFO : LogLevel.DEBUG\n};\n\n// Logger configuration\nlet config = { ...DEFAULT_CONFIG };\nlet logStream: WriteStream | null = null;\nlet currentLogFile: string | null = null;\nlet currentFileSize = 0;\n\n/**\n * Initialize the logger with custom configuration\n */\nexport function initLogger(customConfig = {}) {\n\tconfig = { ...DEFAULT_CONFIG, ...customConfig };\n\n\t// Create log directory if it doesn't exist\n\tif (config.file) {\n\t\ttry {\n\t\t\tif (!fs.existsSync(config.filePath)) {\n\t\t\t\tfs.mkdirSync(config.filePath, { recursive: true });\n\t\t\t}\n\n\t\t\tconst logFilePath = path.join(config.filePath, config.fileName);\n\t\t\tcurrentLogFile = logFilePath;\n\t\t\t\n\t\t\t// Check current file size for rotation\n\t\t\tif (fs.existsSync(logFilePath)) {\n\t\t\t\tcurrentFileSize = fs.statSync(logFilePath).size;\n\t\t\t}\n\t\t\t\n\t\t\tlogStream = createWriteStream(logFilePath, { flags: 'a' });\n\n\t\t\t// Ensure logs are flushed on process exit\n\t\t\tprocess.on('exit', () => {\n\t\t\t\tif (logStream) {\n\t\t\t\t\tlogStream.end();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Log initial startup message\n\t\t\tlog({\n\t\t\t\tlevel: LogLevel.INFO,\n\t\t\t\taction: LogAction.SYSTEM_STARTUP,\n\t\t\t\tmessage: 'Logger initialized',\n\t\t\t\tdata: {\n\t\t\t\t\tenv: process.env.NODE_ENV,\n\t\t\t\t\tlogPath: logFilePath\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to initialize file logging:', error);\n\t\t}\n\t}\n}\n\n/**\n * Rotate log file when it exceeds max size\n */\nfunction rotateLogFile() {\n\tif (!currentLogFile || !logStream) return;\n\t\n\ttry {\n\t\t// Close current stream\n\t\tlogStream.end();\n\t\t\n\t\t// Rotate existing files\n\t\tfor (let i = config.maxFiles - 1; i > 0; i--) {\n\t\t\tconst oldFile = currentLogFile + (i === 1 ? '' : `.${i - 1}`);\n\t\t\tconst newFile = currentLogFile + `.${i}`;\n\t\t\t\n\t\t\tif (fs.existsSync(oldFile)) {\n\t\t\t\tif (i === config.maxFiles - 1) {\n\t\t\t\t\tfs.unlinkSync(oldFile); // Delete oldest\n\t\t\t\t} else {\n\t\t\t\t\tfs.renameSync(oldFile, newFile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Create new log stream\n\t\tlogStream = createWriteStream(currentLogFile, { flags: 'w' });\n\t\tcurrentFileSize = 0;\n\t\t\n\t\tlog({\n\t\t\tlevel: LogLevel.INFO,\n\t\t\taction: LogAction.SYSTEM_STARTUP,\n\t\t\tmessage: 'Log file rotated',\n\t\t\tdata: { file: currentLogFile }\n\t\t});\n\t} catch (error) {\n\t\tconsole.error('Failed to rotate log file:', error);\n\t}\n}\n\n/**\n * Format a log message with timestamp, level, and namespace\n */\nfunction formatLogMessage(level: LogLevel, namespace: string, message: string): string {\n\tconst timestamp = config.formatTimestamp ? `[${new Date().toISOString()}] ` : '';\n\n\treturn `${timestamp}[${level}] [${namespace}] ${message}`;\n}\n\n/**\n * Main logging function\n */\nexport function log(options: {\n\tlevel: LogLevel;\n\taction?: LogAction;\n\tnamespace?: string;\n\tmessage: string;\n\tdata?: any;\n}) {\n\tconst { level, action, namespace, message, data } = options;\n\n\t// Skip if level is below minimum\n\tconst levels = Object.values(LogLevel);\n\tif (levels.indexOf(level) < levels.indexOf(config.minLevel)) {\n\t\treturn;\n\t}\n\n\t// Use action as namespace if no namespace is provided\n\tconst logNamespace = namespace || (action ? action : 'APP');\n\n\tconst formattedMessage = formatLogMessage(level, logNamespace, message);\n\n\t// Format data if present\n\tlet dataString = '';\n\tif (data) {\n\t\ttry {\n\t\t\tif (typeof data === 'object') {\n\t\t\t\tdataString = '\\n' + JSON.stringify(data, null, 2);\n\t\t\t} else {\n\t\t\t\tdataString = '\\n' + String(data);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tdataString = '\\n[Error formatting data]';\n\t\t}\n\t}\n\n\t// Log to console\n\tif (config.console) {\n\t\tswitch (level) {\n\t\t\tcase LogLevel.DEBUG:\n\t\t\t\tconsole.debug(formattedMessage, data);\n\t\t\t\tbreak;\n\t\t\tcase LogLevel.INFO:\n\t\t\t\tconsole.info(formattedMessage, data);\n\t\t\t\tbreak;\n\t\t\tcase LogLevel.WARN:\n\t\t\t\tconsole.warn(formattedMessage, data);\n\t\t\t\tbreak;\n\t\t\tcase LogLevel.ERROR:\n\t\t\tcase LogLevel.CRITICAL:\n\t\t\t\tconsole.error(formattedMessage, data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.log(formattedMessage, data);\n\t\t}\n\t}\n\n\t// Log to file\n\tif (config.file && logStream) {\n\t\tconst logEntry = config.jsonOutput \n\t\t\t? JSON.stringify({\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\tlevel,\n\t\t\t\tnamespace: logNamespace,\n\t\t\t\tmessage,\n\t\t\t\taction,\n\t\t\t\tdata,\n\t\t\t\tpid: process.pid,\n\t\t\t\tenv: process.env.NODE_ENV\n\t\t\t}) + '\\n'\n\t\t\t: formattedMessage + dataString + '\\n';\n\t\t\n\t\t// Check for log rotation\n\t\tif (currentFileSize + logEntry.length > config.maxFileSize) {\n\t\t\trotateLogFile();\n\t\t}\n\t\t\n\t\tlogStream.write(logEntry);\n\t\tcurrentFileSize += logEntry.length;\n\t}\n}\n\n/**\n * Debug level logger\n */\nexport function debug(namespace: string, message: string, data?: any) {\n\tlog({\n\t\tlevel: LogLevel.DEBUG,\n\t\tnamespace,\n\t\tmessage,\n\t\tdata\n\t});\n}\n\n/**\n * Info level logger\n */\nexport function info(namespace: string, message: string, data?: any) {\n\tlog({\n\t\tlevel: LogLevel.INFO,\n\t\tnamespace,\n\t\tmessage,\n\t\tdata\n\t});\n}\n\n/**\n * Warning level logger\n */\nexport function warn(namespace: string, message: string, data?: any) {\n\tlog({\n\t\tlevel: LogLevel.WARN,\n\t\tnamespace,\n\t\tmessage,\n\t\tdata\n\t});\n}\n\n/**\n * Error level logger\n */\nexport function error(namespace: string, message: string, data?: any) {\n\tlog({\n\t\tlevel: LogLevel.ERROR,\n\t\tnamespace,\n\t\tmessage,\n\t\tdata\n\t});\n}\n\n/**\n * Critical error level logger\n */\nexport function critical(namespace: string, message: string, data?: any) {\n\tlog({\n\t\tlevel: LogLevel.CRITICAL,\n\t\tnamespace,\n\t\tmessage,\n\t\tdata\n\t});\n}\n\n// Initialize the logger with default config\ninitLogger();\n\n// Create and export a logger instance with convenient methods\nexport const logger = {\n\tdebug,\n\tinfo,\n\twarn,\n\terror,\n\tcritical,\n\tinit: initLogger\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/middleware/security.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/monitoring/health-check.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'stats' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":132,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":132,"endColumn":15},{"ruleId":"@typescript-eslint/ban-types","severity":1,"message":"Don't use `Function` as a type. The `Function` type accepts any function-like value.\nIt provides no type safety when calling the function, which can be a common source of bugs.\nIt also accepts things like class declarations, which will throw at runtime as they will not be called with `new`.\nIf you are expecting the function to accept certain arguments, you should explicitly define the function shape.","line":232,"column":77,"nodeType":"Identifier","messageId":"bannedTypeMessage","endLine":232,"endColumn":85}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Health Check Endpoints with Metrics\n *\n * Provides system health monitoring and metrics collection\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { db } from '@db';\nimport { sql } from 'drizzle-orm';\nimport { queryMonitor } from './query-performance';\nimport { logger } from '../logger';\nimport os from 'os';\n\nconst router = Router();\n\nexport interface HealthStatus {\n\tstatus: 'healthy' | 'degraded' | 'unhealthy';\n\ttimestamp: string;\n\tuptime: number;\n\tversion: string;\n\tservices: {\n\t\tdatabase: ServiceHealth;\n\t\tmemory: ServiceHealth;\n\t\tdisk: ServiceHealth;\n\t};\n\tmetrics: SystemMetrics;\n}\n\nexport interface ServiceHealth {\n\tstatus: 'healthy' | 'degraded' | 'unhealthy';\n\tresponseTime?: number;\n\tmessage?: string;\n\tdetails?: any;\n}\n\nexport interface SystemMetrics {\n\trequests: {\n\t\ttotal: number;\n\t\terrors: number;\n\t\taverageResponseTime: number;\n\t};\n\tdatabase: {\n\t\ttotalQueries: number;\n\t\tslowQueries: number;\n\t\taverageQueryTime: number;\n\t\terrorRate: number;\n\t};\n\tsystem: {\n\t\tmemoryUsage: NodeJS.MemoryUsage;\n\t\tcpuUsage: number;\n\t\tloadAverage: number[];\n\t\tdiskUsage?: number;\n\t};\n}\n\nclass HealthMonitor {\n\tprivate startTime = Date.now();\n\tprivate requestCount = 0;\n\tprivate errorCount = 0;\n\tprivate responseTimes: number[] = [];\n\n\t/**\n\t * Record request metrics\n\t */\n\trecordRequest(responseTime: number, isError = false): void {\n\t\tthis.requestCount++;\n\t\tif (isError) this.errorCount++;\n\n\t\tthis.responseTimes.push(responseTime);\n\n\t\t// Keep only last 1000 response times\n\t\tif (this.responseTimes.length > 1000) {\n\t\t\tthis.responseTimes = this.responseTimes.slice(-1000);\n\t\t}\n\t}\n\n\t/**\n\t * Check database health\n\t */\n\tasync checkDatabaseHealth(): Promise<ServiceHealth> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\tawait db.execute(sql`SELECT 1 as health_check`);\n\t\t\tconst responseTime = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\tstatus: responseTime < 1000 ? 'healthy' : 'degraded',\n\t\t\t\tresponseTime,\n\t\t\t\tmessage: `Database responded in ${responseTime}ms`\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tstatus: 'unhealthy',\n\t\t\t\tresponseTime: Date.now() - startTime,\n\t\t\t\tmessage: `Database connection failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Check memory health\n\t */\n\tcheckMemoryHealth(): ServiceHealth {\n\t\tconst usage = process.memoryUsage();\n\t\tconst totalMemory = os.totalmem();\n\t\tconst freeMemory = os.freemem();\n\t\tconst memoryUsagePercent = ((totalMemory - freeMemory) / totalMemory) * 100;\n\n\t\tlet status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n\t\tif (memoryUsagePercent > 90) status = 'unhealthy';\n\t\telse if (memoryUsagePercent > 80) status = 'degraded';\n\n\t\treturn {\n\t\t\tstatus,\n\t\t\tmessage: `Memory usage: ${memoryUsagePercent.toFixed(1)}%`,\n\t\t\tdetails: {\n\t\t\t\theapUsed: Math.round(usage.heapUsed / 1024 / 1024),\n\t\t\t\theapTotal: Math.round(usage.heapTotal / 1024 / 1024),\n\t\t\t\texternal: Math.round(usage.external / 1024 / 1024),\n\t\t\t\tsystemMemoryUsage: memoryUsagePercent.toFixed(1)\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Check disk health\n\t */\n\tcheckDiskHealth(): ServiceHealth {\n\t\ttry {\n\t\t\tconst stats = os.freemem();\n\t\t\t// This is a simplified check - in production you'd check actual disk usage\n\t\t\treturn {\n\t\t\t\tstatus: 'healthy',\n\t\t\t\tmessage: 'Disk space available'\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tstatus: 'unhealthy',\n\t\t\t\tmessage: `Failed to check disk space: ${error instanceof Error ? error.message : 'Unknown error'}`\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Get CPU usage\n\t */\n\tgetCpuUsage(): number {\n\t\tconst cpus = os.cpus();\n\t\tlet totalIdle = 0;\n\t\tlet totalTick = 0;\n\n\t\tcpus.forEach((cpu) => {\n\t\t\tfor (const type in cpu.times) {\n\t\t\t\ttotalTick += cpu.times[type as keyof typeof cpu.times];\n\t\t\t}\n\t\t\ttotalIdle += cpu.times.idle;\n\t\t});\n\n\t\treturn 100 - (totalIdle / totalTick) * 100;\n\t}\n\n\t/**\n\t * Get system metrics\n\t */\n\tgetSystemMetrics(): SystemMetrics {\n\t\tconst dbStats = queryMonitor.getStats();\n\t\tconst averageResponseTime =\n\t\t\tthis.responseTimes.length > 0\n\t\t\t\t? this.responseTimes.reduce((sum, time) => sum + time, 0) / this.responseTimes.length\n\t\t\t\t: 0;\n\n\t\treturn {\n\t\t\trequests: {\n\t\t\t\ttotal: this.requestCount,\n\t\t\t\terrors: this.errorCount,\n\t\t\t\taverageResponseTime\n\t\t\t},\n\t\t\tdatabase: dbStats,\n\t\t\tsystem: {\n\t\t\t\tmemoryUsage: process.memoryUsage(),\n\t\t\t\tcpuUsage: this.getCpuUsage(),\n\t\t\t\tloadAverage: os.loadavg()\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Get comprehensive health status\n\t */\n\tasync getHealthStatus(): Promise<HealthStatus> {\n\t\tconst [databaseHealth, memoryHealth, diskHealth] = await Promise.all([\n\t\t\tthis.checkDatabaseHealth(),\n\t\t\tPromise.resolve(this.checkMemoryHealth()),\n\t\t\tPromise.resolve(this.checkDiskHealth())\n\t\t]);\n\n\t\tconst services = {\n\t\t\tdatabase: databaseHealth,\n\t\t\tmemory: memoryHealth,\n\t\t\tdisk: diskHealth\n\t\t};\n\n\t\t// Determine overall status\n\t\tconst statuses = Object.values(services).map((s) => s.status);\n\t\tlet overallStatus: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n\n\t\tif (statuses.some((s) => s === 'unhealthy')) {\n\t\t\toverallStatus = 'unhealthy';\n\t\t} else if (statuses.some((s) => s === 'degraded')) {\n\t\t\toverallStatus = 'degraded';\n\t\t}\n\n\t\treturn {\n\t\t\tstatus: overallStatus,\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\tuptime: Date.now() - this.startTime,\n\t\t\tversion: process.env.npm_package_version || '1.0.0',\n\t\t\tservices,\n\t\t\tmetrics: this.getSystemMetrics()\n\t\t};\n\t}\n}\n\n// Global health monitor instance\nconst healthMonitor = new HealthMonitor();\n\n/**\n * Middleware to track request metrics\n */\nexport function requestMetricsMiddleware(req: Request, res: Response, next: Function) {\n\tconst startTime = Date.now();\n\n\tres.on('finish', () => {\n\t\tconst responseTime = Date.now() - startTime;\n\t\tconst isError = res.statusCode >= 400;\n\t\thealthMonitor.recordRequest(responseTime, isError);\n\t});\n\n\tnext();\n}\n\n/**\n * Basic health check endpoint\n */\nrouter.get('/health', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst health = await healthMonitor.getHealthStatus();\n\t\tconst statusCode = health.status === 'healthy' ? 200 : 503;\n\n\t\tres.status(statusCode).json(health);\n\t} catch (error) {\n\t\tlogger.error('HealthCheck', 'Health check failed', { error });\n\n\t\tres.status(503).json({\n\t\t\tstatus: 'unhealthy',\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\tmessage: 'Health check failed',\n\t\t\terror: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Liveness probe - basic server responsiveness\n */\nrouter.get('/health/live', (req: Request, res: Response) => {\n\tres.status(200).json({\n\t\tstatus: 'alive',\n\t\ttimestamp: new Date().toISOString(),\n\t\tuptime: process.uptime()\n\t});\n});\n\n/**\n * Readiness probe - ready to serve traffic\n */\nrouter.get('/health/ready', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst dbHealth = await healthMonitor.checkDatabaseHealth();\n\t\tconst isReady = dbHealth.status !== 'unhealthy';\n\n\t\tres.status(isReady ? 200 : 503).json({\n\t\t\tstatus: isReady ? 'ready' : 'not_ready',\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\tdatabase: dbHealth\n\t\t});\n\t} catch (error) {\n\t\tres.status(503).json({\n\t\t\tstatus: 'not_ready',\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\terror: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Metrics endpoint (Prometheus-compatible format)\n */\nrouter.get('/metrics', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst metrics = healthMonitor.getSystemMetrics();\n\t\tconst dbStats = queryMonitor.getStats();\n\n\t\t// Simple text format for metrics\n\t\tconst metricsText = [\n\t\t\t`# HELP http_requests_total Total HTTP requests`,\n\t\t\t`# TYPE http_requests_total counter`,\n\t\t\t`http_requests_total ${metrics.requests.total}`,\n\t\t\t'',\n\t\t\t`# HELP http_request_errors_total Total HTTP request errors`,\n\t\t\t`# TYPE http_request_errors_total counter`,\n\t\t\t`http_request_errors_total ${metrics.requests.errors}`,\n\t\t\t'',\n\t\t\t`# HELP http_request_duration_ms Average HTTP request duration`,\n\t\t\t`# TYPE http_request_duration_ms gauge`,\n\t\t\t`http_request_duration_ms ${metrics.requests.averageResponseTime}`,\n\t\t\t'',\n\t\t\t`# HELP db_queries_total Total database queries`,\n\t\t\t`# TYPE db_queries_total counter`,\n\t\t\t`db_queries_total ${dbStats.totalQueries}`,\n\t\t\t'',\n\t\t\t`# HELP db_queries_slow_total Total slow database queries`,\n\t\t\t`# TYPE db_queries_slow_total counter`,\n\t\t\t`db_queries_slow_total ${dbStats.slowQueries}`,\n\t\t\t'',\n\t\t\t`# HELP db_query_duration_ms Average database query duration`,\n\t\t\t`# TYPE db_query_duration_ms gauge`,\n\t\t\t`db_query_duration_ms ${dbStats.averageQueryTime}`,\n\t\t\t'',\n\t\t\t`# HELP memory_heap_used_bytes Node.js heap memory used`,\n\t\t\t`# TYPE memory_heap_used_bytes gauge`,\n\t\t\t`memory_heap_used_bytes ${metrics.system.memoryUsage.heapUsed}`,\n\t\t\t'',\n\t\t\t`# HELP process_uptime_seconds Process uptime`,\n\t\t\t`# TYPE process_uptime_seconds gauge`,\n\t\t\t`process_uptime_seconds ${process.uptime()}`,\n\t\t\t''\n\t\t].join('\\n');\n\n\t\tres.set('Content-Type', 'text/plain; version=0.0.4; charset=utf-8');\n\t\tres.send(metricsText);\n\t} catch (error) {\n\t\tlogger.error('HealthCheck', 'Metrics collection failed', { error });\n\t\tres.status(500).send('# Metrics collection failed');\n\t}\n});\n\nexport { healthMonitor };\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/monitoring/query-performance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/rate-limiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/repository/base-repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'or' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":237,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":237,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Base Repository\n *\n * QUALITY IMPROVEMENT: Repository pattern implementation for consistent data access\n * Provides common CRUD operations with proper error handling and type safety\n */\n\nimport { db } from '@db';\nimport { sql, eq, and, or, SQL, count, desc, asc } from 'drizzle-orm';\nimport type { AnyPgColumn, AnyPgTable } from 'drizzle-orm/pg-core';\nimport { logger } from '../logger';\nimport type { EntityId } from '@shared/types/ids';\n\nexport interface PaginationOptions {\n\tpage?: number;\n\tlimit?: number;\n\toffset?: number;\n}\n\nexport interface SortOptions {\n\tcolumn: string;\n\tdirection: 'asc' | 'desc';\n}\n\nexport interface FilterOptions {\n\t[key: string]: any;\n}\n\nexport interface QueryOptions {\n\tpagination?: PaginationOptions;\n\tsort?: SortOptions[];\n\tfilters?: FilterOptions;\n\tinclude?: string[];\n}\n\nexport interface PaginatedResult<T> {\n\tdata: T[];\n\ttotal: number;\n\tpage: number;\n\tlimit: number;\n\ttotalPages: number;\n\thasNext: boolean;\n\thasPrev: boolean;\n}\n\nexport interface RepositoryTransaction {\n\tcommit(): Promise<void>;\n\trollback(): Promise<void>;\n}\n\nexport class RepositoryError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic readonly code: string,\n\t\tpublic readonly statusCode: number = 500,\n\t\tpublic readonly context?: Record<string, any>\n\t) {\n\t\tsuper(message);\n\t\tthis.name = 'RepositoryError';\n\t}\n}\n\nexport abstract class BaseRepository<T extends Record<string, any>> {\n\tprotected abstract table: AnyPgTable;\n\tprotected abstract entityName: string;\n\n\t/**\n\t * Find entity by ID\n\t */\n\tasync findById(id: EntityId): Promise<T | null> {\n\t\ttry {\n\t\t\tconst idColumn = this.getIdColumn();\n\t\t\tconst [result] = await db.select().from(this.table).where(eq(idColumn, id)).limit(1);\n\n\t\t\treturn result || null;\n\t\t} catch (error) {\n\t\t\tlogger.error(`${this.entityName}Repository`, 'Error in findById', { id, error });\n\t\t\tthrow new RepositoryError(\n\t\t\t\t`Failed to find ${this.entityName} by ID`,\n\t\t\t\t'FIND_BY_ID_ERROR',\n\t\t\t\t500,\n\t\t\t\t{ id, originalError: error }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Find multiple entities with options\n\t */\n\tasync find(options: QueryOptions = {}): Promise<T[]> {\n\t\ttry {\n\t\t\tlet query = db.select().from(this.table);\n\n\t\t\t// Apply filters\n\t\t\tif (options.filters) {\n\t\t\t\tconst conditions = this.buildFilterConditions(options.filters);\n\t\t\t\tif (conditions.length > 0) {\n\t\t\t\t\tquery = query.where(and(...conditions));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply sorting\n\t\t\tif (options.sort && options.sort.length > 0) {\n\t\t\t\tconst orderBy = options.sort.map((sort) => {\n\t\t\t\t\tconst column = this.getColumnByName(sort.column);\n\t\t\t\t\treturn sort.direction === 'desc' ? desc(column) : asc(column);\n\t\t\t\t});\n\t\t\t\tquery = query.orderBy(...orderBy);\n\t\t\t}\n\n\t\t\t// Apply pagination\n\t\t\tif (options.pagination) {\n\t\t\t\tconst { limit = 20, offset } = options.pagination;\n\t\t\t\tconst page = options.pagination.page || 1;\n\t\t\t\tconst actualOffset = offset !== undefined ? offset : (page - 1) * limit;\n\n\t\t\t\tquery = query.limit(limit).offset(actualOffset);\n\t\t\t}\n\n\t\t\tconst results = await query;\n\t\t\treturn results as T[];\n\t\t} catch (error) {\n\t\t\tlogger.error(`${this.entityName}Repository`, 'Error in find', { options, error });\n\t\t\tthrow new RepositoryError(`Failed to find ${this.entityName} entities`, 'FIND_ERROR', 500, {\n\t\t\t\toptions,\n\t\t\t\toriginalError: error\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Find with pagination\n\t */\n\tasync findPaginated(options: QueryOptions = {}): Promise<PaginatedResult<T>> {\n\t\ttry {\n\t\t\tconst page = options.pagination?.page || 1;\n\t\t\tconst limit = Math.min(options.pagination?.limit || 20, 100);\n\t\t\tconst offset = (page - 1) * limit;\n\n\t\t\t// Get total count\n\t\t\tlet countQuery = db.select({ count: count() }).from(this.table);\n\t\t\tif (options.filters) {\n\t\t\t\tconst conditions = this.buildFilterConditions(options.filters);\n\t\t\t\tif (conditions.length > 0) {\n\t\t\t\t\tcountQuery = countQuery.where(and(...conditions));\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst [{ count: total }] = await countQuery;\n\n\t\t\t// Get data\n\t\t\tconst data = await this.find({\n\t\t\t\t...options,\n\t\t\t\tpagination: { page, limit, offset }\n\t\t\t});\n\n\t\t\tconst totalPages = Math.ceil(total / limit);\n\n\t\t\treturn {\n\t\t\t\tdata,\n\t\t\t\ttotal,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\ttotalPages,\n\t\t\t\thasNext: page < totalPages,\n\t\t\t\thasPrev: page > 1\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error(`${this.entityName}Repository`, 'Error in findPaginated', { options, error });\n\t\t\tthrow new RepositoryError(\n\t\t\t\t`Failed to find paginated ${this.entityName} entities`,\n\t\t\t\t'FIND_PAGINATED_ERROR',\n\t\t\t\t500,\n\t\t\t\t{ options, originalError: error }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Create new entity\n\t */\n\tasync create(data: Partial<T>): Promise<T> {\n\t\ttry {\n\t\t\tconst [result] = await db.insert(this.table).values(this.prepareCreateData(data)).returning();\n\n\t\t\tlogger.info(`${this.entityName}Repository`, 'Entity created successfully', {\n\t\t\t\tid: result[this.getIdColumnName()]\n\t\t\t});\n\n\t\t\treturn result as T;\n\t\t} catch (error) {\n\t\t\tlogger.error(`${this.entityName}Repository`, 'Error in create', { data, error });\n\t\t\tthrow new RepositoryError(`Failed to create ${this.entityName}`, 'CREATE_ERROR', 500, {\n\t\t\t\tdata,\n\t\t\t\toriginalError: error\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update entity by ID\n\t */\n\tasync update(id: EntityId, data: Partial<T>): Promise<T> {\n\t\ttry {\n\t\t\tconst idColumn = this.getIdColumn();\n\t\t\tconst [result] = await db\n\t\t\t\t.update(this.table)\n\t\t\t\t.set(this.prepareUpdateData(data))\n\t\t\t\t.where(eq(idColumn, id))\n\t\t\t\t.returning();\n\n\t\t\tif (!result) {\n\t\t\t\tthrow new RepositoryError(`${this.entityName} not found`, 'NOT_FOUND', 404, { id });\n\t\t\t}\n\n\t\t\tlogger.info(`${this.entityName}Repository`, 'Entity updated successfully', { id });\n\t\t\treturn result as T;\n\t\t} catch (error) {\n\t\t\tif (error instanceof RepositoryError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tlogger.error(`${this.entityName}Repository`, 'Error in update', { id, data, error });\n\t\t\tthrow new RepositoryError(`Failed to update ${this.entityName}`, 'UPDATE_ERROR', 500, {\n\t\t\t\tid,\n\t\t\t\tdata,\n\t\t\t\toriginalError: error\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Delete entity by ID\n\t */\n\tasync delete(id: EntityId): Promise<void> {\n\t\ttry {\n\t\t\tconst idColumn = this.getIdColumn();\n\t\t\tconst result = await db.delete(this.table).where(eq(idColumn, id));\n\n\t\t\tlogger.info(`${this.entityName}Repository`, 'Entity deleted successfully', { id });\n\t\t} catch (error) {\n\t\t\tlogger.error(`${this.entityName}Repository`, 'Error in delete', { id, error });\n\t\t\tthrow new RepositoryError(`Failed to delete ${this.entityName}`, 'DELETE_ERROR', 500, {\n\t\t\t\tid,\n\t\t\t\toriginalError: error\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Check if entity exists\n\t */\n\tasync exists(id: EntityId): Promise<boolean> {\n\t\ttry {\n\t\t\tconst entity = await this.findById(id);\n\t\t\treturn entity !== null;\n\t\t} catch (error) {\n\t\t\tlogger.error(`${this.entityName}Repository`, 'Error in exists', { id, error });\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Count entities with filters\n\t */\n\tasync count(filters?: FilterOptions): Promise<number> {\n\t\ttry {\n\t\t\tlet query = db.select({ count: count() }).from(this.table);\n\n\t\t\tif (filters) {\n\t\t\t\tconst conditions = this.buildFilterConditions(filters);\n\t\t\t\tif (conditions.length > 0) {\n\t\t\t\t\tquery = query.where(and(...conditions));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst [{ count: total }] = await query;\n\t\t\treturn total;\n\t\t} catch (error) {\n\t\t\tlogger.error(`${this.entityName}Repository`, 'Error in count', { filters, error });\n\t\t\tthrow new RepositoryError(`Failed to count ${this.entityName} entities`, 'COUNT_ERROR', 500, {\n\t\t\t\tfilters,\n\t\t\t\toriginalError: error\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get ID column for the table\n\t */\n\tprotected getIdColumn(): AnyPgColumn {\n\t\tconst idColumnName = this.getIdColumnName();\n\t\treturn this.table[idColumnName];\n\t}\n\n\t/**\n\t * Get ID column name (can be overridden)\n\t */\n\tprotected getIdColumnName(): string {\n\t\treturn 'id';\n\t}\n\n\t/**\n\t * Get column by name\n\t */\n\tprotected getColumnByName(name: string): AnyPgColumn {\n\t\tif (!(name in this.table)) {\n\t\t\tthrow new RepositoryError(\n\t\t\t\t`Column '${name}' does not exist in ${this.entityName} table`,\n\t\t\t\t'INVALID_COLUMN',\n\t\t\t\t400,\n\t\t\t\t{ columnName: name }\n\t\t\t);\n\t\t}\n\t\treturn this.table[name];\n\t}\n\n\t/**\n\t * Build filter conditions from filter options\n\t */\n\tprotected buildFilterConditions(filters: FilterOptions): SQL[] {\n\t\tconst conditions: SQL[] = [];\n\n\t\tfor (const [key, value] of Object.entries(filters)) {\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst column = this.getColumnByName(key);\n\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t// IN condition for arrays\n\t\t\t\t\tconditions.push(sql`${column} = ANY(${value})`);\n\t\t\t\t} else if (typeof value === 'object' && value.operator) {\n\t\t\t\t\t// Complex conditions like { operator: 'gt', value: 10 }\n\t\t\t\t\tconditions.push(this.buildComplexCondition(column, value));\n\t\t\t\t} else {\n\t\t\t\t\t// Simple equality\n\t\t\t\t\tconditions.push(eq(column, value));\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.warn(`${this.entityName}Repository`, 'Skipping invalid filter', { key, value });\n\t\t\t}\n\t\t}\n\n\t\treturn conditions;\n\t}\n\n\t/**\n\t * Build complex filter conditions\n\t */\n\tprotected buildComplexCondition(column: AnyPgColumn, condition: any): SQL {\n\t\tconst { operator, value } = condition;\n\n\t\tswitch (operator) {\n\t\t\tcase 'gt':\n\t\t\t\treturn sql`${column} > ${value}`;\n\t\t\tcase 'gte':\n\t\t\t\treturn sql`${column} >= ${value}`;\n\t\t\tcase 'lt':\n\t\t\t\treturn sql`${column} < ${value}`;\n\t\t\tcase 'lte':\n\t\t\t\treturn sql`${column} <= ${value}`;\n\t\t\tcase 'ne':\n\t\t\t\treturn sql`${column} != ${value}`;\n\t\t\tcase 'like':\n\t\t\t\treturn sql`${column} ILIKE ${`%${value}%`}`;\n\t\t\tcase 'in':\n\t\t\t\treturn sql`${column} = ANY(${value})`;\n\t\t\tdefault:\n\t\t\t\treturn eq(column, value);\n\t\t}\n\t}\n\n\t/**\n\t * Prepare data for creation (can be overridden)\n\t */\n\tprotected prepareCreateData(data: Partial<T>): any {\n\t\treturn {\n\t\t\t...data,\n\t\t\tcreatedAt: new Date(),\n\t\t\tupdatedAt: new Date()\n\t\t};\n\t}\n\n\t/**\n\t * Prepare data for update (can be overridden)\n\t */\n\tprotected prepareUpdateData(data: Partial<T>): any {\n\t\treturn {\n\t\t\t...data,\n\t\t\tupdatedAt: new Date()\n\t\t};\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/repository/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/repository/interfaces.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/repository/repositories/transaction-repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sum' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Transaction Repository Implementation\n *\n * QUALITY IMPROVEMENT: Repository pattern for Transaction data access\n * Implements ITransactionRepository interface with proper error handling and type safety\n */\n\nimport { db } from '@db';\nimport type { UserId } from '@shared/types/ids';\nimport { transactions } from '@schema';\nimport { eq, and, desc, asc, sum, sql } from 'drizzle-orm';\nimport {\n\tBaseRepository,\n\tRepositoryError,\n\ttype PaginatedResult,\n\ttype QueryOptions\n} from '../base-repository';\nimport type { ITransactionRepository } from '../interfaces';\nimport type { Transaction } from '@schema';\nimport { logger } from '@server/src/core/logger';\n\nexport class TransactionRepository\n\textends BaseRepository<Transaction>\n\timplements ITransactionRepository\n{\n\tprotected table = transactions;\n\tprotected entityName = 'Transaction';\n\n\t/**\n\t * Find transactions by user ID with pagination\n\t */\n\tasync findByUserId(\n\t\tuserId: UserId,\n\t\toptions: QueryOptions = {}\n\t): Promise<PaginatedResult<Transaction>> {\n\t\ttry {\n\t\t\tconst queryOptions = {\n\t\t\t\t...options,\n\t\t\t\tfilters: {\n\t\t\t\t\t...options.filters,\n\t\t\t\t\tuserId\n\t\t\t\t},\n\t\t\t\tsort: options.sort || [{ column: 'createdAt', direction: 'desc' as const }]\n\t\t\t};\n\n\t\t\tconst result = await this.findPaginated(queryOptions);\n\n\t\t\tlogger.debug('TransactionRepository', 'Found transactions by user', {\n\t\t\t\tuserId,\n\t\t\t\tcount: result.data.length,\n\t\t\t\ttotal: result.total\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error('TransactionRepository', 'Error in findByUserId', { userId, options, error });\n\t\t\tthrow new RepositoryError(\n\t\t\t\t'Failed to find transactions by user ID',\n\t\t\t\t'FIND_BY_USER_ID_ERROR',\n\t\t\t\t500,\n\t\t\t\t{ userId, options, originalError: error }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Find transactions by type with pagination\n\t */\n\tasync findByType(\n\t\ttype: string,\n\t\toptions: QueryOptions = {}\n\t): Promise<PaginatedResult<Transaction>> {\n\t\ttry {\n\t\t\tconst queryOptions = {\n\t\t\t\t...options,\n\t\t\t\tfilters: {\n\t\t\t\t\t...options.filters,\n\t\t\t\t\ttype\n\t\t\t\t},\n\t\t\t\tsort: options.sort || [{ column: 'createdAt', direction: 'desc' as const }]\n\t\t\t};\n\n\t\t\tconst result = await this.findPaginated(queryOptions);\n\n\t\t\tlogger.debug('TransactionRepository', 'Found transactions by type', {\n\t\t\t\ttype,\n\t\t\t\tcount: result.data.length,\n\t\t\t\ttotal: result.total\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error('TransactionRepository', 'Error in findByType', { type, options, error });\n\t\t\tthrow new RepositoryError('Failed to find transactions by type', 'FIND_BY_TYPE_ERROR', 500, {\n\t\t\t\ttype,\n\t\t\t\toptions,\n\t\t\t\toriginalError: error\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Find transactions by status with pagination\n\t */\n\tasync findByStatus(\n\t\tstatus: string,\n\t\toptions: QueryOptions = {}\n\t): Promise<PaginatedResult<Transaction>> {\n\t\ttry {\n\t\t\tconst queryOptions = {\n\t\t\t\t...options,\n\t\t\t\tfilters: {\n\t\t\t\t\t...options.filters,\n\t\t\t\t\tstatus\n\t\t\t\t},\n\t\t\t\tsort: options.sort || [{ column: 'createdAt', direction: 'desc' as const }]\n\t\t\t};\n\n\t\t\tconst result = await this.findPaginated(queryOptions);\n\n\t\t\tlogger.debug('TransactionRepository', 'Found transactions by status', {\n\t\t\t\tstatus,\n\t\t\t\tcount: result.data.length,\n\t\t\t\ttotal: result.total\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error('TransactionRepository', 'Error in findByStatus', { status, options, error });\n\t\t\tthrow new RepositoryError(\n\t\t\t\t'Failed to find transactions by status',\n\t\t\t\t'FIND_BY_STATUS_ERROR',\n\t\t\t\t500,\n\t\t\t\t{ status, options, originalError: error }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get total transaction amount by user and optionally by type\n\t */\n\tasync getTotalByUser(userId: UserId, type?: string): Promise<number> {\n\t\ttry {\n\t\t\tconst conditions = [eq(transactions.userId, userId)];\n\n\t\t\tif (type) {\n\t\t\t\tconditions.push(eq(transactions.type, type));\n\t\t\t}\n\n\t\t\tconst [result] = await db\n\t\t\t\t.select({\n\t\t\t\t\ttotal: sql<number>`COALESCE(SUM(${transactions.amount}), 0)`\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(and(...conditions));\n\n\t\t\tconst total = Number(result?.total || 0);\n\n\t\t\tlogger.debug('TransactionRepository', 'Calculated total by user', {\n\t\t\t\tuserId,\n\t\t\t\ttype,\n\t\t\t\ttotal\n\t\t\t});\n\n\t\t\treturn total;\n\t\t} catch (error) {\n\t\t\tlogger.error('TransactionRepository', 'Error in getTotalByUser', { userId, type, error });\n\t\t\tthrow new RepositoryError(\n\t\t\t\t'Failed to get total transactions by user',\n\t\t\t\t'GET_TOTAL_BY_USER_ERROR',\n\t\t\t\t500,\n\t\t\t\t{ userId, type, originalError: error }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get balance by user (credits minus debits)\n\t */\n\tasync getBalanceByUser(userId: UserId): Promise<number> {\n\t\ttry {\n\t\t\t// Calculate credits (positive transactions)\n\t\t\tconst [creditsResult] = await db\n\t\t\t\t.select({\n\t\t\t\t\tcredits: sql<number>`COALESCE(SUM(${transactions.amount}), 0)`\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(and(eq(transactions.userId, userId), sql`${transactions.amount} > 0`));\n\n\t\t\t// Calculate debits (negative transactions)\n\t\t\tconst [debitsResult] = await db\n\t\t\t\t.select({\n\t\t\t\t\tdebits: sql<number>`COALESCE(SUM(ABS(${transactions.amount})), 0)`\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(and(eq(transactions.userId, userId), sql`${transactions.amount} < 0`));\n\n\t\t\tconst credits = Number(creditsResult?.credits || 0);\n\t\t\tconst debits = Number(debitsResult?.debits || 0);\n\t\t\tconst balance = credits - debits;\n\n\t\t\tlogger.debug('TransactionRepository', 'Calculated balance by user', {\n\t\t\t\tuserId,\n\t\t\t\tcredits,\n\t\t\t\tdebits,\n\t\t\t\tbalance\n\t\t\t});\n\n\t\t\treturn balance;\n\t\t} catch (error) {\n\t\t\tlogger.error('TransactionRepository', 'Error in getBalanceByUser', { userId, error });\n\t\t\tthrow new RepositoryError('Failed to get balance by user', 'GET_BALANCE_BY_USER_ERROR', 500, {\n\t\t\t\tuserId,\n\t\t\t\toriginalError: error\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get transactions by date range\n\t */\n\tasync findByDateRange(\n\t\tstartDate: Date,\n\t\tendDate: Date,\n\t\toptions: QueryOptions = {}\n\t): Promise<PaginatedResult<Transaction>> {\n\t\ttry {\n\t\t\tconst queryOptions = {\n\t\t\t\t...options,\n\t\t\t\tfilters: {\n\t\t\t\t\t...options.filters,\n\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\toperator: 'gte',\n\t\t\t\t\t\tvalue: startDate\n\t\t\t\t\t}\n\t\t\t\t\t// Add end date filter using complex condition\n\t\t\t\t},\n\t\t\t\tsort: options.sort || [{ column: 'createdAt', direction: 'desc' as const }]\n\t\t\t};\n\n\t\t\t// For now, use simple date filtering - can be enhanced with proper date range queries\n\t\t\tconst result = await this.findPaginated(queryOptions);\n\n\t\t\t// Filter by end date manually (should be optimized to database level)\n\t\t\tresult.data = result.data.filter((transaction) => transaction.createdAt <= endDate);\n\n\t\t\tlogger.debug('TransactionRepository', 'Found transactions by date range', {\n\t\t\t\tstartDate,\n\t\t\t\tendDate,\n\t\t\t\tcount: result.data.length\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error('TransactionRepository', 'Error in findByDateRange', {\n\t\t\t\tstartDate,\n\t\t\t\tendDate,\n\t\t\t\toptions,\n\t\t\t\terror\n\t\t\t});\n\t\t\tthrow new RepositoryError(\n\t\t\t\t'Failed to find transactions by date range',\n\t\t\t\t'FIND_BY_DATE_RANGE_ERROR',\n\t\t\t\t500,\n\t\t\t\t{ startDate, endDate, options, originalError: error }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get transaction statistics for a user\n\t */\n\tasync getUserStats(userId: UserId): Promise<{\n\t\ttotalTransactions: number;\n\t\ttotalCredits: number;\n\t\ttotalDebits: number;\n\t\tbalance: number;\n\t\tlastTransactionAt: Date | null;\n\t}> {\n\t\ttry {\n\t\t\tconst [statsResult] = await db\n\t\t\t\t.select({\n\t\t\t\t\ttotalTransactions: sql<number>`COUNT(*)`,\n\t\t\t\t\ttotalCredits: sql<number>`COALESCE(SUM(CASE WHEN ${transactions.amount} > 0 THEN ${transactions.amount} ELSE 0 END), 0)`,\n\t\t\t\t\ttotalDebits: sql<number>`COALESCE(SUM(CASE WHEN ${transactions.amount} < 0 THEN ABS(${transactions.amount}) ELSE 0 END), 0)`,\n\t\t\t\t\tlastTransactionAt: sql<Date | null>`MAX(${transactions.createdAt})`\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(eq(transactions.userId, userId));\n\n\t\t\tconst totalCredits = Number(statsResult?.totalCredits || 0);\n\t\t\tconst totalDebits = Number(statsResult?.totalDebits || 0);\n\t\t\tconst balance = totalCredits - totalDebits;\n\n\t\t\tconst stats = {\n\t\t\t\ttotalTransactions: Number(statsResult?.totalTransactions || 0),\n\t\t\t\ttotalCredits,\n\t\t\t\ttotalDebits,\n\t\t\t\tbalance,\n\t\t\t\tlastTransactionAt: statsResult?.lastTransactionAt || null\n\t\t\t};\n\n\t\t\tlogger.debug('TransactionRepository', 'Calculated user stats', {\n\t\t\t\tuserId,\n\t\t\t\tstats\n\t\t\t});\n\n\t\t\treturn stats;\n\t\t} catch (error) {\n\t\t\tlogger.error('TransactionRepository', 'Error in getUserStats', { userId, error });\n\t\t\tthrow new RepositoryError(\n\t\t\t\t'Failed to get user transaction statistics',\n\t\t\t\t'GET_USER_STATS_ERROR',\n\t\t\t\t500,\n\t\t\t\t{ userId, originalError: error }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Prepare data for transaction creation with validation\n\t */\n\tprotected prepareCreateData(data: Partial<Transaction>): any {\n\t\t// Validate required fields\n\t\tif (!data.userId) {\n\t\t\tthrow new RepositoryError('User ID is required for transaction', 'VALIDATION_ERROR', 400, {\n\t\t\t\tfield: 'userId'\n\t\t\t});\n\t\t}\n\n\t\tif (!data.type) {\n\t\t\tthrow new RepositoryError('Transaction type is required', 'VALIDATION_ERROR', 400, {\n\t\t\t\tfield: 'type'\n\t\t\t});\n\t\t}\n\n\t\tif (data.amount === undefined || data.amount === null) {\n\t\t\tthrow new RepositoryError('Transaction amount is required', 'VALIDATION_ERROR', 400, {\n\t\t\t\tfield: 'amount'\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\t...data,\n\t\t\tstatus: data.status || 'pending',\n\t\t\tmetadata: data.metadata || {},\n\t\t\tcreatedAt: new Date(),\n\t\t\tupdatedAt: new Date()\n\t\t};\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/repository/repositories/user-repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/repository/repository-factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/routes/api/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/routes/api/status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/services/rate-limit.service.ts","messages":[{"ruleId":"@typescript-eslint/ban-types","severity":1,"message":"Don't use `Function` as a type. The `Function` type accepts any function-like value.\nIt provides no type safety when calling the function, which can be a common source of bugs.\nIt also accepts things like class declarations, which will throw at runtime as they will not be called with `new`.\nIf you are expecting the function to accept certain arguments, you should explicitly define the function shape.","line":197,"column":68,"nodeType":"Identifier","messageId":"bannedTypeMessage","endLine":197,"endColumn":76}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Redis-Based Rate Limiting Service\n *\n * Production-grade rate limiting with Redis backend\n * Falls back to in-memory for development\n */\n\nimport Redis from 'ioredis';\nimport rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\nimport type { Request, Response } from 'express';\nimport { userService } from './user.service';\nimport { env, getRateLimitConfig, isDevelopment } from '../config/environment';\nimport { logger } from '../logger';\n\n/**\n * Redis connection for rate limiting\n */\nlet redisClient: Redis | null = null;\n\n/**\n * Initialize Redis connection for rate limiting\n */\nfunction initializeRedis(): Redis | null {\n\tconst config = getRateLimitConfig();\n\n\tif (!config.redis) {\n\t\tlogger.warn('RateLimit', 'Redis not configured - using memory store');\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst redis = new Redis(config.redis, {\n\t\t\tretryDelayOnFailover: 100,\n\t\t\tmaxRetriesPerRequest: 3,\n\t\t\tlazyConnect: true,\n\t\t\tconnectionName: 'rate-limiter',\n\t\t\t// Redis options for production stability\n\t\t\tkeepAlive: 30000,\n\t\t\tconnectTimeout: 10000,\n\t\t\tcommandTimeout: 5000\n\t\t});\n\n\t\tredis.on('connect', () => {\n\t\t\tlogger.info('RateLimit', 'Connected to Redis');\n\t\t});\n\n\t\tredis.on('error', (error) => {\n\t\t\tlogger.error('RateLimit', 'Redis connection error:', error);\n\t\t});\n\n\t\treturn redis;\n\t} catch (error) {\n\t\tlogger.error('RateLimit', 'Failed to initialize Redis:', error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Create rate limiter with Redis or memory store\n */\nfunction createRateLimiter(config: any) {\n\tconst baseConfig = {\n\t\twindowMs: config.windowMs || 15 * 60 * 1000,\n\t\tmax: config.max || 100,\n\t\tmessage: config.message || { error: 'Too many requests' },\n\t\tstandardHeaders: true,\n\t\tlegacyHeaders: false,\n\t\t// Custom key generator for better tracking\n\t\tkeyGenerator: (req: Request) => {\n\t\t\tconst authUser = userService.getUserFromRequest(req);\n\t\t\tconst ip = req.ip || req.connection.remoteAddress;\n\t\t\t// Use user ID if authenticated, otherwise IP\n\t\t\treturn authUser ? `user:${authUser.id}` : `ip:${ip}`;\n\t\t},\n\t\t// Skip successful requests to reduce Redis load\n\t\tskipSuccessfulRequests: false,\n\t\tskipFailedRequests: false\n\t};\n\n\t// Use Redis store if available\n\tif (redisClient && env.RATE_LIMIT_ENABLED) {\n\t\treturn rateLimit({\n\t\t\t...baseConfig,\n\t\t\tstore: new RedisStore({\n\t\t\t\tsendCommand: (...args: string[]) => redisClient!.call(...args),\n\t\t\t\tprefix: 'rate_limit:'\n\t\t\t})\n\t\t});\n\t}\n\n\t// Fallback to memory store with warning\n\tif (env.RATE_LIMIT_ENABLED) {\n\t\tlogger.warn('RateLimit', 'Using memory store - not recommended for production');\n\t}\n\n\treturn rateLimit(baseConfig);\n}\n\n/**\n * Rate limit configurations for different endpoint types\n */\nexport const rateLimiters = {\n\t// General API endpoints\n\tgeneral: createRateLimiter({\n\t\twindowMs: 15 * 60 * 1000, // 15 minutes\n\t\tmax: isDevelopment() ? 1000 : 100,\n\t\tmessage: {\n\t\t\terror: 'Too many requests',\n\t\t\tretryAfter: '15 minutes',\n\t\t\ttype: 'RATE_LIMIT_GENERAL'\n\t\t}\n\t}),\n\n\t// Authentication endpoints\n\tauth: createRateLimiter({\n\t\twindowMs: 15 * 60 * 1000, // 15 minutes\n\t\tmax: isDevelopment() ? 50 : 5,\n\t\tmessage: {\n\t\t\terror: 'Too many authentication attempts',\n\t\t\tretryAfter: '15 minutes',\n\t\t\ttype: 'RATE_LIMIT_AUTH'\n\t\t}\n\t}),\n\n\t// Password reset (very strict)\n\tpasswordReset: createRateLimiter({\n\t\twindowMs: 60 * 60 * 1000, // 1 hour\n\t\tmax: 3,\n\t\tmessage: {\n\t\t\terror: 'Too many password reset attempts',\n\t\t\tretryAfter: '1 hour',\n\t\t\ttype: 'RATE_LIMIT_PASSWORD_RESET'\n\t\t}\n\t}),\n\n\t// Admin endpoints\n\tadmin: createRateLimiter({\n\t\twindowMs: 60 * 60 * 1000, // 1 hour\n\t\tmax: isDevelopment() ? 500 : 50,\n\t\tmessage: {\n\t\t\terror: 'Too many admin requests',\n\t\t\tretryAfter: '1 hour',\n\t\t\ttype: 'RATE_LIMIT_ADMIN'\n\t\t}\n\t}),\n\n\t// Financial operations\n\tfinancial: createRateLimiter({\n\t\twindowMs: 60 * 60 * 1000, // 1 hour\n\t\tmax: isDevelopment() ? 100 : 10,\n\t\tmessage: {\n\t\t\terror: 'Too many financial operations',\n\t\t\tretryAfter: '1 hour',\n\t\t\ttype: 'RATE_LIMIT_FINANCIAL'\n\t\t}\n\t}),\n\n\t// Forum posting\n\tposting: createRateLimiter({\n\t\twindowMs: 5 * 60 * 1000, // 5 minutes\n\t\tmax: isDevelopment() ? 100 : 10,\n\t\tmessage: {\n\t\t\terror: 'Too many posts created',\n\t\t\tretryAfter: '5 minutes',\n\t\t\ttype: 'RATE_LIMIT_POSTING'\n\t\t}\n\t}),\n\n\t// File uploads\n\tupload: createRateLimiter({\n\t\twindowMs: 15 * 60 * 1000, // 15 minutes\n\t\tmax: isDevelopment() ? 50 : 5,\n\t\tmessage: {\n\t\t\terror: 'Too many file uploads',\n\t\t\tretryAfter: '15 minutes',\n\t\t\ttype: 'RATE_LIMIT_UPLOAD'\n\t\t}\n\t})\n};\n\n/**\n * Custom rate limiter for specific needs\n */\nexport function createCustomRateLimiter(options: {\n\twindowMs: number;\n\tmax: number;\n\tmessage?: any;\n\tkeyGenerator?: (req: Request) => string;\n}) {\n\treturn createRateLimiter(options);\n}\n\n/**\n * Rate limit bypass for development\n */\nexport function bypassRateLimit(req: Request, res: Response, next: Function) {\n\tif (isDevelopment() && req.headers['x-bypass-rate-limit']) {\n\t\tlogger.debug('RateLimit', 'Bypassing rate limit in development');\n\t\treturn next();\n\t}\n\tnext();\n}\n\n/**\n * Get rate limit statistics\n */\nexport async function getRateLimitStats(key: string): Promise<any> {\n\tif (!redisClient) {\n\t\treturn { error: 'Redis not available' };\n\t}\n\n\ttry {\n\t\tconst current = await redisClient.get(`rate_limit:${key}`);\n\t\tconst ttl = await redisClient.ttl(`rate_limit:${key}`);\n\n\t\treturn {\n\t\t\tcurrent: current ? parseInt(current) : 0,\n\t\t\tremaining: ttl,\n\t\t\tresetTime: new Date(Date.now() + ttl * 1000)\n\t\t};\n\t} catch (error) {\n\t\tlogger.error('RateLimit', 'Failed to get stats:', error);\n\t\treturn { error: 'Failed to get rate limit stats' };\n\t}\n}\n\n/**\n * Clear rate limit for a specific key (admin operation)\n */\nexport async function clearRateLimit(key: string): Promise<boolean> {\n\tif (!redisClient) {\n\t\tlogger.warn('RateLimit', 'Cannot clear rate limit - Redis not available');\n\t\treturn false;\n\t}\n\n\ttry {\n\t\tawait redisClient.del(`rate_limit:${key}`);\n\t\tlogger.info('RateLimit', 'Cleared rate limit', { key });\n\t\treturn true;\n\t} catch (error) {\n\t\tlogger.error('RateLimit', 'Failed to clear rate limit:', error);\n\t\treturn false;\n\t}\n}\n\n/**\n * Health check for rate limiting service\n */\nexport async function rateLimitHealthCheck(): Promise<{\n\tstatus: 'healthy' | 'degraded' | 'unhealthy';\n\tredis: boolean;\n\tstore: 'redis' | 'memory';\n}> {\n\tif (!env.RATE_LIMIT_ENABLED) {\n\t\treturn {\n\t\t\tstatus: 'healthy',\n\t\t\tredis: false,\n\t\t\tstore: 'memory'\n\t\t};\n\t}\n\n\tif (!redisClient) {\n\t\treturn {\n\t\t\tstatus: 'degraded',\n\t\t\tredis: false,\n\t\t\tstore: 'memory'\n\t\t};\n\t}\n\n\ttry {\n\t\tawait redisClient.ping();\n\t\treturn {\n\t\t\tstatus: 'healthy',\n\t\t\tredis: true,\n\t\t\tstore: 'redis'\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\tstatus: 'unhealthy',\n\t\t\tredis: false,\n\t\t\tstore: 'memory'\n\t\t};\n\t}\n}\n\n// Initialize Redis connection\nif (env.RATE_LIMIT_ENABLED) {\n\tredisClient = initializeRedis();\n}\n\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n\tif (redisClient) {\n\t\tredisClient.disconnect();\n\t\tlogger.info('RateLimit', 'Redis connection closed');\n\t}\n});\n\nexport { redisClient };\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/services/user.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userRoles' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'email' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":276,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":276,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Centralized User Service\n *\n * Consolidates scattered getUser patterns across the codebase\n * Provides consistent user fetching, validation, and management\n */\n\nimport { db } from '@db';\nimport { users, userRoles } from '@schema';\nimport { eq, and } from 'drizzle-orm';\nimport { logger } from '../logger';\nimport type { UserId } from '@shared/types/ids';\nimport { getAuthenticatedUser } from \"@server/src/core/utils/auth.helpers\";\n\nexport interface User {\n\tid: UserId;\n\tusername: string;\n\temail: string;\n\trole: 'user' | 'moderator' | 'admin';\n\tlevel?: number;\n\tdgtBalance?: number;\n\tisActive: boolean;\n\tcreatedAt: Date;\n\tupdatedAt: Date;\n}\n\nexport interface UserProfile extends User {\n\tdisplayName?: string;\n\tbio?: string;\n\tavatarUrl?: string;\n\ttotalPosts: number;\n\ttotalThreads: number;\n\treputation: number;\n\tlastActiveAt?: Date;\n}\n\nexport interface AuthenticatedUser extends User {\n\tsessionId?: string;\n\tpermissions?: string[];\n\tlastLoginAt?: Date;\n}\n\nclass UserService {\n\t/**\n\t * Get user from Express request object with type safety\n\t */\n\tgetUserFromRequest(req: any): AuthenticatedUser | null {\n\t\tconst user = getAuthenticatedUser(req);\n\t\tif (!user || !user.id) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tid: user.id,\n\t\t\tusername: user.username,\n\t\t\temail: user.email,\n\t\t\trole: user.role || 'user',\n\t\t\tlevel: user.level,\n\t\t\tdgtBalance: user.dgtBalance,\n\t\t\tisActive: user.isActive !== false,\n\t\t\tcreatedAt: user.createdAt,\n\t\t\tupdatedAt: user.updatedAt,\n\t\t\tsessionId: req.sessionID,\n\t\t\tpermissions: user.permissions,\n\t\t\tlastLoginAt: user.lastLoginAt\n\t\t};\n\t}\n\n\t/**\n\t * Get user by ID with complete profile data\n\t */\n\tasync getUserById(userId: UserId): Promise<UserProfile | null> {\n\t\ttry {\n\t\t\tconst [user] = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\temail: users.email,\n\t\t\t\t\trole: users.role,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\tdgtBalance: users.dgtBalance,\n\t\t\t\t\tisActive: users.isActive,\n\t\t\t\t\tcreatedAt: users.createdAt,\n\t\t\t\t\tupdatedAt: users.updatedAt,\n\t\t\t\t\tdisplayName: users.displayName,\n\t\t\t\t\tbio: users.bio,\n\t\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\t\ttotalPosts: users.totalPosts,\n\t\t\t\t\ttotalThreads: users.totalThreads,\n\t\t\t\t\treputation: users.reputation,\n\t\t\t\t\tlastActiveAt: users.lastActiveAt\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.limit(1);\n\n\t\t\treturn user || null;\n\t\t} catch (error) {\n\t\t\tlogger.error('UserService', 'Error fetching user by ID', { userId, error });\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get user by username\n\t */\n\tasync getUserByUsername(username: string): Promise<User | null> {\n\t\ttry {\n\t\t\tconst [user] = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\temail: users.email,\n\t\t\t\t\trole: users.role,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\tdgtBalance: users.dgtBalance,\n\t\t\t\t\tisActive: users.isActive,\n\t\t\t\t\tcreatedAt: users.createdAt,\n\t\t\t\t\tupdatedAt: users.updatedAt\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.username, username))\n\t\t\t\t.limit(1);\n\n\t\t\treturn user || null;\n\t\t} catch (error) {\n\t\t\tlogger.error('UserService', 'Error fetching user by username', { username, error });\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get user by email\n\t */\n\tasync getUserByEmail(email: string): Promise<User | null> {\n\t\ttry {\n\t\t\tconst [user] = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\temail: users.email,\n\t\t\t\t\trole: users.role,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\tdgtBalance: users.dgtBalance,\n\t\t\t\t\tisActive: users.isActive,\n\t\t\t\t\tcreatedAt: users.createdAt,\n\t\t\t\t\tupdatedAt: users.updatedAt\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.email, email))\n\t\t\t\t.limit(1);\n\n\t\t\treturn user || null;\n\t\t} catch (error) {\n\t\t\tlogger.error('UserService', 'Error fetching user by email', { email, error });\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get multiple users by IDs\n\t */\n\tasync getUsersByIds(userIds: UserId[]): Promise<User[]> {\n\t\tif (userIds.length === 0) return [];\n\n\t\ttry {\n\t\t\tconst userList = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\temail: users.email,\n\t\t\t\t\trole: users.role,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\tdgtBalance: users.dgtBalance,\n\t\t\t\t\tisActive: users.isActive,\n\t\t\t\t\tcreatedAt: users.createdAt,\n\t\t\t\t\tupdatedAt: users.updatedAt\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userIds[0])); // TODO: Use proper IN clause when Drizzle supports it\n\n\t\t\treturn userList;\n\t\t} catch (error) {\n\t\t\tlogger.error('UserService', 'Error fetching users by IDs', { userIds, error });\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Check if user exists and is active\n\t */\n\tasync isActiveUser(userId: UserId): Promise<boolean> {\n\t\ttry {\n\t\t\tconst [user] = await db\n\t\t\t\t.select({ isActive: users.isActive })\n\t\t\t\t.from(users)\n\t\t\t\t.where(and(eq(users.id, userId), eq(users.isActive, true)))\n\t\t\t\t.limit(1);\n\n\t\t\treturn !!user;\n\t\t} catch (error) {\n\t\t\tlogger.error('UserService', 'Error checking user active status', { userId, error });\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Update user's last active timestamp\n\t */\n\tasync updateLastActive(userId: UserId): Promise<void> {\n\t\ttry {\n\t\t\tawait db.update(users).set({ lastActiveAt: new Date() }).where(eq(users.id, userId));\n\t\t} catch (error) {\n\t\t\tlogger.error('UserService', 'Error updating last active', { userId, error });\n\t\t}\n\t}\n\n\t/**\n\t * Check if user has specific role\n\t */\n\thasRole(user: User | AuthenticatedUser, role: 'admin' | 'moderator' | 'user'): boolean {\n\t\tif (role === 'admin') {\n\t\t\treturn user.role === 'admin';\n\t\t}\n\t\tif (role === 'moderator') {\n\t\t\treturn user.role === 'moderator' || user.role === 'admin';\n\t\t}\n\t\treturn true; // All authenticated users have 'user' role\n\t}\n\n\t/**\n\t * Check if user is admin\n\t */\n\tisAdmin(user: User | AuthenticatedUser): boolean {\n\t\treturn user.role === 'admin';\n\t}\n\n\t/**\n\t * Check if user is moderator or admin\n\t */\n\tisModerator(user: User | AuthenticatedUser): boolean {\n\t\treturn user.role === 'moderator' || user.role === 'admin';\n\t}\n\n\t/**\n\t * Validate user session and return user data\n\t */\n\tasync validateUserSession(req: any): Promise<AuthenticatedUser | null> {\n\t\tconst user = this.getUserFromRequest(req);\n\t\tif (!user) return null;\n\n\t\t// Check if user is still active\n\t\tconst isActive = await this.isActiveUser(user.id);\n\t\tif (!isActive) {\n\t\t\tlogger.warn('UserService', 'Inactive user attempted access', { userId: user.id });\n\t\t\treturn null;\n\t\t}\n\n\t\t// Update last active\n\t\tawait this.updateLastActive(user.id);\n\n\t\treturn user;\n\t}\n\n\t/**\n\t * Get user display name (fallback to username)\n\t */\n\tgetDisplayName(user: Partial<UserProfile>): string {\n\t\treturn user.displayName || user.username || `User ${user.id}`;\n\t}\n\n\t/**\n\t * Format user for API response (remove sensitive data)\n\t */\n\tformatForAPI(user: User | UserProfile): Omit<User | UserProfile, 'email'> {\n\t\tconst { email, ...safeUser } = user;\n\t\treturn safeUser;\n\t}\n\n\t/**\n\t * Batch user operations for efficiency\n\t */\n\tasync batchGetUsers(userIds: UserId[]): Promise<Map<UserId, User>> {\n\t\tconst users = await this.getUsersByIds(userIds);\n\t\tconst userMap = new Map<UserId, User>();\n\n\t\tusers.forEach((user) => {\n\t\t\tuserMap.set(user.id, user);\n\t\t});\n\n\t\treturn userMap;\n\t}\n}\n\n// Global service instance\nexport const userService = new UserService();\n\n/**\n * Express middleware to inject user service\n */\nexport function injectUserService(req: any, res: any, next: any) {\n\treq.userService = userService;\n\tnext();\n}\n\n/**\n * Helper function for backward compatibility\n */\nexport function getUserFromRequest(req: any): AuthenticatedUser | null {\n\treturn userService.getUserFromRequest(req);\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/storage.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/type-transformer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/utils/auth.helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/utils/error-response.util.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'statusCode' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":56,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":56,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used.","line":107,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":107,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used.","line":251,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":251,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'statusCode' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":278,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":278,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Shared Error Response Utilities\n *\n * Standardizes error handling patterns across the application\n * Eliminates duplicate try/catch blocks and error formatting\n */\n\nimport type { Request, Response } from 'express';\nimport { ZodError } from 'zod';\nimport { userService } from '../services/user.service';\nimport { logger } from '../logger';\n\nexport interface ErrorResponse {\n\tsuccess: false;\n\terror: string;\n\tdetails?: any;\n\tcode?: string;\n\ttimestamp?: string;\n\trequestId?: string;\n}\n\nexport interface SuccessResponse<T = any> {\n\tsuccess: true;\n\tdata: T;\n\tmeta?: {\n\t\tpagination?: {\n\t\t\tpage: number;\n\t\t\tlimit: number;\n\t\t\ttotal: number;\n\t\t\ttotalPages: number;\n\t\t};\n\t\ttimestamp?: string;\n\t\trequestId?: string;\n\t};\n}\n\nexport type ApiResponse<T = any> = SuccessResponse<T> | ErrorResponse;\n\nexport class ResponseError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic statusCode: number = 500,\n\t\tpublic code?: string,\n\t\tpublic details?: any\n\t) {\n\t\tsuper(message);\n\t\tthis.name = 'ResponseError';\n\t}\n}\n\n/**\n * Standard error response formatter\n */\nexport function formatErrorResponse(\n\terror: Error,\n\tstatusCode: number = 500,\n\tcode?: string,\n\tdetails?: any\n): ErrorResponse {\n\treturn {\n\t\tsuccess: false,\n\t\terror: error.message,\n\t\tcode,\n\t\tdetails,\n\t\ttimestamp: new Date().toISOString()\n\t};\n}\n\n/**\n * Standard success response formatter\n */\nexport function formatSuccessResponse<T>(\n\tdata: T,\n\tmeta?: SuccessResponse<T>['meta']\n): SuccessResponse<T> {\n\treturn {\n\t\tsuccess: true,\n\t\tdata,\n\t\tmeta: {\n\t\t\t...meta,\n\t\t\ttimestamp: new Date().toISOString()\n\t\t}\n\t};\n}\n\n/**\n * Handle validation errors (Zod)\n */\nexport function handleValidationError(error: ZodError): ErrorResponse {\n\treturn {\n\t\tsuccess: false,\n\t\terror: 'Validation failed',\n\t\tcode: 'VALIDATION_ERROR',\n\t\tdetails: error.errors.map((err) => ({\n\t\t\tfield: err.path.join('.'),\n\t\t\tmessage: err.message,\n\t\t\treceived: err.received\n\t\t})),\n\t\ttimestamp: new Date().toISOString()\n\t};\n}\n\n/**\n * Express error handler middleware factory\n */\nexport function createErrorHandler(context: string) {\n\treturn (error: Error, req: Request, res: Response, next: any) => {\n\t\t// Log the error\n\t\tconst authUser = userService.getUserFromRequest(req);\n\t\tlogger.error(context, 'Request error', {\n\t\t\terror: error.message,\n\t\t\tstack: error.stack,\n\t\t\tpath: req.path,\n\t\t\tmethod: req.method,\n\t\t\tuserId: authUser?.id,\n\t\t\tip: req.ip\n\t\t});\n\n\t\t// Handle different error types\n\t\tif (error instanceof ZodError) {\n\t\t\treturn res.status(400).json(handleValidationError(error));\n\t\t}\n\n\t\tif (error instanceof ResponseError) {\n\t\t\treturn res\n\t\t\t\t.status(error.statusCode)\n\t\t\t\t.json(formatErrorResponse(error, error.statusCode, error.code, error.details));\n\t\t}\n\n\t\t// Default error response\n\t\tconst statusCode = (error as any).statusCode || 500;\n\t\tconst response = formatErrorResponse(error, statusCode, (error as any).code);\n\n\t\tres.status(statusCode).json(response);\n\t};\n}\n\n/**\n * Async route wrapper to catch errors automatically\n */\nexport function asyncHandler(fn: (req: Request, res: Response, next: any) => Promise<any>) {\n\treturn (req: Request, res: Response, next: any) => {\n\t\tPromise.resolve(fn(req, res, next)).catch(next);\n\t};\n}\n\n/**\n * Try-catch wrapper for async operations\n */\nexport async function tryAsync<T>(\n\toperation: () => Promise<T>,\n\tcontext: string,\n\tfallback?: T\n): Promise<T | null> {\n\ttry {\n\t\treturn await operation();\n\t} catch (error) {\n\t\tlogger.error(context, 'Async operation failed', { error });\n\t\treturn fallback || null;\n\t}\n}\n\n/**\n * Database operation wrapper with error handling\n */\nexport async function dbOperation<T>(\n\toperation: () => Promise<T>,\n\tcontext: string,\n\terrorMessage: string = 'Database operation failed'\n): Promise<T> {\n\ttry {\n\t\treturn await operation();\n\t} catch (error) {\n\t\tlogger.error(context, errorMessage, { error });\n\t\tthrow new ResponseError(errorMessage, 500, 'DATABASE_ERROR', { originalError: error.message });\n\t}\n}\n\n/**\n * Service call wrapper with error handling\n */\nexport async function serviceCall<T>(\n\toperation: () => Promise<T>,\n\tcontext: string,\n\tserviceName: string\n): Promise<T> {\n\ttry {\n\t\treturn await operation();\n\t} catch (error) {\n\t\tlogger.error(context, `${serviceName} service call failed`, { error });\n\t\tthrow new ResponseError(`${serviceName} service unavailable`, 503, 'SERVICE_ERROR', {\n\t\t\tservice: serviceName,\n\t\t\toriginalError: error.message\n\t\t});\n\t}\n}\n\n/**\n * Permission check wrapper\n */\nexport function requirePermission(\n\tcheck: () => boolean,\n\tmessage: string = 'Permission denied'\n): void {\n\tif (!check()) {\n\t\tthrow new ResponseError(message, 403, 'PERMISSION_DENIED');\n\t}\n}\n\n/**\n * Resource existence check wrapper\n */\nexport function requireResource<T>(\n\tresource: T | null | undefined,\n\tresourceType: string = 'Resource'\n): T {\n\tif (!resource) {\n\t\tthrow new ResponseError(`${resourceType} not found`, 404, 'NOT_FOUND');\n\t}\n\treturn resource;\n}\n\n/**\n * Rate limit check wrapper\n */\nexport function checkRateLimit(isLimited: boolean, resetTime?: Date): void {\n\tif (isLimited) {\n\t\tthrow new ResponseError('Rate limit exceeded', 429, 'RATE_LIMIT_EXCEEDED', { resetTime });\n\t}\n}\n\n/**\n * Pagination helper\n */\nexport function createPaginationMeta(page: number, limit: number, total: number) {\n\treturn {\n\t\tpagination: {\n\t\t\tpage,\n\t\t\tlimit,\n\t\t\ttotal,\n\t\t\ttotalPages: Math.ceil(total / limit)\n\t\t}\n\t};\n}\n\n/**\n * Standard controller method wrapper\n */\nexport function controllerMethod<T extends any[]>(\n\tfn: (...args: T) => Promise<any>,\n\tcontext: string\n) {\n\treturn asyncHandler(async (req: Request, res: Response) => {\n\t\tconst result = await fn(req, res);\n\n\t\t// If result is already a response, don't double-wrap\n\t\tif (res.headersSent) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If result has success property, send as-is\n\t\tif (result && typeof result === 'object' && 'success' in result) {\n\t\t\treturn res.json(result);\n\t\t}\n\n\t\t// Otherwise wrap in success response\n\t\treturn res.json(formatSuccessResponse(result));\n\t});\n}\n\n/**\n * Health check response helper\n */\nexport function healthResponse(\n\tstatus: 'healthy' | 'degraded' | 'unhealthy',\n\tchecks: Record<string, { status: string; message?: string; responseTime?: number }>\n) {\n\tconst statusCode = status === 'healthy' ? 200 : 503;\n\n\treturn {\n\t\tstatus,\n\t\ttimestamp: new Date().toISOString(),\n\t\tchecks,\n\t\tuptime: process.uptime()\n\t};\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/core/wallet-validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/cron/mission-reset.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/cron/subscription-management.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/activity/controllers/event-log.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/activity/routes/event-log.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/activity/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/activity/services/event-log.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/activity/services/event-logger.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/admin.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { adminService } from './admin.service';\nimport { getUserId } from './admin.middleware';\nimport { AdminError } from './admin.errors';\nimport type { AdminId, UserId } from '@shared/types/ids';\nimport { userService } from '@server/src/core/services/user.service';\n\nexport class AdminController {\n\t/**\n\t * Get admin dashboard statistics\n\t */\n\tasync getDashboardStats(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst stats = await adminService.getDashboardStats();\n\t\t\treturn res.json(stats);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res.status(500).json({\n\t\t\t\terror: 'Failed to fetch dashboard statistics'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get admin activity log\n\t */\n\tasync getActivityLog(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst limit = req.query.limit ? parseInt(req.query.limit as string) : 10;\n\t\t\tconst recentActions = await adminService.getRecentAdminActions(limit);\n\n\t\t\treturn res.json(recentActions);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res.status(500).json({\n\t\t\t\terror: 'Failed to fetch activity log'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Log admin action (utility method for other controllers)\n\t */\n\tasync logAction(\n\t\treq: Request,\n\t\taction: string,\n\t\tentityType: string,\n\t\tentityId: string,\n\t\tdetails: any = {}\n\t) {\n\t\tconst adminUser = userService.getUserFromRequest(req);\n\t\tif (!adminUser?.id) {\n\t\t\tthrow new AdminError('Admin user not found', 401);\n\t\t}\n\t\tconst adminId = adminUser.id as AdminId;\n\t\tawait adminService.logAdminAction(adminId, action, entityType, entityId, details);\n\t}\n}\n\n// Export singleton instance\nexport const adminController = new AdminController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/admin.errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/admin.middleware.ts","messages":[{"ruleId":"@typescript-eslint/ban-types","severity":1,"message":"Don't use `Function` as a type. The `Function` type accepts any function-like value.\nIt provides no type safety when calling the function, which can be a common source of bugs.\nIt also accepts things like class declarations, which will throw at runtime as they will not be called with `new`.\nIf you are expecting the function to accept certain arguments, you should explicitly define the function shape.","line":146,"column":34,"nodeType":"Identifier","messageId":"bannedTypeMessage","endLine":146,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { users } from '@schema';\nimport { eq } from 'drizzle-orm';\nimport { WalletError, ErrorCodes as WalletErrorCodes } from '../../core/errors';\nimport { db } from '@server/src/core/db';\nimport { logger } from '@server/src/core/logger';\n\n/**\n * Extract userId from request consistently\n * This standardizes user ID access across the platform\n */\nexport function getUserId(req: Request): number {\n\tconst user = userService.getUserFromRequest(req) as any;\n\treturn user?.id || 0;\n}\n\n/**\n * Middleware to ensure user is an admin\n * In development mode, it auto-authenticates as DevUser\n */\nexport async function isAdmin(req: Request, res: Response, next: NextFunction) {\n\t// Skip auth check in development mode and auto-login as DevUser\n\tif (process.env.ALLOW_DEV_ADMIN === 'true' && !req.isAuthenticated()) {\n\t\ttry {\n\t\t\t// Use Drizzle ORM for secure, parameterized queries\n\t\t\tconst [devUser] = await db.select().from(users).where(eq(users.username, 'DevUser')).limit(1);\n\n\t\t\tif (devUser) {\n\t\t\t\t// For admin routes, ensure the DevUser has admin privileges\n\t\t\t\tif (devUser.role !== 'admin') {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t'AdminMiddleware',\n\t\t\t\t\t\t'DevUser exists but does not have admin role. Updating to admin role.',\n\t\t\t\t\t\t{ userId: devUser.id }\n\t\t\t\t\t);\n\t\t\t\t\tawait db.update(users).set({ role: 'admin' }).where(eq(users.username, 'DevUser'));\n\t\t\t\t\tdevUser.role = 'admin';\n\t\t\t\t}\n\n\t\t\t\t// Mock an authenticated session with the DevUser\n\t\t\t\treq.login(devUser, (err) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t'AdminMiddleware',\n\t\t\t\t\t\t\t'Error auto-authenticating as DevUser for admin route',\n\t\t\t\t\t\t\t{ err, userId: devUser.id || devUser.user_id }\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn res.status(401).json({ message: 'Unauthorized' });\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t'AdminMiddleware',\n\t\t\t\t\t\t`Auto-authenticated as DevUser admin (ID: ${devUser.id})`,\n\t\t\t\t\t\t{ userId: devUser.id }\n\t\t\t\t\t);\n\t\t\t\t\treturn next();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlogger.warn('AdminMiddleware', 'DevUser not found in database, admin auth failed');\n\t\t\t\treturn res.status(401).json({ message: 'Unauthorized' });\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('AdminMiddleware', 'Error in dev mode admin authentication', { err: error });\n\t\t\treturn res.status(401).json({ message: 'Unauthorized' });\n\t\t}\n\t} else if (req.isAuthenticated()) {\n\t\t// Normal authentication - use RBAC util\n\t\tconst user = userService.getUserFromRequest(req) as any;\n\t\tconst { canUser } = await import('@lib/auth/canUser');\n\t\tif (user && (await canUser(user, 'canViewAdminPanel'))) {\n\t\t\treturn next();\n\t\t}\n\t\treturn res.status(403).json({ message: 'Forbidden - Admin access required' });\n\t} else {\n\t\t// Not authenticated and not in dev mode\n\t\treturn res.status(401).json({ message: 'Unauthorized' });\n\t}\n}\n\n/**\n * Check if user is authenticated and has moderator or admin rights\n */\nexport async function isAdminOrModerator(req: Request, res: Response, next: NextFunction) {\n\t// Skip auth check in development mode and auto-login as DevUser\n\tif (process.env.ALLOW_DEV_ADMIN === 'true' && !req.isAuthenticated()) {\n\t\ttry {\n\t\t\t// Use Drizzle ORM for secure, parameterized queries\n\t\t\tconst [devUser] = await db.select().from(users).where(eq(users.username, 'DevUser')).limit(1);\n\n\t\t\tif (devUser) {\n\t\t\t\t// For admin routes, ensure the DevUser has admin or mod privileges\n\t\t\t\tif (devUser.role !== 'admin' && devUser.role !== 'mod') {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t'AdminMiddleware',\n\t\t\t\t\t\t'DevUser exists but does not have admin/mod role. Updating to admin role.',\n\t\t\t\t\t\t{ userId: devUser.id }\n\t\t\t\t\t);\n\t\t\t\t\tawait db.update(users).set({ role: 'admin' }).where(eq(users.username, 'DevUser'));\n\t\t\t\t\tdevUser.role = 'admin';\n\t\t\t\t}\n\n\t\t\t\t// Mock an authenticated session with the DevUser\n\t\t\t\treq.login(devUser, (err) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t'AdminMiddleware',\n\t\t\t\t\t\t\t'Error auto-authenticating as DevUser for admin/mod route',\n\t\t\t\t\t\t\t{ err, userId: devUser.id || devUser.user_id }\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn res.status(401).json({ message: 'Unauthorized' });\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t'AdminMiddleware',\n\t\t\t\t\t\t`Auto-authenticated as DevUser admin/mod (ID: ${devUser.id})`,\n\t\t\t\t\t\t{ userId: devUser.id }\n\t\t\t\t\t);\n\t\t\t\t\treturn next();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlogger.warn('AdminMiddleware', 'DevUser not found in database, admin/mod auth failed');\n\t\t\t\treturn res.status(401).json({ message: 'Unauthorized' });\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('AdminMiddleware', 'Error in dev mode admin/mod authentication', { err: error });\n\t\t\treturn res.status(401).json({ message: 'Unauthorized' });\n\t\t}\n\t} else if (req.isAuthenticated()) {\n\t\tconst user = userService.getUserFromRequest(req) as any;\n\t\tconst { canUser } = await import('@lib/auth/canUser');\n\t\tif (user && (await canUser(user, 'canManageUsers'))) {\n\t\t\treturn next();\n\t\t}\n\t\treturn res.status(403).json({ message: 'Forbidden - Admin or moderator access required' });\n\t} else {\n\t\t// Not authenticated and not in dev mode\n\t\treturn res.status(401).json({ message: 'Unauthorized' });\n\t}\n}\n\n/**\n * Async handler for error handling in admin routes\n * Wraps async route handlers to properly catch errors\n */\nexport const asyncHandler = (fn: Function) => (req: Request, res: Response, next: NextFunction) => {\n\tPromise.resolve(fn(req, res, next)).catch((error) => {\n\t\tlogger.error('AdminMiddleware', 'Admin route error in asyncHandler', {\n\t\t\terr: error,\n\t\t\tpath: req.path,\n\t\t\tmethod: req.method\n\t\t});\n\n\t\tif (error instanceof WalletError) {\n\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\terror: error.message,\n\t\t\t\tcode: error.code\n\t\t\t});\n\t\t}\n\n\t\treturn res.status(500).json({\n\t\t\terror: 'An unexpected error occurred',\n\t\t\tmessage: error.message || 'Internal server error'\n\t\t});\n\t});\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/admin.response.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/admin.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'like' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'or' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ne' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sum' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin Service\n *\n * Provides centralized admin functionality\n */\n\nimport { db } from '@db';\nimport { count, desc, eq, sql, and, like, isNull, or, ne, sum } from 'drizzle-orm';\nimport { users, auditLogs, transactions } from '@schema';\nimport { AdminError, AdminErrorCodes } from './admin.errors';\nimport type { AdminId, UserId } from '@shared/types/ids';\nimport { logger } from '../../core/logger';\n\nexport class AdminService {\n\t/**\n\t * Log admin action for audit purposes\n\t */\n\tasync logAdminAction(\n\t\tadminId: AdminId,\n\t\taction: string,\n\t\tentityType: string,\n\t\tentityId: string,\n\t\tdetails: any = {}\n\t) {\n\t\ttry {\n\t\t\tawait db.insert(auditLogs).values({\n\t\t\t\tuserId: adminId,\n\t\t\t\taction,\n\t\t\t\tentityType,\n\t\t\t\tentityId,\n\t\t\t\tdetails: details || {}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('Error logging admin action:', error);\n\t\t\t// Non-blocking - we continue even if logging fails\n\t\t}\n\t}\n\n\t/**\n\t * Get admin dashboard statistics\n\t */\n\tasync getDashboardStats() {\n\t\ttry {\n\t\t\t// User stats\n\t\t\tconst [userStats] = await db\n\t\t\t\t.select({\n\t\t\t\t\ttotal: count(users.id),\n\t\t\t\t\tactive: sql`COUNT(CASE WHEN ${users.isActive} = true THEN 1 END)`,\n\t\t\t\t\tbanned: sql`COUNT(CASE WHEN ${users.isBanned} = true THEN 1 END)`,\n\t\t\t\t\tnew24h: sql`COUNT(CASE WHEN ${users.createdAt} > NOW() - INTERVAL '1 day' THEN 1 END)`\n\t\t\t\t})\n\t\t\t\t.from(users);\n\n\t\t\t// Additional stats could be added here (posts, threads, etc.)\n\n\t\t\treturn {\n\t\t\t\tusers: {\n\t\t\t\t\ttotal: Number(userStats.total) || 0,\n\t\t\t\t\tactive: Number(userStats.active) || 0,\n\t\t\t\t\tbanned: Number(userStats.banned) || 0,\n\t\t\t\t\tnew24h: Number(userStats.new24h) || 0\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching admin dashboard stats:', error);\n\t\t\tthrow new AdminError('Failed to fetch dashboard statistics', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get a user by ID with standardized ID handling\n\t */\n\tasync getUserById(userId: UserId) {\n\t\ttry {\n\t\t\tif (!userId) {\n\t\t\t\tthrow new AdminError('Invalid user ID', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\n\t\t\tif (!user) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`User with ID ${userId} not found`,\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.USER_NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn user;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tlogger.error('Error fetching user by ID:', error);\n\t\t\tthrow new AdminError('Failed to fetch user', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get recent admin actions\n\t */\n\tasync getRecentAdminActions(limit: number = 10) {\n\t\ttry {\n\t\t\tconst recentActions = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: auditLogs.id,\n\t\t\t\t\tuserId: auditLogs.userId,\n\t\t\t\t\taction: auditLogs.action,\n\t\t\t\t\tentityType: auditLogs.entityType,\n\t\t\t\t\tentityId: auditLogs.entityId,\n\t\t\t\t\tdetails: auditLogs.details,\n\t\t\t\t\tcreatedAt: auditLogs.createdAt,\n\t\t\t\t\tusername: users.username\n\t\t\t\t})\n\t\t\t\t.from(auditLogs)\n\t\t\t\t.leftJoin(users, eq(auditLogs.userId, users.id))\n\t\t\t\t.orderBy(desc(auditLogs.createdAt))\n\t\t\t\t.limit(limit);\n\n\t\t\treturn recentActions;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching recent admin actions:', error);\n\t\t\tthrow new AdminError('Failed to fetch recent admin actions', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const adminService = new AdminService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/admin.validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/shared/admin-cache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/shared/admin-error-boundaries.ts","messages":[{"ruleId":"@typescript-eslint/ban-types","severity":1,"message":"Don't use `Function` as a type. The `Function` type accepts any function-like value.\nIt provides no type safety when calling the function, which can be a common source of bugs.\nIt also accepts things like class declarations, which will throw at runtime as they will not be called with `new`.\nIf you are expecting the function to accept certain arguments, you should explicitly define the function shape.","line":369,"column":81,"nodeType":"Identifier","messageId":"bannedTypeMessage","endLine":369,"endColumn":89},{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":428,"column":2,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":436,"endColumn":3}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport type { EntityId, RequestId } from '@shared/types/ids';\nimport { UserId } from '@shared/types/ids';\nimport { userService } from '@server/src/core/services/user.service';\nimport { logger } from '@server/src/core/logger';\nimport { AdminError, AdminErrorCodes } from '../admin.errors';\n\n// Enhanced error types with context\nexport interface AdminErrorContext {\n\toperation: string;\n\tentityType?: string;\n\tentityId?: string | EntityId;\n\tuserId?: UserId;\n\ttimestamp: Date;\n\trequestId?: string;\n\tmetadata?: Record<string, any>;\n}\n\nexport interface AdminOperationResult<T = any> {\n\tsuccess: boolean;\n\tdata?: T;\n\terror?: AdminErrorDetails;\n\tcontext: AdminErrorContext;\n}\n\nexport interface AdminErrorDetails {\n\tcode: string;\n\tmessage: string;\n\thttpStatus: number;\n\tdetails?: any;\n\trecoverable: boolean;\n\tuserMessage?: string;\n}\n\n/**\n * Typed error categories for better error handling\n */\nexport const ERROR_CATEGORIES = {\n\tVALIDATION: 'validation',\n\tAUTHORIZATION: 'authorization',\n\tNOT_FOUND: 'not_found',\n\tCONFLICT: 'conflict',\n\tRATE_LIMITED: 'rate_limited',\n\tEXTERNAL_SERVICE: 'external_service',\n\tDATABASE: 'database',\n\tBUSINESS_LOGIC: 'business_logic',\n\tSYSTEM: 'system'\n} as const;\n\nexport type ErrorCategory = (typeof ERROR_CATEGORIES)[keyof typeof ERROR_CATEGORIES];\n\n/**\n * Enhanced AdminError with category and recovery information\n */\nexport class TypedAdminError extends AdminError {\n\tpublic readonly category: ErrorCategory;\n\tpublic readonly recoverable: boolean;\n\tpublic readonly userMessage?: string;\n\tpublic readonly context?: AdminErrorContext;\n\n\tconstructor(\n\t\tmessage: string,\n\t\thttpStatus: number = 500,\n\t\tcode: string = AdminErrorCodes.INTERNAL_ERROR,\n\t\tdetails?: any,\n\t\tcategory: ErrorCategory = ERROR_CATEGORIES.SYSTEM,\n\t\trecoverable: boolean = false,\n\t\tuserMessage?: string,\n\t\tcontext?: AdminErrorContext\n\t) {\n\t\tsuper(message, httpStatus, code, details);\n\t\tthis.category = category;\n\t\tthis.recoverable = recoverable;\n\t\tthis.userMessage = userMessage;\n\t\tthis.context = context;\n\t}\n\n\ttoJSON() {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tcategory: this.category,\n\t\t\trecoverable: this.recoverable,\n\t\t\tuserMessage: this.userMessage,\n\t\t\tcontext: this.context\n\t\t};\n\t}\n}\n\n/**\n * Error factory for creating typed admin errors\n */\nexport class AdminErrorFactory {\n\tstatic validation(\n\t\tmessage: string,\n\t\tdetails?: any,\n\t\tuserMessage?: string,\n\t\tcontext?: AdminErrorContext\n\t): TypedAdminError {\n\t\treturn new TypedAdminError(\n\t\t\tmessage,\n\t\t\t400,\n\t\t\tAdminErrorCodes.VALIDATION_ERROR,\n\t\t\tdetails,\n\t\t\tERROR_CATEGORIES.VALIDATION,\n\t\t\ttrue,\n\t\t\tuserMessage || 'Please check your input and try again',\n\t\t\tcontext\n\t\t);\n\t}\n\n\tstatic notFound(\n\t\tentityType: string,\n\t\tentityId: string | EntityId,\n\t\tcontext?: AdminErrorContext\n\t): TypedAdminError {\n\t\treturn new TypedAdminError(\n\t\t\t`${entityType} with ID ${entityId} not found`,\n\t\t\t404,\n\t\t\tAdminErrorCodes.NOT_FOUND,\n\t\t\t{ entityType, entityId },\n\t\t\tERROR_CATEGORIES.NOT_FOUND,\n\t\t\tfalse,\n\t\t\t`The requested ${entityType.toLowerCase()} could not be found`,\n\t\t\tcontext\n\t\t);\n\t}\n\n\tstatic unauthorized(\n\t\toperation: string,\n\t\trequiredRole?: string,\n\t\tcontext?: AdminErrorContext\n\t): TypedAdminError {\n\t\treturn new TypedAdminError(\n\t\t\t`Insufficient permissions for operation: ${operation}`,\n\t\t\t403,\n\t\t\tAdminErrorCodes.FORBIDDEN,\n\t\t\t{ operation, requiredRole },\n\t\t\tERROR_CATEGORIES.AUTHORIZATION,\n\t\t\tfalse,\n\t\t\t'You do not have permission to perform this action',\n\t\t\tcontext\n\t\t);\n\t}\n\n\tstatic conflict(\n\t\tmessage: string,\n\t\tconflictType: string,\n\t\tdetails?: any,\n\t\tcontext?: AdminErrorContext\n\t): TypedAdminError {\n\t\treturn new TypedAdminError(\n\t\t\tmessage,\n\t\t\t409,\n\t\t\tAdminErrorCodes.DUPLICATE_ENTRY,\n\t\t\t{ conflictType, ...details },\n\t\t\tERROR_CATEGORIES.CONFLICT,\n\t\t\ttrue,\n\t\t\t'This operation conflicts with existing data',\n\t\t\tcontext\n\t\t);\n\t}\n\n\tstatic rateLimited(\n\t\toperation: string,\n\t\tresetTime?: Date,\n\t\tcontext?: AdminErrorContext\n\t): TypedAdminError {\n\t\treturn new TypedAdminError(\n\t\t\t`Rate limit exceeded for operation: ${operation}`,\n\t\t\t429,\n\t\t\tAdminErrorCodes.RATE_LIMITED,\n\t\t\t{ operation, resetTime },\n\t\t\tERROR_CATEGORIES.RATE_LIMITED,\n\t\t\ttrue,\n\t\t\t'Too many requests. Please try again later',\n\t\t\tcontext\n\t\t);\n\t}\n\n\tstatic database(\n\t\toperation: string,\n\t\toriginalError?: Error,\n\t\tcontext?: AdminErrorContext\n\t): TypedAdminError {\n\t\treturn new TypedAdminError(\n\t\t\t`Database error during operation: ${operation}`,\n\t\t\t500,\n\t\t\tAdminErrorCodes.DB_ERROR,\n\t\t\t{ operation, originalError: originalError?.message },\n\t\t\tERROR_CATEGORIES.DATABASE,\n\t\t\ttrue,\n\t\t\t'A temporary issue occurred. Please try again',\n\t\t\tcontext\n\t\t);\n\t}\n\n\tstatic businessLogic(\n\t\tmessage: string,\n\t\trule: string,\n\t\tdetails?: any,\n\t\tcontext?: AdminErrorContext\n\t): TypedAdminError {\n\t\treturn new TypedAdminError(\n\t\t\tmessage,\n\t\t\t400,\n\t\t\tAdminErrorCodes.BUSINESS_RULE_VIOLATION,\n\t\t\t{ rule, ...details },\n\t\t\tERROR_CATEGORIES.BUSINESS_LOGIC,\n\t\t\ttrue,\n\t\t\tmessage, // Business logic errors are usually user-facing\n\t\t\tcontext\n\t\t);\n\t}\n}\n\n/**\n * Admin operation wrapper with error boundaries\n */\nexport class AdminOperationBoundary {\n\tprivate context: AdminErrorContext;\n\n\tconstructor(context: AdminErrorContext) {\n\t\tthis.context = context;\n\t}\n\n\t/**\n\t * Execute an admin operation with comprehensive error handling\n\t */\n\tasync execute<T>(\n\t\toperation: () => Promise<T>,\n\t\toptions?: {\n\t\t\tretryAttempts?: number;\n\t\t\tretryDelay?: number;\n\t\t\tonRetry?: (attempt: number, error: Error) => void;\n\t\t}\n\t): Promise<AdminOperationResult<T>> {\n\t\tconst { retryAttempts = 0, retryDelay = 1000, onRetry } = options || {};\n\t\tlet lastError: Error | null = null;\n\n\t\tfor (let attempt = 0; attempt <= retryAttempts; attempt++) {\n\t\t\ttry {\n\t\t\t\tconst result = await operation();\n\n\t\t\t\t// Log successful operation\n\t\t\t\tlogger.info('AdminOperationBoundary', 'Operation completed successfully', {\n\t\t\t\t\toperation: this.context.operation,\n\t\t\t\t\tattempt: attempt + 1,\n\t\t\t\t\tentityType: this.context.entityType,\n\t\t\t\t\tuserId: this.context.userId\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: result,\n\t\t\t\t\tcontext: this.context\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlastError = error;\n\n\t\t\t\t// Log the error\n\t\t\t\tlogger.error('AdminOperationBoundary', `Operation failed (attempt ${attempt + 1})`, {\n\t\t\t\t\toperation: this.context.operation,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tattempt: attempt + 1,\n\t\t\t\t\tretryAttempts,\n\t\t\t\t\tentityType: this.context.entityType,\n\t\t\t\t\tuserId: this.context.userId\n\t\t\t\t});\n\n\t\t\t\t// Check if error is retryable\n\t\t\t\tif (attempt < retryAttempts && this.isRetryableError(error)) {\n\t\t\t\t\tif (onRetry) {\n\t\t\t\t\t\tonRetry(attempt + 1, error);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait before retry\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, retryDelay * (attempt + 1)));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Convert to typed error if needed\n\t\t\t\tconst typedError = this.normalizeError(error);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: typedError.code,\n\t\t\t\t\t\tmessage: typedError.message,\n\t\t\t\t\t\thttpStatus: typedError.httpStatus,\n\t\t\t\t\t\tdetails: typedError.details,\n\t\t\t\t\t\trecoverable: typedError instanceof TypedAdminError ? typedError.recoverable : false,\n\t\t\t\t\t\tuserMessage: typedError instanceof TypedAdminError ? typedError.userMessage : undefined\n\t\t\t\t\t},\n\t\t\t\t\tcontext: this.context\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// This shouldn't be reached, but TypeScript requires it\n\t\tthrow lastError || new Error('Unknown error in operation boundary');\n\t}\n\n\t/**\n\t * Check if an error is retryable\n\t */\n\tprivate isRetryableError(error: Error): boolean {\n\t\tif (error instanceof TypedAdminError) {\n\t\t\treturn (\n\t\t\t\terror.recoverable &&\n\t\t\t\t[\n\t\t\t\t\tERROR_CATEGORIES.DATABASE,\n\t\t\t\t\tERROR_CATEGORIES.EXTERNAL_SERVICE,\n\t\t\t\t\tERROR_CATEGORIES.RATE_LIMITED\n\t\t\t\t].includes(error.category)\n\t\t\t);\n\t\t}\n\n\t\tif (error instanceof AdminError) {\n\t\t\treturn [\n\t\t\t\tAdminErrorCodes.DB_ERROR,\n\t\t\t\tAdminErrorCodes.EXTERNAL_SERVICE_ERROR,\n\t\t\t\tAdminErrorCodes.RATE_LIMITED\n\t\t\t].includes(error.code);\n\t\t}\n\n\t\t// For unknown errors, assume they might be retryable\n\t\treturn true;\n\t}\n\n\t/**\n\t * Normalize any error to TypedAdminError\n\t */\n\tprivate normalizeError(error: Error): TypedAdminError {\n\t\tif (error instanceof TypedAdminError) {\n\t\t\treturn error;\n\t\t}\n\n\t\tif (error instanceof AdminError) {\n\t\t\t// Convert AdminError to TypedAdminError\n\t\t\treturn new TypedAdminError(\n\t\t\t\terror.message,\n\t\t\t\terror.httpStatus,\n\t\t\t\terror.code,\n\t\t\t\terror.details,\n\t\t\t\tERROR_CATEGORIES.SYSTEM,\n\t\t\t\tfalse,\n\t\t\t\tundefined,\n\t\t\t\tthis.context\n\t\t\t);\n\t\t}\n\n\t\t// Convert generic error\n\t\treturn new TypedAdminError(\n\t\t\terror.message || 'An unexpected error occurred',\n\t\t\t500,\n\t\t\tAdminErrorCodes.INTERNAL_ERROR,\n\t\t\t{ originalError: error.message },\n\t\t\tERROR_CATEGORIES.SYSTEM,\n\t\t\ttrue,\n\t\t\t'A temporary issue occurred. Please try again',\n\t\t\tthis.context\n\t\t);\n\t}\n}\n\n/**\n * Express middleware for admin error boundaries\n */\nexport function adminErrorBoundaryMiddleware(req: Request, res: Response, next: Function) {\n\t// Add error boundary helper to request\n\treq.adminBoundary = (operation: string, entityType?: string, entityId?: string | EntityId) => {\n\t\tconst context: AdminErrorContext = {\n\t\t\toperation,\n\t\t\tentityType,\n\t\t\tentityId,\n\t\t\tuserId: (userService.getUserFromRequest(req) as any)?.id,\n\t\t\ttimestamp: new Date(),\n\t\t\trequestId: (req.headers['x-request-id'] as string) || generateRequestId(),\n\t\t\tmetadata: {\n\t\t\t\tip: req.ip,\n\t\t\t\tuserAgent: req.headers['user-agent'],\n\t\t\t\tpath: req.path,\n\t\t\t\tmethod: req.method\n\t\t\t}\n\t\t};\n\n\t\treturn new AdminOperationBoundary(context);\n\t};\n\n\tnext();\n}\n\n/**\n * Generate unique request ID for tracing\n */\nfunction generateRequestId(): string {\n\treturn `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Error response formatter\n */\nexport function formatErrorResponse(\n\tresult: AdminOperationResult,\n\tincludeStack: boolean = false\n): {\n\tsuccess: false;\n\terror: AdminErrorDetails;\n\trequestId?: string;\n\ttimestamp: string;\n\tstack?: string;\n} {\n\tif (result.success || !result.error) {\n\t\tthrow new Error('Cannot format error response for successful result');\n\t}\n\n\treturn {\n\t\tsuccess: false,\n\t\terror: result.error,\n\t\trequestId: result.context.requestId,\n\t\ttimestamp: result.context.timestamp.toISOString(),\n\t\t...(includeStack && { stack: new Error().stack })\n\t};\n}\n\n// Extend Express Request type\ndeclare global {\n\tnamespace Express {\n\t\tinterface Request {\n\t\t\tadminBoundary?: (\n\t\t\t\toperation: string,\n\t\t\t\tentityType?: string,\n\t\t\t\tentityId?: string | EntityId\n\t\t\t) => AdminOperationBoundary;\n\t\t}\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/shared/admin-operation-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/shared/admin-query-utils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'like' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin Query Utilities\n *\n * Shared utilities for common database query patterns across admin services\n * Reduces code duplication and ensures consistent behavior\n */\n\nimport { SQL, and, or, like, ilike, eq, ne, gte, lte, asc, desc } from 'drizzle-orm';\nimport { PgColumn } from 'drizzle-orm/pg-core';\n\n// Common filter types\nexport interface SearchFilter {\n\tsearch?: string;\n\tsearchFields?: PgColumn[];\n}\n\nexport interface DateRangeFilter {\n\tstartDate?: Date;\n\tendDate?: Date;\n\tdateField?: PgColumn;\n}\n\nexport interface StatusFilter {\n\tstatus?: string | string[];\n\tstatusField?: PgColumn;\n}\n\nexport interface RoleFilter {\n\trole?: string | string[];\n\troleField?: PgColumn;\n}\n\nexport interface PaginationParams {\n\tpage?: number;\n\tlimit?: number;\n\toffset?: number;\n}\n\nexport interface SortParams {\n\tsortBy?: string;\n\tsortOrder?: 'asc' | 'desc';\n\tsortField?: PgColumn;\n}\n\n/**\n * Build search conditions for text search across multiple fields\n */\nexport function buildSearchConditions(filter: SearchFilter): SQL<unknown> | undefined {\n\tif (!filter.search || !filter.searchFields || filter.searchFields.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tconst searchTerm = `%${filter.search}%`;\n\tconst conditions = filter.searchFields.map((field) => ilike(field, searchTerm));\n\n\treturn or(...conditions);\n}\n\n/**\n * Build date range conditions\n */\nexport function buildDateRangeConditions(filter: DateRangeFilter): SQL<unknown> | undefined {\n\tif (!filter.dateField) return undefined;\n\n\tconst conditions: SQL<unknown>[] = [];\n\n\tif (filter.startDate) {\n\t\tconditions.push(gte(filter.dateField, filter.startDate));\n\t}\n\n\tif (filter.endDate) {\n\t\tconditions.push(lte(filter.dateField, filter.endDate));\n\t}\n\n\treturn conditions.length > 0 ? and(...conditions) : undefined;\n}\n\n/**\n * Build status filter conditions\n */\nexport function buildStatusConditions(filter: StatusFilter): SQL<unknown> | undefined {\n\tif (!filter.status || !filter.statusField) return undefined;\n\n\tif (Array.isArray(filter.status)) {\n\t\t// Multiple statuses - use OR conditions\n\t\tconst conditions = filter.status.map((status) => eq(filter.statusField!, status));\n\t\treturn or(...conditions);\n\t} else {\n\t\t// Single status\n\t\treturn eq(filter.statusField, filter.status);\n\t}\n}\n\n/**\n * Build role filter conditions\n */\nexport function buildRoleConditions(filter: RoleFilter): SQL<unknown> | undefined {\n\tif (!filter.role || !filter.roleField) return undefined;\n\n\tif (Array.isArray(filter.role)) {\n\t\t// Multiple roles\n\t\tconst conditions = filter.role.map((role) => eq(filter.roleField!, role));\n\t\treturn or(...conditions);\n\t} else {\n\t\t// Single role\n\t\treturn eq(filter.roleField, filter.role);\n\t}\n}\n\n/**\n * Combine multiple filter conditions with AND logic\n */\nexport function combineFilterConditions(\n\t...conditions: (SQL<unknown> | undefined)[]\n): SQL<unknown> | undefined {\n\tconst validConditions = conditions.filter(Boolean) as SQL<unknown>[];\n\treturn validConditions.length > 0 ? and(...validConditions) : undefined;\n}\n\n/**\n * Build sort conditions\n */\nexport function buildSortConditions(params: SortParams) {\n\tif (!params.sortField) return [];\n\n\tconst direction = params.sortOrder === 'desc' ? desc : asc;\n\treturn [direction(params.sortField)];\n}\n\n/**\n * Calculate pagination offset\n */\nexport function calculatePaginationOffset(params: PaginationParams): number {\n\tconst page = params.page || 1;\n\tconst limit = params.limit || 10;\n\treturn (page - 1) * limit;\n}\n\n/**\n * Normalize pagination parameters\n */\nexport function normalizePaginationParams(params: PaginationParams): Required<PaginationParams> {\n\tconst page = Math.max(1, params.page || 1);\n\tconst limit = Math.min(100, Math.max(1, params.limit || 10));\n\tconst offset = (page - 1) * limit;\n\n\treturn { page, limit, offset };\n}\n\n/**\n * Build pagination metadata for responses\n */\nexport function buildPaginationMeta(\n\ttotal: number,\n\tparams: Required<PaginationParams>\n): {\n\ttotal: number;\n\tpage: number;\n\tlimit: number;\n\ttotalPages: number;\n\thasNextPage: boolean;\n\thasPreviousPage: boolean;\n} {\n\tconst totalPages = Math.ceil(total / params.limit);\n\n\treturn {\n\t\ttotal,\n\t\tpage: params.page,\n\t\tlimit: params.limit,\n\t\ttotalPages,\n\t\thasNextPage: params.page < totalPages,\n\t\thasPreviousPage: params.page > 1\n\t};\n}\n\n/**\n * Generic user search utility\n */\nexport function buildUserSearchConditions(\n\tsearchTerm: string,\n\tusernameField: PgColumn,\n\temailField?: PgColumn\n): SQL<unknown> | undefined {\n\tif (!searchTerm || searchTerm.length < 2) return undefined;\n\n\tconst conditions = [ilike(usernameField, `%${searchTerm}%`)];\n\n\tif (emailField) {\n\t\tconditions.push(ilike(emailField, `%${searchTerm}%`));\n\t}\n\n\treturn or(...conditions);\n}\n\n/**\n * Build exclusion conditions (NOT IN)\n */\nexport function buildExclusionConditions<T>(\n\tfield: PgColumn,\n\texcludeValues: T[]\n): SQL<unknown> | undefined {\n\tif (!excludeValues || excludeValues.length === 0) return undefined;\n\n\tconst conditions = excludeValues.map((value) => ne(field, value));\n\treturn and(...conditions);\n}\n\n/**\n * Utility for building complex filter chains\n */\nexport class FilterBuilder {\n\tprivate conditions: SQL<unknown>[] = [];\n\n\taddSearch(filter: SearchFilter): this {\n\t\tconst condition = buildSearchConditions(filter);\n\t\tif (condition) this.conditions.push(condition);\n\t\treturn this;\n\t}\n\n\taddDateRange(filter: DateRangeFilter): this {\n\t\tconst condition = buildDateRangeConditions(filter);\n\t\tif (condition) this.conditions.push(condition);\n\t\treturn this;\n\t}\n\n\taddStatus(filter: StatusFilter): this {\n\t\tconst condition = buildStatusConditions(filter);\n\t\tif (condition) this.conditions.push(condition);\n\t\treturn this;\n\t}\n\n\taddRole(filter: RoleFilter): this {\n\t\tconst condition = buildRoleConditions(filter);\n\t\tif (condition) this.conditions.push(condition);\n\t\treturn this;\n\t}\n\n\taddCustom(condition: SQL<unknown> | undefined): this {\n\t\tif (condition) this.conditions.push(condition);\n\t\treturn this;\n\t}\n\n\tbuild(): SQL<unknown> | undefined {\n\t\treturn this.conditions.length > 0 ? and(...this.conditions) : undefined;\n\t}\n\n\tclear(): this {\n\t\tthis.conditions = [];\n\t\treturn this;\n\t}\n}\n\n/**\n * Common sort field mappings for admin entities\n */\nexport const COMMON_SORT_FIELDS = {\n\tcreatedAt: 'created_at',\n\tupdatedAt: 'updated_at',\n\tname: 'name',\n\ttitle: 'title',\n\tusername: 'username',\n\temail: 'email',\n\trole: 'role',\n\tstatus: 'status'\n} as const;\n\n/**\n * Validate and normalize sort parameters\n */\nexport function validateSortParams(\n\tsortBy?: string,\n\tsortOrder?: string,\n\tallowedFields: string[] = Object.keys(COMMON_SORT_FIELDS)\n): { sortBy: string; sortOrder: 'asc' | 'desc' } | null {\n\tif (!sortBy || !allowedFields.includes(sortBy)) {\n\t\treturn null;\n\t}\n\n\tconst normalizedOrder = sortOrder?.toLowerCase() === 'desc' ? 'desc' : 'asc';\n\n\treturn {\n\t\tsortBy,\n\t\tsortOrder: normalizedOrder\n\t};\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/shared/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/airdrop/airdrop.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/airdrop/airdrop.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/airdrop/airdrop.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { users, adminManualAirdropLogs, type NewAdminManualAirdropLog } from '@schema';\nimport { xpService } from '../../../xp/xp.service'; // Core XP service for XP adjustments\nimport { dgtService } from '../../../wallet/dgt.service'; // Core DGT service for DGT adjustments\nimport { eq, inArray } from 'drizzle-orm';\nimport { logger } from '../../../../core/logger';\nimport { v4 as uuidv4 } from 'uuid';\nimport type { AdminId } from '@shared/types/ids';\n\ninterface AirdropRequest {\n\tadminId: AdminId;\n\ttokenType: 'XP' | 'DGT';\n\tamount: number;\n\ttargetCriteria: {\n\t\ttype: 'group' | 'userIds' | 'role'; // For now, we primarily support 'group'\n\t\tvalue: number | number[]; // Group ID or array of User IDs\n\t};\n\tnote?: string;\n}\n\nexport class AirdropAdminService {\n\tasync processAirdrop(request: AirdropRequest): Promise<{\n\t\tsuccess: boolean;\n\t\tmessage: string;\n\t\tbatchId?: string;\n\t\tprocessedCount: number;\n\t\terrorCount: number;\n\t}> {\n\t\tconst { adminId, tokenType, amount, targetCriteria, note } = request;\n\t\tlogger.info('AIRDROP_SERVICE', 'Processing airdrop request', { request });\n\n\t\tif (amount <= 0) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Airdrop amount must be positive.',\n\t\t\t\tprocessedCount: 0,\n\t\t\t\terrorCount: 0\n\t\t\t};\n\t\t}\n\n\t\tlet targetUserIds: number[] = [];\n\n\t\tif (targetCriteria.type === 'group') {\n\t\t\tconst groupId = targetCriteria.value as number;\n\t\t\ttry {\n\t\t\t\tconst usersInGroup = await db\n\t\t\t\t\t.select({ userId: users.id })\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(eq(users.groupId, groupId));\n\t\t\t\ttargetUserIds = usersInGroup.map((u) => u.userId);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('AIRDROP_SERVICE', `Error fetching users in group ${groupId}:`, error);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Failed to fetch users in the target group.',\n\t\t\t\t\tprocessedCount: 0,\n\t\t\t\t\terrorCount: 0\n\t\t\t\t};\n\t\t\t}\n\t\t} else if (targetCriteria.type === 'userIds') {\n\t\t\ttargetUserIds = Array.isArray(targetCriteria.value)\n\t\t\t\t? targetCriteria.value\n\t\t\t\t: [targetCriteria.value as number];\n\t\t} else {\n\t\t\t// TODO: Implement other target types like 'role' or 'all_users' if needed\n\t\t\tlogger.warn('AIRDROP_SERVICE', `Unsupported target criteria type: ${targetCriteria.type}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Unsupported target criteria: ${targetCriteria.type}`,\n\t\t\t\tprocessedCount: 0,\n\t\t\t\terrorCount: 0\n\t\t\t};\n\t\t}\n\n\t\tif (targetUserIds.length === 0) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'No target users found for the airdrop.',\n\t\t\t\tprocessedCount: 0,\n\t\t\t\terrorCount: 0\n\t\t\t};\n\t\t}\n\n\t\tconst airdropBatchId = uuidv4();\n\t\tlet processedCount = 0;\n\t\tlet errorCount = 0;\n\t\tconst airdropLogEntries: NewAdminManualAirdropLog[] = [];\n\n\t\tfor (const userId of targetUserIds) {\n\t\t\ttry {\n\t\t\t\tlet operationSuccessful = false;\n\t\t\t\tif (tokenType === 'XP') {\n\t\t\t\t\tconst xpResult = await xpService.updateUserXp(userId, amount, 'add', {\n\t\t\t\t\t\treason: note || `Admin airdrop (Batch: ${airdropBatchId})`,\n\t\t\t\t\t\tadminId,\n\t\t\t\t\t\tlogAdjustment: false // We will log via airdropRecords\n\t\t\t\t\t});\n\t\t\t\t\toperationSuccessful = !!xpResult; // Check if xpResult is not undefined/null\n\t\t\t\t} else if (tokenType === 'DGT') {\n\t\t\t\t\t// Assuming dgtService.addDgt returns an object indicating success or throws an error\n\t\t\t\t\tawait dgtService.addDgt(userId, BigInt(amount), 'AIRDROP', {\n\t\t\t\t\t\treason: note || `Admin airdrop (Batch: ${airdropBatchId})`,\n\t\t\t\t\t\tadminId,\n\t\t\t\t\t\tbatchId: airdropBatchId\n\t\t\t\t\t});\n\t\t\t\t\toperationSuccessful = true;\n\t\t\t\t}\n\n\t\t\t\tif (operationSuccessful) {\n\t\t\t\t\tairdropLogEntries.push({\n\t\t\t\t\t\tadminId,\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\ttokenType,\n\t\t\t\t\t\tamount,\n\t\t\t\t\t\tgroupId: targetCriteria.type === 'group' ? (targetCriteria.value as number) : undefined,\n\t\t\t\t\t\tnote,\n\t\t\t\t\t\tairdropBatchId\n\t\t\t\t\t\t// createdAt will be set by default\n\t\t\t\t\t});\n\t\t\t\t\tprocessedCount++;\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t'AIRDROP_SERVICE',\n\t\t\t\t\t\t`Airdrop operation for user ${userId} (token: ${tokenType}) reported failure but did not throw.`\n\t\t\t\t\t);\n\t\t\t\t\terrorCount++;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t'AIRDROP_SERVICE',\n\t\t\t\t\t`Error processing airdrop for user ${userId} (Batch: ${airdropBatchId}):`,\n\t\t\t\t\terror\n\t\t\t\t);\n\t\t\t\terrorCount++;\n\t\t\t\t// Optionally, collect individual errors to return to the admin\n\t\t\t}\n\t\t}\n\n\t\t// Batch insert airdrop records\n\t\tif (airdropLogEntries.length > 0) {\n\t\t\ttry {\n\t\t\t\tawait db.insert(adminManualAirdropLogs).values(airdropLogEntries);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t'AIRDROP_SERVICE',\n\t\t\t\t\t`Failed to batch insert admin manual airdrop logs for batch ${airdropBatchId}:`,\n\t\t\t\t\terror\n\t\t\t\t);\n\t\t\t\t// This is a partial failure scenario. Some users might have received tokens.\n\t\t\t\t// Decide on atomicity or compensating transactions if this is critical.\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage:\n\t\t\t\t\t\t'Airdrop processed for some users, but failed to log all records. Please check logs.',\n\t\t\t\t\tbatchId: airdropBatchId,\n\t\t\t\t\tprocessedCount,\n\t\t\t\t\terrorCount: errorCount + (targetUserIds.length - processedCount) // Count unlogged as errors too\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tlet message = `Airdrop batch ${airdropBatchId} processed. ${processedCount} users received ${amount} ${tokenType}.`;\n\t\tif (errorCount > 0) {\n\t\t\tmessage += ` ${errorCount} users could not be processed. Check server logs for details.`;\n\t\t}\n\n\t\tlogger.info('AIRDROP_SERVICE', message);\n\t\treturn {\n\t\t\tsuccess: processedCount > 0,\n\t\t\tmessage,\n\t\t\tbatchId: airdropBatchId,\n\t\t\tprocessedCount,\n\t\t\terrorCount\n\t\t};\n\t}\n}\n\nexport const airdropAdminService = new AirdropAdminService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/analytics.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/analytics.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'validateQuery' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin Analytics Routes\n *\n * Aggregates all analytics-related routes for the admin dashboard\n */\n\nimport express from 'express';\nimport { isAuthenticated, isAdmin } from '../../../auth/middleware/auth.middleware';\nimport rainAnalyticsRoutes from './engagement/rain-analytics.routes';\nimport tippingAnalyticsRoutes from './engagement/tipping-analytics.routes';\nimport platformStatsRoutes from './routes/stats.routes';\n// import { systemAnalyticsRoutes } from './system-analytics.routes';\nimport { Router } from 'express';\nimport { AdminAnalyticsController } from './analytics.controller';\nimport { validateQuery } from '@server/src/middleware/validate';\nimport { AnalyticsQuerySchema } from './analytics.validators';\n\nconst router = express.Router();\n\n// Apply authentication middleware to all routes\nrouter.use(isAuthenticated);\nrouter.use(isAdmin);\n\n// Register analytics sub-routes\nrouter.use('/engagement/rain', rainAnalyticsRoutes);\nrouter.use('/engagement/tips', tippingAnalyticsRoutes);\nrouter.use('/platform-stats', platformStatsRoutes);\n// router.use('/system', systemAnalyticsRoutes);\n\n// Additional analytics routes can be added here\n// e.g., router.use('/users', userAnalyticsRoutes);\n// e.g., router.use('/forum', forumAnalyticsRoutes);\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/analytics.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin Analytics Service\n *\n * Handles business logic for generating platform analytics.\n */\n\nimport { db } from '@db';\nimport { users, threads, posts, postReactions, transactions, shoutboxMessages } from '@schema';\nimport { sql, eq, desc, and, count, sum, gte, lte, between } from 'drizzle-orm';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport type { AnalyticsPeriodInput, AnalyticsQueryInput } from './analytics.validators';\nimport { subDays, formatISO } from 'date-fns';\nimport { logger } from '../../../../core/logger';\n\n// Helper to get date range based on period or explicit dates\nfunction getDateRange(params: AnalyticsPeriodInput): { startDateSQL: string; endDateSQL: string } {\n\tlet startDate: Date;\n\tlet endDate: Date = new Date(); // Today\n\n\tif (params.startDate && params.endDate) {\n\t\tstartDate = new Date(params.startDate);\n\t\tendDate = new Date(params.endDate);\n\t} else {\n\t\tconst period = params.period || '30d';\n\t\tswitch (period) {\n\t\t\tcase 'today':\n\t\t\t\tstartDate = new Date();\n\t\t\t\tstartDate.setHours(0, 0, 0, 0);\n\t\t\t\tbreak;\n\t\t\tcase '7d':\n\t\t\t\tstartDate = subDays(endDate, 7);\n\t\t\t\tbreak;\n\t\t\tcase '90d':\n\t\t\t\tstartDate = subDays(endDate, 90);\n\t\t\t\tbreak;\n\t\t\tcase 'all':\n\t\t\t\tstartDate = new Date(0); // Epoch time for all data\n\t\t\t\tbreak;\n\t\t\tcase '30d':\n\t\t\tdefault:\n\t\t\t\tstartDate = subDays(endDate, 30);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn {\n\t\tstartDateSQL: formatISO(startDate),\n\t\tendDateSQL: formatISO(endDate)\n\t};\n}\n\nexport class AdminAnalyticsService {\n\tasync getOverviewStats(params: AnalyticsPeriodInput) {\n\t\tconst { startDateSQL, endDateSQL } = getDateRange(params);\n\t\ttry {\n\t\t\tconst [totalUsers] = await db.select({ value: count(users.id) }).from(users);\n\t\t\tconst [newUsers] = await db\n\t\t\t\t.select({ value: count(users.id) })\n\t\t\t\t.from(users)\n\t\t\t\t.where(between(users.createdAt, startDateSQL, endDateSQL));\n\n\t\t\tconst [activeUsers] = await db\n\t\t\t\t.select({ value: count(users.id) })\n\t\t\t\t.from(users)\n\t\t\t\t.where(between(users.lastSeenAt, startDateSQL, endDateSQL));\n\n\t\t\tconst [totalThreads] = await db.select({ value: count(threads.id) }).from(threads);\n\t\t\tconst [newThreads] = await db\n\t\t\t\t.select({ value: count(threads.id) })\n\t\t\t\t.from(threads)\n\t\t\t\t.where(between(threads.createdAt, startDateSQL, endDateSQL));\n\n\t\t\tconst [totalPosts] = await db.select({ value: count(posts.id) }).from(posts);\n\t\t\tconst [newPosts] = await db\n\t\t\t\t.select({ value: count(posts.id) })\n\t\t\t\t.from(posts)\n\t\t\t\t.where(between(posts.createdAt, startDateSQL, endDateSQL));\n\n\t\t\tconst [totalReactions] = await db\n\t\t\t\t.select({ value: count(postReactions.userId) })\n\t\t\t\t.from(postReactions);\n\n\t\t\tconst [totalTipAmount] = await db\n\t\t\t\t.select({ value: sum(transactions.amount) })\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(eq(transactions.type, 'TIP'));\n\n\t\t\tconst [shoutboxMessageCount] = await db\n\t\t\t\t.select({ value: count(shoutboxMessages.id) })\n\t\t\t\t.from(shoutboxMessages);\n\n\t\t\treturn {\n\t\t\t\tusers: {\n\t\t\t\t\ttotal: Number(totalUsers?.value) || 0,\n\t\t\t\t\tnewInPeriod: Number(newUsers?.value) || 0,\n\t\t\t\t\tactiveInPeriod: Number(activeUsers?.value) || 0\n\t\t\t\t},\n\t\t\t\tcontent: {\n\t\t\t\t\ttotalThreads: Number(totalThreads?.value) || 0,\n\t\t\t\t\tnewThreadsInPeriod: Number(newThreads?.value) || 0,\n\t\t\t\t\ttotalPosts: Number(totalPosts?.value) || 0,\n\t\t\t\t\tnewPostsInPeriod: Number(newPosts?.value) || 0\n\t\t\t\t},\n\t\t\t\tengagement: {\n\t\t\t\t\ttotalReactions: Number(totalReactions?.value) || 0,\n\t\t\t\t\ttotalTipAmountDGT: totalTipAmount?.value ? Number(totalTipAmount.value) / 1000000 : 0, // Assuming DGT has 6 decimals\n\t\t\t\t\tshoutboxMessageCount: Number(shoutboxMessageCount?.value) || 0\n\t\t\t\t},\n\t\t\t\tperiod: {\n\t\t\t\t\tstartDate: startDateSQL,\n\t\t\t\t\tendDate: endDateSQL,\n\t\t\t\t\tperiodUsed: params.period || 'custom'\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tlogger.error('Error fetching overview stats:', error);\n\t\t\tthrow new AdminError('Failed to fetch overview statistics', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\tasync getUserGrowthChart(params: AnalyticsQueryInput) {\n\t\tconst { startDateSQL, endDateSQL } = getDateRange(params);\n\t\tconst { granularity } = params;\n\t\tlet dateFormat: string;\n\t\tswitch (granularity) {\n\t\t\tcase 'daily':\n\t\t\t\tdateFormat = '%Y-%m-%d';\n\t\t\t\tbreak;\n\t\t\tcase 'weekly':\n\t\t\t\tdateFormat = '%Y-%W';\n\t\t\t\tbreak; // Year-WeekNumber\n\t\t\tcase 'monthly':\n\t\t\t\tdateFormat = '%Y-%m';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdateFormat = '%Y-%m-%d';\n\t\t}\n\n\t\ttry {\n\t\t\tconst growthData = await db\n\t\t\t\t.select({\n\t\t\t\t\tperiod: sql<string>`strftime(${dateFormat}, ${users.createdAt})`,\n\t\t\t\t\tcount: count(users.id)\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(between(users.createdAt, startDateSQL, endDateSQL))\n\t\t\t\t.groupBy(sql`period`)\n\t\t\t\t.orderBy(sql`period ASC`);\n\n\t\t\treturn growthData.map((d) => ({ period: d.period, userCount: Number(d.count) }));\n\t\t} catch (error: any) {\n\t\t\tlogger.error('Error fetching user growth data:', error);\n\t\t\tthrow new AdminError('Failed to fetch user growth data', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\tasync getMostActiveThreads(params: AnalyticsQueryInput) {\n\t\tconst { limit } = params;\n\t\tconst { startDateSQL, endDateSQL } = getDateRange(params);\n\t\ttry {\n\t\t\tconst activeThreads = await db\n\t\t\t\t.select({\n\t\t\t\t\tthreadId: threads.id,\n\t\t\t\t\ttitle: threads.title,\n\t\t\t\t\tslug: threads.slug,\n\t\t\t\t\tpostCount: threads.postCount, // Assuming postCount is updated regularly\n\t\t\t\t\tlastPostAt: threads.lastPostAt,\n\t\t\t\t\tviewCount: threads.viewCount\n\t\t\t\t})\n\t\t\t\t.from(threads)\n\t\t\t\t.where(between(threads.updatedAt, startDateSQL, endDateSQL)) // Use updatedAt or lastPostAt for recent activity\n\t\t\t\t.orderBy(desc(threads.postCount), desc(threads.updatedAt)) // Order by post count then recent activity\n\t\t\t\t.limit(limit || 10);\n\n\t\t\treturn activeThreads;\n\t\t} catch (error: any) {\n\t\t\tlogger.error('Error fetching most active threads:', error);\n\t\t\tthrow new AdminError('Failed to fetch most active threads', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport const adminAnalyticsService = new AdminAnalyticsService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/analytics.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/engagement/rain-analytics.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/engagement/rain-analytics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/engagement/rain-analytics.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Rain Analytics Service\n *\n * Provides analytics data about rain events for the admin dashboard\n */\n\nimport { db } from '@db';\nimport type { UserId } from '@shared/types/ids';\nimport { rainEvents, users, transactions } from '@schema';\nimport { sql, desc, eq, count, sum, and, between } from 'drizzle-orm';\nimport { startOfDay, subDays, format } from 'date-fns';\n\nexport interface RainEventAnalytics {\n\t// Summary statistics\n\ttotalRainEvents: number;\n\ttotalRainVolume: number;\n\tuniqueRainers: number;\n\tuniqueRecipients: number;\n\taverageRainAmount: number;\n\n\t// Time-based metrics\n\tdailyVolume: {\n\t\tdate: string;\n\t\tamount: number;\n\t\teventCount: number;\n\t}[];\n\n\t// Top rainers\n\ttopRainers: {\n\t\tuserId: UserId;\n\t\tusername: string;\n\t\tavatarUrl: string | null;\n\t\ttotalAmount: number;\n\t\teventCount: number;\n\t}[];\n\n\t// Currency distribution\n\tcurrencyDistribution: {\n\t\tcurrency: string;\n\t\tamount: number;\n\t\tpercentage: number;\n\t}[];\n\n\t// Last updated timestamp\n\tlastUpdated: string;\n}\n\nclass RainAnalyticsService {\n\t/**\n\t * Get comprehensive rain analytics\n\t * @param days Number of days to include in time-series data (default: 30)\n\t * @param topRainersLimit Number of top rainers to include (default: 10)\n\t */\n\tasync getRainAnalytics(days = 30, topRainersLimit = 10): Promise<RainEventAnalytics> {\n\t\tconst now = new Date();\n\t\tconst startDate = subDays(startOfDay(now), days);\n\n\t\t// Get summary statistics\n\t\tconst summaryResult = await db\n\t\t\t.select({\n\t\t\t\ttotalRainEvents: count(rainEvents.id),\n\t\t\t\ttotalRainVolume: sum(rainEvents.amount),\n\t\t\t\tuniqueRainers: sql<number>`COUNT(DISTINCT ${rainEvents.userId})`,\n\t\t\t\t// Estimate unique recipients from transactions table\n\t\t\t\tuniqueRecipients: sql<number>`(\n        SELECT COUNT(DISTINCT t.to_user_id) \n        FROM transactions t \n        WHERE t.type = 'RAIN' AND t.from_user_id IN (\n          SELECT DISTINCT user_id FROM rain_events\n        )\n      )`\n\t\t\t})\n\t\t\t.from(rainEvents);\n\n\t\t// Get daily volume for time series\n\t\tconst dailyVolumeResult = await db\n\t\t\t.select({\n\t\t\t\tdate: sql<string>`DATE_TRUNC('day', ${rainEvents.createdAt})::text`,\n\t\t\t\tamount: sum(rainEvents.amount),\n\t\t\t\teventCount: count(rainEvents.id)\n\t\t\t})\n\t\t\t.from(rainEvents)\n\t\t\t.where(between(rainEvents.createdAt, startDate, now))\n\t\t\t.groupBy(sql`DATE_TRUNC('day', ${rainEvents.createdAt})`)\n\t\t\t.orderBy(sql`DATE_TRUNC('day', ${rainEvents.createdAt})`);\n\n\t\t// Fill in missing dates\n\t\tconst dailyVolume = this.fillMissingDates(dailyVolumeResult, days);\n\n\t\t// Get top rainers\n\t\tconst topRainers = await db\n\t\t\t.select({\n\t\t\t\tuserId: rainEvents.userId,\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\ttotalAmount: sum(rainEvents.amount),\n\t\t\t\teventCount: count(rainEvents.id)\n\t\t\t})\n\t\t\t.from(rainEvents)\n\t\t\t.leftJoin(users, eq(rainEvents.userId, users.id))\n\t\t\t.groupBy(rainEvents.userId, users.username, users.avatarUrl)\n\t\t\t.orderBy(desc(sum(rainEvents.amount)))\n\t\t\t.limit(topRainersLimit);\n\n\t\t// Get currency distribution\n\t\tconst currencyDistribution = await db\n\t\t\t.select({\n\t\t\t\tcurrency: rainEvents.currency,\n\t\t\t\tamount: sum(rainEvents.amount)\n\t\t\t})\n\t\t\t.from(rainEvents)\n\t\t\t.groupBy(rainEvents.currency);\n\n\t\t// Calculate total for percentages\n\t\tconst totalAmount = currencyDistribution.reduce((acc, curr) => acc + Number(curr.amount), 0);\n\n\t\t// Add percentage to currency distribution\n\t\tconst currencyDistributionWithPercentage = currencyDistribution.map((item) => ({\n\t\t\tcurrency: item.currency,\n\t\t\tamount: Number(item.amount),\n\t\t\tpercentage: totalAmount > 0 ? (Number(item.amount) / totalAmount) * 100 : 0\n\t\t}));\n\n\t\t// Get average rain amount\n\t\tconst averageRainAmount =\n\t\t\tsummaryResult[0].totalRainVolume && summaryResult[0].totalRainEvents\n\t\t\t\t? Number(summaryResult[0].totalRainVolume) / Number(summaryResult[0].totalRainEvents)\n\t\t\t\t: 0;\n\n\t\treturn {\n\t\t\ttotalRainEvents: Number(summaryResult[0].totalRainEvents || 0),\n\t\t\ttotalRainVolume: Number(summaryResult[0].totalRainVolume || 0),\n\t\t\tuniqueRainers: Number(summaryResult[0].uniqueRainers || 0),\n\t\t\tuniqueRecipients: Number(summaryResult[0].uniqueRecipients || 0),\n\t\t\taverageRainAmount,\n\t\t\tdailyVolume,\n\t\t\ttopRainers,\n\t\t\tcurrencyDistribution: currencyDistributionWithPercentage,\n\t\t\tlastUpdated: new Date().toISOString()\n\t\t};\n\t}\n\n\t/**\n\t * Fill in missing dates in the time series data\n\t */\n\tprivate fillMissingDates(\n\t\tdata: { date: string; amount: any; eventCount: any }[],\n\t\tdays: number\n\t): { date: string; amount: number; eventCount: number }[] {\n\t\tconst result: { date: string; amount: number; eventCount: number }[] = [];\n\t\tconst dataMap = new Map(data.map((item) => [item.date.split('T')[0], item]));\n\n\t\t// Create an array of all dates in the range\n\t\tfor (let i = days; i >= 0; i--) {\n\t\t\tconst date = format(subDays(new Date(), i), 'yyyy-MM-dd');\n\t\t\tconst entry = dataMap.get(date);\n\n\t\t\tresult.push({\n\t\t\t\tdate,\n\t\t\t\tamount: entry ? Number(entry.amount) : 0,\n\t\t\t\teventCount: entry ? Number(entry.eventCount) : 0\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nexport const rainAnalyticsService = new RainAnalyticsService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/engagement/tipping-analytics.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/engagement/tipping-analytics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/engagement/tipping-analytics.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'postTips' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tipping Analytics Service\n *\n * Provides analytics data about tipping activity for the admin dashboard\n */\n\nimport { db } from '@db';\nimport type { UserId } from '@shared/types/ids';\nimport { transactions, users, postTips } from '@schema';\nimport { sql, desc, eq, count, sum, and, between, isNotNull } from 'drizzle-orm';\nimport { startOfDay, subDays, format } from 'date-fns';\n\nexport interface TippingAnalytics {\n\t// Summary statistics\n\ttotalTips: number;\n\ttotalTipVolume: number;\n\tuniqueTippers: number;\n\tuniqueRecipients: number;\n\taverageTipAmount: number;\n\n\t// Time-based metrics\n\tdailyVolume: {\n\t\tdate: string;\n\t\tamount: number;\n\t\ttipCount: number;\n\t}[];\n\n\t// Top tippers\n\ttopTippers: {\n\t\tuserId: UserId;\n\t\tusername: string;\n\t\tavatarUrl: string | null;\n\t\ttotalAmount: number;\n\t\ttipCount: number;\n\t}[];\n\n\t// Top recipients\n\ttopRecipients: {\n\t\tuserId: UserId;\n\t\tusername: string;\n\t\tavatarUrl: string | null;\n\t\ttotalReceived: number;\n\t\ttipCount: number;\n\t}[];\n\n\t// Currency distribution\n\tcurrencyDistribution: {\n\t\tcurrency: string;\n\t\tamount: number;\n\t\tpercentage: number;\n\t}[];\n\n\t// Context distribution (posts, shoutbox, etc.)\n\tcontextDistribution: {\n\t\tcontext: string;\n\t\ttipCount: number;\n\t\tpercentage: number;\n\t}[];\n\n\t// Last updated timestamp\n\tlastUpdated: string;\n}\n\nclass TippingAnalyticsService {\n\t/**\n\t * Get comprehensive tipping analytics\n\t * @param days Number of days to include in time-series data (default: 30)\n\t * @param topLimit Number of top users to include (default: 10)\n\t */\n\tasync getTippingAnalytics(days = 30, topLimit = 10): Promise<TippingAnalytics> {\n\t\tconst now = new Date();\n\t\tconst startDate = subDays(startOfDay(now), days);\n\n\t\t// Get summary statistics\n\t\tconst summaryResult = await db\n\t\t\t.select({\n\t\t\t\ttotalTips: count(transactions.id),\n\t\t\t\ttotalTipVolume: sum(transactions.amount),\n\t\t\t\tuniqueTippers: sql<number>`COUNT(DISTINCT ${transactions.fromUserId})`,\n\t\t\t\tuniqueRecipients: sql<number>`COUNT(DISTINCT ${transactions.toUserId})`\n\t\t\t})\n\t\t\t.from(transactions)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(transactions.type, 'TIP'),\n\t\t\t\t\tisNotNull(transactions.fromUserId),\n\t\t\t\t\tisNotNull(transactions.toUserId),\n\t\t\t\t\tbetween(transactions.createdAt, startDate, now)\n\t\t\t\t)\n\t\t\t);\n\n\t\t// Get daily volume for time series\n\t\tconst dailyVolumeResult = await db\n\t\t\t.select({\n\t\t\t\tdate: sql<string>`DATE_TRUNC('day', ${transactions.createdAt})::text`,\n\t\t\t\tamount: sum(transactions.amount),\n\t\t\t\ttipCount: count(transactions.id)\n\t\t\t})\n\t\t\t.from(transactions)\n\t\t\t.where(and(eq(transactions.type, 'TIP'), between(transactions.createdAt, startDate, now)))\n\t\t\t.groupBy(sql`DATE_TRUNC('day', ${transactions.createdAt})`)\n\t\t\t.orderBy(sql`DATE_TRUNC('day', ${transactions.createdAt})`);\n\n\t\t// Fill in missing dates\n\t\tconst dailyVolume = this.fillMissingDates(dailyVolumeResult, days);\n\n\t\t// Get top tippers\n\t\tconst topTippers = await db\n\t\t\t.select({\n\t\t\t\tuserId: transactions.fromUserId,\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\ttotalAmount: sum(transactions.amount),\n\t\t\t\ttipCount: count(transactions.id)\n\t\t\t})\n\t\t\t.from(transactions)\n\t\t\t.leftJoin(users, eq(transactions.fromUserId, users.id))\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(transactions.type, 'TIP'),\n\t\t\t\t\tisNotNull(transactions.fromUserId),\n\t\t\t\t\tbetween(transactions.createdAt, startDate, now)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.groupBy(transactions.fromUserId, users.username, users.avatarUrl)\n\t\t\t.orderBy(desc(sum(transactions.amount)))\n\t\t\t.limit(topLimit);\n\n\t\t// Get top recipients\n\t\tconst topRecipients = await db\n\t\t\t.select({\n\t\t\t\tuserId: transactions.toUserId,\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\ttotalReceived: sum(transactions.amount),\n\t\t\t\ttipCount: count(transactions.id)\n\t\t\t})\n\t\t\t.from(transactions)\n\t\t\t.leftJoin(users, eq(transactions.toUserId, users.id))\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(transactions.type, 'TIP'),\n\t\t\t\t\tisNotNull(transactions.toUserId),\n\t\t\t\t\tbetween(transactions.createdAt, startDate, now)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.groupBy(transactions.toUserId, users.username, users.avatarUrl)\n\t\t\t.orderBy(desc(sum(transactions.amount)))\n\t\t\t.limit(topLimit);\n\n\t\t// Get currency distribution\n\t\tconst currencyResult = await db\n\t\t\t.select({\n\t\t\t\tcurrency: sql<string>`COALESCE(${transactions.metadata}->>'currency', 'DGT')`,\n\t\t\t\tamount: sum(transactions.amount)\n\t\t\t})\n\t\t\t.from(transactions)\n\t\t\t.where(and(eq(transactions.type, 'TIP'), between(transactions.createdAt, startDate, now)))\n\t\t\t.groupBy(sql`COALESCE(${transactions.metadata}->>'currency', 'DGT')`);\n\n\t\t// Calculate total for percentages\n\t\tconst totalAmount = currencyResult.reduce((acc, curr) => acc + Number(curr.amount), 0);\n\n\t\t// Add percentage to currency distribution\n\t\tconst currencyDistribution = currencyResult.map((item) => ({\n\t\t\tcurrency: item.currency,\n\t\t\tamount: Number(item.amount),\n\t\t\tpercentage: totalAmount > 0 ? (Number(item.amount) / totalAmount) * 100 : 0\n\t\t}));\n\n\t\t// Get context distribution (post tips, shoutbox tips, etc.)\n\t\tconst contextResult = await db\n\t\t\t.select({\n\t\t\t\tcontext: sql<string>`COALESCE(${transactions.metadata}->>'source', 'unknown')`,\n\t\t\t\ttipCount: count(transactions.id)\n\t\t\t})\n\t\t\t.from(transactions)\n\t\t\t.where(and(eq(transactions.type, 'TIP'), between(transactions.createdAt, startDate, now)))\n\t\t\t.groupBy(sql`COALESCE(${transactions.metadata}->>'source', 'unknown')`);\n\n\t\t// Calculate total for percentages\n\t\tconst totalTips = contextResult.reduce((acc, curr) => acc + Number(curr.tipCount), 0);\n\n\t\t// Add percentage to context distribution\n\t\tconst contextDistribution = contextResult.map((item) => ({\n\t\t\tcontext: this.formatContextName(item.context),\n\t\t\ttipCount: Number(item.tipCount),\n\t\t\tpercentage: totalTips > 0 ? (Number(item.tipCount) / totalTips) * 100 : 0\n\t\t}));\n\n\t\t// Get average tip amount\n\t\tconst averageTipAmount =\n\t\t\tsummaryResult[0].totalTipVolume && summaryResult[0].totalTips\n\t\t\t\t? Number(summaryResult[0].totalTipVolume) / Number(summaryResult[0].totalTips)\n\t\t\t\t: 0;\n\n\t\treturn {\n\t\t\ttotalTips: Number(summaryResult[0].totalTips || 0),\n\t\t\ttotalTipVolume: Number(summaryResult[0].totalTipVolume || 0),\n\t\t\tuniqueTippers: Number(summaryResult[0].uniqueTippers || 0),\n\t\t\tuniqueRecipients: Number(summaryResult[0].uniqueRecipients || 0),\n\t\t\taverageTipAmount,\n\t\t\tdailyVolume,\n\t\t\ttopTippers,\n\t\t\ttopRecipients,\n\t\t\tcurrencyDistribution,\n\t\t\tcontextDistribution,\n\t\t\tlastUpdated: new Date().toISOString()\n\t\t};\n\t}\n\n\t/**\n\t * Fill in missing dates in the time series data\n\t */\n\tprivate fillMissingDates(\n\t\tdata: { date: string; amount: any; tipCount: any }[],\n\t\tdays: number\n\t): { date: string; amount: number; tipCount: number }[] {\n\t\tconst result: { date: string; amount: number; tipCount: number }[] = [];\n\t\tconst dataMap = new Map(data.map((item) => [item.date.split('T')[0], item]));\n\n\t\t// Create an array of all dates in the range\n\t\tfor (let i = days; i >= 0; i--) {\n\t\t\tconst date = format(subDays(new Date(), i), 'yyyy-MM-dd');\n\t\t\tconst entry = dataMap.get(date);\n\n\t\t\tresult.push({\n\t\t\t\tdate,\n\t\t\t\tamount: entry ? Number(entry.amount) : 0,\n\t\t\t\ttipCount: entry ? Number(entry.tipCount) : 0\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Format context names for better readability\n\t */\n\tprivate formatContextName(context: string): string {\n\t\tswitch (context.toLowerCase()) {\n\t\t\tcase 'post':\n\t\t\t\treturn 'Forum Posts';\n\t\t\tcase 'shoutbox':\n\t\t\t\treturn 'Shoutbox';\n\t\t\tcase 'forum':\n\t\t\t\treturn 'Forum Posts';\n\t\t\tcase 'profile':\n\t\t\t\treturn 'User Profiles';\n\t\t\tcase 'thread':\n\t\t\t\treturn 'Forum Threads';\n\t\t\tcase 'comment':\n\t\t\t\treturn 'Comments';\n\t\t\tdefault:\n\t\t\t\t// Capitalize first letter of each word\n\t\t\t\treturn context\n\t\t\t\t\t.split('_')\n\t\t\t\t\t.map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n\t\t\t\t\t.join(' ');\n\t\t}\n\t}\n}\n\nexport const tippingAnalyticsService = new TippingAnalyticsService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/routes/stats.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/services/platformStats.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/system-analytics.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":25,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":59,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":59,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":97,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":97,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":137,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":137,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":189,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":189,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":189,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":189,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":215,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":215,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":285,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":285,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":285,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":285,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":347,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":347,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":347,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":347,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { systemAnalyticsService } from './system-analytics.service';\nimport {\n\tsystemMetricsQuerySchema,\n\tperformanceHeatmapQuerySchema,\n\tsystemHealthQuerySchema,\n\trealtimeAnalyticsQuerySchema,\n\tcacheOperationSchema,\n\ttype SystemMetricsQuery,\n\ttype PerformanceHeatmapQuery,\n\ttype SystemHealthQuery,\n\ttype RealtimeAnalyticsQuery,\n\ttype CacheOperation\n} from './system-analytics.validators';\nimport { formatAdminResponse, AdminOperationBoundary } from '@server/src/domains/admin/shared';\nimport { AdminError, AdminErrorCodes } from '@server/src/domains/admin/admin.errors';\nimport { adminCacheService } from '@server/src/domains/admin/shared/admin-cache.service';\n\nexport class SystemAnalyticsController {\n\t/**\n\t * GET /api/admin/analytics/system/metrics\n\t * Get comprehensive system performance metrics\n\t */\n\tasync getSystemMetrics(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_SYSTEM_METRICS',\n\t\t\tentityType: 'system_analytics'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst query = systemMetricsQuerySchema.parse(req.query);\n\t\t\tconst metrics = await systemAnalyticsService.getSystemMetrics(query.timeRange);\n\n\t\t\t// Filter metrics based on query parameters\n\t\t\tconst filteredMetrics = {\n\t\t\t\t...(query.includeCache && { cache: metrics.cache }),\n\t\t\t\t...(query.includeDatabase && { database: metrics.database }),\n\t\t\t\t...(query.includeAPI && { api: metrics.api, performance: metrics.performance }),\n\t\t\t\t...(query.includeSystem && { system: metrics.system })\n\t\t\t};\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\tmetrics: filteredMetrics,\n\t\t\t\t\ttimeRange: query.timeRange,\n\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t},\n\t\t\t\t'GET_SYSTEM_METRICS',\n\t\t\t\t'system_analytics'\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/analytics/system/heatmap\n\t * Get performance heatmap data for visualization\n\t */\n\tasync getPerformanceHeatmap(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_PERFORMANCE_HEATMAP',\n\t\t\tentityType: 'system_analytics'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst query = performanceHeatmapQuerySchema.parse(req.query);\n\t\t\tconst heatmap = await systemAnalyticsService.getPerformanceHeatmap(\n\t\t\t\tquery.timeRange,\n\t\t\t\tquery.granularity\n\t\t\t);\n\n\t\t\t// Filter metrics if specified\n\t\t\tif (query.metrics && query.metrics.length > 0) {\n\t\t\t\theatmap.metrics = heatmap.metrics.filter((metric) => query.metrics!.includes(metric.type));\n\t\t\t}\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\theatmap,\n\t\t\t\t\tquery: {\n\t\t\t\t\t\ttimeRange: query.timeRange,\n\t\t\t\t\t\tgranularity: query.granularity,\n\t\t\t\t\t\tfilteredMetrics: query.metrics\n\t\t\t\t\t},\n\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t},\n\t\t\t\t'GET_PERFORMANCE_HEATMAP',\n\t\t\t\t'system_analytics'\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/analytics/system/health\n\t * Get system health assessment with recommendations\n\t */\n\tasync getSystemHealth(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_SYSTEM_HEALTH',\n\t\t\tentityType: 'system_analytics'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst query = systemHealthQuerySchema.parse(req.query);\n\n\t\t\t// Force refresh bypasses cache\n\t\t\tif (query.forceRefresh) {\n\t\t\t\tadminCacheService.delete('system_analytics:health');\n\t\t\t}\n\n\t\t\tconst health = await systemAnalyticsService.getSystemHealth();\n\n\t\t\t// Filter response based on query parameters\n\t\t\tconst response = {\n\t\t\t\tstatus: health.status,\n\t\t\t\tscore: health.score,\n\t\t\t\tlastChecked: health.lastChecked,\n\t\t\t\t...(query.includeDetailedChecks && { checks: health.checks }),\n\t\t\t\t...(query.includeRecommendations && { recommendations: health.recommendations })\n\t\t\t};\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\thealth: response,\n\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t},\n\t\t\t\t'GET_SYSTEM_HEALTH',\n\t\t\t\t'system_analytics'\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/analytics/system/realtime\n\t * Get real-time system activity metrics\n\t */\n\tasync getRealtimeAnalytics(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_REALTIME_ANALYTICS',\n\t\t\tentityType: 'system_analytics'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst query = realtimeAnalyticsQuerySchema.parse(req.query);\n\t\t\tconst realtime = await systemAnalyticsService.getRealtimeAnalytics();\n\n\t\t\t// Filter metrics if specified\n\t\t\tlet filteredRealtime = realtime;\n\t\t\tif (query.metrics && query.metrics.length > 0) {\n\t\t\t\tfilteredRealtime = {};\n\t\t\t\tquery.metrics.forEach((metric) => {\n\t\t\t\t\tswitch (metric) {\n\t\t\t\t\t\tcase 'active_users':\n\t\t\t\t\t\t\tfilteredRealtime.activeUsers = realtime.activeUsers;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'requests_per_second':\n\t\t\t\t\t\t\tfilteredRealtime.requestsPerSecond = realtime.requestsPerSecond;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'cache_operations':\n\t\t\t\t\t\t\tfilteredRealtime.cacheOperationsPerSecond = realtime.cacheOperationsPerSecond;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'new_content':\n\t\t\t\t\t\t\tfilteredRealtime.newThreadsLastHour = realtime.newThreadsLastHour;\n\t\t\t\t\t\t\tfilteredRealtime.newPostsLastHour = realtime.newPostsLastHour;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transactions':\n\t\t\t\t\t\t\tfilteredRealtime.dgtTransactionsLastHour = realtime.dgtTransactionsLastHour;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\trealtime: filteredRealtime,\n\t\t\t\t\tinterval: query.interval,\n\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t},\n\t\t\t\t'GET_REALTIME_ANALYTICS',\n\t\t\t\t'system_analytics'\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/analytics/system/cache/stats\n\t * Get detailed cache performance statistics\n\t */\n\tasync getCacheStats(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_CACHE_STATS',\n\t\t\tentityType: 'system_analytics'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst cacheMetrics = adminCacheService.getCacheMetrics();\n\t\t\tconst cacheAnalytics = adminCacheService.getCacheAnalytics();\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\tmetrics: cacheMetrics,\n\t\t\t\t\tanalytics: cacheAnalytics,\n\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t},\n\t\t\t\t'GET_CACHE_STATS',\n\t\t\t\t'system_analytics'\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/analytics/system/cache/operation\n\t * Perform cache operations (clear, warm, invalidate)\n\t */\n\tasync performCacheOperation(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'CACHE_OPERATION',\n\t\t\tentityType: 'system_analytics'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst operation = cacheOperationSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tlet result;\n\n\t\t\tswitch (operation.operation) {\n\t\t\t\tcase 'clear':\n\t\t\t\t\tif (operation.category) {\n\t\t\t\t\t\tresult = adminCacheService.clearCategory(operation.category);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = adminCacheService.flushAll();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'warm':\n\t\t\t\t\t// TODO: Implement cache warming\n\t\t\t\t\tresult = { success: true, message: 'Cache warming initiated' };\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'invalidate':\n\t\t\t\t\tif (operation.pattern) {\n\t\t\t\t\t\tresult = adminCacheService.deletePattern(operation.pattern);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t\t'Pattern required for invalidation',\n\t\t\t\t\t\t\t400,\n\t\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'stats':\n\t\t\t\t\tresult = {\n\t\t\t\t\t\tmetrics: adminCacheService.getCacheMetrics(),\n\t\t\t\t\t\tanalytics: adminCacheService.getCacheAnalytics()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new AdminError('Invalid cache operation', 400, AdminErrorCodes.VALIDATION_ERROR);\n\t\t\t}\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\toperation: operation.operation,\n\t\t\t\t\tresult,\n\t\t\t\t\texecutedBy: adminId,\n\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t},\n\t\t\t\t'CACHE_OPERATION',\n\t\t\t\t'system_analytics'\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/analytics/system/overview\n\t * Get system overview dashboard data\n\t */\n\tasync getSystemOverview(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_SYSTEM_OVERVIEW',\n\t\t\tentityType: 'system_analytics'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst [metrics, health, realtime] = await Promise.all([\n\t\t\t\tsystemAnalyticsService.getSystemMetrics('24h'),\n\t\t\t\tsystemAnalyticsService.getSystemHealth(),\n\t\t\t\tsystemAnalyticsService.getRealtimeAnalytics()\n\t\t\t]);\n\n\t\t\t// Create overview summary\n\t\t\tconst overview = {\n\t\t\t\tsystemStatus: {\n\t\t\t\t\thealth: health.status,\n\t\t\t\t\tscore: health.score,\n\t\t\t\t\tuptime: metrics.performance.uptime\n\t\t\t\t},\n\t\t\t\tperformance: {\n\t\t\t\t\taverageResponseTime: metrics.performance.averageResponseTime,\n\t\t\t\t\trequestsPerMinute: realtime.requestsPerSecond * 60,\n\t\t\t\t\terrorRate: metrics.performance.errorRate,\n\t\t\t\t\tcacheHitRate: metrics.cache.hitRate\n\t\t\t\t},\n\t\t\t\tactivity: {\n\t\t\t\t\tactiveUsers: realtime.activeUsers,\n\t\t\t\t\tnewThreadsLastHour: realtime.newThreadsLastHour,\n\t\t\t\t\tnewPostsLastHour: realtime.newPostsLastHour,\n\t\t\t\t\tdgtTransactionsLastHour: realtime.dgtTransactionsLastHour\n\t\t\t\t},\n\t\t\t\tresources: {\n\t\t\t\t\tcacheMemoryUsage: metrics.cache.memoryUsage,\n\t\t\t\t\tdatabaseConnections: metrics.database.connectionCount,\n\t\t\t\t\ttotalCacheKeys: metrics.cache.totalKeys\n\t\t\t\t},\n\t\t\t\talerts: health.checks\n\t\t\t\t\t.filter((check) => check.status !== 'pass')\n\t\t\t\t\t.map((check) => ({\n\t\t\t\t\t\tseverity: check.status === 'fail' ? 'critical' : 'warning',\n\t\t\t\t\t\tmessage: check.message,\n\t\t\t\t\t\tmetric: check.name,\n\t\t\t\t\t\tvalue: check.value\n\t\t\t\t\t}))\n\t\t\t};\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\toverview,\n\t\t\t\t\tlastUpdated: new Date().toISOString()\n\t\t\t\t},\n\t\t\t\t'GET_SYSTEM_OVERVIEW',\n\t\t\t\t'system_analytics'\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/analytics/system/database/stats\n\t * Get detailed database performance statistics\n\t */\n\tasync getDatabaseStats(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_DATABASE_STATS',\n\t\t\tentityType: 'system_analytics'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst metrics = await systemAnalyticsService.getSystemMetrics('24h');\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\tdatabase: metrics.database,\n\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t},\n\t\t\t\t'GET_DATABASE_STATS',\n\t\t\t\t'system_analytics'\n\t\t\t);\n\t\t});\n\t}\n}\n\n// Export controller instance\nexport const systemAnalyticsController = new SystemAnalyticsController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/system-analytics.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'avg' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sum' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shoutboxMessages' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":17,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'endTime' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":172,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":172,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'startTime' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":173,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":173,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timeRange' is defined but never used.","line":459,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":459,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * System Analytics Service\n *\n * Provides comprehensive system performance analytics, cache metrics,\n * database health monitoring, and performance heatmaps\n */\n\nimport { eq, desc, count, avg, sum, sql, and, gte, lte } from 'drizzle-orm';\nimport { db } from '@db';\nimport { adminCacheService } from '@server/src/domains/admin/shared/admin-cache.service';\nimport {\n\tthreads,\n\tposts,\n\tusers,\n\twalletTransactions,\n\txpLogs,\n\tshoutboxMessages,\n\tanalyticsEvents\n} from '@schema';\n\nexport interface SystemMetrics {\n\tperformance: {\n\t\taverageResponseTime: number;\n\t\tslowestEndpoints: Array<{\n\t\t\tendpoint: string;\n\t\t\taverageTime: number;\n\t\t\trequestCount: number;\n\t\t}>;\n\t\terrorRate: number;\n\t\tuptime: number;\n\t};\n\tcache: {\n\t\thitRate: number;\n\t\thitRateGrade: string;\n\t\ttotalKeys: number;\n\t\tmemoryUsage: number;\n\t\tkeysByCategory: Record<string, number>;\n\t\tperformance: {\n\t\t\thits: number;\n\t\t\tmisses: number;\n\t\t\ttotalRequests: number;\n\t\t};\n\t\trecommendations: string[];\n\t};\n\tdatabase: {\n\t\tconnectionCount: number;\n\t\tqueryPerformance: {\n\t\t\taverageTime: number;\n\t\t\tslowestQueries: Array<{\n\t\t\t\tquery: string;\n\t\t\t\tavgTime: number;\n\t\t\t\tcount: number;\n\t\t\t}>;\n\t\t};\n\t\ttableStats: Array<{\n\t\t\ttableName: string;\n\t\t\trowCount: number;\n\t\t\tsize: string;\n\t\t\tindexes: number;\n\t\t}>;\n\t\treplicationLag?: number;\n\t};\n\tapi: {\n\t\trequestsPerMinute: number;\n\t\ttopEndpoints: Array<{\n\t\t\tendpoint: string;\n\t\t\trequests: number;\n\t\t\tresponseTime: number;\n\t\t}>;\n\t\terrorsByType: Record<string, number>;\n\t\tstatusCodes: Record<string, number>;\n\t};\n\tsystem: {\n\t\tcpuUsage?: number;\n\t\tmemoryUsage?: number;\n\t\tdiskUsage?: number;\n\t\tnetworkIO?: {\n\t\t\tincoming: number;\n\t\t\toutgoing: number;\n\t\t};\n\t};\n}\n\nexport interface PerformanceHeatmap {\n\ttimeSlots: string[];\n\tmetrics: Array<{\n\t\tname: string;\n\t\ttype: 'response_time' | 'request_count' | 'error_rate' | 'cache_hit_rate';\n\t\tdata: number[][];\n\t\tthreshold: {\n\t\t\texcellent: number;\n\t\t\tgood: number;\n\t\t\tfair: number;\n\t\t\tpoor: number;\n\t\t};\n\t}>;\n}\n\nexport interface SystemHealth {\n\tstatus: 'healthy' | 'degraded' | 'critical';\n\tscore: number; // 0-100\n\tchecks: Array<{\n\t\tname: string;\n\t\tstatus: 'pass' | 'warn' | 'fail';\n\t\tvalue: number | string;\n\t\tthreshold: number | string;\n\t\tmessage: string;\n\t}>;\n\trecommendations: string[];\n\tlastChecked: Date;\n}\n\nexport class SystemAnalyticsService {\n\tprivate readonly CACHE_KEY_PREFIX = 'system_analytics';\n\tprivate readonly DEFAULT_TTL = 300; // 5 minutes\n\n\t/**\n\t * Get comprehensive system metrics\n\t */\n\tasync getSystemMetrics(timeRange: '1h' | '24h' | '7d' | '30d' = '24h'): Promise<SystemMetrics> {\n\t\tconst cacheKey = `${this.CACHE_KEY_PREFIX}:metrics:${timeRange}`;\n\n\t\treturn adminCacheService.getOrSet(\n\t\t\tcacheKey,\n\t\t\tasync () => {\n\t\t\t\tconst [cacheMetrics, databaseMetrics, apiMetrics] = await Promise.all([\n\t\t\t\t\tthis.getCacheMetrics(),\n\t\t\t\t\tthis.getDatabaseMetrics(),\n\t\t\t\t\tthis.getAPIMetrics(timeRange)\n\t\t\t\t]);\n\n\t\t\t\treturn {\n\t\t\t\t\tperformance: {\n\t\t\t\t\t\taverageResponseTime: apiMetrics.averageResponseTime,\n\t\t\t\t\t\tslowestEndpoints: apiMetrics.slowestEndpoints,\n\t\t\t\t\t\terrorRate: apiMetrics.errorRate,\n\t\t\t\t\t\tuptime: 99.9 // TODO: Implement actual uptime tracking\n\t\t\t\t\t},\n\t\t\t\t\tcache: cacheMetrics,\n\t\t\t\t\tdatabase: databaseMetrics,\n\t\t\t\t\tapi: {\n\t\t\t\t\t\trequestsPerMinute: apiMetrics.requestsPerMinute,\n\t\t\t\t\t\ttopEndpoints: apiMetrics.topEndpoints,\n\t\t\t\t\t\terrorsByType: apiMetrics.errorsByType,\n\t\t\t\t\t\tstatusCodes: apiMetrics.statusCodes\n\t\t\t\t\t},\n\t\t\t\t\tsystem: {\n\t\t\t\t\t\tcpuUsage: undefined, // TODO: Implement system monitoring\n\t\t\t\t\t\tmemoryUsage: undefined,\n\t\t\t\t\t\tdiskUsage: undefined,\n\t\t\t\t\t\tnetworkIO: undefined\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\tthis.DEFAULT_TTL\n\t\t);\n\t}\n\n\t/**\n\t * Get performance heatmap data\n\t */\n\tasync getPerformanceHeatmap(\n\t\ttimeRange: '24h' | '7d' | '30d' = '24h',\n\t\tgranularity: 'hour' | 'day' = 'hour'\n\t): Promise<PerformanceHeatmap> {\n\t\tconst cacheKey = `${this.CACHE_KEY_PREFIX}:heatmap:${timeRange}:${granularity}`;\n\n\t\treturn adminCacheService.getOrSet(\n\t\t\tcacheKey,\n\t\t\tasync () => {\n\t\t\t\tconst timeSlots = this.generateTimeSlots(timeRange, granularity);\n\t\t\t\tconst endTime = new Date();\n\t\t\t\tconst startTime = this.getStartTime(timeRange);\n\n\t\t\t\t// Generate mock heatmap data - In production, this would query actual metrics\n\t\t\t\tconst responseTimeData = this.generateHeatmapData(timeSlots, 50, 200);\n\t\t\t\tconst requestCountData = this.generateHeatmapData(timeSlots, 100, 1000);\n\t\t\t\tconst errorRateData = this.generateHeatmapData(timeSlots, 0, 5);\n\t\t\t\tconst cacheHitRateData = this.generateHeatmapData(timeSlots, 80, 98);\n\n\t\t\t\treturn {\n\t\t\t\t\ttimeSlots,\n\t\t\t\t\tmetrics: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Response Time (ms)',\n\t\t\t\t\t\t\ttype: 'response_time',\n\t\t\t\t\t\t\tdata: responseTimeData,\n\t\t\t\t\t\t\tthreshold: { excellent: 100, good: 200, fair: 500, poor: 1000 }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Request Count',\n\t\t\t\t\t\t\ttype: 'request_count',\n\t\t\t\t\t\t\tdata: requestCountData,\n\t\t\t\t\t\t\tthreshold: { excellent: 1000, good: 500, fair: 200, poor: 50 }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Error Rate (%)',\n\t\t\t\t\t\t\ttype: 'error_rate',\n\t\t\t\t\t\t\tdata: errorRateData,\n\t\t\t\t\t\t\tthreshold: { excellent: 0.1, good: 0.5, fair: 1, poor: 5 }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Cache Hit Rate (%)',\n\t\t\t\t\t\t\ttype: 'cache_hit_rate',\n\t\t\t\t\t\t\tdata: cacheHitRateData,\n\t\t\t\t\t\t\tthreshold: { excellent: 95, good: 90, fair: 80, poor: 70 }\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t};\n\t\t\t},\n\t\t\tthis.DEFAULT_TTL\n\t\t);\n\t}\n\n\t/**\n\t * Get system health assessment\n\t */\n\tasync getSystemHealth(): Promise<SystemHealth> {\n\t\tconst cacheKey = `${this.CACHE_KEY_PREFIX}:health`;\n\n\t\treturn adminCacheService.getOrSet(\n\t\t\tcacheKey,\n\t\t\tasync () => {\n\t\t\t\tconst [cacheMetrics, databaseMetrics] = await Promise.all([\n\t\t\t\t\tthis.getCacheMetrics(),\n\t\t\t\t\tthis.getDatabaseMetrics()\n\t\t\t\t]);\n\n\t\t\t\tconst checks = [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Cache Hit Rate',\n\t\t\t\t\t\tstatus: this.getHealthStatus(cacheMetrics.hitRate, 90, 80) as 'pass' | 'warn' | 'fail',\n\t\t\t\t\t\tvalue: `${cacheMetrics.hitRate.toFixed(1)}%`,\n\t\t\t\t\t\tthreshold: '90%',\n\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\tcacheMetrics.hitRate >= 90\n\t\t\t\t\t\t\t\t? 'Excellent cache performance'\n\t\t\t\t\t\t\t\t: cacheMetrics.hitRate >= 80\n\t\t\t\t\t\t\t\t\t? 'Good cache performance'\n\t\t\t\t\t\t\t\t\t: 'Cache performance needs attention'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Database Connections',\n\t\t\t\t\t\tstatus: this.getHealthStatus(databaseMetrics.connectionCount, 50, 80, true) as\n\t\t\t\t\t\t\t| 'pass'\n\t\t\t\t\t\t\t| 'warn'\n\t\t\t\t\t\t\t| 'fail',\n\t\t\t\t\t\tvalue: databaseMetrics.connectionCount,\n\t\t\t\t\t\tthreshold: '< 50',\n\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\tdatabaseMetrics.connectionCount < 50\n\t\t\t\t\t\t\t\t? 'Normal connection usage'\n\t\t\t\t\t\t\t\t: databaseMetrics.connectionCount < 80\n\t\t\t\t\t\t\t\t\t? 'Elevated connection usage'\n\t\t\t\t\t\t\t\t\t: 'High connection usage'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Memory Usage',\n\t\t\t\t\t\tstatus: this.getHealthStatus(cacheMetrics.memoryUsage, 80, 90, true) as\n\t\t\t\t\t\t\t| 'pass'\n\t\t\t\t\t\t\t| 'warn'\n\t\t\t\t\t\t\t| 'fail',\n\t\t\t\t\t\tvalue: `${cacheMetrics.memoryUsage.toFixed(1)} MB`,\n\t\t\t\t\t\tthreshold: '< 80 MB',\n\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\tcacheMetrics.memoryUsage < 80\n\t\t\t\t\t\t\t\t? 'Normal memory usage'\n\t\t\t\t\t\t\t\t: cacheMetrics.memoryUsage < 90\n\t\t\t\t\t\t\t\t\t? 'Elevated memory usage'\n\t\t\t\t\t\t\t\t\t: 'High memory usage'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Query Performance',\n\t\t\t\t\t\tstatus: this.getHealthStatus(\n\t\t\t\t\t\t\tdatabaseMetrics.queryPerformance.averageTime,\n\t\t\t\t\t\t\t50,\n\t\t\t\t\t\t\t100,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t) as 'pass' | 'warn' | 'fail',\n\t\t\t\t\t\tvalue: `${databaseMetrics.queryPerformance.averageTime.toFixed(1)}ms`,\n\t\t\t\t\t\tthreshold: '< 50ms',\n\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\tdatabaseMetrics.queryPerformance.averageTime < 50\n\t\t\t\t\t\t\t\t? 'Excellent query performance'\n\t\t\t\t\t\t\t\t: databaseMetrics.queryPerformance.averageTime < 100\n\t\t\t\t\t\t\t\t\t? 'Good query performance'\n\t\t\t\t\t\t\t\t\t: 'Query performance needs optimization'\n\t\t\t\t\t}\n\t\t\t\t];\n\n\t\t\t\tconst passCount = checks.filter((c) => c.status === 'pass').length;\n\t\t\t\tconst warnCount = checks.filter((c) => c.status === 'warn').length;\n\t\t\t\tconst failCount = checks.filter((c) => c.status === 'fail').length;\n\n\t\t\t\tconst score = Math.round((passCount * 100 + warnCount * 60) / checks.length);\n\t\t\t\tconst status: 'healthy' | 'degraded' | 'critical' =\n\t\t\t\t\tfailCount > 0 ? 'critical' : warnCount > 1 ? 'degraded' : 'healthy';\n\n\t\t\t\tconst recommendations = [\n\t\t\t\t\t...cacheMetrics.recommendations,\n\t\t\t\t\t...(score < 80 ? ['Consider optimizing database queries'] : []),\n\t\t\t\t\t...(databaseMetrics.connectionCount > 50\n\t\t\t\t\t\t? ['Monitor database connection pool usage']\n\t\t\t\t\t\t: []),\n\t\t\t\t\t...(cacheMetrics.memoryUsage > 80 ? ['Consider increasing cache memory limits'] : [])\n\t\t\t\t];\n\n\t\t\t\treturn {\n\t\t\t\t\tstatus,\n\t\t\t\t\tscore,\n\t\t\t\t\tchecks,\n\t\t\t\t\trecommendations,\n\t\t\t\t\tlastChecked: new Date()\n\t\t\t\t};\n\t\t\t},\n\t\t\t60 // 1 minute TTL for health checks\n\t\t);\n\t}\n\n\t/**\n\t * Get real-time activity analytics\n\t */\n\tasync getRealtimeAnalytics(): Promise<{\n\t\tactiveUsers: number;\n\t\trequestsPerSecond: number;\n\t\tnewThreadsLastHour: number;\n\t\tnewPostsLastHour: number;\n\t\tdgtTransactionsLastHour: number;\n\t\tcacheOperationsPerSecond: number;\n\t}> {\n\t\tconst oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n\t\tconst fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);\n\n\t\tconst [newThreadsCount, newPostsCount, dgtTransactionsCount, activeUsersCount] =\n\t\t\tawait Promise.all([\n\t\t\t\t// New threads in last hour\n\t\t\t\tdb.select({ count: count() }).from(threads).where(gte(threads.createdAt, oneHourAgo)),\n\n\t\t\t\t// New posts in last hour\n\t\t\t\tdb.select({ count: count() }).from(posts).where(gte(posts.createdAt, oneHourAgo)),\n\n\t\t\t\t// DGT transactions in last hour\n\t\t\t\tdb\n\t\t\t\t\t.select({ count: count() })\n\t\t\t\t\t.from(walletTransactions)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\tgte(walletTransactions.createdAt, oneHourAgo),\n\t\t\t\t\t\t\teq(walletTransactions.currency, 'DGT')\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\n\t\t\t\t// Active users (users with activity in last 5 minutes)\n\t\t\t\tdb\n\t\t\t\t\t.select({ count: count() })\n\t\t\t\t\t.from(analyticsEvents)\n\t\t\t\t\t.where(gte(analyticsEvents.createdAt, fiveMinutesAgo))\n\t\t\t]);\n\n\t\tconst cacheMetrics = await this.getCacheMetrics();\n\n\t\treturn {\n\t\t\tactiveUsers: activeUsersCount[0]?.count || 0,\n\t\t\trequestsPerSecond: Math.round((cacheMetrics.performance.totalRequests || 0) / 60), // Rough estimate\n\t\t\tnewThreadsLastHour: newThreadsCount[0]?.count || 0,\n\t\t\tnewPostsLastHour: newPostsCount[0]?.count || 0,\n\t\t\tdgtTransactionsLastHour: dgtTransactionsCount[0]?.count || 0,\n\t\t\tcacheOperationsPerSecond: Math.round(\n\t\t\t\t(cacheMetrics.performance.hits + cacheMetrics.performance.misses) / 60\n\t\t\t)\n\t\t};\n\t}\n\n\t// ============ PRIVATE HELPER METHODS ============\n\n\tprivate async getCacheMetrics() {\n\t\tconst metrics = adminCacheService.getCacheMetrics();\n\t\tconst analytics = adminCacheService.getCacheAnalytics();\n\n\t\treturn {\n\t\t\thitRate: analytics.hitRate,\n\t\t\thitRateGrade: analytics.hitRateGrade,\n\t\t\ttotalKeys: metrics.keys,\n\t\t\tmemoryUsage: parseFloat((metrics.ksize / 1024 / 1024).toFixed(2)), // Convert to MB\n\t\t\tkeysByCategory: analytics.keysByCategory,\n\t\t\tperformance: {\n\t\t\t\thits: analytics.hits,\n\t\t\t\tmisses: analytics.misses,\n\t\t\t\ttotalRequests: analytics.hits + analytics.misses\n\t\t\t},\n\t\t\trecommendations: analytics.recommendations\n\t\t};\n\t}\n\n\tprivate async getDatabaseMetrics() {\n\t\t// Get basic database statistics\n\t\tconst tableStats = await this.getDatabaseTableStats();\n\n\t\treturn {\n\t\t\tconnectionCount: Math.floor(Math.random() * 20) + 10, // Mock data - implement actual connection monitoring\n\t\t\tqueryPerformance: {\n\t\t\t\taverageTime: Math.random() * 50 + 25, // Mock data\n\t\t\t\tslowestQueries: [\n\t\t\t\t\t{ query: 'SELECT * FROM threads WHERE...', avgTime: 85.2, count: 1250 },\n\t\t\t\t\t{ query: 'SELECT * FROM posts WHERE...', avgTime: 65.8, count: 2100 },\n\t\t\t\t\t{ query: 'SELECT * FROM users WHERE...', avgTime: 45.3, count: 890 }\n\t\t\t\t]\n\t\t\t},\n\t\t\ttableStats,\n\t\t\treplicationLag: undefined // Not implemented\n\t\t};\n\t}\n\n\tprivate async getDatabaseTableStats() {\n\t\t// Get row counts for major tables\n\t\tconst [threadsCount, postsCount, usersCount, transactionsCount, xpLogsCount] =\n\t\t\tawait Promise.all([\n\t\t\t\tdb.select({ count: count() }).from(threads),\n\t\t\t\tdb.select({ count: count() }).from(posts),\n\t\t\t\tdb.select({ count: count() }).from(users),\n\t\t\t\tdb.select({ count: count() }).from(walletTransactions),\n\t\t\t\tdb.select({ count: count() }).from(xpLogs)\n\t\t\t]);\n\n\t\treturn [\n\t\t\t{\n\t\t\t\ttableName: 'threads',\n\t\t\t\trowCount: threadsCount[0]?.count || 0,\n\t\t\t\tsize: '~15 MB',\n\t\t\t\tindexes: 8\n\t\t\t},\n\t\t\t{\n\t\t\t\ttableName: 'posts',\n\t\t\t\trowCount: postsCount[0]?.count || 0,\n\t\t\t\tsize: '~45 MB',\n\t\t\t\tindexes: 12\n\t\t\t},\n\t\t\t{\n\t\t\t\ttableName: 'users',\n\t\t\t\trowCount: usersCount[0]?.count || 0,\n\t\t\t\tsize: '~8 MB',\n\t\t\t\tindexes: 6\n\t\t\t},\n\t\t\t{\n\t\t\t\ttableName: 'wallet_transactions',\n\t\t\t\trowCount: transactionsCount[0]?.count || 0,\n\t\t\t\tsize: '~25 MB',\n\t\t\t\tindexes: 10\n\t\t\t},\n\t\t\t{\n\t\t\t\ttableName: 'xp_logs',\n\t\t\t\trowCount: xpLogsCount[0]?.count || 0,\n\t\t\t\tsize: '~12 MB',\n\t\t\t\tindexes: 7\n\t\t\t}\n\t\t];\n\t}\n\n\tprivate async getAPIMetrics(timeRange: string) {\n\t\t// Mock API metrics - In production, implement actual request tracking\n\t\treturn {\n\t\t\taverageResponseTime: Math.random() * 100 + 50,\n\t\t\tslowestEndpoints: [\n\t\t\t\t{ endpoint: '/api/forum/threads', averageTime: 145.2, requestCount: 1250 },\n\t\t\t\t{ endpoint: '/api/wallet/transactions', averageTime: 125.8, requestCount: 890 },\n\t\t\t\t{ endpoint: '/api/admin/analytics', averageTime: 95.3, requestCount: 450 }\n\t\t\t],\n\t\t\terrorRate: Math.random() * 2 + 0.5,\n\t\t\trequestsPerMinute: Math.floor(Math.random() * 200) + 100,\n\t\t\ttopEndpoints: [\n\t\t\t\t{ endpoint: '/api/forum/threads', requests: 1250, responseTime: 85.2 },\n\t\t\t\t{ endpoint: '/api/auth/verify', requests: 980, responseTime: 45.1 },\n\t\t\t\t{ endpoint: '/api/wallet/balance', requests: 850, responseTime: 65.8 }\n\t\t\t],\n\t\t\terrorsByType: {\n\t\t\t\tValidationError: 15,\n\t\t\t\tDatabaseError: 8,\n\t\t\t\tAuthenticationError: 12,\n\t\t\t\tRateLimitError: 5\n\t\t\t},\n\t\t\tstatusCodes: {\n\t\t\t\t'200': 8750,\n\t\t\t\t'400': 45,\n\t\t\t\t'401': 12,\n\t\t\t\t'403': 8,\n\t\t\t\t'404': 25,\n\t\t\t\t'500': 8\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate generateTimeSlots(timeRange: string, granularity: string): string[] {\n\t\tconst slots = [];\n\t\tconst now = new Date();\n\t\tconst hoursToGenerate = timeRange === '24h' ? 24 : timeRange === '7d' ? 168 : 720; // 30d = 720 hours\n\t\tconst stepSize = granularity === 'hour' ? 1 : 24;\n\n\t\tfor (let i = hoursToGenerate; i >= 0; i -= stepSize) {\n\t\t\tconst time = new Date(now.getTime() - i * 60 * 60 * 1000);\n\t\t\tslots.push(time.toISOString());\n\t\t}\n\n\t\treturn slots;\n\t}\n\n\tprivate generateHeatmapData(timeSlots: string[], min: number, max: number): number[][] {\n\t\t// Generate mock heatmap data - in production, query actual metrics\n\t\tconst hours = timeSlots.length;\n\t\tconst data: number[][] = [];\n\n\t\tfor (let hour = 0; hour < hours; hour++) {\n\t\t\tconst hourData: number[] = [];\n\t\t\tfor (let minute = 0; minute < 60; minute += 5) {\n\t\t\t\t// 5-minute intervals\n\t\t\t\tconst value = Math.random() * (max - min) + min;\n\t\t\t\thourData.push(Math.round(value * 100) / 100);\n\t\t\t}\n\t\t\tdata.push(hourData);\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tprivate getStartTime(timeRange: string): Date {\n\t\tconst now = new Date();\n\t\tswitch (timeRange) {\n\t\t\tcase '1h':\n\t\t\t\treturn new Date(now.getTime() - 60 * 60 * 1000);\n\t\t\tcase '24h':\n\t\t\t\treturn new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\t\t\tcase '7d':\n\t\t\t\treturn new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n\t\t\tcase '30d':\n\t\t\t\treturn new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\t\t\tdefault:\n\t\t\t\treturn new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\t\t}\n\t}\n\n\tprivate getHealthStatus(\n\t\tvalue: number,\n\t\tgoodThreshold: number,\n\t\tpoorThreshold: number,\n\t\tinverse = false\n\t): 'pass' | 'warn' | 'fail' {\n\t\tif (inverse) {\n\t\t\t// For metrics where lower is better (connections, memory usage, etc.)\n\t\t\tif (value <= goodThreshold) return 'pass';\n\t\t\tif (value <= poorThreshold) return 'warn';\n\t\t\treturn 'fail';\n\t\t} else {\n\t\t\t// For metrics where higher is better (hit rate, etc.)\n\t\t\tif (value >= goodThreshold) return 'pass';\n\t\t\tif (value >= poorThreshold) return 'warn';\n\t\t\treturn 'fail';\n\t\t}\n\t}\n}\n\n// Export service instance\nexport const systemAnalyticsService = new SystemAnalyticsService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/analytics/system-analytics.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/animation-packs/animation-packs.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/animation-packs/animation-packs.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/animation-packs/animation-packs.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/announcements/announcements.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'announcementsRouter' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":32,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Router } from 'express';\nimport { isAdmin } from '../../../../domains/auth/middleware/auth.middleware';\nimport {\n\tgetAnnouncementsController,\n\tgetAllAnnouncementsController,\n\tgetAnnouncementByIdController,\n\tcreateAnnouncementController,\n\tupdateAnnouncementController,\n\tdeactivateAnnouncementController\n} from './controllers/announcements.controller';\n\n// Export a function to register announcement routes\nexport function registerAnnouncementRoutes(app: Router) {\n\t// Public route for getting active announcements\n\tapp.get('/api/announcements', getAnnouncementsController);\n\n\t// Admin routes for managing announcements\n\tconst adminRouter = Router();\n\tapp.use('/api/admin/announcements', isAdmin, adminRouter);\n\n\t// Admin CRUD operations for announcements\n\tadminRouter.get('/', getAllAnnouncementsController);\n\tadminRouter.post('/', createAnnouncementController);\n\tadminRouter.get('/:id', getAnnouncementByIdController);\n\tadminRouter.put('/:id', updateAnnouncementController);\n\tadminRouter.delete('/:id', deactivateAnnouncementController);\n\n\treturn app;\n}\n\n// Create a standalone router for direct use (useful for testing or when mounting at a different path)\nconst announcementsRouter = Router();\nconst publicRouter = Router();\n\n// Public routes\npublicRouter.get('/', getAnnouncementsController);\n\n// Admin routes\nconst adminRouter = Router();\nadminRouter.get('/', getAllAnnouncementsController);\nadminRouter.post('/', createAnnouncementController);\nadminRouter.get('/:id', getAnnouncementByIdController);\nadminRouter.put('/:id', updateAnnouncementController);\nadminRouter.delete('/:id', deactivateAnnouncementController);\n\n// Export both routers\nexport { publicRouter, adminRouter };\n\n// Export a default router that includes both public and admin routes (protected by isAdmin middleware)\nexport default function createAnnouncementRouter() {\n\tconst router = Router();\n\n\t// Mount the public routes\n\trouter.use('/api/announcements', publicRouter);\n\n\t// Mount the admin routes with protection\n\trouter.use('/api/admin/announcements', isAdmin, adminRouter);\n\n\treturn router;\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/announcements/controllers/announcements.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'z' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { Request, Response } from 'express';\nimport type { EntityId } from '@shared/types/ids';\nimport { z } from 'zod';\nimport { insertAnnouncementSchema } from '@schema';\nimport {\n\tgetActiveAnnouncements,\n\tgetAllAnnouncements,\n\tgetAnnouncementById,\n\tcreateAnnouncement,\n\tupdateAnnouncement,\n\tdeactivateAnnouncement\n} from '../services/announcements.service';\nimport { logger } from '../../../../core/logger';\n\n// Removed redundant getUserId helper - use userService.getUserFromRequest(req)?.id directly\n\n/**\n * Controller for fetching active announcements (public endpoint)\n */\nexport async function getAnnouncementsController(req: Request, res: Response) {\n\ttry {\n\t\tconst isTicker = req.query.ticker === 'true';\n\t\tconst userRole = userService.getUserFromRequest(req)?.role || 'guest';\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\tconst announcements = await getActiveAnnouncements({\n\t\t\ttickerOnly: isTicker,\n\t\t\tuserRole,\n\t\t\tuserId,\n\t\t\tlimit: 10\n\t\t});\n\n\t\treturn res.status(200).json(announcements);\n\t} catch (error) {\n\t\tlogger.error('Error fetching announcements:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n}\n\n/**\n * Controller for fetching all announcements (admin endpoint)\n */\nexport async function getAllAnnouncementsController(req: Request, res: Response) {\n\ttry {\n\t\tconst announcements = await getAllAnnouncements();\n\t\treturn res.status(200).json(announcements);\n\t} catch (error) {\n\t\tlogger.error('Error fetching all announcements:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n}\n\n/**\n * Controller for getting a single announcement (admin endpoint)\n */\nexport async function getAnnouncementByIdController(req: Request, res: Response) {\n\ttry {\n\t\tconst id = req.params.id as EntityId;\n\t\tif (isNaN(id)) {\n\t\t\treturn res.status(400).json({ message: 'Invalid announcement ID' });\n\t\t}\n\n\t\tconst announcement = await getAnnouncementById(id);\n\n\t\tif (!announcement) {\n\t\t\treturn res.status(404).json({ message: 'Announcement not found' });\n\t\t}\n\n\t\treturn res.status(200).json(announcement);\n\t} catch (error) {\n\t\tlogger.error('Error fetching announcement:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n}\n\n/**\n * Controller for creating a new announcement (admin endpoint)\n */\nexport async function createAnnouncementController(req: Request, res: Response) {\n\ttry {\n\t\tif (!userService.getUserFromRequest(req)) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized' });\n\t\t}\n\n\t\t// Validate input against schema\n\t\tconst validatedData = insertAnnouncementSchema.parse({\n\t\t\t...req.body,\n\t\t\tcreatedBy: userService.getUserFromRequest(req)\n\t\t});\n\n\t\tconst newAnnouncement = await createAnnouncement(validatedData);\n\t\treturn res.status(201).json(newAnnouncement);\n\t} catch (error: any) {\n\t\tif (error.name === 'ZodError') {\n\t\t\treturn res.status(400).json({ message: 'Invalid announcement data', errors: error.errors });\n\t\t}\n\t\tlogger.error('Error creating announcement:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n}\n\n/**\n * Controller for updating an announcement (admin endpoint)\n */\nexport async function updateAnnouncementController(req: Request, res: Response) {\n\ttry {\n\t\tconst id = req.params.id as EntityId;\n\t\tif (isNaN(id)) {\n\t\t\treturn res.status(400).json({ message: 'Invalid announcement ID' });\n\t\t}\n\n\t\t// First check if the announcement exists\n\t\tconst existingAnnouncement = await getAnnouncementById(id);\n\n\t\tif (!existingAnnouncement) {\n\t\t\treturn res.status(404).json({ message: 'Announcement not found' });\n\t\t}\n\n\t\t// Update the announcement\n\t\tconst updatedAnnouncement = await updateAnnouncement(id, req.body);\n\n\t\treturn res.status(200).json(updatedAnnouncement);\n\t} catch (error) {\n\t\tlogger.error('Error updating announcement:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n}\n\n/**\n * Controller for deactivating an announcement (admin endpoint)\n */\nexport async function deactivateAnnouncementController(req: Request, res: Response) {\n\ttry {\n\t\tconst id = req.params.id as EntityId;\n\t\tif (isNaN(id)) {\n\t\t\treturn res.status(400).json({ message: 'Invalid announcement ID' });\n\t\t}\n\n\t\tconst deactivatedAnnouncement = await deactivateAnnouncement(id);\n\n\t\tif (!deactivatedAnnouncement) {\n\t\t\treturn res.status(404).json({ message: 'Announcement not found' });\n\t\t}\n\n\t\treturn res.status(200).json({ message: 'Announcement deactivated successfully' });\n\t} catch (error) {\n\t\tlogger.error('Error deactivating announcement:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/announcements/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/announcements/services/announcements.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'insertAnnouncementSchema' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { announcements, users } from '@schema';\nimport { count, desc, eq, isNull, lte, gte, sql, and } from 'drizzle-orm';\nimport { insertAnnouncementSchema } from '@schema';\nimport { UserId } from \"@shared/types\";\n\n/**\n * Get all active announcements with filtering\n */\nexport async function getActiveAnnouncements(options: {\n\ttickerOnly?: boolean;\n\tuserRole?: string;\n\tuserId?: UserId;\n\tlimit?: number;\n}) {\n\tconst { tickerOnly, userRole = 'guest', userId, limit = 10 } = options;\n\tconst now = new Date();\n\n\t// Get all active announcements\n\tconst activeAnnouncements = await db\n\t\t.select({\n\t\t\tid: announcements.id,\n\t\t\tcontent: announcements.content,\n\t\t\ticon: announcements.icon,\n\t\t\ttype: announcements.type,\n\t\t\tcreatedAt: announcements.createdAt,\n\t\t\texpiresAt: announcements.expiresAt,\n\t\t\tpriority: announcements.priority,\n\t\t\tvisibleTo: announcements.visibleTo,\n\t\t\ttickerMode: announcements.tickerMode,\n\t\t\tlink: announcements.link,\n\t\t\tbgColor: announcements.bgColor,\n\t\t\ttextColor: announcements.textColor\n\t\t})\n\t\t.from(announcements)\n\t\t.where(\n\t\t\tand(\n\t\t\t\teq(announcements.isActive, true),\n\t\t\t\t// Either there's no expiration date or it's in the future\n\t\t\t\tsql`(${announcements.expiresAt} IS NULL OR ${announcements.expiresAt} > ${now})`\n\t\t\t)\n\t\t)\n\t\t.orderBy(desc(announcements.priority), desc(announcements.createdAt))\n\t\t.limit(50);\n\n\t// Filter announcements based on user role and visibility settings\n\tlet filteredAnnouncements = activeAnnouncements.filter((announcement) => {\n\t\tconst visibleTo = (announcement.visibleTo as string[]) || ['all'];\n\n\t\t// Show to everyone if 'all' is in the visibility list\n\t\tif (visibleTo.includes('all')) return true;\n\n\t\t// Check for user role (guest, user, mod, admin)\n\t\tif (visibleTo.includes(userRole)) return true;\n\n\t\t// If user is logged in, check for specific user group IDs\n\t\tif (userId && visibleTo.some((group) => !['guest', 'user', 'mod', 'admin'].includes(group))) {\n\t\t\t// For now, include any group-specific announcements if user is logged in\n\t\t\t// In a full implementation, you'd check against the user's actual groups\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t});\n\n\t// Further filter for ticker mode if specified\n\tif (tickerOnly === true) {\n\t\tfilteredAnnouncements = filteredAnnouncements.filter((a) => a.tickerMode === true);\n\t}\n\n\t// Limit the results\n\treturn filteredAnnouncements.slice(0, limit);\n}\n\n/**\n * Get all announcements with creator info (for admin use)\n */\nexport async function getAllAnnouncements() {\n\treturn await db\n\t\t.select({\n\t\t\tid: announcements.id,\n\t\t\tcontent: announcements.content,\n\t\t\ticon: announcements.icon,\n\t\t\ttype: announcements.type,\n\t\t\tisActive: announcements.isActive,\n\t\t\tcreatedBy: announcements.createdBy,\n\t\t\tcreatedAt: announcements.createdAt,\n\t\t\tupdatedAt: announcements.updatedAt,\n\t\t\texpiresAt: announcements.expiresAt,\n\t\t\tpriority: announcements.priority,\n\t\t\tvisibleTo: announcements.visibleTo,\n\t\t\ttickerMode: announcements.tickerMode,\n\t\t\tlink: announcements.link,\n\t\t\tbgColor: announcements.bgColor,\n\t\t\ttextColor: announcements.textColor,\n\t\t\tcreatorUsername: users.username\n\t\t})\n\t\t.from(announcements)\n\t\t.leftJoin(users, eq(announcements.createdBy, users.id))\n\t\t.orderBy(desc(announcements.createdAt));\n}\n\n/**\n * Get a single announcement by ID\n */\nexport async function getAnnouncementById(id: Id<'id'>) {\n\tconst result = await db.select().from(announcements).where(eq(announcements.id, id)).limit(1);\n\n\treturn result.length > 0 ? result[0] : null;\n}\n\n/**\n * Create a new announcement\n */\nexport async function createAnnouncement(announcementData: any) {\n\tconst result = await db.insert(announcements).values(announcementData).returning();\n\n\treturn result[0];\n}\n\n/**\n * Update an existing announcement\n */\nexport async function updateAnnouncement(id: Id<'id'>, updateData: any) {\n\t// Add updated timestamp\n\tconst dataWithTimestamp = {\n\t\t...updateData,\n\t\tupdatedAt: new Date()\n\t};\n\n\tconst result = await db\n\t\t.update(announcements)\n\t\t.set(dataWithTimestamp)\n\t\t.where(eq(announcements.id, id))\n\t\t.returning();\n\n\treturn result.length > 0 ? result[0] : null;\n}\n\n/**\n * Soft delete an announcement by setting isActive to false\n */\nexport async function deactivateAnnouncement(id: Id<'id'>) {\n\tconst result = await db\n\t\t.update(announcements)\n\t\t.set({\n\t\t\tisActive: false,\n\t\t\tupdatedAt: new Date()\n\t\t})\n\t\t.where(eq(announcements.id, id))\n\t\t.returning();\n\n\treturn result.length > 0 ? result[0] : null;\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/avatar-frames/avatar-frames.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/avatar-frames/avatar-frames.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/avatar-frames/avatar-frames.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/backup-restore/backup-restore.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":40,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":40,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":58,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":76,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":76,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":100,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":100,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":124,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":124,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":183,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":183,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":183,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":183,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":202,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":202,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":220,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":220,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":238,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":238,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":256,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":256,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":280,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":280,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":304,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":304,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":324,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":324,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":342,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":342,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":360,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":360,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":384,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":384,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":409,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":409,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":433,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":433,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":459,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":459,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":459,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":459,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":476,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":476,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":476,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":476,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":493,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":493,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":493,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":493,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":512,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":512,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":512,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":512,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":27,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { z } from 'zod';\nimport { backupService, createBackupSchema, listBackupsSchema } from './backup.service';\nimport {\n\trestoreService,\n\tcreateRestoreSchema,\n\tlistRestoreOperationsSchema\n} from './restore.service';\nimport {\n\tbackupScheduleService,\n\tcreateScheduleSchema,\n\tupdateScheduleSchema,\n\tlistSchedulesSchema\n} from './schedule.service';\nimport { formatAdminResponse, AdminOperationBoundary } from '../../shared';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { logger } from '../../../../core/logger';\n\n// Additional validation schemas\nconst backupIdSchema = z.object({\n\tid: z.coerce.number().positive()\n});\n\nconst restoreValidationSchema = z.object({\n\tbackupId: z.coerce.number().positive()\n});\n\nconst downloadBackupSchema = z.object({\n\tid: z.coerce.number().positive()\n});\n\nexport class BackupRestoreController {\n\t// ============ BACKUP OPERATIONS ============\n\n\t/**\n\t * GET /api/admin/backups\n\t * List all backups with filtering and pagination\n\t */\n\tasync getBackups(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'LIST_BACKUPS',\n\t\t\tentityType: 'backup'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst filters = listBackupsSchema.parse(req.query);\n\t\t\tconst result = await backupService.getBackups(filters);\n\n\t\t\treturn formatAdminResponse(result, 'LIST_BACKUPS', 'backup');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/backups/:id\n\t * Get backup details by ID\n\t */\n\tasync getBackup(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_BACKUP',\n\t\t\tentityType: 'backup'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = backupIdSchema.parse(req.params);\n\t\t\tconst backup = await backupService.getBackup(id);\n\n\t\t\treturn formatAdminResponse({ backup }, 'GET_BACKUP', 'backup');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/backups\n\t * Create a new manual backup\n\t */\n\tasync createBackup(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'CREATE_BACKUP',\n\t\t\tentityType: 'backup'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst backupData = createBackupSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await backupService.createBackup(backupData, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'CREATE_BACKUP', 'backup');\n\t\t});\n\t}\n\n\t/**\n\t * DELETE /api/admin/backups/:id\n\t * Delete a backup and its file\n\t */\n\tasync deleteBackup(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'DELETE_BACKUP',\n\t\t\tentityType: 'backup'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = backupIdSchema.parse(req.params);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await backupService.deleteBackup(id, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'DELETE_BACKUP', 'backup');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/backups/:id/progress\n\t * Get backup progress for active operations\n\t */\n\tasync getBackupProgress(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_BACKUP_PROGRESS',\n\t\t\tentityType: 'backup'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = backupIdSchema.parse(req.params);\n\t\t\tconst progress = backupService.getBackupProgress(id);\n\n\t\t\treturn formatAdminResponse({ progress }, 'GET_BACKUP_PROGRESS', 'backup');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/backups/:id/download\n\t * Download backup file\n\t */\n\tasync downloadBackup(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst { id } = downloadBackupSchema.parse(req.params);\n\t\t\tconst backup = await backupService.getBackup(id);\n\n\t\t\tif (!backup.fileExists) {\n\t\t\t\treturn res.status(404).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Backup file not found'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Set appropriate headers for file download\n\t\t\tres.setHeader('Content-Disposition', `attachment; filename=\"${backup.filename}\"`);\n\t\t\tres.setHeader('Content-Type', 'application/octet-stream');\n\n\t\t\t// Stream the file\n\t\t\tconst fs = await import('fs');\n\t\t\tconst stream = fs.createReadStream(backup.filePath);\n\n\t\t\tstream.on('error', (error) => {\n\t\t\t\tlogger.error('Error streaming backup file:', error);\n\t\t\t\tres.status(500).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Failed to download backup file'\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tstream.pipe(res);\n\t\t} catch (error) {\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message || 'Failed to download backup'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * GET /api/admin/backups/storage/stats\n\t * Get backup storage statistics\n\t */\n\tasync getStorageStats(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_STORAGE_STATS',\n\t\t\tentityType: 'backup'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst stats = await backupService.getStorageStats();\n\n\t\t\treturn formatAdminResponse(stats, 'GET_STORAGE_STATS', 'backup');\n\t\t});\n\t}\n\n\t// ============ RESTORE OPERATIONS ============\n\n\t/**\n\t * GET /api/admin/restores\n\t * List all restore operations\n\t */\n\tasync getRestoreOperations(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'LIST_RESTORE_OPERATIONS',\n\t\t\tentityType: 'restore'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst filters = listRestoreOperationsSchema.parse(req.query);\n\t\t\tconst result = await restoreService.getRestoreOperations(filters);\n\n\t\t\treturn formatAdminResponse(result, 'LIST_RESTORE_OPERATIONS', 'restore');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/restores/:operationId\n\t * Get restore operation details\n\t */\n\tasync getRestoreOperation(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_RESTORE_OPERATION',\n\t\t\tentityType: 'restore'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { operationId } = req.params;\n\t\t\tconst operation = await restoreService.getRestoreOperation(operationId);\n\n\t\t\treturn formatAdminResponse({ operation }, 'GET_RESTORE_OPERATION', 'restore');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/restores/validate\n\t * Validate a backup for restore and get impact assessment\n\t */\n\tasync validateRestore(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'VALIDATE_RESTORE',\n\t\t\tentityType: 'restore'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { backupId } = restoreValidationSchema.parse(req.body);\n\t\t\tconst validation = await restoreService.validateRestoreOperation(backupId);\n\n\t\t\treturn formatAdminResponse(validation, 'VALIDATE_RESTORE', 'restore');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/restores\n\t * Create a new restore operation\n\t */\n\tasync createRestoreOperation(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'CREATE_RESTORE_OPERATION',\n\t\t\tentityType: 'restore'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst restoreData = createRestoreSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await restoreService.createRestoreOperation(restoreData, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'CREATE_RESTORE_OPERATION', 'restore');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/restores/:operationId/cancel\n\t * Cancel a pending restore operation\n\t */\n\tasync cancelRestoreOperation(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'CANCEL_RESTORE_OPERATION',\n\t\t\tentityType: 'restore'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { operationId } = req.params;\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await restoreService.cancelRestoreOperation(operationId, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'CANCEL_RESTORE_OPERATION', 'restore');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/restores/:operationId/progress\n\t * Get restore progress for active operations\n\t */\n\tasync getRestoreProgress(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_RESTORE_PROGRESS',\n\t\t\tentityType: 'restore'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { operationId } = req.params;\n\t\t\tconst progress = restoreService.getRestoreProgress(operationId);\n\n\t\t\treturn formatAdminResponse({ progress }, 'GET_RESTORE_PROGRESS', 'restore');\n\t\t});\n\t}\n\n\t// ============ SCHEDULE OPERATIONS ============\n\n\t/**\n\t * GET /api/admin/backup-schedules\n\t * List all backup schedules\n\t */\n\tasync getSchedules(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'LIST_BACKUP_SCHEDULES',\n\t\t\tentityType: 'backupSchedule'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst filters = listSchedulesSchema.parse(req.query);\n\t\t\tconst result = await backupScheduleService.getSchedules(filters);\n\n\t\t\treturn formatAdminResponse(result, 'LIST_BACKUP_SCHEDULES', 'backupSchedule');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/backup-schedules/:id\n\t * Get schedule details by ID\n\t */\n\tasync getSchedule(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_BACKUP_SCHEDULE',\n\t\t\tentityType: 'backupSchedule'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = backupIdSchema.parse(req.params);\n\t\t\tconst schedule = await backupScheduleService.getSchedule(id);\n\n\t\t\treturn formatAdminResponse({ schedule }, 'GET_BACKUP_SCHEDULE', 'backupSchedule');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/backup-schedules\n\t * Create a new backup schedule\n\t */\n\tasync createSchedule(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'CREATE_BACKUP_SCHEDULE',\n\t\t\tentityType: 'backupSchedule'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst scheduleData = createScheduleSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await backupScheduleService.createSchedule(scheduleData, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'CREATE_BACKUP_SCHEDULE', 'backupSchedule');\n\t\t});\n\t}\n\n\t/**\n\t * PUT /api/admin/backup-schedules/:id\n\t * Update a backup schedule\n\t */\n\tasync updateSchedule(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'UPDATE_BACKUP_SCHEDULE',\n\t\t\tentityType: 'backupSchedule'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = backupIdSchema.parse(req.params);\n\t\t\tconst scheduleData = updateScheduleSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await backupScheduleService.updateSchedule(id, scheduleData, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'UPDATE_BACKUP_SCHEDULE', 'backupSchedule');\n\t\t});\n\t}\n\n\t/**\n\t * DELETE /api/admin/backup-schedules/:id\n\t * Delete a backup schedule\n\t */\n\tasync deleteSchedule(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'DELETE_BACKUP_SCHEDULE',\n\t\t\tentityType: 'backupSchedule'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = backupIdSchema.parse(req.params);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await backupScheduleService.deleteSchedule(id, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'DELETE_BACKUP_SCHEDULE', 'backupSchedule');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/backup-schedules/:id/trigger\n\t * Trigger a schedule to run immediately\n\t */\n\tasync triggerSchedule(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'TRIGGER_BACKUP_SCHEDULE',\n\t\t\tentityType: 'backupSchedule'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = backupIdSchema.parse(req.params);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await backupScheduleService.triggerSchedule(id, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'TRIGGER_BACKUP_SCHEDULE', 'backupSchedule');\n\t\t});\n\t}\n\n\t// ============ SCHEDULER MANAGEMENT ============\n\n\t/**\n\t * GET /api/admin/backup-schedules/scheduler/status\n\t * Get backup scheduler status\n\t */\n\tasync getSchedulerStatus(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_SCHEDULER_STATUS',\n\t\t\tentityType: 'backupSchedule'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst status = backupScheduleService.getSchedulerStatus();\n\n\t\t\treturn formatAdminResponse(status, 'GET_SCHEDULER_STATUS', 'backupSchedule');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/backup-schedules/scheduler/start\n\t * Start the backup scheduler\n\t */\n\tasync startScheduler(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'START_BACKUP_SCHEDULER',\n\t\t\tentityType: 'backupSchedule'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst result = await backupScheduleService.startScheduler();\n\n\t\t\treturn formatAdminResponse(result, 'START_BACKUP_SCHEDULER', 'backupSchedule');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/backup-schedules/scheduler/stop\n\t * Stop the backup scheduler\n\t */\n\tasync stopScheduler(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'STOP_BACKUP_SCHEDULER',\n\t\t\tentityType: 'backupSchedule'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst result = backupScheduleService.stopScheduler();\n\n\t\t\treturn formatAdminResponse(result, 'STOP_BACKUP_SCHEDULER', 'backupSchedule');\n\t\t});\n\t}\n\n\t// ============ UTILITY ENDPOINTS ============\n\n\t/**\n\t * GET /api/admin/backup-restore/health\n\t * Health check for backup and restore system\n\t */\n\tasync getSystemHealth(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_BACKUP_SYSTEM_HEALTH',\n\t\t\tentityType: 'backup'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\t// Check system health\n\t\t\tconst storageStats = await backupService.getStorageStats();\n\t\t\tconst schedulerStatus = backupScheduleService.getSchedulerStatus();\n\n\t\t\t// Basic health indicators\n\t\t\tconst health = {\n\t\t\t\tstatus: 'healthy',\n\t\t\t\tstorage: {\n\t\t\t\t\tusagePercent: storageStats.usagePercent,\n\t\t\t\t\ttotalSizeMB: storageStats.totalSizeMB,\n\t\t\t\t\tmaxStorageMB: storageStats.maxStorageMB,\n\t\t\t\t\tstatus:\n\t\t\t\t\t\tstorageStats.usagePercent > 90\n\t\t\t\t\t\t\t? 'critical'\n\t\t\t\t\t\t\t: storageStats.usagePercent > 80\n\t\t\t\t\t\t\t\t? 'warning'\n\t\t\t\t\t\t\t\t: 'healthy'\n\t\t\t\t},\n\t\t\t\tscheduler: {\n\t\t\t\t\trunning: schedulerStatus.running,\n\t\t\t\t\tuptime: schedulerStatus.uptime,\n\t\t\t\t\tstatus: schedulerStatus.running ? 'healthy' : 'stopped'\n\t\t\t\t},\n\t\t\t\tbackups: {\n\t\t\t\t\ttotal: storageStats.totalCount,\n\t\t\t\t\tcompleted: storageStats.completedCount,\n\t\t\t\t\tfailed: storageStats.failedCount,\n\t\t\t\t\tactive: storageStats.activeCount\n\t\t\t\t},\n\t\t\t\trecommendations: storageStats.recommendations || []\n\t\t\t};\n\n\t\t\t// Overall health assessment\n\t\t\tif (health.storage.status === 'critical' || !health.scheduler.running) {\n\t\t\t\thealth.status = 'unhealthy';\n\t\t\t} else if (\n\t\t\t\thealth.storage.status === 'warning' ||\n\t\t\t\tstorageStats.failedCount > storageStats.completedCount * 0.1\n\t\t\t) {\n\t\t\t\thealth.status = 'degraded';\n\t\t\t}\n\n\t\t\treturn formatAdminResponse(health, 'GET_BACKUP_SYSTEM_HEALTH', 'backup');\n\t\t});\n\t}\n}\n\n// Export controller instance\nexport const backupRestoreController = new BackupRestoreController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/backup-restore/backup-restore.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/backup-restore/backup.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminId' is defined but never used.","line":256,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":256,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used.","line":622,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":622,"endColumn":66}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Backup Service\n *\n * Handles database backup operations using PostgreSQL pg_dump\n */\n\nimport { db } from '@db';\nimport { adminBackups, backupSettings } from '@schema';\nimport { eq, desc, and, gte, lte, ilike, or } from 'drizzle-orm';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { adminCacheService } from '../../shared';\nimport { spawn } from 'child_process';\nimport { createHash } from 'crypto';\nimport { createReadStream, createWriteStream, statSync, unlinkSync, existsSync } from 'fs';\nimport { createGzip } from 'zlib';\nimport { pipeline } from 'stream/promises';\nimport { join, dirname } from 'path';\nimport { mkdirSync } from 'fs';\nimport { z } from 'zod';\nimport type { BackupId } from '@shared/types/ids';\nimport { logger } from '../../../../core/logger';\n\n// Validation schemas\nexport const createBackupSchema = z.object({\n\tdisplayName: z.string().min(1).max(255),\n\tdescription: z.string().optional(),\n\tbackupType: z.enum(['full', 'schema', 'selective']).default('full'),\n\tbackupFormat: z.enum(['custom', 'plain', 'tar']).default('custom'),\n\tincludedTables: z.array(z.string()).default([]),\n\tincludedSchemas: z.array(z.string()).default(['public']),\n\texcludedTables: z.array(z.string()).default([]),\n\ttags: z.array(z.string()).default([]),\n\tcompressionType: z.enum(['gzip', 'none']).default('gzip'),\n\tisProtected: z.boolean().default(false)\n});\n\nexport const listBackupsSchema = z.object({\n\tpage: z.coerce.number().min(1).default(1),\n\tlimit: z.coerce.number().min(1).max(100).default(20),\n\tstatus: z.enum(['pending', 'running', 'completed', 'failed']).optional(),\n\tbackupType: z.enum(['full', 'schema', 'selective']).optional(),\n\tsource: z.enum(['manual', 'scheduled']).optional(),\n\tsearch: z.string().optional(),\n\tstartDate: z.string().datetime().optional(),\n\tendDate: z.string().datetime().optional(),\n\ttags: z.array(z.string()).default([])\n});\n\nexport type CreateBackupInput = z.infer<typeof createBackupSchema>;\nexport type ListBackupsInput = z.infer<typeof listBackupsSchema>;\n\ninterface BackupProgress {\n\tbackupId: BackupId;\n\tstatus: 'pending' | 'running' | 'completed' | 'failed';\n\tprogressPercent: number;\n\tcurrentStep: string;\n\testimatedTimeRemaining?: number;\n\terrorMessage?: string;\n}\n\nexport class BackupService {\n\tprivate activeBackups = new Map<number, BackupProgress>();\n\tprivate readonly BACKUP_BASE_PATH = process.env.BACKUP_STORAGE_PATH || '/var/backups/degentalk';\n\n\t/**\n\t * Create a new database backup\n\t */\n\tasync createBackup(\n\t\tdata: CreateBackupInput,\n\t\tadminId: string\n\t): Promise<{ backupId: BackupId; message: string }> {\n\t\ttry {\n\t\t\t// Validate input\n\t\t\tconst validatedData = createBackupSchema.parse(data);\n\n\t\t\t// Get backup settings\n\t\t\tconst settings = await this.getBackupSettings();\n\n\t\t\t// Check storage space\n\t\t\tawait this.checkStorageSpace(settings);\n\n\t\t\t// Generate unique filename\n\t\t\tconst timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n\t\t\tconst filename = `degentalk_${validatedData.backupType}_${timestamp}`;\n\t\t\tconst fileExtension = this.getFileExtension(\n\t\t\t\tvalidatedData.backupFormat,\n\t\t\t\tvalidatedData.compressionType\n\t\t\t);\n\t\t\tconst fullFilename = `${filename}${fileExtension}`;\n\t\t\tconst filePath = join(this.BACKUP_BASE_PATH, 'manual', fullFilename);\n\n\t\t\t// Ensure directory exists\n\t\t\tmkdirSync(dirname(filePath), { recursive: true });\n\n\t\t\t// Create backup record\n\t\t\tconst [backup] = await db\n\t\t\t\t.insert(adminBackups)\n\t\t\t\t.values({\n\t\t\t\t\tfilename: fullFilename,\n\t\t\t\t\tdisplayName: validatedData.displayName,\n\t\t\t\t\tdescription: validatedData.description,\n\t\t\t\t\tbackupType: validatedData.backupType,\n\t\t\t\t\tsource: 'manual',\n\t\t\t\t\tfilePath,\n\t\t\t\t\tdatabaseName: this.getDatabaseName(),\n\t\t\t\t\tbackupFormat: validatedData.backupFormat,\n\t\t\t\t\tcompressionType: validatedData.compressionType,\n\t\t\t\t\tincludedTables: validatedData.includedTables,\n\t\t\t\t\tincludedSchemas: validatedData.includedSchemas,\n\t\t\t\t\texcludedTables: validatedData.excludedTables,\n\t\t\t\t\ttags: validatedData.tags,\n\t\t\t\t\tisProtected: validatedData.isProtected,\n\t\t\t\t\tstatus: 'pending',\n\t\t\t\t\tcreatedBy: adminId\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Start backup process asynchronously\n\t\t\tthis.executeBackup(backup.id, filePath, validatedData).catch((error) => {\n\t\t\t\tlogger.error(`Backup ${backup.id} failed:`, error);\n\t\t\t\tthis.updateBackupStatus(backup.id, 'failed', error.message);\n\t\t\t});\n\n\t\t\t// Invalidate cache\n\t\t\tawait adminCacheService.invalidateEntity('backup');\n\n\t\t\treturn {\n\t\t\t\tbackupId: backup.id,\n\t\t\t\tmessage: `Backup \"${validatedData.displayName}\" started successfully`\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to create backup', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get list of backups with filtering and pagination\n\t */\n\tasync getBackups(filters: ListBackupsInput) {\n\t\ttry {\n\t\t\tconst validatedFilters = listBackupsSchema.parse(filters);\n\n\t\t\tlet query = db.select().from(adminBackups);\n\t\t\tconst conditions = [];\n\n\t\t\t// Apply filters\n\t\t\tif (validatedFilters.status) {\n\t\t\t\tconditions.push(eq(adminBackups.status, validatedFilters.status));\n\t\t\t}\n\n\t\t\tif (validatedFilters.backupType) {\n\t\t\t\tconditions.push(eq(adminBackups.backupType, validatedFilters.backupType));\n\t\t\t}\n\n\t\t\tif (validatedFilters.source) {\n\t\t\t\tconditions.push(eq(adminBackups.source, validatedFilters.source));\n\t\t\t}\n\n\t\t\tif (validatedFilters.search) {\n\t\t\t\tconditions.push(\n\t\t\t\t\tor(\n\t\t\t\t\t\tilike(adminBackups.displayName, `%${validatedFilters.search}%`),\n\t\t\t\t\t\tilike(adminBackups.description, `%${validatedFilters.search}%`),\n\t\t\t\t\t\tilike(adminBackups.filename, `%${validatedFilters.search}%`)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (validatedFilters.startDate) {\n\t\t\t\tconditions.push(gte(adminBackups.createdAt, validatedFilters.startDate));\n\t\t\t}\n\n\t\t\tif (validatedFilters.endDate) {\n\t\t\t\tconditions.push(lte(adminBackups.createdAt, validatedFilters.endDate));\n\t\t\t}\n\n\t\t\t// Apply conditions\n\t\t\tif (conditions.length > 0) {\n\t\t\t\tquery = query.where(and(...conditions));\n\t\t\t}\n\n\t\t\t// Apply ordering and pagination\n\t\t\tconst backups = await query\n\t\t\t\t.orderBy(desc(adminBackups.createdAt))\n\t\t\t\t.limit(validatedFilters.limit)\n\t\t\t\t.offset((validatedFilters.page - 1) * validatedFilters.limit);\n\n\t\t\t// Get total count for pagination\n\t\t\tconst [countResult] = await db\n\t\t\t\t.select({ count: adminBackups.id })\n\t\t\t\t.from(adminBackups)\n\t\t\t\t.where(conditions.length > 0 ? and(...conditions) : undefined);\n\n\t\t\treturn {\n\t\t\t\tbackups: backups.map((backup) => ({\n\t\t\t\t\t...backup,\n\t\t\t\t\tfileSizeMB: backup.fileSize\n\t\t\t\t\t\t? Math.round((backup.fileSize / (1024 * 1024)) * 100) / 100\n\t\t\t\t\t\t: null,\n\t\t\t\t\tprogress: this.activeBackups.get(backup.id)\n\t\t\t\t})),\n\t\t\t\tpagination: {\n\t\t\t\t\tpage: validatedFilters.page,\n\t\t\t\t\tlimit: validatedFilters.limit,\n\t\t\t\t\ttotal: countResult?.count || 0,\n\t\t\t\t\ttotalPages: Math.ceil((countResult?.count || 0) / validatedFilters.limit)\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to fetch backups', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get backup details by ID\n\t */\n\tasync getBackup(id: Id<'id'>) {\n\t\ttry {\n\t\t\tconst [backup] = await db.select().from(adminBackups).where(eq(adminBackups.id, id));\n\n\t\t\tif (!backup) {\n\t\t\t\tthrow new AdminError(`Backup not found: ${id}`, 404, AdminErrorCodes.NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Check if file exists\n\t\t\tconst fileExists = existsSync(backup.filePath);\n\n\t\t\treturn {\n\t\t\t\t...backup,\n\t\t\t\tfileSizeMB: backup.fileSize\n\t\t\t\t\t? Math.round((backup.fileSize / (1024 * 1024)) * 100) / 100\n\t\t\t\t\t: null,\n\t\t\t\tfileExists,\n\t\t\t\tprogress: this.activeBackups.get(backup.id)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to fetch backup', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Delete a backup and its file\n\t */\n\tasync deleteBackup(id: Id<'id'>, adminId: string) {\n\t\ttry {\n\t\t\tconst backup = await this.getBackup(id);\n\n\t\t\t// Check if backup is protected\n\t\t\tif (backup.isProtected) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Cannot delete protected backup',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Check if backup is currently running\n\t\t\tif (backup.status === 'running' || backup.status === 'pending') {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Cannot delete backup that is currently running',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Delete file if it exists\n\t\t\tif (backup.fileExists) {\n\t\t\t\ttry {\n\t\t\t\t\tunlinkSync(backup.filePath);\n\t\t\t\t} catch (fileError) {\n\t\t\t\t\tlogger.warn(`Could not delete backup file ${backup.filePath}:`, fileError);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Delete backup record\n\t\t\tawait db.delete(adminBackups).where(eq(adminBackups.id, id));\n\n\t\t\t// Invalidate cache\n\t\t\tawait adminCacheService.invalidateEntity('backup');\n\n\t\t\treturn { success: true, message: `Backup \"${backup.displayName}\" deleted successfully` };\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to delete backup', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get backup progress for active operations\n\t */\n\tgetBackupProgress(id: Id<'id'>): BackupProgress | null {\n\t\treturn this.activeBackups.get(id) || null;\n\t}\n\n\t/**\n\t * Get backup storage statistics\n\t */\n\tasync getStorageStats() {\n\t\ttry {\n\t\t\t// Get total backups and storage usage\n\t\t\tconst backups = await db.select().from(adminBackups);\n\n\t\t\tconst stats = backups.reduce(\n\t\t\t\t(acc, backup) => {\n\t\t\t\t\tacc.totalCount++;\n\t\t\t\t\tacc.totalSize += backup.fileSize || 0;\n\n\t\t\t\t\tif (backup.status === 'completed') acc.completedCount++;\n\t\t\t\t\tif (backup.status === 'failed') acc.failedCount++;\n\t\t\t\t\tif (backup.status === 'running' || backup.status === 'pending') acc.activeCount++;\n\n\t\t\t\t\tacc.byType[backup.backupType] = (acc.byType[backup.backupType] || 0) + 1;\n\t\t\t\t\tacc.bySource[backup.source] = (acc.bySource[backup.source] || 0) + 1;\n\n\t\t\t\t\treturn acc;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttotalCount: 0,\n\t\t\t\t\tcompletedCount: 0,\n\t\t\t\t\tfailedCount: 0,\n\t\t\t\t\tactiveCount: 0,\n\t\t\t\t\ttotalSize: 0,\n\t\t\t\t\ttotalSizeMB: 0,\n\t\t\t\t\tbyType: {} as Record<string, number>,\n\t\t\t\t\tbySource: {} as Record<string, number>\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tstats.totalSizeMB = Math.round((stats.totalSize / (1024 * 1024)) * 100) / 100;\n\n\t\t\t// Get settings for comparison\n\t\t\tconst settings = await this.getBackupSettings();\n\t\t\tconst maxSizeMB = Math.round(settings.maxStorageSize / (1024 * 1024));\n\t\t\tconst usagePercent = Math.round((stats.totalSizeMB / maxSizeMB) * 100);\n\n\t\t\treturn {\n\t\t\t\t...stats,\n\t\t\t\tmaxStorageMB: maxSizeMB,\n\t\t\t\tusagePercent,\n\t\t\t\trecommendations: this.generateStorageRecommendations(stats, settings)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow new AdminError('Failed to fetch storage statistics', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t// Private helper methods\n\n\tprivate async executeBackup(backupId: BackupId, filePath: string, options: CreateBackupInput) {\n\t\ttry {\n\t\t\t// Update status to running\n\t\t\tawait this.updateBackupStatus(backupId, 'running', null, {\n\t\t\t\tstartedAt: new Date().toISOString()\n\t\t\t});\n\n\t\t\tthis.activeBackups.set(backupId, {\n\t\t\t\tbackupId,\n\t\t\t\tstatus: 'running',\n\t\t\t\tprogressPercent: 0,\n\t\t\t\tcurrentStep: 'Initializing backup...'\n\t\t\t});\n\n\t\t\t// Build pg_dump command\n\t\t\tconst pgDumpArgs = this.buildPgDumpArgs(options);\n\n\t\t\t// Update progress\n\t\t\tthis.updateProgress(backupId, 10, 'Connecting to database...');\n\n\t\t\t// Execute pg_dump\n\t\t\tconst outputPath =\n\t\t\t\toptions.compressionType === 'gzip' ? filePath.replace('.gz', '') : filePath;\n\n\t\t\tawait this.executePgDump(pgDumpArgs, outputPath, backupId);\n\n\t\t\t// Compress if needed\n\t\t\tif (options.compressionType === 'gzip') {\n\t\t\t\tthis.updateProgress(backupId, 90, 'Compressing backup...');\n\t\t\t\tawait this.compressFile(outputPath, filePath);\n\t\t\t\tunlinkSync(outputPath); // Remove uncompressed file\n\t\t\t}\n\n\t\t\t// Calculate file size and checksum\n\t\t\tthis.updateProgress(backupId, 95, 'Calculating checksum...');\n\t\t\tconst fileSize = statSync(filePath).size;\n\t\t\tconst checksum = await this.calculateMD5(filePath);\n\n\t\t\t// Update backup record with completion\n\t\t\tawait this.updateBackupStatus(backupId, 'completed', null, {\n\t\t\t\tcompletedAt: new Date().toISOString(),\n\t\t\t\tfileSize,\n\t\t\t\tchecksumMd5: checksum\n\t\t\t});\n\n\t\t\tthis.updateProgress(backupId, 100, 'Backup completed successfully');\n\n\t\t\t// Remove from active backups after a delay\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.activeBackups.delete(backupId);\n\t\t\t}, 5000);\n\t\t} catch (error) {\n\t\t\tawait this.updateBackupStatus(backupId, 'failed', error.message);\n\t\t\tthis.activeBackups.set(backupId, {\n\t\t\t\tbackupId,\n\t\t\t\tstatus: 'failed',\n\t\t\t\tprogressPercent: 0,\n\t\t\t\tcurrentStep: 'Backup failed',\n\t\t\t\terrorMessage: error.message\n\t\t\t});\n\n\t\t\t// Clean up partial files\n\t\t\ttry {\n\t\t\t\tif (existsSync(filePath)) unlinkSync(filePath);\n\t\t\t} catch (cleanupError) {\n\t\t\t\tlogger.warn(`Could not clean up failed backup file:`, cleanupError);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate buildPgDumpArgs(options: CreateBackupInput): string[] {\n\t\tconst args = [\n\t\t\t'--verbose',\n\t\t\t'--no-password' // Use environment variables for auth\n\t\t];\n\n\t\t// Set format\n\t\tif (options.backupFormat === 'custom') {\n\t\t\targs.push('--format=custom');\n\t\t} else if (options.backupFormat === 'tar') {\n\t\t\targs.push('--format=tar');\n\t\t}\n\n\t\t// Backup type options\n\t\tif (options.backupType === 'schema') {\n\t\t\targs.push('--schema-only');\n\t\t}\n\n\t\t// Include/exclude tables\n\t\tif (options.includedTables.length > 0) {\n\t\t\toptions.includedTables.forEach((table) => {\n\t\t\t\targs.push(`--table=${table}`);\n\t\t\t});\n\t\t}\n\n\t\tif (options.excludedTables.length > 0) {\n\t\t\toptions.excludedTables.forEach((table) => {\n\t\t\t\targs.push(`--exclude-table=${table}`);\n\t\t\t});\n\t\t}\n\n\t\t// Include schemas\n\t\tif (options.includedSchemas.length > 0) {\n\t\t\toptions.includedSchemas.forEach((schema) => {\n\t\t\t\tif (schema !== 'public') {\n\t\t\t\t\t// public is default\n\t\t\t\t\targs.push(`--schema=${schema}`);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn args;\n\t}\n\n\tprivate async executePgDump(\n\t\targs: string[],\n\t\toutputPath: string,\n\t\tbackupId: BackupId\n\t): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst pgDump = spawn('pg_dump', [...args, '--file', outputPath], {\n\t\t\t\tenv: {\n\t\t\t\t\t...process.env,\n\t\t\t\t\tPGPASSWORD: this.extractPasswordFromUrl(process.env.DATABASE_URL!)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpgDump.on('error', (error) => {\n\t\t\t\treject(new Error(`pg_dump process error: ${error.message}`));\n\t\t\t});\n\n\t\t\tpgDump.on('close', (code) => {\n\t\t\t\tif (code === 0) {\n\t\t\t\t\tresolve();\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error(`pg_dump exited with code ${code}`));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Update progress periodically\n\t\t\tconst progressInterval = setInterval(() => {\n\t\t\t\tthis.updateProgress(\n\t\t\t\t\tbackupId,\n\t\t\t\t\tMath.min(80, (this.activeBackups.get(backupId)?.progressPercent || 0) + 5),\n\t\t\t\t\t'Creating backup...'\n\t\t\t\t);\n\t\t\t}, 2000);\n\n\t\t\tpgDump.on('close', () => {\n\t\t\t\tclearInterval(progressInterval);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async compressFile(inputPath: string, outputPath: string): Promise<void> {\n\t\tconst input = createReadStream(inputPath);\n\t\tconst output = createWriteStream(outputPath);\n\t\tconst gzip = createGzip({ level: 6 });\n\n\t\tawait pipeline(input, gzip, output);\n\t}\n\n\tprivate async calculateMD5(filePath: string): Promise<string> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst hash = createHash('md5');\n\t\t\tconst stream = createReadStream(filePath);\n\n\t\t\tstream.on('data', (data) => hash.update(data));\n\t\t\tstream.on('end', () => resolve(hash.digest('hex')));\n\t\t\tstream.on('error', reject);\n\t\t});\n\t}\n\n\tprivate updateProgress(backupId: BackupId, percent: number, step: string) {\n\t\tconst progress = this.activeBackups.get(backupId);\n\t\tif (progress) {\n\t\t\tprogress.progressPercent = percent;\n\t\t\tprogress.currentStep = step;\n\t\t\tthis.activeBackups.set(backupId, progress);\n\t\t}\n\t}\n\n\tprivate async updateBackupStatus(\n\t\tid: Id<'id'>,\n\t\tstatus: 'pending' | 'running' | 'completed' | 'failed',\n\t\terrorMessage?: string | null,\n\t\tadditionalData?: Record<string, any>\n\t) {\n\t\tconst updateData: any = { status };\n\n\t\tif (errorMessage !== undefined) {\n\t\t\tupdateData.errorMessage = errorMessage;\n\t\t}\n\n\t\tif (additionalData) {\n\t\t\tObject.assign(updateData, additionalData);\n\t\t}\n\n\t\tawait db.update(adminBackups).set(updateData).where(eq(adminBackups.id, id));\n\t}\n\n\tprivate async getBackupSettings() {\n\t\t// Get or create default backup settings\n\t\tconst [settings] = await db.select().from(backupSettings).limit(1);\n\n\t\tif (!settings) {\n\t\t\tconst [newSettings] = await db.insert(backupSettings).values({}).returning();\n\t\t\treturn newSettings;\n\t\t}\n\n\t\treturn settings;\n\t}\n\n\tprivate async checkStorageSpace(settings: any) {\n\t\t// Implementation would check available disk space\n\t\t// For now, just check against configured limits\n\t\tconst stats = await this.getStorageStats();\n\n\t\tif (stats.totalSize >= settings.maxStorageSize) {\n\t\t\tthrow new AdminError(\n\t\t\t\t'Storage limit exceeded. Please clean up old backups.',\n\t\t\t\t400,\n\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate getFileExtension(format: string, compression: string): string {\n\t\tlet ext = '';\n\n\t\tif (format === 'custom') ext = '.dump';\n\t\telse if (format === 'tar') ext = '.tar';\n\t\telse ext = '.sql';\n\n\t\tif (compression === 'gzip') ext += '.gz';\n\n\t\treturn ext;\n\t}\n\n\tprivate getDatabaseName(): string {\n\t\tconst dbUrl = process.env.DATABASE_URL || '';\n\t\tconst match = dbUrl.match(/\\/([^?]+)(\\?|$)/);\n\t\treturn match ? match[1] : 'degentalk';\n\t}\n\n\tprivate extractPasswordFromUrl(url: string): string {\n\t\ttry {\n\t\t\tconst parsed = new URL(url);\n\t\t\treturn parsed.password;\n\t\t} catch {\n\t\t\treturn '';\n\t\t}\n\t}\n\n\tprivate generateStorageRecommendations(stats: any, settings: any): string[] {\n\t\tconst recommendations = [];\n\n\t\tif (stats.usagePercent > 80) {\n\t\t\trecommendations.push('Storage usage is high. Consider cleaning up old backups.');\n\t\t}\n\n\t\tif (stats.failedCount > stats.completedCount * 0.1) {\n\t\t\trecommendations.push('High failure rate detected. Check backup configuration.');\n\t\t}\n\n\t\tif (stats.activeCount > 3) {\n\t\t\trecommendations.push('Multiple backups running simultaneously may impact performance.');\n\t\t}\n\n\t\treturn recommendations;\n\t}\n}\n\n// Export singleton instance\nexport const backupService = new BackupService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/backup-restore/restore.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminBackups' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminId' is defined but never used.","line":274,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":274,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'impact' is defined but never used.","line":564,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":564,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminId' is defined but never used.","line":595,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":595,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'restoreType' is defined but never used.","line":595,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":595,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":597,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":597,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Restore Service\n *\n * Handles database restore operations with safety validations\n */\n\nimport { db } from '@db';\nimport { adminBackups, restoreOperations, backupSettings } from '@schema';\nimport { eq, desc } from 'drizzle-orm';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { adminCacheService } from '../../shared';\nimport { backupService } from './backup.service';\nimport { spawn } from 'child_process';\nimport { existsSync, statSync } from 'fs';\nimport { randomUUID } from 'crypto';\nimport { z } from 'zod';\nimport type { BackupId } from '@shared/types/ids';\nimport { logger } from '../../../../core/logger';\n\n// Validation schemas\nexport const createRestoreSchema = z.object({\n\tsourceBackupId: z.string().uuid(),\n\tdisplayName: z.string().min(1).max(255),\n\tdescription: z.string().optional(),\n\trestoreType: z.enum(['full', 'schema_only', 'data_only', 'selective']).default('full'),\n\tcreatePreBackup: z.boolean().default(true),\n\tincludedTables: z.array(z.string()).default([]),\n\texcludedTables: z.array(z.string()).default([]),\n\tincludeIndexes: z.boolean().default(true),\n\tincludeConstraints: z.boolean().default(true),\n\tincludeTriggers: z.boolean().default(true),\n\tconfirmationToken: z.string().min(1) // Required for safety\n});\n\nexport const listRestoreOperationsSchema = z.object({\n\tpage: z.coerce.number().min(1).default(1),\n\tlimit: z.coerce.number().min(1).max(100).default(20),\n\tstatus: z\n\t\t.enum(['pending', 'pre_backup', 'restoring', 'completed', 'failed', 'cancelled'])\n\t\t.optional(),\n\trestoreType: z.enum(['full', 'schema_only', 'data_only', 'selective']).optional()\n});\n\nexport type CreateRestoreInput = z.infer<typeof createRestoreSchema>;\nexport type ListRestoreOperationsInput = z.infer<typeof listRestoreOperationsSchema>;\n\ninterface RestoreProgress {\n\toperationId: string;\n\tstatus: 'pending' | 'pre_backup' | 'restoring' | 'completed' | 'failed' | 'cancelled';\n\tprogressPercent: number;\n\tcurrentStep: string;\n\testimatedTimeRemaining?: number;\n\terrorMessage?: string;\n\tcanRollback: boolean;\n}\n\nexport class RestoreService {\n\tprivate activeRestores = new Map<string, RestoreProgress>();\n\n\t/**\n\t * Validate backup file and get restore impact assessment\n\t */\n\tasync validateRestoreOperation(backupId: BackupId) {\n\t\ttry {\n\t\t\t// Get backup details\n\t\t\tconst backup = await backupService.getBackup(backupId);\n\n\t\t\tif (!backup) {\n\t\t\t\tthrow new AdminError(`Backup not found: ${backupId}`, 404, AdminErrorCodes.NOT_FOUND);\n\t\t\t}\n\n\t\t\tif (backup.status !== 'completed') {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Can only restore from completed backups',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!backup.fileExists) {\n\t\t\t\tthrow new AdminError('Backup file not found on disk', 400, AdminErrorCodes.NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Validate backup file integrity\n\t\t\tconst validationResult = await this.validateBackupFile(backup);\n\n\t\t\t// Generate impact assessment\n\t\t\tconst impactAssessment = await this.generateImpactAssessment(backup);\n\n\t\t\t// Generate warnings\n\t\t\tconst warnings = this.generateRestoreWarnings(backup, impactAssessment);\n\n\t\t\treturn {\n\t\t\t\tbackup,\n\t\t\t\tvalidation: validationResult,\n\t\t\t\timpactAssessment,\n\t\t\t\twarnings,\n\t\t\t\tconfirmationRequired: true,\n\t\t\t\testimatedDuration: this.estimateRestoreDuration(backup)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to validate restore operation', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create a new restore operation\n\t */\n\tasync createRestoreOperation(\n\t\tdata: CreateRestoreInput,\n\t\tadminId: string\n\t): Promise<{ operationId: string; message: string }> {\n\t\ttry {\n\t\t\t// Validate input\n\t\t\tconst validatedData = createRestoreSchema.parse(data);\n\n\t\t\t// Validate backup and get assessment\n\t\t\tconst validation = await this.validateRestoreOperation(validatedData.sourceBackupId);\n\n\t\t\t// Check if user has permission for this type of restore\n\t\t\tawait this.checkRestorePermissions(adminId, validatedData.restoreType);\n\n\t\t\t// Generate operation ID\n\t\t\tconst operationId = randomUUID();\n\n\t\t\t// Get source backup details\n\t\t\tconst sourceBackup = validation.backup;\n\n\t\t\t// Create restore operation record\n\t\t\tconst [operation] = await db\n\t\t\t\t.insert(restoreOperations)\n\t\t\t\t.values({\n\t\t\t\t\toperationId,\n\t\t\t\t\tdisplayName: validatedData.displayName,\n\t\t\t\t\tdescription: validatedData.description,\n\t\t\t\t\tsourceBackupId: validatedData.sourceBackupId,\n\t\t\t\t\tsourceFilename: sourceBackup.filename,\n\t\t\t\t\trestoreType: validatedData.restoreType,\n\t\t\t\t\tcreatePreBackup: validatedData.createPreBackup,\n\t\t\t\t\tincludedTables: validatedData.includedTables,\n\t\t\t\t\texcludedTables: validatedData.excludedTables,\n\t\t\t\t\tincludeIndexes: validatedData.includeIndexes,\n\t\t\t\t\tincludeConstraints: validatedData.includeConstraints,\n\t\t\t\t\tincludeTriggers: validatedData.includeTriggers,\n\t\t\t\t\tstatus: 'pending',\n\t\t\t\t\tinitiatedBy: adminId,\n\t\t\t\t\tconfirmationToken: validatedData.confirmationToken,\n\t\t\t\t\tconfirmationExpiresAt: new Date(Date.now() + 30 * 60 * 1000).toISOString(), // 30 minutes\n\t\t\t\t\tvalidationWarnings: validation.warnings,\n\t\t\t\t\timpactAssessment: validation.impactAssessment\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Start restore process asynchronously\n\t\t\tthis.executeRestore(operation.id, operationId, validatedData, adminId).catch((error) => {\n\t\t\t\tlogger.error(`Restore operation ${operationId} failed:`, error);\n\t\t\t\tthis.updateRestoreStatus(operation.id, 'failed', error.message);\n\t\t\t});\n\n\t\t\t// Invalidate cache\n\t\t\tawait adminCacheService.invalidateEntity('restore');\n\n\t\t\treturn {\n\t\t\t\toperationId,\n\t\t\t\tmessage: `Restore operation \"${validatedData.displayName}\" started successfully`\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to create restore operation', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get list of restore operations\n\t */\n\tasync getRestoreOperations(filters: ListRestoreOperationsInput) {\n\t\ttry {\n\t\t\tconst validatedFilters = listRestoreOperationsSchema.parse(filters);\n\n\t\t\tconst query = db.select().from(restoreOperations);\n\t\t\tconst conditions = [];\n\n\t\t\t// Apply filters\n\t\t\tif (validatedFilters.status) {\n\t\t\t\tconditions.push(eq(restoreOperations.status, validatedFilters.status));\n\t\t\t}\n\n\t\t\tif (validatedFilters.restoreType) {\n\t\t\t\tconditions.push(eq(restoreOperations.restoreType, validatedFilters.restoreType));\n\t\t\t}\n\n\t\t\t// Apply conditions and pagination\n\t\t\tconst operations = await query\n\t\t\t\t.orderBy(desc(restoreOperations.createdAt))\n\t\t\t\t.limit(validatedFilters.limit)\n\t\t\t\t.offset((validatedFilters.page - 1) * validatedFilters.limit);\n\n\t\t\t// Add progress information\n\t\t\tconst operationsWithProgress = operations.map((operation) => ({\n\t\t\t\t...operation,\n\t\t\t\tprogress: this.activeRestores.get(operation.operationId),\n\t\t\t\tdurationMinutes: operation.duration ? Math.round(operation.duration / 60) : null\n\t\t\t}));\n\n\t\t\treturn {\n\t\t\t\toperations: operationsWithProgress,\n\t\t\t\tpagination: {\n\t\t\t\t\tpage: validatedFilters.page,\n\t\t\t\t\tlimit: validatedFilters.limit,\n\t\t\t\t\ttotal: operations.length, // Would need count query for accurate total\n\t\t\t\t\ttotalPages: Math.ceil(operations.length / validatedFilters.limit)\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow new AdminError('Failed to fetch restore operations', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get restore operation details\n\t */\n\tasync getRestoreOperation(operationId: string) {\n\t\ttry {\n\t\t\tconst [operation] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(restoreOperations)\n\t\t\t\t.where(eq(restoreOperations.operationId, operationId));\n\n\t\t\tif (!operation) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`Restore operation not found: ${operationId}`,\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Get source backup details\n\t\t\tconst sourceBackup = await backupService.getBackup(operation.sourceBackupId);\n\n\t\t\t// Get pre-restore backup if exists\n\t\t\tlet preRestoreBackup = null;\n\t\t\tif (operation.preRestoreBackupId) {\n\t\t\t\tpreRestoreBackup = await backupService.getBackup(operation.preRestoreBackupId);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...operation,\n\t\t\t\tsourceBackup,\n\t\t\t\tpreRestoreBackup,\n\t\t\t\tprogress: this.activeRestores.get(operationId),\n\t\t\t\tdurationMinutes: operation.duration ? Math.round(operation.duration / 60) : null\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to fetch restore operation', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Cancel a pending restore operation\n\t */\n\tasync cancelRestoreOperation(operationId: string, adminId: string) {\n\t\ttry {\n\t\t\tconst operation = await this.getRestoreOperation(operationId);\n\n\t\t\tif (operation.status !== 'pending') {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Can only cancel pending restore operations',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Update status to cancelled\n\t\t\tawait this.updateRestoreStatus(operation.id, 'cancelled');\n\n\t\t\t// Remove from active restores\n\t\t\tthis.activeRestores.delete(operationId);\n\n\t\t\treturn { success: true, message: 'Restore operation cancelled successfully' };\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to cancel restore operation', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get restore progress for active operations\n\t */\n\tgetRestoreProgress(operationId: string): RestoreProgress | null {\n\t\treturn this.activeRestores.get(operationId) || null;\n\t}\n\n\t// Private helper methods\n\n\tprivate async executeRestore(\n\t\tdbId: Id<'db'>,\n\t\toperationId: string,\n\t\toptions: CreateRestoreInput,\n\t\tadminId: string\n\t) {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Initialize progress tracking\n\t\t\tthis.activeRestores.set(operationId, {\n\t\t\t\toperationId,\n\t\t\t\tstatus: 'pending',\n\t\t\t\tprogressPercent: 0,\n\t\t\t\tcurrentStep: 'Initializing restore operation...',\n\t\t\t\tcanRollback: true\n\t\t\t});\n\n\t\t\t// Update status to starting\n\t\t\tawait this.updateRestoreStatus(dbId, 'pre_backup', null, {\n\t\t\t\tstartedAt: new Date().toISOString()\n\t\t\t});\n\n\t\t\t// Step 1: Create pre-restore backup if requested\n\t\t\tlet preRestoreBackupId = null;\n\t\t\tif (options.createPreBackup) {\n\t\t\t\tthis.updateProgress(operationId, 5, 'Creating safety backup...');\n\t\t\t\tpreRestoreBackupId = await this.createPreRestoreBackup(adminId);\n\n\t\t\t\tawait db\n\t\t\t\t\t.update(restoreOperations)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tpreRestoreBackupId,\n\t\t\t\t\t\tpreBackupCompletedAt: new Date().toISOString()\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(restoreOperations.id, dbId));\n\t\t\t}\n\n\t\t\t// Step 2: Prepare for restore\n\t\t\tthis.updateProgress(operationId, 15, 'Preparing database for restore...');\n\t\t\tawait this.updateRestoreStatus(dbId, 'restoring', null, {\n\t\t\t\trestoreStartedAt: new Date().toISOString()\n\t\t\t});\n\n\t\t\t// Step 3: Execute restore\n\t\t\tthis.updateProgress(operationId, 20, 'Restoring database...');\n\t\t\tawait this.executePgRestore(operationId, options);\n\n\t\t\t// Step 4: Verify restore\n\t\t\tthis.updateProgress(operationId, 90, 'Verifying restore...');\n\t\t\tconst verificationResult = await this.verifyRestore();\n\n\t\t\t// Step 5: Update completion\n\t\t\tconst endTime = Date.now();\n\t\t\tconst duration = Math.round((endTime - startTime) / 1000);\n\n\t\t\tawait this.updateRestoreStatus(dbId, 'completed', null, {\n\t\t\t\tcompletedAt: new Date().toISOString(),\n\t\t\t\tduration,\n\t\t\t\ttablesRestored: verificationResult.tablesCount,\n\t\t\t\trowsRestored: verificationResult.rowsCount\n\t\t\t});\n\n\t\t\tthis.updateProgress(operationId, 100, 'Restore completed successfully');\n\n\t\t\t// Remove from active restores after delay\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.activeRestores.delete(operationId);\n\t\t\t}, 10000);\n\t\t} catch (error) {\n\t\t\tconst endTime = Date.now();\n\t\t\tconst duration = Math.round((endTime - startTime) / 1000);\n\n\t\t\tawait this.updateRestoreStatus(dbId, 'failed', error.message, {\n\t\t\t\tduration\n\t\t\t});\n\n\t\t\tthis.activeRestores.set(operationId, {\n\t\t\t\toperationId,\n\t\t\t\tstatus: 'failed',\n\t\t\t\tprogressPercent: 0,\n\t\t\t\tcurrentStep: 'Restore failed',\n\t\t\t\terrorMessage: error.message,\n\t\t\t\tcanRollback: true\n\t\t\t});\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async createPreRestoreBackup(adminId: string): Promise<number> {\n\t\tconst result = await backupService.createBackup(\n\t\t\t{\n\t\t\t\tdisplayName: `Pre-restore backup ${new Date().toISOString()}`,\n\t\t\t\tdescription: 'Automatic backup created before restore operation',\n\t\t\t\tbackupType: 'full',\n\t\t\t\tbackupFormat: 'custom',\n\t\t\t\ttags: ['pre-restore', 'automatic'],\n\t\t\t\tisProtected: true\n\t\t\t},\n\t\t\tadminId\n\t\t);\n\n\t\treturn result.backupId;\n\t}\n\n\tprivate async executePgRestore(operationId: string, options: CreateRestoreInput): Promise<void> {\n\t\t// Get source backup\n\t\tconst sourceBackup = await backupService.getBackup(options.sourceBackupId);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst args = this.buildPgRestoreArgs(options, sourceBackup);\n\n\t\t\tconst pgRestore = spawn('pg_restore', args, {\n\t\t\t\tenv: {\n\t\t\t\t\t...process.env,\n\t\t\t\t\tPGPASSWORD: this.extractPasswordFromUrl(process.env.DATABASE_URL!)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpgRestore.on('error', (error) => {\n\t\t\t\treject(new Error(`pg_restore process error: ${error.message}`));\n\t\t\t});\n\n\t\t\tpgRestore.on('close', (code) => {\n\t\t\t\tif (code === 0) {\n\t\t\t\t\tresolve();\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error(`pg_restore exited with code ${code}`));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Update progress periodically\n\t\t\tconst progressInterval = setInterval(() => {\n\t\t\t\tconst current = this.activeRestores.get(operationId);\n\t\t\t\tif (current && current.progressPercent < 85) {\n\t\t\t\t\tthis.updateProgress(\n\t\t\t\t\t\toperationId,\n\t\t\t\t\t\tMath.min(85, current.progressPercent + 5),\n\t\t\t\t\t\t'Restoring data...'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}, 3000);\n\n\t\t\tpgRestore.on('close', () => {\n\t\t\t\tclearInterval(progressInterval);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate buildPgRestoreArgs(options: CreateRestoreInput, sourceBackup: any): string[] {\n\t\tconst args = [\n\t\t\t'--verbose',\n\t\t\t'--no-password',\n\t\t\t'--clean', // Clean (drop) database objects before recreating\n\t\t\t'--if-exists' // Use IF EXISTS when dropping objects\n\t\t];\n\n\t\t// Database connection\n\t\tconst dbUrl = new URL(process.env.DATABASE_URL!);\n\t\targs.push(`--host=${dbUrl.hostname}`);\n\t\targs.push(`--port=${dbUrl.port || '5432'}`);\n\t\targs.push(`--username=${dbUrl.username}`);\n\t\targs.push(`--dbname=${dbUrl.pathname.slice(1)}`);\n\n\t\t// Restore type options\n\t\tif (options.restoreType === 'schema_only') {\n\t\t\targs.push('--schema-only');\n\t\t} else if (options.restoreType === 'data_only') {\n\t\t\targs.push('--data-only');\n\t\t}\n\n\t\t// Include/exclude options\n\t\tif (!options.includeIndexes) {\n\t\t\targs.push('--no-indexes');\n\t\t}\n\n\t\tif (!options.includeConstraints) {\n\t\t\targs.push('--no-constraints');\n\t\t}\n\n\t\tif (!options.includeTriggers) {\n\t\t\targs.push('--no-triggers');\n\t\t}\n\n\t\t// Tables\n\t\tif (options.includedTables.length > 0) {\n\t\t\toptions.includedTables.forEach((table) => {\n\t\t\t\targs.push(`--table=${table}`);\n\t\t\t});\n\t\t}\n\n\t\t// Exclude tables (for selective restore)\n\t\tif (options.excludedTables.length > 0) {\n\t\t\toptions.excludedTables.forEach((table) => {\n\t\t\t\targs.push(`--exclude-table=${table}`);\n\t\t\t});\n\t\t}\n\n\t\t// Source file\n\t\targs.push(sourceBackup.filePath);\n\n\t\treturn args;\n\t}\n\n\tprivate async validateBackupFile(backup: any) {\n\t\ttry {\n\t\t\t// Check file exists and size\n\t\t\tif (!existsSync(backup.filePath)) {\n\t\t\t\tthrow new Error('Backup file not found');\n\t\t\t}\n\n\t\t\tconst stats = statSync(backup.filePath);\n\t\t\tconst currentSize = stats.size;\n\n\t\t\t// Check if file size matches recorded size (within 1% tolerance)\n\t\t\tif (backup.fileSize && Math.abs(currentSize - backup.fileSize) > backup.fileSize * 0.01) {\n\t\t\t\tthrow new Error('Backup file size mismatch - file may be corrupted');\n\t\t\t}\n\n\t\t\t// Verify MD5 checksum if available\n\t\t\tif (backup.checksumMd5) {\n\t\t\t\t// Implementation would calculate and compare MD5\n\t\t\t\t// Skipped for now due to complexity\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tvalid: true,\n\t\t\t\tfileSize: currentSize,\n\t\t\t\tlastModified: stats.mtime,\n\t\t\t\twarnings: []\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tvalid: false,\n\t\t\t\terror: error.message,\n\t\t\t\twarnings: ['Backup file validation failed']\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate async generateImpactAssessment(backup: any) {\n\t\t// This would analyze the backup and current database to assess impact\n\t\treturn {\n\t\t\testimatedDowntime: '5-15 minutes',\n\t\t\taffectedTables: backup.includedTables || ['All tables'],\n\t\t\tdataLossRisk: backup.backupType === 'full' ? 'Low' : 'Medium',\n\t\t\trollbackTime: '2-5 minutes',\n\t\t\tdatabaseSizeChange: 'Unknown',\n\t\t\tuserImpact: 'High - Database will be temporarily unavailable'\n\t\t};\n\t}\n\n\tprivate generateRestoreWarnings(backup: any, impact: any): string[] {\n\t\tconst warnings = [];\n\n\t\tif (backup.backupType !== 'full') {\n\t\t\twarnings.push('Partial backup - some data may not be restored');\n\t\t}\n\n\t\tconst backupAge = Date.now() - new Date(backup.createdAt).getTime();\n\t\tconst daysOld = Math.floor(backupAge / (1000 * 60 * 60 * 24));\n\n\t\tif (daysOld > 7) {\n\t\t\twarnings.push(`Backup is ${daysOld} days old - recent data will be lost`);\n\t\t}\n\n\t\tif (backup.fileSize > 1000 * 1024 * 1024) {\n\t\t\t// > 1GB\n\t\t\twarnings.push('Large backup file - restore may take significant time');\n\t\t}\n\n\t\twarnings.push('Database will be unavailable during restore');\n\t\twarnings.push('All current data will be replaced');\n\n\t\treturn warnings;\n\t}\n\n\tprivate estimateRestoreDuration(backup: any): number {\n\t\t// Rough estimation based on backup size\n\t\tconst sizeGB = (backup.fileSize || 0) / (1024 * 1024 * 1024);\n\t\treturn Math.max(5, Math.round(sizeGB * 3)); // ~3 minutes per GB, minimum 5 minutes\n\t}\n\n\tprivate async checkRestorePermissions(adminId: string, restoreType: string) {\n\t\t// Get backup settings to check permissions\n\t\tconst [settings] = await db.select().from(backupSettings).limit(1);\n\n\t\t// For now, require admin role for all restores\n\t\t// This would integrate with the user role system\n\t\treturn true;\n\t}\n\n\tprivate async verifyRestore() {\n\t\t// Basic verification - check if database is accessible and has expected structure\n\t\ttry {\n\t\t\tconst result = await db.execute(`\n\t\t\t\tSELECT \n\t\t\t\t\tCOUNT(*) as table_count,\n\t\t\t\t\t(SELECT COUNT(*) FROM users) as user_count\n\t\t\t\tFROM information_schema.tables \n\t\t\t\tWHERE table_schema = 'public'\n\t\t\t`);\n\n\t\t\treturn {\n\t\t\t\ttablesCount: result.rows[0]?.table_count || 0,\n\t\t\t\trowsCount: result.rows[0]?.user_count || 0,\n\t\t\t\tverified: true\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow new Error(`Restore verification failed: ${error.message}`);\n\t\t}\n\t}\n\n\tprivate updateProgress(operationId: string, percent: number, step: string) {\n\t\tconst progress = this.activeRestores.get(operationId);\n\t\tif (progress) {\n\t\t\tprogress.progressPercent = percent;\n\t\t\tprogress.currentStep = step;\n\t\t\tthis.activeRestores.set(operationId, progress);\n\t\t}\n\t}\n\n\tprivate async updateRestoreStatus(\n\t\tid: Id<'id'>,\n\t\tstatus: 'pending' | 'pre_backup' | 'restoring' | 'completed' | 'failed' | 'cancelled',\n\t\terrorMessage?: string | null,\n\t\tadditionalData?: Record<string, any>\n\t) {\n\t\tconst updateData: any = { status };\n\n\t\tif (errorMessage !== undefined) {\n\t\t\tupdateData.errorMessage = errorMessage;\n\t\t}\n\n\t\tif (additionalData) {\n\t\t\tObject.assign(updateData, additionalData);\n\t\t}\n\n\t\tawait db.update(restoreOperations).set(updateData).where(eq(restoreOperations.id, id));\n\t}\n\n\tprivate extractPasswordFromUrl(url: string): string {\n\t\ttry {\n\t\t\tconst parsed = new URL(url);\n\t\t\treturn parsed.password;\n\t\t} catch {\n\t\t\treturn '';\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const restoreService = new RestoreService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/backup-restore/schedule.service.ts","messages":[{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\*.","line":24,"column":17,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":24,"endColumn":18,"suggestions":[{"messageId":"removeEscape","fix":{"range":[689,690],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[689,689],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\/.","line":24,"column":19,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":24,"endColumn":20,"suggestions":[{"messageId":"removeEscape","fix":{"range":[691,692],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[691,691],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\,.","line":24,"column":23,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":24,"endColumn":24,"suggestions":[{"messageId":"removeEscape","fix":{"range":[695,696],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[695,695],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminId' is defined but never used.","line":159,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":159,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timezone' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":503,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":503,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'parts' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":508,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":508,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Backup Schedule Service\n *\n * Manages scheduled backup operations and cron-based automation\n */\n\nimport { db } from '@db';\nimport { backupSchedules, adminBackups } from '@schema';\nimport { eq, desc, and, lte } from 'drizzle-orm';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { adminCacheService } from '../../shared';\nimport { backupService } from './backup.service';\nimport { z } from 'zod';\nimport { logger } from '../../../../core/logger';\n\n// Validation schemas\nexport const createScheduleSchema = z.object({\n\tname: z.string().min(1).max(255),\n\tdescription: z.string().optional(),\n\tcronExpression: z\n\t\t.string()\n\t\t.min(1)\n\t\t.max(100)\n\t\t.regex(/^[\\d\\s\\*\\/\\-\\,]+$/, 'Invalid cron expression format'),\n\ttimezone: z.string().default('UTC'),\n\tbackupType: z.enum(['full', 'schema', 'selective']).default('full'),\n\tbackupFormat: z.enum(['custom', 'plain', 'tar']).default('custom'),\n\tcompressionType: z.enum(['gzip', 'none']).default('gzip'),\n\tincludedTables: z.array(z.string()).default([]),\n\tincludedSchemas: z.array(z.string()).default(['public']),\n\texcludedTables: z.array(z.string()).default([]),\n\tretentionDays: z.number().min(1).max(365).default(30),\n\tmaxBackups: z.number().min(1).max(100).default(10),\n\tisActive: z.boolean().default(true),\n\tnotifyOnSuccess: z.boolean().default(false),\n\tnotifyOnFailure: z.boolean().default(true),\n\tnotificationEmails: z.array(z.string().email()).default([])\n});\n\nexport const updateScheduleSchema = createScheduleSchema.partial();\n\nexport const listSchedulesSchema = z.object({\n\tpage: z.coerce.number().min(1).default(1),\n\tlimit: z.coerce.number().min(1).max(100).default(20),\n\tisActive: z.boolean().optional(),\n\tbackupType: z.enum(['full', 'schema', 'selective']).optional()\n});\n\nexport type CreateScheduleInput = z.infer<typeof createScheduleSchema>;\nexport type UpdateScheduleInput = z.infer<typeof updateScheduleSchema>;\nexport type ListSchedulesInput = z.infer<typeof listSchedulesSchema>;\n\nexport class BackupScheduleService {\n\tprivate schedulerRunning = false;\n\tprivate schedulerInterval: NodeJS.Timeout | null = null;\n\n\t/**\n\t * Create a new backup schedule\n\t */\n\tasync createSchedule(data: CreateScheduleInput, adminId: string) {\n\t\ttry {\n\t\t\tconst validatedData = createScheduleSchema.parse(data);\n\n\t\t\t// Validate cron expression\n\t\t\tconst nextRun = this.calculateNextRun(validatedData.cronExpression, validatedData.timezone);\n\n\t\t\t// Create schedule record\n\t\t\tconst [schedule] = await db\n\t\t\t\t.insert(backupSchedules)\n\t\t\t\t.values({\n\t\t\t\t\t...validatedData,\n\t\t\t\t\tnextRunAt: nextRun.toISOString(),\n\t\t\t\t\tcreatedBy: adminId,\n\t\t\t\t\tupdatedBy: adminId\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Start scheduler if this is the first active schedule\n\t\t\tawait this.ensureSchedulerRunning();\n\n\t\t\t// Invalidate cache\n\t\t\tawait adminCacheService.invalidateEntity('backupSchedule');\n\n\t\t\treturn {\n\t\t\t\tschedule,\n\t\t\t\tmessage: `Backup schedule \"${validatedData.name}\" created successfully`,\n\t\t\t\tnextRun: nextRun.toISOString()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to create backup schedule', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update an existing backup schedule\n\t */\n\tasync updateSchedule(id: Id<'id'>, data: UpdateScheduleInput, adminId: string) {\n\t\ttry {\n\t\t\tconst validatedData = updateScheduleSchema.parse(data);\n\n\t\t\t// Get existing schedule\n\t\t\tconst [existingSchedule] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(backupSchedules)\n\t\t\t\t.where(eq(backupSchedules.id, id));\n\n\t\t\tif (!existingSchedule) {\n\t\t\t\tthrow new AdminError(`Backup schedule not found: ${id}`, 404, AdminErrorCodes.NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Calculate new next run time if cron expression changed\n\t\t\tlet nextRunAt = existingSchedule.nextRunAt;\n\t\t\tif (validatedData.cronExpression || validatedData.timezone) {\n\t\t\t\tconst cronExpr = validatedData.cronExpression || existingSchedule.cronExpression;\n\t\t\t\tconst timezone = validatedData.timezone || existingSchedule.timezone;\n\t\t\t\tnextRunAt = this.calculateNextRun(cronExpr, timezone).toISOString();\n\t\t\t}\n\n\t\t\t// Update schedule\n\t\t\tconst [updatedSchedule] = await db\n\t\t\t\t.update(backupSchedules)\n\t\t\t\t.set({\n\t\t\t\t\t...validatedData,\n\t\t\t\t\tnextRunAt,\n\t\t\t\t\tupdatedBy: adminId,\n\t\t\t\t\tupdatedAt: new Date().toISOString()\n\t\t\t\t})\n\t\t\t\t.where(eq(backupSchedules.id, id))\n\t\t\t\t.returning();\n\n\t\t\t// Ensure scheduler is running if schedule is active\n\t\t\tif (updatedSchedule.isActive) {\n\t\t\t\tawait this.ensureSchedulerRunning();\n\t\t\t}\n\n\t\t\t// Invalidate cache\n\t\t\tawait adminCacheService.invalidateEntity('backupSchedule');\n\n\t\t\treturn {\n\t\t\t\tschedule: updatedSchedule,\n\t\t\t\tmessage: `Backup schedule \"${updatedSchedule.name}\" updated successfully`\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to update backup schedule', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Delete a backup schedule\n\t */\n\tasync deleteSchedule(id: Id<'id'>, adminId: string) {\n\t\ttry {\n\t\t\tconst [schedule] = await db.select().from(backupSchedules).where(eq(backupSchedules.id, id));\n\n\t\t\tif (!schedule) {\n\t\t\t\tthrow new AdminError(`Backup schedule not found: ${id}`, 404, AdminErrorCodes.NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Delete the schedule\n\t\t\tawait db.delete(backupSchedules).where(eq(backupSchedules.id, id));\n\n\t\t\t// Invalidate cache\n\t\t\tawait adminCacheService.invalidateEntity('backupSchedule');\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Backup schedule \"${schedule.name}\" deleted successfully`\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to delete backup schedule', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get list of backup schedules\n\t */\n\tasync getSchedules(filters: ListSchedulesInput) {\n\t\ttry {\n\t\t\tconst validatedFilters = listSchedulesSchema.parse(filters);\n\n\t\t\tlet query = db.select().from(backupSchedules);\n\t\t\tconst conditions = [];\n\n\t\t\t// Apply filters\n\t\t\tif (validatedFilters.isActive !== undefined) {\n\t\t\t\tconditions.push(eq(backupSchedules.isActive, validatedFilters.isActive));\n\t\t\t}\n\n\t\t\tif (validatedFilters.backupType) {\n\t\t\t\tconditions.push(eq(backupSchedules.backupType, validatedFilters.backupType));\n\t\t\t}\n\n\t\t\t// Apply conditions and pagination\n\t\t\tif (conditions.length > 0) {\n\t\t\t\tquery = query.where(and(...conditions));\n\t\t\t}\n\n\t\t\tconst schedules = await query\n\t\t\t\t.orderBy(desc(backupSchedules.createdAt))\n\t\t\t\t.limit(validatedFilters.limit)\n\t\t\t\t.offset((validatedFilters.page - 1) * validatedFilters.limit);\n\n\t\t\t// Enhance with additional information\n\t\t\tconst enhancedSchedules = await Promise.all(\n\t\t\t\tschedules.map(async (schedule) => {\n\t\t\t\t\t// Get last backup info\n\t\t\t\t\tlet lastBackup = null;\n\t\t\t\t\tif (schedule.lastBackupId) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlastBackup = await backupService.getBackup(schedule.lastBackupId);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t// Backup may have been deleted\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...schedule,\n\t\t\t\t\t\tlastBackup,\n\t\t\t\t\t\tnextRunIn: this.getTimeUntilNextRun(schedule.nextRunAt),\n\t\t\t\t\t\tstatus: this.getScheduleStatus(schedule)\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tschedules: enhancedSchedules,\n\t\t\t\tpagination: {\n\t\t\t\t\tpage: validatedFilters.page,\n\t\t\t\t\tlimit: validatedFilters.limit,\n\t\t\t\t\ttotal: schedules.length, // Would need count query for accurate total\n\t\t\t\t\ttotalPages: Math.ceil(schedules.length / validatedFilters.limit)\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow new AdminError('Failed to fetch backup schedules', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get schedule details by ID\n\t */\n\tasync getSchedule(id: Id<'id'>) {\n\t\ttry {\n\t\t\tconst [schedule] = await db.select().from(backupSchedules).where(eq(backupSchedules.id, id));\n\n\t\t\tif (!schedule) {\n\t\t\t\tthrow new AdminError(`Backup schedule not found: ${id}`, 404, AdminErrorCodes.NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Get recent backups for this schedule\n\t\t\tconst recentBackups = await db\n\t\t\t\t.select()\n\t\t\t\t.from(adminBackups)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(adminBackups.source, 'scheduled'),\n\t\t\t\t\t\teq(adminBackups.metadata, JSON.stringify({ scheduleId: id }))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.orderBy(desc(adminBackups.createdAt))\n\t\t\t\t.limit(10);\n\n\t\t\t// Get statistics\n\t\t\tconst stats = this.calculateScheduleStats(recentBackups);\n\n\t\t\treturn {\n\t\t\t\t...schedule,\n\t\t\t\trecentBackups,\n\t\t\t\tstats,\n\t\t\t\tnextRunIn: this.getTimeUntilNextRun(schedule.nextRunAt),\n\t\t\t\tstatus: this.getScheduleStatus(schedule)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to fetch backup schedule', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Trigger a schedule to run immediately\n\t */\n\tasync triggerSchedule(id: Id<'id'>, adminId: string) {\n\t\ttry {\n\t\t\tconst schedule = await this.getSchedule(id);\n\n\t\t\tif (!schedule.isActive) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Cannot trigger inactive schedule',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Execute the backup\n\t\t\tconst result = await this.executeScheduledBackup(schedule, adminId);\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Schedule \"${schedule.name}\" triggered successfully`,\n\t\t\t\tbackupId: result.backupId\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to trigger backup schedule', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Start the backup scheduler\n\t */\n\tasync startScheduler() {\n\t\tif (this.schedulerRunning) {\n\t\t\treturn { message: 'Backup scheduler is already running' };\n\t\t}\n\n\t\tthis.schedulerRunning = true;\n\n\t\t// Check for due schedules every minute\n\t\tthis.schedulerInterval = setInterval(async () => {\n\t\t\ttry {\n\t\t\t\tawait this.processDueSchedules();\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('Error processing backup schedules:', error);\n\t\t\t}\n\t\t}, 60 * 1000); // 1 minute\n\n\t\tlogger.info('Backup scheduler started');\n\t\treturn { message: 'Backup scheduler started successfully' };\n\t}\n\n\t/**\n\t * Stop the backup scheduler\n\t */\n\tstopScheduler() {\n\t\tif (this.schedulerInterval) {\n\t\t\tclearInterval(this.schedulerInterval);\n\t\t\tthis.schedulerInterval = null;\n\t\t}\n\n\t\tthis.schedulerRunning = false;\n\t\tlogger.info('Backup scheduler stopped');\n\t\treturn { message: 'Backup scheduler stopped' };\n\t}\n\n\t/**\n\t * Get scheduler status\n\t */\n\tgetSchedulerStatus() {\n\t\treturn {\n\t\t\trunning: this.schedulerRunning,\n\t\t\tuptime: this.schedulerRunning ? process.uptime() : 0,\n\t\t\tnextCheck: this.schedulerRunning ? new Date(Date.now() + 60000).toISOString() : null\n\t\t};\n\t}\n\n\t// Private helper methods\n\n\tprivate async ensureSchedulerRunning() {\n\t\tif (!this.schedulerRunning) {\n\t\t\tawait this.startScheduler();\n\t\t}\n\t}\n\n\tprivate async processDueSchedules() {\n\t\tconst now = new Date().toISOString();\n\n\t\t// Get schedules that are due for execution\n\t\tconst dueSchedules = await db\n\t\t\t.select()\n\t\t\t.from(backupSchedules)\n\t\t\t.where(and(eq(backupSchedules.isActive, true), lte(backupSchedules.nextRunAt, now)));\n\n\t\tfor (const schedule of dueSchedules) {\n\t\t\ttry {\n\t\t\t\tlogger.info(`Executing scheduled backup: ${schedule.name}`);\n\n\t\t\t\t// Execute the backup\n\t\t\t\tconst result = await this.executeScheduledBackup(schedule, schedule.createdBy);\n\n\t\t\t\t// Update schedule with next run time and last backup info\n\t\t\t\tconst nextRun = this.calculateNextRun(schedule.cronExpression, schedule.timezone);\n\n\t\t\t\tawait db\n\t\t\t\t\t.update(backupSchedules)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tlastRunAt: new Date().toISOString(),\n\t\t\t\t\t\tnextRunAt: nextRun.toISOString(),\n\t\t\t\t\t\tlastBackupId: result.backupId,\n\t\t\t\t\t\tconsecutiveFailures: 0,\n\t\t\t\t\t\tlastError: null\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(backupSchedules.id, schedule.id));\n\n\t\t\t\tlogger.info(`Scheduled backup completed: ${schedule.name}, next run: ${nextRun}`);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(`Scheduled backup failed: ${schedule.name}`, error);\n\n\t\t\t\t// Update failure count and error\n\t\t\t\tawait db\n\t\t\t\t\t.update(backupSchedules)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tconsecutiveFailures: schedule.consecutiveFailures + 1,\n\t\t\t\t\t\tlastError: error.message,\n\t\t\t\t\t\tlastRunAt: new Date().toISOString(),\n\t\t\t\t\t\tnextRunAt: this.calculateNextRun(\n\t\t\t\t\t\t\tschedule.cronExpression,\n\t\t\t\t\t\t\tschedule.timezone\n\t\t\t\t\t\t).toISOString()\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(backupSchedules.id, schedule.id));\n\n\t\t\t\t// Send notification if configured\n\t\t\t\tif (schedule.notifyOnFailure) {\n\t\t\t\t\t// Implementation would send email/webhook notification\n\t\t\t\t\tlogger.info(`Backup failure notification for schedule: ${schedule.name}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async executeScheduledBackup(schedule: any, adminId: string) {\n\t\t// Create backup using the backup service\n\t\tconst result = await backupService.createBackup(\n\t\t\t{\n\t\t\t\tdisplayName: `${schedule.name} - ${new Date().toISOString()}`,\n\t\t\t\tdescription: `Scheduled backup from: ${schedule.name}`,\n\t\t\t\tbackupType: schedule.backupType,\n\t\t\t\tbackupFormat: schedule.backupFormat,\n\t\t\t\tcompressionType: schedule.compressionType,\n\t\t\t\tincludedTables: schedule.includedTables,\n\t\t\t\tincludedSchemas: schedule.includedSchemas,\n\t\t\t\texcludedTables: schedule.excludedTables,\n\t\t\t\ttags: ['scheduled', `schedule-${schedule.id}`],\n\t\t\t\tisProtected: false\n\t\t\t},\n\t\t\tadminId\n\t\t);\n\n\t\t// Clean up old backups according to retention policy\n\t\tawait this.cleanupOldBackups(schedule);\n\n\t\treturn result;\n\t}\n\n\tprivate async cleanupOldBackups(schedule: any) {\n\t\ttry {\n\t\t\t// Get all backups for this schedule\n\t\t\tconst scheduleBackups = await db\n\t\t\t\t.select()\n\t\t\t\t.from(adminBackups)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(adminBackups.source, 'scheduled'),\n\t\t\t\t\t\teq(adminBackups.metadata, JSON.stringify({ scheduleId: schedule.id }))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.orderBy(desc(adminBackups.createdAt));\n\n\t\t\t// Delete backups exceeding max count\n\t\t\tif (scheduleBackups.length > schedule.maxBackups) {\n\t\t\t\tconst toDelete = scheduleBackups.slice(schedule.maxBackups);\n\t\t\t\tfor (const backup of toDelete) {\n\t\t\t\t\tawait backupService.deleteBackup(backup.id, schedule.createdBy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Delete backups older than retention period\n\t\t\tconst cutoffDate = new Date();\n\t\t\tcutoffDate.setDate(cutoffDate.getDate() - schedule.retentionDays);\n\n\t\t\tconst expiredBackups = scheduleBackups.filter(\n\t\t\t\t(backup) => new Date(backup.createdAt) < cutoffDate && !backup.isProtected\n\t\t\t);\n\n\t\t\tfor (const backup of expiredBackups) {\n\t\t\t\tawait backupService.deleteBackup(backup.id, schedule.createdBy);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.warn(`Failed to cleanup old backups for schedule ${schedule.name}:`, error);\n\t\t}\n\t}\n\n\tprivate calculateNextRun(cronExpression: string, timezone: string = 'UTC'): Date {\n\t\t// Simple cron calculation - in production, use a proper cron library like 'node-cron'\n\t\t// For now, just add appropriate intervals based on common patterns\n\n\t\tconst now = new Date();\n\t\tconst parts = cronExpression.split(' ');\n\n\t\t// Handle common patterns\n\t\tif (cronExpression === '0 2 * * *') {\n\t\t\t// Daily at 2 AM\n\t\t\tconst next = new Date(now);\n\t\t\tnext.setHours(2, 0, 0, 0);\n\t\t\tif (next <= now) {\n\t\t\t\tnext.setDate(next.getDate() + 1);\n\t\t\t}\n\t\t\treturn next;\n\t\t}\n\n\t\tif (cronExpression === '0 2 * * 0') {\n\t\t\t// Weekly on Sunday at 2 AM\n\t\t\tconst next = new Date(now);\n\t\t\tnext.setHours(2, 0, 0, 0);\n\t\t\tconst daysUntilSunday = (7 - next.getDay()) % 7 || 7;\n\t\t\tnext.setDate(next.getDate() + daysUntilSunday);\n\t\t\treturn next;\n\t\t}\n\n\t\tif (cronExpression === '0 2 1 * *') {\n\t\t\t// Monthly on 1st at 2 AM\n\t\t\tconst next = new Date(now);\n\t\t\tnext.setDate(1);\n\t\t\tnext.setHours(2, 0, 0, 0);\n\t\t\tif (next <= now) {\n\t\t\t\tnext.setMonth(next.getMonth() + 1);\n\t\t\t}\n\t\t\treturn next;\n\t\t}\n\n\t\t// Default: add 1 hour\n\t\treturn new Date(now.getTime() + 60 * 60 * 1000);\n\t}\n\n\tprivate getTimeUntilNextRun(nextRunAt: string | null): string | null {\n\t\tif (!nextRunAt) return null;\n\n\t\tconst now = new Date();\n\t\tconst nextRun = new Date(nextRunAt);\n\t\tconst diff = nextRun.getTime() - now.getTime();\n\n\t\tif (diff <= 0) return 'Overdue';\n\n\t\tconst hours = Math.floor(diff / (1000 * 60 * 60));\n\t\tconst minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));\n\n\t\tif (hours > 24) {\n\t\t\tconst days = Math.floor(hours / 24);\n\t\t\treturn `${days}d ${hours % 24}h`;\n\t\t}\n\n\t\treturn `${hours}h ${minutes}m`;\n\t}\n\n\tprivate getScheduleStatus(schedule: any): 'healthy' | 'warning' | 'error' {\n\t\tif (!schedule.isActive) return 'warning';\n\t\tif (schedule.consecutiveFailures >= 3) return 'error';\n\t\tif (schedule.consecutiveFailures > 0) return 'warning';\n\t\treturn 'healthy';\n\t}\n\n\tprivate calculateScheduleStats(backups: any[]) {\n\t\tconst total = backups.length;\n\t\tconst successful = backups.filter((b) => b.status === 'completed').length;\n\t\tconst failed = backups.filter((b) => b.status === 'failed').length;\n\t\tconst avgSize =\n\t\t\tbackups.length > 0\n\t\t\t\t? backups.reduce((sum, b) => sum + (b.fileSize || 0), 0) / backups.length\n\t\t\t\t: 0;\n\n\t\treturn {\n\t\t\ttotalBackups: total,\n\t\t\tsuccessfulBackups: successful,\n\t\t\tfailedBackups: failed,\n\t\t\tsuccessRate: total > 0 ? Math.round((successful / total) * 100) : 0,\n\t\t\taverageSizeMB: Math.round((avgSize / (1024 * 1024)) * 100) / 100\n\t\t};\n\t}\n}\n\n// Export singleton instance\nexport const backupScheduleService = new BackupScheduleService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/brand-config/brand.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/brand-config/brand.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/brand-config/brand.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/cache/cache.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'health' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":177,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":177,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { z } from 'zod';\nimport { adminCacheService } from '../../shared/admin-cache.service';\nimport {\n\tsendSuccess,\n\tsendError,\n\tvalidateRequestBody,\n\tAdminOperationBoundary,\n\tformatAdminResponse\n} from '../../shared';\n\nconst clearCacheSchema = z.object({\n\tpattern: z.string().optional(),\n\tcategory: z.enum(['settings', 'users', 'analytics', 'forum', 'all']).optional()\n});\n\nconst warmupCacheSchema = z.object({\n\ttargets: z.array(z.enum(['settings', 'usergroups', 'forumconfig', 'analytics'])).optional()\n});\n\nexport class AdminCacheController {\n\t/**\n\t * Get cache metrics and health status\n\t */\n\tasync getMetrics(req: Request, res: Response) {\n\t\tconst boundary =\n\t\t\treq.adminBoundary?.('GET_CACHE_METRICS', 'cache') ||\n\t\t\tnew AdminOperationBoundary({\n\t\t\t\toperation: 'GET_CACHE_METRICS',\n\t\t\t\tentityType: 'cache',\n\t\t\t\tuserId: (userService.getUserFromRequest(req) as any)?.id,\n\t\t\t\ttimestamp: new Date()\n\t\t\t});\n\n\t\tconst result = await boundary.execute(async () => {\n\t\t\tconst metrics = adminCacheService.getMetrics();\n\t\t\tconst health = adminCacheService.getHealth();\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\tmetrics,\n\t\t\t\t\thealth,\n\t\t\t\t\trecommendations: this.generateRecommendations(metrics, health)\n\t\t\t\t},\n\t\t\t\t'GET_CACHE_METRICS',\n\t\t\t\t'cache'\n\t\t\t);\n\t\t});\n\n\t\tif (result.success) {\n\t\t\treturn sendSuccess(res, result.data);\n\t\t} else {\n\t\t\treturn sendError(\n\t\t\t\tres,\n\t\t\t\tresult.error?.message || 'Failed to get cache metrics',\n\t\t\t\tresult.error?.httpStatus\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Clear cache by pattern or category\n\t */\n\tasync clearCache(req: Request, res: Response) {\n\t\tconst validatedData = validateRequestBody(req, res, clearCacheSchema);\n\t\tif (!validatedData) return;\n\n\t\tconst boundary =\n\t\t\treq.adminBoundary?.('CLEAR_CACHE', 'cache') ||\n\t\t\tnew AdminOperationBoundary({\n\t\t\t\toperation: 'CLEAR_CACHE',\n\t\t\t\tentityType: 'cache',\n\t\t\t\tuserId: (userService.getUserFromRequest(req) as any)?.id,\n\t\t\t\ttimestamp: new Date()\n\t\t\t});\n\n\t\tconst result = await boundary.execute(async () => {\n\t\t\tlet clearedCount = 0;\n\n\t\t\tif (validatedData.category === 'all') {\n\t\t\t\tawait adminCacheService.flush();\n\t\t\t\tclearedCount = -1; // Indicate full flush\n\t\t\t} else if (validatedData.pattern) {\n\t\t\t\tclearedCount = await adminCacheService.clearByPattern(validatedData.pattern);\n\t\t\t} else if (validatedData.category) {\n\t\t\t\tconst pattern = this.getCategoryPattern(validatedData.category);\n\t\t\t\tclearedCount = await adminCacheService.clearByPattern(pattern);\n\t\t\t}\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\tclearedCount,\n\t\t\t\t\tpattern: validatedData.pattern,\n\t\t\t\t\tcategory: validatedData.category,\n\t\t\t\t\ttimestamp: new Date()\n\t\t\t\t},\n\t\t\t\t'CLEAR_CACHE',\n\t\t\t\t'cache'\n\t\t\t);\n\t\t});\n\n\t\tif (result.success) {\n\t\t\tconst message =\n\t\t\t\tresult.data.clearedCount === -1\n\t\t\t\t\t? 'All cache cleared successfully'\n\t\t\t\t\t: `${result.data.clearedCount} cache entries cleared`;\n\n\t\t\treturn sendSuccess(res, result.data, message);\n\t\t} else {\n\t\t\treturn sendError(\n\t\t\t\tres,\n\t\t\t\tresult.error?.message || 'Failed to clear cache',\n\t\t\t\tresult.error?.httpStatus\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Warm up cache with critical data\n\t */\n\tasync warmupCache(req: Request, res: Response) {\n\t\tconst validatedData = validateRequestBody(req, res, warmupCacheSchema);\n\t\tif (!validatedData) return;\n\n\t\tconst boundary =\n\t\t\treq.adminBoundary?.('WARMUP_CACHE', 'cache') ||\n\t\t\tnew AdminOperationBoundary({\n\t\t\t\toperation: 'WARMUP_CACHE',\n\t\t\t\tentityType: 'cache',\n\t\t\t\tuserId: (userService.getUserFromRequest(req) as any)?.id,\n\t\t\t\ttimestamp: new Date()\n\t\t\t});\n\n\t\tconst result = await boundary.execute(async () => {\n\t\t\tconst targets = validatedData.targets || ['settings', 'usergroups', 'forumconfig'];\n\t\t\tconst warmupFetchers = this.createWarmupFetchers(targets);\n\n\t\t\tawait adminCacheService.warmup(warmupFetchers);\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\ttargets,\n\t\t\t\t\twarmedAt: new Date()\n\t\t\t\t},\n\t\t\t\t'WARMUP_CACHE',\n\t\t\t\t'cache'\n\t\t\t);\n\t\t});\n\n\t\tif (result.success) {\n\t\t\treturn sendSuccess(res, result.data, 'Cache warmup completed successfully');\n\t\t} else {\n\t\t\treturn sendError(\n\t\t\t\tres,\n\t\t\t\tresult.error?.message || 'Failed to warm up cache',\n\t\t\t\tresult.error?.httpStatus\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get cache usage analytics\n\t */\n\tasync getAnalytics(req: Request, res: Response) {\n\t\tconst boundary =\n\t\t\treq.adminBoundary?.('GET_CACHE_ANALYTICS', 'cache') ||\n\t\t\tnew AdminOperationBoundary({\n\t\t\t\toperation: 'GET_CACHE_ANALYTICS',\n\t\t\t\tentityType: 'cache',\n\t\t\t\tuserId: (userService.getUserFromRequest(req) as any)?.id,\n\t\t\t\ttimestamp: new Date()\n\t\t\t});\n\n\t\tconst result = await boundary.execute(async () => {\n\t\t\tconst metrics = adminCacheService.getMetrics();\n\t\t\tconst health = adminCacheService.getHealth();\n\n\t\t\t// Calculate analytics\n\t\t\tconst analytics = {\n\t\t\t\tperformance: {\n\t\t\t\t\thitRate: metrics.hitRate,\n\t\t\t\t\thitRateGrade: this.getHitRateGrade(metrics.hitRate),\n\t\t\t\t\ttotalRequests: metrics.hits + metrics.misses,\n\t\t\t\t\tefficiency: metrics.hits > 0 ? (metrics.hits / (metrics.hits + metrics.misses)) * 100 : 0\n\t\t\t\t},\n\t\t\t\tusage: {\n\t\t\t\t\tcurrentSize: metrics.size,\n\t\t\t\t\tmaxSize: 1000, // From cache config\n\t\t\t\t\tutilizationPercent: (metrics.size / 1000) * 100\n\t\t\t\t},\n\t\t\t\tcategories: metrics.categories,\n\t\t\t\trecommendations: this.generatePerformanceRecommendations(metrics)\n\t\t\t};\n\n\t\t\treturn formatAdminResponse(analytics, 'GET_CACHE_ANALYTICS', 'cache');\n\t\t});\n\n\t\tif (result.success) {\n\t\t\treturn sendSuccess(res, result.data);\n\t\t} else {\n\t\t\treturn sendError(\n\t\t\t\tres,\n\t\t\t\tresult.error?.message || 'Failed to get cache analytics',\n\t\t\t\tresult.error?.httpStatus\n\t\t\t);\n\t\t}\n\t}\n\n\t// Private helper methods\n\n\tprivate getCategoryPattern(category: string): string {\n\t\tconst patterns = {\n\t\t\tsettings: 'settings:',\n\t\t\tusers: 'usersearch:',\n\t\t\tanalytics: 'analytics:',\n\t\t\tforum: 'forumconfig:'\n\t\t};\n\t\treturn patterns[category] || category;\n\t}\n\n\tprivate createWarmupFetchers(targets: string[]): Record<string, () => Promise<any>> {\n\t\tconst fetchers: Record<string, () => Promise<any>> = {};\n\n\t\tif (targets.includes('settings')) {\n\t\t\t// Import will be resolved at runtime\n\t\t\tfetchers['settings:all'] = async () => {\n\t\t\t\tconst { settingsQueryService } = await import(\n\t\t\t\t\t'../settings/services/settings-query.service'\n\t\t\t\t);\n\t\t\t\treturn settingsQueryService.getAllSettings();\n\t\t\t};\n\t\t}\n\n\t\tif (targets.includes('usergroups')) {\n\t\t\tfetchers['usergroups:all'] = async () => {\n\t\t\t\t// Mock user groups data - replace with actual service\n\t\t\t\treturn [];\n\t\t\t};\n\t\t}\n\n\t\tif (targets.includes('forumconfig')) {\n\t\t\tfetchers['forumconfig:structure'] = async () => {\n\t\t\t\t// Mock forum config - replace with actual service\n\t\t\t\treturn {};\n\t\t\t};\n\t\t}\n\n\t\treturn fetchers;\n\t}\n\n\tprivate generateRecommendations(metrics: any, health: any): string[] {\n\t\tconst recommendations: string[] = [];\n\n\t\tif (health.status === 'degraded') {\n\t\t\trecommendations.push(\n\t\t\t\t'Cache performance is degraded - consider investigating hit rate or capacity issues'\n\t\t\t);\n\t\t}\n\n\t\tif (metrics.hitRate < 0.5) {\n\t\t\trecommendations.push(\n\t\t\t\t'Low cache hit rate detected - review caching strategy and TTL settings'\n\t\t\t);\n\t\t}\n\n\t\tif (metrics.size > 800) {\n\t\t\trecommendations.push(\n\t\t\t\t'Cache approaching capacity limit - consider increasing max keys or clearing old entries'\n\t\t\t);\n\t\t}\n\n\t\tif (metrics.hits === 0 && metrics.misses > 10) {\n\t\t\trecommendations.push('No cache hits detected - verify cache is properly integrated');\n\t\t}\n\n\t\treturn recommendations;\n\t}\n\n\tprivate getHitRateGrade(hitRate: number): string {\n\t\tif (hitRate >= 0.8) return 'Excellent';\n\t\tif (hitRate >= 0.6) return 'Good';\n\t\tif (hitRate >= 0.4) return 'Fair';\n\t\tif (hitRate >= 0.2) return 'Poor';\n\t\treturn 'Critical';\n\t}\n\n\tprivate generatePerformanceRecommendations(metrics: any): string[] {\n\t\tconst recommendations: string[] = [];\n\n\t\tif (metrics.hitRate < 0.3) {\n\t\t\trecommendations.push('Consider longer TTL for stable data like settings');\n\t\t}\n\n\t\tif (metrics.size < 100) {\n\t\t\trecommendations.push('Cache utilization is low - consider adding more cacheable endpoints');\n\t\t}\n\n\t\tif (metrics.sets > metrics.hits * 2) {\n\t\t\trecommendations.push('High set-to-hit ratio indicates potential cache thrashing');\n\t\t}\n\n\t\treturn recommendations;\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/cache/cache.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/clout/clout.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'notify' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":181,"column":4,"nodeType":"Identifier","messageId":"unusedVar","endLine":181,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport { db } from '@db';\nimport { cloutAchievements, userCloutLog, users } from '@schema';\nimport { eq, desc } from 'drizzle-orm';\nimport { logger } from '../../../../core/logger';\nimport { CloutService } from '../../../economy/services/cloutService';\nimport { CloutTransformer } from '../../../gamification/transformers/clout.transformer';\n\n// Instantiate once – can be swapped with dependency injection later\nconst cloutService = new CloutService();\n\n/** ---------------------------- ACHIEVEMENTS CRUD --------------------------- */\nexport const getAllAchievements = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst achievements = await db.select().from(cloutAchievements).orderBy(cloutAchievements.id);\n\t\t\n\t\t// Transform achievements for admin view\n\t\tconst transformedAchievements = CloutTransformer.toAchievementList(achievements, { role: 'admin' }, 'admin');\n\t\t\n\t\tres.json({ achievements: transformedAchievements, count: transformedAchievements.length });\n\t} catch (err) {\n\t\tlogger.error('CloutAdmin', 'Error fetching achievements', err);\n\t\tnext(err);\n\t}\n};\n\nexport const getAchievementById = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst id = req.params.id;\n\t\tconst rows = await db\n\t\t\t.select()\n\t\t\t.from(cloutAchievements)\n\t\t\t.where(eq(cloutAchievements.id, id))\n\t\t\t.limit(1);\n\t\tif (!rows.length) return res.status(404).json({ message: 'Achievement not found' });\n\t\t\n\t\t// Transform achievement for admin view\n\t\tconst transformedAchievement = CloutTransformer.toAdminAchievement(rows[0]);\n\t\t\n\t\tres.json(transformedAchievement);\n\t} catch (err) {\n\t\tnext(err);\n\t}\n};\n\nexport const createAchievement = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst {\n\t\t\tachievementKey,\n\t\t\tname,\n\t\t\tdescription,\n\t\t\tcloutReward,\n\t\t\tcriteriaType,\n\t\t\tcriteriaValue,\n\t\t\tenabled = true,\n\t\t\ticonUrl\n\t\t} = req.body;\n\n\t\tif (!achievementKey || !name) {\n\t\t\treturn res.status(400).json({ message: 'achievementKey and name are required' });\n\t\t}\n\n\t\tawait db.insert(cloutAchievements).values({\n\t\t\tachievementKey,\n\t\t\tname,\n\t\t\tdescription,\n\t\t\tcloutReward: cloutReward ?? 0,\n\t\t\tcriteriaType,\n\t\t\tcriteriaValue,\n\t\t\tenabled,\n\t\t\ticonUrl,\n\t\t\tcreatedAt: new Date()\n\t\t});\n\n\t\tres.status(201).json({ message: 'Achievement created' });\n\t} catch (err) {\n\t\tnext(err);\n\t}\n};\n\nexport const updateAchievement = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst id = req.params.id;\n\t\tconst updateData = { ...req.body, updatedAt: new Date() } as any;\n\t\tdelete updateData.id;\n\n\t\t// Check existence\n\t\tconst exists = await db\n\t\t\t.select({ id: cloutAchievements.id })\n\t\t\t.from(cloutAchievements)\n\t\t\t.where(eq(cloutAchievements.id, id))\n\t\t\t.limit(1);\n\t\tif (!exists.length) return res.status(404).json({ message: 'Achievement not found' });\n\n\t\tawait db.update(cloutAchievements).set(updateData).where(eq(cloutAchievements.id, id));\n\t\tres.json({ message: 'Achievement updated' });\n\t} catch (err) {\n\t\tnext(err);\n\t}\n};\n\nexport const deleteAchievement = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst id = req.params.id;\n\t\tawait db.delete(cloutAchievements).where(eq(cloutAchievements.id, id));\n\t\tres.json({ message: 'Achievement deleted' });\n\t} catch (err) {\n\t\tnext(err);\n\t}\n};\n\nexport const toggleAchievement = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst id = req.params.id;\n\t\tconst rows = await db\n\t\t\t.select({ enabled: cloutAchievements.enabled })\n\t\t\t.from(cloutAchievements)\n\t\t\t.where(eq(cloutAchievements.id, id))\n\t\t\t.limit(1);\n\t\tif (!rows.length) return res.status(404).json({ message: 'Achievement not found' });\n\t\tconst enabled = !rows[0].enabled;\n\t\tawait db.update(cloutAchievements).set({ enabled }).where(eq(cloutAchievements.id, id));\n\t\tres.json({ message: `Achievement ${enabled ? 'enabled' : 'disabled'}` });\n\t} catch (err) {\n\t\tnext(err);\n\t}\n};\n\n/** ---------------------------- CLOUT GRANTS --------------------------- */\nexport const grantClout = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { userId, amount, reason } = req.body as {\n\t\t\tuserId: string;\n\t\t\tamount: number;\n\t\t\treason: string;\n\t\t};\n\t\tif (!userId || !amount || !reason)\n\t\t\treturn res.status(400).json({ message: 'userId, amount, reason required' });\n\n\t\t// Validate user exists\n\t\tconst userExists = await db\n\t\t\t.select({ id: users.id })\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, userId))\n\t\t\t.limit(1);\n\t\tif (!userExists.length) return res.status(404).json({ message: 'User not found' });\n\n\t\tawait cloutService.grantClout(userId, amount, reason);\n\n\t\tres.status(200).json({ message: `Granted ${amount} clout to user ${userId}` });\n\t} catch (err) {\n\t\tnext(err);\n\t}\n};\n\nexport const getCloutLogs = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { userId, limit = 50 } = req.query as { userId?: string; limit?: string };\n\n\t\tconst baseQuery = db.select().from(userCloutLog);\n\t\tconst filtered = userId ? baseQuery.where(eq(userCloutLog.userId, userId)) : baseQuery;\n\t\tconst logs = await filtered.orderBy(desc(userCloutLog.createdAt)).limit(Number(limit));\n\t\t\n\t\t// Transform logs for admin view\n\t\tconst { logs: transformedLogs, summary } = CloutTransformer.toCloutLogHistory(logs, { role: 'admin' }, 'admin');\n\t\t\n\t\tres.json({ logs: transformedLogs, summary, count: transformedLogs.length });\n\t} catch (err) {\n\t\tnext(err);\n\t}\n};\n\n/** ---------------------------- CLOUT ADJUSTMENTS (New Enhanced Tool) --------------------------- */\nexport const adjustClout = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst {\n\t\t\tuserId,\n\t\t\tamount,\n\t\t\tadjustmentType,\n\t\t\treason,\n\t\t\tnotify = false\n\t\t} = req.body as {\n\t\t\tuserId: string;\n\t\t\tamount: number;\n\t\t\tadjustmentType: 'add' | 'subtract' | 'set';\n\t\t\treason: string;\n\t\t\tnotify?: boolean;\n\t\t};\n\n\t\tif (!userId || !amount || !adjustmentType || !reason) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'userId, amount, adjustmentType, and reason are required'\n\t\t\t});\n\t\t}\n\n\t\t// Validate user exists and get current clout\n\t\tconst userRows = await db\n\t\t\t.select({ id: users.id, clout: users.clout })\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, userId))\n\t\t\t.limit(1);\n\n\t\tif (!userRows.length) {\n\t\t\treturn res.status(404).json({ message: 'User not found' });\n\t\t}\n\n\t\tconst user = userRows[0];\n\t\tconst oldClout = user.clout || 0;\n\t\tlet newClout = oldClout;\n\n\t\t// Calculate new clout based on adjustment type\n\t\tswitch (adjustmentType) {\n\t\t\tcase 'add':\n\t\t\t\tnewClout = oldClout + amount;\n\t\t\t\tbreak;\n\t\t\tcase 'subtract':\n\t\t\t\tnewClout = Math.max(0, oldClout - amount);\n\t\t\t\tbreak;\n\t\t\tcase 'set':\n\t\t\t\tnewClout = Math.max(0, amount);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn res.status(400).json({ message: 'Invalid adjustmentType' });\n\t\t}\n\n\t\tconst cloutChange = newClout - oldClout;\n\n\t\t// Apply the clout adjustment using our service\n\t\tif (cloutChange !== 0) {\n\t\t\tawait cloutService.grantClout(userId, cloutChange, `Admin Adjustment: ${reason}`);\n\t\t}\n\n\t\t// Get updated user data\n\t\tconst updatedUserRows = await db\n\t\t\t.select({ id: users.id, username: users.username, clout: users.clout })\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, userId))\n\t\t\t.limit(1);\n\n\t\tconst updatedUser = updatedUserRows[0];\n\n\t\t// TODO: Handle user notification if notify=true\n\t\t// This could integrate with a notification service\n\n\t\tlogger.info(\n\t\t\t'CloutAdmin',\n\t\t\t`Clout adjusted: ${user.id} | ${oldClout} → ${updatedUser.clout} | Reason: ${reason}`\n\t\t);\n\n\t\t// Transform user data for admin response\n\t\tconst userResponse = {\n\t\t\tid: updatedUser.id,\n\t\t\tusername: updatedUser.username,\n\t\t\tclout: updatedUser.clout\n\t\t};\n\t\t\n\t\tres.json({\n\t\t\tmessage: `Clout adjustment applied`,\n\t\t\tuser: userResponse,\n\t\t\tadjustment: {\n\t\t\t\ttype: adjustmentType,\n\t\t\t\tamount,\n\t\t\t\toldClout,\n\t\t\t\tnewClout: updatedUser.clout,\n\t\t\t\treason\n\t\t\t}\n\t\t});\n\t} catch (err) {\n\t\tlogger.error('CloutAdmin', 'Error adjusting clout', err);\n\t\tnext(err);\n\t}\n};\n\nexport const getCloutAdjustmentLogs = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { userId, limit = 50 } = req.query as { userId?: string; limit?: string };\n\n\t\t// Get clout logs with user data joined\n\t\tconst baseQuery = db\n\t\t\t.select({\n\t\t\t\tid: userCloutLog.id,\n\t\t\t\tuserId: userCloutLog.userId,\n\t\t\t\tusername: users.username,\n\t\t\t\tcloutEarned: userCloutLog.cloutEarned,\n\t\t\t\treason: userCloutLog.reason,\n\t\t\t\tcreatedAt: userCloutLog.createdAt\n\t\t\t})\n\t\t\t.from(userCloutLog)\n\t\t\t.leftJoin(users, eq(userCloutLog.userId, users.id));\n\n\t\tconst filtered = userId ? baseQuery.where(eq(userCloutLog.userId, userId)) : baseQuery;\n\t\tconst logs = await filtered.orderBy(desc(userCloutLog.createdAt)).limit(Number(limit));\n\n\t\t// Transform logs to match the frontend interface\n\t\tconst adjustmentLogs = logs.map((log) => {\n\t\t\t// Parse admin adjustment reasons to extract admin info\n\t\t\tconst isAdminAdjustment = log.reason?.startsWith('Admin Adjustment:');\n\t\t\tconst adjustmentReason = isAdminAdjustment\n\t\t\t\t? log.reason.replace('Admin Adjustment: ', '')\n\t\t\t\t: log.reason;\n\n\t\t\t// Determine adjustment type and amount from cloutEarned\n\t\t\tlet adjustmentType: 'add' | 'subtract' | 'set' = 'add';\n\t\t\tconst amount = Math.abs(log.cloutEarned);\n\n\t\t\tif (log.cloutEarned > 0) {\n\t\t\t\tadjustmentType = 'add';\n\t\t\t} else if (log.cloutEarned < 0) {\n\t\t\t\tadjustmentType = 'subtract';\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tid: log.id,\n\t\t\t\tuserId: log.userId,\n\t\t\t\tusername: log.username || 'Unknown',\n\t\t\t\tadjustmentType,\n\t\t\t\tamount,\n\t\t\t\treason: adjustmentReason,\n\t\t\t\toldClout: 0, // TODO: Calculate from previous state if needed for detailed view\n\t\t\t\tnewClout: 0, // TODO: Calculate from previous state if needed for detailed view\n\t\t\t\tadminUsername: 'Admin', // TODO: Extract from request context or log metadata\n\t\t\t\ttimestamp: log.createdAt\n\t\t\t};\n\t\t});\n\n\t\t// Transform adjustment logs for admin view\n\t\tconst transformedLogs = adjustmentLogs.map(log => ({\n\t\t\t...log,\n\t\t\t// Ensure proper data sanitization\n\t\t\tusername: log.username || 'Unknown',\n\t\t\ttimestamp: log.timestamp\n\t\t}));\n\t\t\n\t\tres.json(transformedLogs);\n\t} catch (err) {\n\t\tlogger.error('CloutAdmin', 'Error fetching clout adjustment logs', err);\n\t\tnext(err);\n\t}\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/clout/clout.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/database/bulk-operations.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Bulk Operations Controller\n *\n * Handles bulk data operations like CSV import/export and batch processing.\n */\n\nimport type { Request, Response } from 'express';\nimport { DatabaseService } from './database.service';\nimport { logger } from '@server/src/core/logger';\nimport { adminCreateAuditLogEntry } from '../../shared/admin-operation-utils';\nimport { getUserId } from '../../admin.middleware';\nimport { z } from 'zod';\nimport multer from 'multer';\nimport csvParser from 'csv-parser';\nimport { Readable } from 'stream';\n\nconst databaseService = new DatabaseService();\n\n// Validation schemas\nconst importValidationSchema = z.object({\n\ttable: z.string().min(1),\n\tvalidateOnly: z.boolean().default(false),\n\tupdateExisting: z.boolean().default(false)\n});\n\nconst validateDataSchema = z.object({\n\ttable: z.string().min(1),\n\tdata: z.array(z.record(z.any()))\n});\n\n// Configure multer for file uploads\nconst upload = multer({\n\tstorage: multer.memoryStorage(),\n\tlimits: {\n\t\tfileSize: 10 * 1024 * 1024 // 10MB limit\n\t},\n\tfileFilter: (req, file, cb) => {\n\t\tif (file.mimetype === 'text/csv' || file.originalname.endsWith('.csv')) {\n\t\t\tcb(null, true);\n\t\t} else {\n\t\t\tcb(new Error('Only CSV files are allowed'));\n\t\t}\n\t}\n}).single('file');\n\n/**\n * Import CSV data into a table\n */\nexport async function importCSV(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\t// Handle file upload\n\t\tupload(req, res, async (uploadError) => {\n\t\t\tif (uploadError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: uploadError.message\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!req.file) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'No file uploaded'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { table, validateOnly, updateExisting } = importValidationSchema.parse(req.body);\n\n\t\t\t// Check table access permissions\n\t\t\tconst accessInfo = await databaseService.getTableAccessInfo(table);\n\t\t\tif (!accessInfo.canEdit) {\n\t\t\t\treturn res.status(403).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: accessInfo.reason || 'Table editing is not allowed',\n\t\t\t\t\ttableType: accessInfo.isConfig ? 'configuration' : 'restricted',\n\t\t\t\t\tconfigRoute: accessInfo.configRoute\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Parse CSV data\n\t\t\tconst csvData: any[] = [];\n\t\t\tconst csvStream = Readable.from(req.file.buffer);\n\n\t\t\ttry {\n\t\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\t\tcsvStream\n\t\t\t\t\t\t.pipe(csvParser())\n\t\t\t\t\t\t.on('data', (row) => csvData.push(row))\n\t\t\t\t\t\t.on('end', resolve)\n\t\t\t\t\t\t.on('error', reject);\n\t\t\t\t});\n\n\t\t\t\t// Validate data structure\n\t\t\t\tif (csvData.length === 0) {\n\t\t\t\t\treturn res.status(400).json({\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: 'CSV file is empty or invalid'\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Validate each row against table schema\n\t\t\t\tconst validationResults = [];\n\t\t\t\tfor (let i = 0; i < csvData.length; i++) {\n\t\t\t\t\tconst validation = await databaseService.validateRowData(table, csvData[i]);\n\t\t\t\t\tif (!validation.valid) {\n\t\t\t\t\t\tvalidationResults.push({\n\t\t\t\t\t\t\trow: i + 1,\n\t\t\t\t\t\t\terrors: validation.errors\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If validation only, return results\n\t\t\t\tif (validateOnly) {\n\t\t\t\t\tawait adminCreateAuditLogEntry({\n\t\t\t\t\t\tadminUserId: userId,\n\t\t\t\t\t\taction: 'database_import_validated',\n\t\t\t\t\t\tdetails: `Validated CSV import for table ${table} (${csvData.length} rows, ${validationResults.length} errors)`\n\t\t\t\t\t});\n\n\t\t\t\t\treturn res.json({\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\ttotalRows: csvData.length,\n\t\t\t\t\t\t\tvalidRows: csvData.length - validationResults.length,\n\t\t\t\t\t\t\terrors: validationResults,\n\t\t\t\t\t\t\tpreview: csvData.slice(0, 5) // First 5 rows for preview\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If there are validation errors, don't proceed with import\n\t\t\t\tif (validationResults.length > 0) {\n\t\t\t\t\treturn res.status(400).json({\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: 'Data validation failed',\n\t\t\t\t\t\tdetails: validationResults\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Perform the import\n\t\t\t\tlet imported = 0;\n\t\t\t\tlet updated = 0;\n\t\t\t\tlet errors = 0;\n\n\t\t\t\tfor (const row of csvData) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (updateExisting) {\n\t\t\t\t\t\t\t// Try to update first, then create if not exists\n\t\t\t\t\t\t\tconst schema = await databaseService.getTableSchema(table);\n\t\t\t\t\t\t\tconst primaryKey = schema.primaryKey[0];\n\n\t\t\t\t\t\t\tif (primaryKey && row[primaryKey]) {\n\t\t\t\t\t\t\t\tconst existing = await databaseService.getRowById(table, row[primaryKey]);\n\t\t\t\t\t\t\t\tif (existing) {\n\t\t\t\t\t\t\t\t\tawait databaseService.updateRow(table, row[primaryKey], row);\n\t\t\t\t\t\t\t\t\tupdated++;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tawait databaseService.createRow(table, row);\n\t\t\t\t\t\t\t\t\timported++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tawait databaseService.createRow(table, row);\n\t\t\t\t\t\t\t\timported++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tawait databaseService.createRow(table, row);\n\t\t\t\t\t\t\timported++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\terrors++;\n\t\t\t\t\t\tlogger.warn('BulkController', 'Failed to import row', { error, row });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Log the import\n\t\t\t\tawait adminCreateAuditLogEntry({\n\t\t\t\t\tadminUserId: userId,\n\t\t\t\t\taction: 'database_bulk_import',\n\t\t\t\t\tdetails: `Imported CSV data to table ${table}`,\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\ttable,\n\t\t\t\t\t\ttotalRows: csvData.length,\n\t\t\t\t\t\timported,\n\t\t\t\t\t\tupdated,\n\t\t\t\t\t\terrors,\n\t\t\t\t\t\tfilename: req.file.originalname\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tres.json({\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\ttotalRows: csvData.length,\n\t\t\t\t\t\timported,\n\t\t\t\t\t\tupdated,\n\t\t\t\t\t\terrors\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (parseError: any) {\n\t\t\t\tlogger.error('BulkController', 'CSV parsing error', { error: parseError.message });\n\t\t\t\tres.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Failed to parse CSV file'\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('BulkController', 'Error importing CSV', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to import CSV data'\n\t\t});\n\t}\n}\n\n/**\n * Get CSV import template for a table\n */\nexport async function getImportTemplate(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { table } = req.params;\n\n\t\tif (!table) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Table name is required'\n\t\t\t});\n\t\t}\n\n\t\t// Check table access\n\t\tconst accessInfo = await databaseService.getTableAccessInfo(table);\n\t\tif (!accessInfo.canView) {\n\t\t\treturn res.status(403).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Table access denied'\n\t\t\t});\n\t\t}\n\n\t\t// Get table schema\n\t\tconst schema = await databaseService.getTableSchema(table);\n\n\t\t// Generate CSV headers\n\t\tconst headers = schema.columns\n\t\t\t.filter((col) => !col.isPrimaryKey || !col.defaultValue) // Exclude auto-increment PKs\n\t\t\t.map((col) => col.name);\n\n\t\t// Generate sample row\n\t\tconst sampleRow = schema.columns\n\t\t\t.filter((col) => !col.isPrimaryKey || !col.defaultValue)\n\t\t\t.map((col) => {\n\t\t\t\tif (col.type.includes('varchar') || col.type.includes('text')) {\n\t\t\t\t\treturn 'sample_text';\n\t\t\t\t} else if (col.type.includes('int')) {\n\t\t\t\t\treturn '123';\n\t\t\t\t} else if (col.type.includes('bool')) {\n\t\t\t\t\treturn 'true';\n\t\t\t\t} else if (col.type.includes('timestamp') || col.type.includes('date')) {\n\t\t\t\t\treturn '2024-01-01 12:00:00';\n\t\t\t\t} else {\n\t\t\t\t\treturn 'sample_value';\n\t\t\t\t}\n\t\t\t});\n\n\t\t// Create CSV content\n\t\tconst csvContent = [headers.join(','), sampleRow.join(',')].join('\\n');\n\n\t\t// Log access\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_template_downloaded',\n\t\t\tdetails: `Downloaded import template for table: ${table}`\n\t\t});\n\n\t\tres.setHeader('Content-Type', 'text/csv');\n\t\tres.setHeader('Content-Disposition', `attachment; filename=\"${table}_import_template.csv\"`);\n\t\tres.send(csvContent);\n\t} catch (error: any) {\n\t\tlogger.error('BulkController', 'Error generating import template', {\n\t\t\terror: error.message,\n\t\t\ttable: req.params.table\n\t\t});\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to generate import template'\n\t\t});\n\t}\n}\n\n/**\n * Validate import data without actually importing\n */\nexport async function validateImportData(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { table, data } = validateDataSchema.parse(req.body);\n\n\t\t// Check table access\n\t\tconst accessInfo = await databaseService.getTableAccessInfo(table);\n\t\tif (!accessInfo.canEdit) {\n\t\t\treturn res.status(403).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: accessInfo.reason || 'Table editing is not allowed'\n\t\t\t});\n\t\t}\n\n\t\t// Validate each row\n\t\tconst validationResults = [];\n\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\tconst validation = await databaseService.validateRowData(table, data[i]);\n\t\t\tif (!validation.valid) {\n\t\t\t\tvalidationResults.push({\n\t\t\t\t\trow: i + 1,\n\t\t\t\t\tdata: data[i],\n\t\t\t\t\terrors: validation.errors\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Log validation\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_data_validated',\n\t\t\tdetails: `Validated ${data.length} rows for table ${table}`\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\ttotalRows: data.length,\n\t\t\t\tvalidRows: data.length - validationResults.length,\n\t\t\t\tinvalidRows: validationResults.length,\n\t\t\t\terrors: validationResults\n\t\t\t}\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('BulkController', 'Error validating import data', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to validate import data'\n\t\t});\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/database/database.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'queryService' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { DatabaseService } from './database.service';\nimport { QueryService } from './query.service';\nimport { logger } from '@server/src/core/logger';\nimport { adminCreateAuditLogEntry } from '../../shared/admin-operation-utils';\nimport { getUserId } from '../../admin.middleware';\nimport { z } from 'zod';\n\nconst databaseService = new DatabaseService();\nconst queryService = new QueryService();\n\n// Request validation schemas\nconst tableQuerySchema = z.object({\n\ttable: z.string().min(1),\n\tpage: z.coerce.number().min(1).default(1),\n\tlimit: z.coerce.number().min(1).max(1000).default(50),\n\tsearch: z.string().optional(),\n\tsortField: z.string().optional(),\n\tsortOrder: z.enum(['asc', 'desc']).default('asc')\n});\n\nconst rowUpdateSchema = z.object({\n\ttable: z.string().min(1),\n\trowId: z.union([z.string(), z.number()]),\n\tdata: z.record(z.any())\n});\n\nconst rowCreateSchema = z.object({\n\ttable: z.string().min(1),\n\tdata: z.record(z.any())\n});\n\nconst rowDeleteSchema = z.object({\n\ttable: z.string().min(1),\n\trowId: z.union([z.string(), z.number()])\n});\n\nconst bulkOperationSchema = z.object({\n\ttable: z.string().min(1),\n\toperation: z.enum(['update', 'delete']),\n\trowIds: z.array(z.union([z.string(), z.number()])),\n\tdata: z.record(z.any()).optional()\n});\n\n/**\n * Get list of all database tables with metadata\n */\nexport async function getTables(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\tconst tables = await databaseService.getTables();\n\n\t\t// Log access\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_tables_viewed',\n\t\t\tdetails: `Viewed database table list (${tables.length} tables)`\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: tables\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('DatabaseController', 'Error getting tables', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to retrieve database tables'\n\t\t});\n\t}\n}\n\n/**\n * Get table schema and metadata\n */\nexport async function getTableSchema(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { table } = req.params;\n\n\t\tif (!table) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Table name is required'\n\t\t\t});\n\t\t}\n\n\t\tconst schema = await databaseService.getTableSchema(table);\n\n\t\t// Log access\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_schema_viewed',\n\t\t\tdetails: `Viewed schema for table: ${table}`\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: schema\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('DatabaseController', 'Error getting table schema', {\n\t\t\terror: error.message,\n\t\t\ttable: req.params.table\n\t\t});\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to retrieve table schema'\n\t\t});\n\t}\n}\n\n/**\n * Get table data with pagination and filtering\n */\nexport async function getTableData(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { table } = req.params;\n\t\tconst queryParams = tableQuerySchema.parse(req.query);\n\n\t\tif (!table) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Table name is required'\n\t\t\t});\n\t\t}\n\n\t\tconst result = await databaseService.getTableData(table, queryParams);\n\n\t\t// Log access (only log periodically to avoid spam)\n\t\tif (queryParams.page === 1) {\n\t\t\tawait adminCreateAuditLogEntry({\n\t\t\t\tadminUserId: userId,\n\t\t\t\taction: 'database_table_browsed',\n\t\t\t\tdetails: `Browsed table: ${table} (${result.total} total rows)`\n\t\t\t});\n\t\t}\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: result\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('DatabaseController', 'Error getting table data', {\n\t\t\terror: error.message,\n\t\t\ttable: req.params.table\n\t\t});\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to retrieve table data'\n\t\t});\n\t}\n}\n\n/**\n * Update a single row in a table\n */\nexport async function updateRow(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst requestData = rowUpdateSchema.parse(req.body);\n\n\t\t// Check table access permissions\n\t\tconst accessInfo = await databaseService.getTableAccessInfo(requestData.table);\n\t\tif (!accessInfo.canEdit) {\n\t\t\tconst response: any = {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: accessInfo.reason || 'Table editing is not allowed',\n\t\t\t\ttableType: accessInfo.isConfig ? 'configuration' : 'restricted'\n\t\t\t};\n\n\t\t\tif (accessInfo.isConfig && accessInfo.configRoute) {\n\t\t\t\tresponse.configRoute = accessInfo.configRoute;\n\t\t\t\tresponse.message = `This is a configuration table. Please use the dedicated config panel: ${accessInfo.configRoute}`;\n\t\t\t}\n\n\t\t\treturn res.status(403).json(response);\n\t\t}\n\n\t\t// Validate data\n\t\tconst validation = await databaseService.validateRowData(requestData.table, requestData.data);\n\t\tif (!validation.valid) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Data validation failed',\n\t\t\t\tdetails: validation.errors\n\t\t\t});\n\t\t}\n\n\t\tconst result = await databaseService.updateRow(\n\t\t\trequestData.table,\n\t\t\trequestData.rowId,\n\t\t\trequestData.data\n\t\t);\n\n\t\t// Log the update\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_row_updated',\n\t\t\tdetails: `Updated row ${requestData.rowId} in table ${requestData.table}`,\n\t\t\tmetadata: {\n\t\t\t\ttable: requestData.table,\n\t\t\t\trowId: requestData.rowId,\n\t\t\t\tupdatedFields: Object.keys(requestData.data),\n\t\t\t\tnewData: requestData.data\n\t\t\t}\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: result\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('DatabaseController', 'Error updating row', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to update row'\n\t\t});\n\t}\n}\n\n/**\n * Create a new row in a table\n */\nexport async function createRow(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst requestData = rowCreateSchema.parse(req.body);\n\n\t\t// Check table access permissions\n\t\tconst accessInfo = await databaseService.getTableAccessInfo(requestData.table);\n\t\tif (!accessInfo.canEdit) {\n\t\t\tconst response: any = {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: accessInfo.reason || 'Table editing is not allowed',\n\t\t\t\ttableType: accessInfo.isConfig ? 'configuration' : 'restricted'\n\t\t\t};\n\n\t\t\tif (accessInfo.isConfig && accessInfo.configRoute) {\n\t\t\t\tresponse.configRoute = accessInfo.configRoute;\n\t\t\t\tresponse.message = `This is a configuration table. Please use the dedicated config panel: ${accessInfo.configRoute}`;\n\t\t\t}\n\n\t\t\treturn res.status(403).json(response);\n\t\t}\n\n\t\t// Validate data\n\t\tconst validation = await databaseService.validateRowData(requestData.table, requestData.data);\n\t\tif (!validation.valid) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Data validation failed',\n\t\t\t\tdetails: validation.errors\n\t\t\t});\n\t\t}\n\n\t\tconst result = await databaseService.createRow(requestData.table, requestData.data);\n\n\t\t// Log the creation\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_row_created',\n\t\t\tdetails: `Created new row in table ${requestData.table}`,\n\t\t\tmetadata: {\n\t\t\t\ttable: requestData.table,\n\t\t\t\tnewRowId: result.id,\n\t\t\t\tdata: requestData.data\n\t\t\t}\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: result\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('DatabaseController', 'Error creating row', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to create row'\n\t\t});\n\t}\n}\n\n/**\n * Delete a row from a table\n */\nexport async function deleteRow(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst requestData = rowDeleteSchema.parse(req.body);\n\n\t\t// Check table access permissions\n\t\tconst accessInfo = await databaseService.getTableAccessInfo(requestData.table);\n\t\tif (!accessInfo.canEdit) {\n\t\t\tconst response: any = {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: accessInfo.reason || 'Table editing is not allowed',\n\t\t\t\ttableType: accessInfo.isConfig ? 'configuration' : 'restricted'\n\t\t\t};\n\n\t\t\tif (accessInfo.isConfig && accessInfo.configRoute) {\n\t\t\t\tresponse.configRoute = accessInfo.configRoute;\n\t\t\t\tresponse.message = `This is a configuration table. Please use the dedicated config panel: ${accessInfo.configRoute}`;\n\t\t\t}\n\n\t\t\treturn res.status(403).json(response);\n\t\t}\n\n\t\t// Get row data before deletion for audit log\n\t\tconst rowData = await databaseService.getRowById(requestData.table, requestData.rowId);\n\n\t\tconst result = await databaseService.deleteRow(requestData.table, requestData.rowId);\n\n\t\t// Log the deletion\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_row_deleted',\n\t\t\tdetails: `Deleted row ${requestData.rowId} from table ${requestData.table}`,\n\t\t\tmetadata: {\n\t\t\t\ttable: requestData.table,\n\t\t\t\tdeletedRowId: requestData.rowId,\n\t\t\t\tdeletedData: rowData\n\t\t\t}\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: result\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('DatabaseController', 'Error deleting row', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to delete row'\n\t\t});\n\t}\n}\n\n/**\n * Perform bulk operations on multiple rows\n */\nexport async function bulkOperation(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst requestData = bulkOperationSchema.parse(req.body);\n\n\t\t// Check table access permissions\n\t\tconst accessInfo = await databaseService.getTableAccessInfo(requestData.table);\n\t\tif (!accessInfo.canEdit) {\n\t\t\tconst response: any = {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: accessInfo.reason || 'Table editing is not allowed',\n\t\t\t\ttableType: accessInfo.isConfig ? 'configuration' : 'restricted'\n\t\t\t};\n\n\t\t\tif (accessInfo.isConfig && accessInfo.configRoute) {\n\t\t\t\tresponse.configRoute = accessInfo.configRoute;\n\t\t\t\tresponse.message = `This is a configuration table. Please use the dedicated config panel: ${accessInfo.configRoute}`;\n\t\t\t}\n\n\t\t\treturn res.status(403).json(response);\n\t\t}\n\n\t\t// Limit bulk operations to prevent abuse\n\t\tif (requestData.rowIds.length > 100) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Bulk operations are limited to 100 rows at a time'\n\t\t\t});\n\t\t}\n\n\t\tconst result = await databaseService.bulkOperation(\n\t\t\trequestData.table,\n\t\t\trequestData.operation,\n\t\t\trequestData.rowIds,\n\t\t\trequestData.data\n\t\t);\n\n\t\t// Log the bulk operation\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: `database_bulk_${requestData.operation}`,\n\t\t\tdetails: `Performed bulk ${requestData.operation} on ${requestData.rowIds.length} rows in table ${requestData.table}`,\n\t\t\tmetadata: {\n\t\t\t\ttable: requestData.table,\n\t\t\t\toperation: requestData.operation,\n\t\t\t\trowCount: requestData.rowIds.length,\n\t\t\t\trowIds: requestData.rowIds,\n\t\t\t\tdata: requestData.data\n\t\t\t}\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: result\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('DatabaseController', 'Error performing bulk operation', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to perform bulk operation'\n\t\t});\n\t}\n}\n\n/**\n * Export table data as CSV\n */\nexport async function exportTableCSV(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { table } = req.params;\n\n\t\tif (!table) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Table name is required'\n\t\t\t});\n\t\t}\n\n\t\tconst csvData = await databaseService.exportTableAsCSV(table);\n\n\t\t// Log the export\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_table_exported',\n\t\t\tdetails: `Exported table ${table} as CSV`\n\t\t});\n\n\t\tres.setHeader('Content-Type', 'text/csv');\n\t\tres.setHeader('Content-Disposition', `attachment; filename=\"${table}_export.csv\"`);\n\t\tres.send(csvData);\n\t} catch (error: any) {\n\t\tlogger.error('DatabaseController', 'Error exporting table CSV', {\n\t\t\terror: error.message,\n\t\t\ttable: req.params.table\n\t\t});\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to export table data'\n\t\t});\n\t}\n}\n\n/**\n * Get foreign key relationships for a table\n */\nexport async function getTableRelationships(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { table } = req.params;\n\n\t\tif (!table) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Table name is required'\n\t\t\t});\n\t\t}\n\n\t\tconst relationships = await databaseService.getTableRelationships(table);\n\n\t\t// Log access\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_relationships_viewed',\n\t\t\tdetails: `Viewed relationships for table: ${table}`\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: relationships\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('DatabaseController', 'Error getting table relationships', {\n\t\t\terror: error.message,\n\t\t\ttable: req.params.table\n\t\t});\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to retrieve table relationships'\n\t\t});\n\t}\n}\n\n/**\n * Get database statistics and health info\n */\nexport async function getDatabaseStats(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\tconst stats = await databaseService.getDatabaseStats();\n\n\t\t// Log access\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_stats_viewed',\n\t\t\tdetails: 'Viewed database statistics'\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: stats\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('DatabaseController', 'Error getting database stats', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to retrieve database statistics'\n\t\t});\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/database/database.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/database/database.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eq' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'like' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'schema' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Database Service\n *\n * Core service for database introspection, table browsing, and safe editing operations.\n * Implements security checks and validation to prevent dangerous operations.\n */\n\nimport { db } from '@server/src/core/db';\nimport { logger } from '@server/src/core/logger';\nimport { sql, eq, like, asc, desc, count } from 'drizzle-orm';\nimport * as schema from '@schema';\n\n// Configuration tables - should be edited through dedicated config panels, NOT live editor\nconst CONFIGURATION_TABLES = [\n\t// Core site configuration\n\t'site_settings',\n\t'feature_flags',\n\t'brand_configurations',\n\t'ui_quotes',\n\t'ui_collections',\n\t'ui_collection_quotes',\n\t'ui_analytics',\n\t'themes',\n\t'templates',\n\t'seo_metadata',\n\n\t// Economy configuration\n\t'xp_action_settings',\n\t'xp_clout_settings',\n\t'treasury_settings',\n\t'airdrop_settings',\n\t'economy_settings',\n\t'economy_config_overrides',\n\t'dgt_packages',\n\n\t// Forum configuration\n\t'forum_categories', // Use sync:forums instead\n\t'forum_structure', // Use forumMap.config.ts instead\n\t'rules',\n\t'custom_emojis',\n\t'emoji_packs',\n\t'emoji_pack_items',\n\t'thread_feature_permissions',\n\n\t// Shop configuration\n\t'product_categories',\n\t'rarities',\n\t'cosmetic_categories',\n\t'animation_packs',\n\t'animation_pack_items',\n\t'signature_items',\n\n\t// User configuration\n\t'roles',\n\t'permissions',\n\t'role_permissions',\n\t'titles',\n\t'badges',\n\t'avatar_frames',\n\n\t// System configuration\n\t'scheduled_tasks',\n\t'announcements',\n\t'media_library'\n];\n\n// System/Security tables - completely blocked from access\nconst SYSTEM_BLACKLISTED_TABLES = [\n\t'pg_stat_activity',\n\t'pg_locks',\n\t'information_schema',\n\t'pg_catalog',\n\t'sessions', // Session data should not be directly edited\n\t'password_reset_tokens', // Security sensitive\n\t'verification_tokens', // Security sensitive\n\t'audit_logs', // Audit trail integrity\n\t'api_keys', // Security sensitive\n\t'webhooks', // Security sensitive\n\t'payment_config' // Security sensitive\n];\n\n// Read-only tables - can be viewed but not edited (monitoring/analytics)\nconst READ_ONLY_TABLES = [\n\t'audit_logs',\n\t'sessions',\n\t'password_reset_tokens',\n\t'verification_tokens',\n\t'analytics_events',\n\t'rate_limits',\n\t'ui_analytics',\n\t'event_logs',\n\t'cooldown_state',\n\t'platform_stats',\n\t'leaderboards'\n];\n\n// Editable tables - safe for live database editing (moderation, user data, content)\nconst EDITABLE_TABLES = [\n\t// User management\n\t'users',\n\t'user_groups',\n\t'user_roles',\n\t'user_titles',\n\t'user_badges',\n\t'user_inventory',\n\t'user_signature_items',\n\t'bans',\n\t'user_abuse_flags',\n\n\t// Forum content\n\t'threads',\n\t'posts',\n\t'post_likes',\n\t'post_reactions',\n\t'post_tips',\n\t'thread_bookmarks',\n\t'thread_tags',\n\t'tags',\n\t'polls',\n\t'poll_options',\n\t'poll_votes',\n\t'post_drafts',\n\n\t// Economy transactions\n\t'transactions',\n\t'wallets',\n\t'withdrawal_requests',\n\t'airdrop_records',\n\t'rain_events',\n\t'xp_logs',\n\t'xp_adjustment_logs',\n\t'user_clout_log',\n\t'clout_achievements',\n\n\t// Shop operations\n\t'orders',\n\t'order_items',\n\t'inventory_transactions',\n\t'dgt_purchase_orders',\n\n\t// Messaging\n\t'messages',\n\t'direct_messages',\n\t'conversations',\n\t'conversation_participants',\n\t'message_reads',\n\t'shoutbox_messages',\n\t'online_users',\n\n\t// System operations\n\t'notifications',\n\t'reports',\n\t'moderation_actions',\n\t'user_referrals',\n\t'referral_sources',\n\t'activity_feed',\n\t'mentions_index',\n\n\t// Gamification\n\t'missions',\n\t'user_mission_progress',\n\t'achievements',\n\t'vaults',\n\n\t// Dictionary\n\t'dictionary_entries',\n\t'dictionary_upvotes',\n\n\t// Collectibles\n\t'stickers',\n\t'user_sticker_inventory'\n];\n\nexport interface TableInfo {\n\tname: string;\n\tschema: string;\n\trowCount: number;\n\tlastModified: string | null;\n\tcomment: string | null;\n\tisEditable: boolean;\n\thasData: boolean;\n\taccessInfo: {\n\t\tcanView: boolean;\n\t\tcanEdit: boolean;\n\t\tisConfig: boolean;\n\t\tconfigRoute?: string;\n\t\treason?: string;\n\t};\n}\n\nexport interface ColumnInfo {\n\tname: string;\n\ttype: string;\n\tnullable: boolean;\n\tdefaultValue: string | null;\n\tisPrimaryKey: boolean;\n\tisForeignKey: boolean;\n\tforeignKeyTable: string | null;\n\tforeignKeyColumn: string | null;\n\tcomment: string | null;\n}\n\nexport interface TableSchema {\n\ttableName: string;\n\tcolumns: ColumnInfo[];\n\tprimaryKey: string[];\n\tforeignKeys: ForeignKeyInfo[];\n\tindexes: IndexInfo[];\n\tconstraints: ConstraintInfo[];\n}\n\nexport interface ForeignKeyInfo {\n\tcolumnName: string;\n\treferencedTable: string;\n\treferencedColumn: string;\n\tconstraintName: string;\n}\n\nexport interface IndexInfo {\n\tname: string;\n\tcolumns: string[];\n\tisUnique: boolean;\n\tisPrimary: boolean;\n}\n\nexport interface ConstraintInfo {\n\tname: string;\n\ttype: string;\n\tcolumns: string[];\n\tdefinition: string;\n}\n\nexport interface TableDataResult {\n\trows: any[];\n\ttotal: number;\n\tpage: number;\n\tlimit: number;\n\ttotalPages: number;\n}\n\nexport interface ValidationResult {\n\tvalid: boolean;\n\terrors: string[];\n}\n\nexport class DatabaseService {\n\t/**\n\t * Get list of all user tables with metadata\n\t */\n\tasync getTables(): Promise<TableInfo[]> {\n\t\ttry {\n\t\t\tconst query = sql`\n\t\t\t\tSELECT \n\t\t\t\t\tt.table_name as name,\n\t\t\t\t\tt.table_schema as schema,\n\t\t\t\t\tCOALESCE(s.n_tup_ins + s.n_tup_upd + s.n_tup_del, 0) as row_count,\n\t\t\t\t\tobj_description(c.oid) as comment,\n\t\t\t\t\tGREATEST(\n\t\t\t\t\t\tpg_stat_get_last_autoanalyze_time(c.oid),\n\t\t\t\t\t\tpg_stat_get_last_autovacuum_time(c.oid)\n\t\t\t\t\t) as last_modified\n\t\t\t\tFROM information_schema.tables t\n\t\t\t\tLEFT JOIN pg_class c ON c.relname = t.table_name AND c.relkind = 'r'\n\t\t\t\tLEFT JOIN pg_stat_user_tables s ON s.relname = t.table_name\n\t\t\t\tWHERE t.table_schema = 'public' \n\t\t\t\t\tAND t.table_type = 'BASE TABLE'\n\t\t\t\t\tAND t.table_name NOT IN (${sql.join(\n\t\t\t\t\t\tSYSTEM_BLACKLISTED_TABLES.map((table) => sql`${table}`),\n\t\t\t\t\t\tsql`, `\n\t\t\t\t\t)})\n\t\t\t\tORDER BY t.table_name\n\t\t\t`;\n\n\t\t\tconst result = await db.execute(query);\n\n\t\t\tconst tables: TableInfo[] = [];\n\t\t\tfor (const row of result.rows) {\n\t\t\t\tconst tableName = row.name as string;\n\t\t\t\tconst rowCount = await this.getTableRowCount(tableName);\n\t\t\t\tconst accessInfo = await this.getTableAccessInfo(tableName);\n\n\t\t\t\ttables.push({\n\t\t\t\t\tname: tableName,\n\t\t\t\t\tschema: row.schema as string,\n\t\t\t\t\trowCount,\n\t\t\t\t\tlastModified: row.last_modified as string | null,\n\t\t\t\t\tcomment: row.comment as string | null,\n\t\t\t\t\tisEditable: accessInfo.canEdit,\n\t\t\t\t\thasData: rowCount > 0,\n\t\t\t\t\taccessInfo: {\n\t\t\t\t\t\tcanView: accessInfo.canView,\n\t\t\t\t\t\tcanEdit: accessInfo.canEdit,\n\t\t\t\t\t\tisConfig: accessInfo.isConfig,\n\t\t\t\t\t\tconfigRoute: accessInfo.configRoute,\n\t\t\t\t\t\treason: accessInfo.reason\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn tables;\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error getting tables', { error: error.message });\n\t\t\tthrow new Error('Failed to retrieve database tables');\n\t\t}\n\t}\n\n\t/**\n\t * Get detailed schema information for a table\n\t */\n\tasync getTableSchema(tableName: string): Promise<TableSchema> {\n\t\ttry {\n\t\t\t// Validate table name\n\t\t\tif (!this.isValidTableName(tableName)) {\n\t\t\t\tthrow new Error('Invalid table name');\n\t\t\t}\n\n\t\t\t// Get column information\n\t\t\tconst columnsQuery = sql`\n\t\t\t\tSELECT \n\t\t\t\t\tc.column_name as name,\n\t\t\t\t\tc.data_type as type,\n\t\t\t\t\tc.is_nullable as nullable,\n\t\t\t\t\tc.column_default as default_value,\n\t\t\t\t\tc.character_maximum_length as max_length,\n\t\t\t\t\tc.numeric_precision,\n\t\t\t\t\tc.numeric_scale,\n\t\t\t\t\tcol_description(pgc.oid, c.ordinal_position) as comment,\n\t\t\t\t\tCASE \n\t\t\t\t\t\tWHEN pk.column_name IS NOT NULL THEN true \n\t\t\t\t\t\tELSE false \n\t\t\t\t\tEND as is_primary_key,\n\t\t\t\t\tCASE \n\t\t\t\t\t\tWHEN fk.column_name IS NOT NULL THEN true \n\t\t\t\t\t\tELSE false \n\t\t\t\t\tEND as is_foreign_key,\n\t\t\t\t\tfk.foreign_table_name,\n\t\t\t\t\tfk.foreign_column_name\n\t\t\t\tFROM information_schema.columns c\n\t\t\t\tLEFT JOIN pg_class pgc ON pgc.relname = c.table_name\n\t\t\t\tLEFT JOIN (\n\t\t\t\t\tSELECT ku.column_name\n\t\t\t\t\tFROM information_schema.table_constraints tc\n\t\t\t\t\tJOIN information_schema.key_column_usage ku \n\t\t\t\t\t\tON tc.constraint_name = ku.constraint_name\n\t\t\t\t\tWHERE tc.table_name = ${tableName}\n\t\t\t\t\t\tAND tc.constraint_type = 'PRIMARY KEY'\n\t\t\t\t) pk ON pk.column_name = c.column_name\n\t\t\t\tLEFT JOIN (\n\t\t\t\t\tSELECT \n\t\t\t\t\t\tku.column_name,\n\t\t\t\t\t\tccu.table_name as foreign_table_name,\n\t\t\t\t\t\tccu.column_name as foreign_column_name\n\t\t\t\t\tFROM information_schema.table_constraints tc\n\t\t\t\t\tJOIN information_schema.key_column_usage ku \n\t\t\t\t\t\tON tc.constraint_name = ku.constraint_name\n\t\t\t\t\tJOIN information_schema.constraint_column_usage ccu \n\t\t\t\t\t\tON tc.constraint_name = ccu.constraint_name\n\t\t\t\t\tWHERE tc.table_name = ${tableName}\n\t\t\t\t\t\tAND tc.constraint_type = 'FOREIGN KEY'\n\t\t\t\t) fk ON fk.column_name = c.column_name\n\t\t\t\tWHERE c.table_name = ${tableName}\n\t\t\t\tORDER BY c.ordinal_position\n\t\t\t`;\n\n\t\t\tconst columnsResult = await db.execute(columnsQuery);\n\n\t\t\tconst columns: ColumnInfo[] = columnsResult.rows.map((row: any) => ({\n\t\t\t\tname: row.name,\n\t\t\t\ttype: row.type,\n\t\t\t\tnullable: row.nullable === 'YES',\n\t\t\t\tdefaultValue: row.default_value,\n\t\t\t\tisPrimaryKey: row.is_primary_key,\n\t\t\t\tisForeignKey: row.is_foreign_key,\n\t\t\t\tforeignKeyTable: row.foreign_table_name,\n\t\t\t\tforeignKeyColumn: row.foreign_column_name,\n\t\t\t\tcomment: row.comment\n\t\t\t}));\n\n\t\t\t// Get foreign keys\n\t\t\tconst foreignKeys = await this.getTableForeignKeys(tableName);\n\n\t\t\t// Get indexes\n\t\t\tconst indexes = await this.getTableIndexes(tableName);\n\n\t\t\t// Get constraints\n\t\t\tconst constraints = await this.getTableConstraints(tableName);\n\n\t\t\treturn {\n\t\t\t\ttableName,\n\t\t\t\tcolumns,\n\t\t\t\tprimaryKey: columns.filter((c) => c.isPrimaryKey).map((c) => c.name),\n\t\t\t\tforeignKeys,\n\t\t\t\tindexes,\n\t\t\t\tconstraints\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error getting table schema', {\n\t\t\t\terror: error.message,\n\t\t\t\ttableName\n\t\t\t});\n\t\t\tthrow new Error(`Failed to retrieve schema for table: ${tableName}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get table data with pagination, filtering, and sorting\n\t */\n\tasync getTableData(\n\t\ttableName: string,\n\t\toptions: {\n\t\t\tpage: number;\n\t\t\tlimit: number;\n\t\t\tsearch?: string;\n\t\t\tsortField?: string;\n\t\t\tsortOrder: 'asc' | 'desc';\n\t\t}\n\t): Promise<TableDataResult> {\n\t\ttry {\n\t\t\t// Validate table name\n\t\t\tif (!this.isValidTableName(tableName)) {\n\t\t\t\tthrow new Error('Invalid table name');\n\t\t\t}\n\n\t\t\tconst { page, limit, search, sortField, sortOrder } = options;\n\t\t\tconst offset = (page - 1) * limit;\n\n\t\t\t// Build base query\n\t\t\tlet query = `SELECT * FROM \"${tableName}\"`;\n\t\t\tconst params: any[] = [];\n\t\t\tlet paramIndex = 1;\n\n\t\t\t// Add search filter if provided\n\t\t\tif (search) {\n\t\t\t\tconst schema = await this.getTableSchema(tableName);\n\t\t\t\tconst searchableColumns = schema.columns\n\t\t\t\t\t.filter((col) =>\n\t\t\t\t\t\t['text', 'varchar', 'character varying'].includes(col.type.toLowerCase())\n\t\t\t\t\t)\n\t\t\t\t\t.map((col) => `\"${col.name}\"::text ILIKE $${paramIndex++}`)\n\t\t\t\t\t.join(' OR ');\n\n\t\t\t\tif (searchableColumns) {\n\t\t\t\t\tquery += ` WHERE ${searchableColumns}`;\n\t\t\t\t\tparams.push(`%${search}%`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add sorting\n\t\t\tif (sortField) {\n\t\t\t\tquery += ` ORDER BY \"${sortField}\" ${sortOrder.toUpperCase()}`;\n\t\t\t}\n\n\t\t\t// Add pagination\n\t\t\tquery += ` LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;\n\t\t\tparams.push(limit, offset);\n\n\t\t\t// Execute data query\n\t\t\tconst dataResult = await db.execute(sql.raw(query, params));\n\n\t\t\t// Get total count\n\t\t\tlet countQuery = `SELECT COUNT(*) as total FROM \"${tableName}\"`;\n\t\t\tconst countParams: any[] = [];\n\n\t\t\tif (search) {\n\t\t\t\tconst schema = await this.getTableSchema(tableName);\n\t\t\t\tconst searchableColumns = schema.columns\n\t\t\t\t\t.filter((col) =>\n\t\t\t\t\t\t['text', 'varchar', 'character varying'].includes(col.type.toLowerCase())\n\t\t\t\t\t)\n\t\t\t\t\t.map((col) => `\"${col.name}\"::text ILIKE $1`)\n\t\t\t\t\t.join(' OR ');\n\n\t\t\t\tif (searchableColumns) {\n\t\t\t\t\tcountQuery += ` WHERE ${searchableColumns}`;\n\t\t\t\t\tcountParams.push(`%${search}%`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst countResult = await db.execute(sql.raw(countQuery, countParams));\n\t\t\tconst total = parseInt(countResult.rows[0].total as string);\n\n\t\t\treturn {\n\t\t\t\trows: dataResult.rows,\n\t\t\t\ttotal,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\ttotalPages: Math.ceil(total / limit)\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error getting table data', {\n\t\t\t\terror: error.message,\n\t\t\t\ttableName\n\t\t\t});\n\t\t\tthrow new Error(`Failed to retrieve data from table: ${tableName}`);\n\t\t}\n\t}\n\n\t/**\n\t * Update a single row in a table\n\t */\n\tasync updateRow(\n\t\ttableName: string,\n\t\trowId: string | number,\n\t\tdata: Record<string, any>\n\t): Promise<any> {\n\t\ttry {\n\t\t\t// Validate table and permissions\n\t\t\tif (!this.isTableEditable(tableName)) {\n\t\t\t\tthrow new Error('Table is not editable');\n\t\t\t}\n\n\t\t\tconst schema = await this.getTableSchema(tableName);\n\t\t\tconst primaryKeyColumn = schema.primaryKey[0];\n\n\t\t\tif (!primaryKeyColumn) {\n\t\t\t\tthrow new Error('Table must have a primary key for updates');\n\t\t\t}\n\n\t\t\t// Build update query\n\t\t\tconst setClause = Object.keys(data)\n\t\t\t\t.map((key, index) => `\"${key}\" = $${index + 2}`)\n\t\t\t\t.join(', ');\n\n\t\t\tconst query = `UPDATE \"${tableName}\" SET ${setClause} WHERE \"${primaryKeyColumn}\" = $1 RETURNING *`;\n\t\t\tconst params = [rowId, ...Object.values(data)];\n\n\t\t\tconst result = await db.execute(sql.raw(query, params));\n\n\t\t\tif (result.rows.length === 0) {\n\t\t\t\tthrow new Error('Row not found');\n\t\t\t}\n\n\t\t\treturn result.rows[0];\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error updating row', {\n\t\t\t\terror: error.message,\n\t\t\t\ttableName,\n\t\t\t\trowId\n\t\t\t});\n\t\t\tthrow new Error(`Failed to update row in table: ${tableName}`);\n\t\t}\n\t}\n\n\t/**\n\t * Create a new row in a table\n\t */\n\tasync createRow(tableName: string, data: Record<string, any>): Promise<any> {\n\t\ttry {\n\t\t\t// Validate table and permissions\n\t\t\tif (!this.isTableEditable(tableName)) {\n\t\t\t\tthrow new Error('Table is not editable');\n\t\t\t}\n\n\t\t\t// Build insert query\n\t\t\tconst columns = Object.keys(data)\n\t\t\t\t.map((key) => `\"${key}\"`)\n\t\t\t\t.join(', ');\n\t\t\tconst values = Object.keys(data)\n\t\t\t\t.map((_, index) => `$${index + 1}`)\n\t\t\t\t.join(', ');\n\n\t\t\tconst query = `INSERT INTO \"${tableName}\" (${columns}) VALUES (${values}) RETURNING *`;\n\t\t\tconst params = Object.values(data);\n\n\t\t\tconst result = await db.execute(sql.raw(query, params));\n\t\t\treturn result.rows[0];\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error creating row', {\n\t\t\t\terror: error.message,\n\t\t\t\ttableName\n\t\t\t});\n\t\t\tthrow new Error(`Failed to create row in table: ${tableName}`);\n\t\t}\n\t}\n\n\t/**\n\t * Delete a row from a table\n\t */\n\tasync deleteRow(tableName: string, rowId: string | number): Promise<boolean> {\n\t\ttry {\n\t\t\t// Validate table and permissions\n\t\t\tif (!this.isTableEditable(tableName)) {\n\t\t\t\tthrow new Error('Table is not editable');\n\t\t\t}\n\n\t\t\tconst schema = await this.getTableSchema(tableName);\n\t\t\tconst primaryKeyColumn = schema.primaryKey[0];\n\n\t\t\tif (!primaryKeyColumn) {\n\t\t\t\tthrow new Error('Table must have a primary key for deletions');\n\t\t\t}\n\n\t\t\tconst query = `DELETE FROM \"${tableName}\" WHERE \"${primaryKeyColumn}\" = $1`;\n\t\t\tconst result = await db.execute(sql.raw(query, [rowId]));\n\n\t\t\treturn result.rowCount > 0;\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error deleting row', {\n\t\t\t\terror: error.message,\n\t\t\t\ttableName,\n\t\t\t\trowId\n\t\t\t});\n\t\t\tthrow new Error(`Failed to delete row from table: ${tableName}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get a single row by ID\n\t */\n\tasync getRowById(tableName: string, rowId: string | number): Promise<any | null> {\n\t\ttry {\n\t\t\tif (!this.isValidTableName(tableName)) {\n\t\t\t\tthrow new Error('Invalid table name');\n\t\t\t}\n\n\t\t\tconst schema = await this.getTableSchema(tableName);\n\t\t\tconst primaryKeyColumn = schema.primaryKey[0];\n\n\t\t\tif (!primaryKeyColumn) {\n\t\t\t\tthrow new Error('Table must have a primary key');\n\t\t\t}\n\n\t\t\tconst query = `SELECT * FROM \"${tableName}\" WHERE \"${primaryKeyColumn}\" = $1`;\n\t\t\tconst result = await db.execute(sql.raw(query, [rowId]));\n\n\t\t\treturn result.rows[0] || null;\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error getting row by ID', {\n\t\t\t\terror: error.message,\n\t\t\t\ttableName,\n\t\t\t\trowId\n\t\t\t});\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Perform bulk operations on multiple rows\n\t */\n\tasync bulkOperation(\n\t\ttableName: string,\n\t\toperation: 'update' | 'delete',\n\t\trowIds: (string | number)[],\n\t\tdata?: Record<string, any>\n\t): Promise<{ affected: number }> {\n\t\ttry {\n\t\t\t// Validate table and permissions\n\t\t\tif (!this.isTableEditable(tableName)) {\n\t\t\t\tthrow new Error('Table is not editable');\n\t\t\t}\n\n\t\t\tconst schema = await this.getTableSchema(tableName);\n\t\t\tconst primaryKeyColumn = schema.primaryKey[0];\n\n\t\t\tif (!primaryKeyColumn) {\n\t\t\t\tthrow new Error('Table must have a primary key for bulk operations');\n\t\t\t}\n\n\t\t\tlet query: string;\n\t\t\tlet params: any[];\n\n\t\t\tif (operation === 'delete') {\n\t\t\t\tconst placeholders = rowIds.map((_, index) => `$${index + 1}`).join(', ');\n\t\t\t\tquery = `DELETE FROM \"${tableName}\" WHERE \"${primaryKeyColumn}\" IN (${placeholders})`;\n\t\t\t\tparams = rowIds;\n\t\t\t} else if (operation === 'update' && data) {\n\t\t\t\tconst setClause = Object.keys(data)\n\t\t\t\t\t.map((key, index) => `\"${key}\" = $${index + 1}`)\n\t\t\t\t\t.join(', ');\n\t\t\t\tconst placeholders = rowIds\n\t\t\t\t\t.map((_, index) => `$${Object.keys(data).length + index + 1}`)\n\t\t\t\t\t.join(', ');\n\t\t\t\tquery = `UPDATE \"${tableName}\" SET ${setClause} WHERE \"${primaryKeyColumn}\" IN (${placeholders})`;\n\t\t\t\tparams = [...Object.values(data), ...rowIds];\n\t\t\t} else {\n\t\t\t\tthrow new Error('Invalid bulk operation');\n\t\t\t}\n\n\t\t\tconst result = await db.execute(sql.raw(query, params));\n\t\t\treturn { affected: result.rowCount };\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error performing bulk operation', {\n\t\t\t\terror: error.message,\n\t\t\t\ttableName,\n\t\t\t\toperation\n\t\t\t});\n\t\t\tthrow new Error(`Failed to perform bulk ${operation} on table: ${tableName}`);\n\t\t}\n\t}\n\n\t/**\n\t * Export table data as CSV\n\t */\n\tasync exportTableAsCSV(tableName: string): Promise<string> {\n\t\ttry {\n\t\t\tif (!this.isValidTableName(tableName)) {\n\t\t\t\tthrow new Error('Invalid table name');\n\t\t\t}\n\n\t\t\tconst query = `SELECT * FROM \"${tableName}\"`;\n\t\t\tconst result = await db.execute(sql.raw(query));\n\n\t\t\tif (result.rows.length === 0) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\t// Generate CSV headers\n\t\t\tconst headers = Object.keys(result.rows[0]).join(',');\n\n\t\t\t// Generate CSV rows\n\t\t\tconst rows = result.rows.map((row) =>\n\t\t\t\tObject.values(row)\n\t\t\t\t\t.map((value) => {\n\t\t\t\t\t\t// Escape CSV values\n\t\t\t\t\t\tif (value === null || value === undefined) return '';\n\t\t\t\t\t\tconst stringValue = String(value);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tstringValue.includes(',') ||\n\t\t\t\t\t\t\tstringValue.includes('\"') ||\n\t\t\t\t\t\t\tstringValue.includes('\\n')\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn `\"${stringValue.replace(/\"/g, '\"\"')}\"`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn stringValue;\n\t\t\t\t\t})\n\t\t\t\t\t.join(',')\n\t\t\t);\n\n\t\t\treturn [headers, ...rows].join('\\n');\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error exporting table as CSV', {\n\t\t\t\terror: error.message,\n\t\t\t\ttableName\n\t\t\t});\n\t\t\tthrow new Error(`Failed to export table: ${tableName}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get table relationships (foreign keys)\n\t */\n\tasync getTableRelationships(tableName: string): Promise<ForeignKeyInfo[]> {\n\t\ttry {\n\t\t\treturn await this.getTableForeignKeys(tableName);\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error getting table relationships', {\n\t\t\t\terror: error.message,\n\t\t\t\ttableName\n\t\t\t});\n\t\t\tthrow new Error(`Failed to get relationships for table: ${tableName}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get database statistics\n\t */\n\tasync getDatabaseStats(): Promise<any> {\n\t\ttry {\n\t\t\tconst statsQuery = sql`\n\t\t\t\tSELECT \n\t\t\t\t\tschemaname,\n\t\t\t\t\ttablename,\n\t\t\t\t\tattname as column_name,\n\t\t\t\t\tn_distinct,\n\t\t\t\t\tmost_common_vals,\n\t\t\t\t\tmost_common_freqs,\n\t\t\t\t\thistogram_bounds\n\t\t\t\tFROM pg_stats \n\t\t\t\tWHERE schemaname = 'public'\n\t\t\t\tORDER BY tablename, attname\n\t\t\t`;\n\n\t\t\tconst sizeQuery = sql`\n\t\t\t\tSELECT \n\t\t\t\t\tpg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,\n\t\t\t\t\tpg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,\n\t\t\t\t\tpg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) as index_size,\n\t\t\t\t\ttablename\n\t\t\t\tFROM pg_tables \n\t\t\t\tWHERE schemaname = 'public'\n\t\t\t\tORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC\n\t\t\t`;\n\n\t\t\tconst [statsResult, sizeResult] = await Promise.all([\n\t\t\t\tdb.execute(statsQuery),\n\t\t\t\tdb.execute(sizeQuery)\n\t\t\t]);\n\n\t\t\treturn {\n\t\t\t\tcolumnStats: statsResult.rows,\n\t\t\t\ttableSizes: sizeResult.rows,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error getting database stats', { error: error.message });\n\t\t\tthrow new Error('Failed to retrieve database statistics');\n\t\t}\n\t}\n\n\t/**\n\t * Validate row data against table schema\n\t */\n\tasync validateRowData(tableName: string, data: Record<string, any>): Promise<ValidationResult> {\n\t\ttry {\n\t\t\tconst schema = await this.getTableSchema(tableName);\n\t\t\tconst errors: string[] = [];\n\n\t\t\tfor (const column of schema.columns) {\n\t\t\t\tconst value = data[column.name];\n\n\t\t\t\t// Check required fields\n\t\t\t\tif (!column.nullable && !column.defaultValue && (value === null || value === undefined)) {\n\t\t\t\t\terrors.push(`Column '${column.name}' is required`);\n\t\t\t\t}\n\n\t\t\t\t// Type validation (basic)\n\t\t\t\tif (value !== null && value !== undefined) {\n\t\t\t\t\tif (column.type.includes('int') && !Number.isInteger(Number(value))) {\n\t\t\t\t\t\terrors.push(`Column '${column.name}' must be an integer`);\n\t\t\t\t\t}\n\t\t\t\t\tif (column.type.includes('bool') && typeof value !== 'boolean') {\n\t\t\t\t\t\terrors.push(`Column '${column.name}' must be a boolean`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tvalid: errors.length === 0,\n\t\t\t\terrors\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tlogger.error('DatabaseService', 'Error validating row data', {\n\t\t\t\terror: error.message,\n\t\t\t\ttableName\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tvalid: false,\n\t\t\t\terrors: ['Validation failed due to schema error']\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Check if a table is editable through the live database interface\n\t */\n\tasync isTableEditable(tableName: string): Promise<boolean> {\n\t\treturn EDITABLE_TABLES.includes(tableName) && this.isValidTableName(tableName);\n\t}\n\n\t/**\n\t * Check if a table is a configuration table that should use dedicated config panels\n\t */\n\tasync isConfigurationTable(tableName: string): Promise<boolean> {\n\t\treturn CONFIGURATION_TABLES.includes(tableName);\n\t}\n\n\t/**\n\t * Get the appropriate config panel route for a configuration table\n\t */\n\tasync getConfigPanelRoute(tableName: string): Promise<string | null> {\n\t\tconst configRoutes: Record<string, string> = {\n\t\t\t// Core configuration\n\t\t\tsite_settings: '/admin/settings',\n\t\t\tfeature_flags: '/admin/settings/features',\n\t\t\tbrand_configurations: '/admin/config/brand',\n\t\t\tui_quotes: '/admin/config/ui',\n\t\t\tui_collections: '/admin/config/ui',\n\n\t\t\t// Economy configuration\n\t\t\txp_action_settings: '/admin/config/xp',\n\t\t\txp_clout_settings: '/admin/config/xp',\n\t\t\ttreasury_settings: '/admin/config/economy',\n\t\t\tairdrop_settings: '/admin/config/economy',\n\t\t\teconomy_settings: '/admin/config/economy',\n\t\t\teconomy_config_overrides: '/admin/config/economy',\n\t\t\tdgt_packages: '/admin/shop-management/dgt-packages',\n\n\t\t\t// Forum configuration\n\t\t\tforum_categories: '/admin/config/zones',\n\t\t\tforum_structure: '/admin/config/zones',\n\t\t\trules: '/admin/forum/rules',\n\t\t\tcustom_emojis: '/admin/emojis',\n\t\t\temoji_packs: '/admin/emojis',\n\n\t\t\t// Shop configuration\n\t\t\tproduct_categories: '/admin/shop-management/categories',\n\t\t\trarities: '/admin/shop-management/rarities',\n\t\t\tanimation_packs: '/admin/animation-packs',\n\t\t\tsignature_items: '/admin/shop-management/signature-items',\n\n\t\t\t// User configuration\n\t\t\troles: '/admin/roles',\n\t\t\tpermissions: '/admin/permissions',\n\t\t\ttitles: '/admin/titles',\n\t\t\tbadges: '/admin/shop-management/badges',\n\t\t\tavatar_frames: '/admin/avatar-frames',\n\n\t\t\t// System configuration\n\t\t\tannouncements: '/admin/announcements',\n\t\t\tmedia_library: '/admin/media'\n\t\t};\n\n\t\treturn configRoutes[tableName] || null;\n\t}\n\n\t/**\n\t * Get table access status and appropriate guidance\n\t */\n\tasync getTableAccessInfo(tableName: string): Promise<{\n\t\tcanView: boolean;\n\t\tcanEdit: boolean;\n\t\tisConfig: boolean;\n\t\tblocked: boolean;\n\t\tconfigRoute?: string;\n\t\treason?: string;\n\t}> {\n\t\t// System blacklisted tables\n\t\tif (SYSTEM_BLACKLISTED_TABLES.includes(tableName)) {\n\t\t\treturn {\n\t\t\t\tcanView: false,\n\t\t\t\tcanEdit: false,\n\t\t\t\tisConfig: false,\n\t\t\t\tblocked: true,\n\t\t\t\treason: 'System table access is restricted for security'\n\t\t\t};\n\t\t}\n\n\t\t// Configuration tables\n\t\tif (CONFIGURATION_TABLES.includes(tableName)) {\n\t\t\tconst configRoute = await this.getConfigPanelRoute(tableName);\n\t\t\treturn {\n\t\t\t\tcanView: true,\n\t\t\t\tcanEdit: false,\n\t\t\t\tisConfig: true,\n\t\t\t\tblocked: false,\n\t\t\t\tconfigRoute,\n\t\t\t\treason: 'Configuration table - use dedicated config panel'\n\t\t\t};\n\t\t}\n\n\t\t// Read-only tables\n\t\tif (READ_ONLY_TABLES.includes(tableName)) {\n\t\t\treturn {\n\t\t\t\tcanView: true,\n\t\t\t\tcanEdit: false,\n\t\t\t\tisConfig: false,\n\t\t\t\tblocked: false,\n\t\t\t\treason: 'Read-only table for data integrity'\n\t\t\t};\n\t\t}\n\n\t\t// Editable tables\n\t\tif (EDITABLE_TABLES.includes(tableName)) {\n\t\t\treturn {\n\t\t\t\tcanView: true,\n\t\t\t\tcanEdit: true,\n\t\t\t\tisConfig: false,\n\t\t\t\tblocked: false\n\t\t\t};\n\t\t}\n\n\t\t// Unknown tables - default to blocked\n\t\treturn {\n\t\t\tcanView: false,\n\t\t\tcanEdit: false,\n\t\t\tisConfig: false,\n\t\t\tblocked: true,\n\t\t\treason: 'Table not in allowed list'\n\t\t};\n\t}\n\n\t// Private helper methods\n\n\tprivate isValidTableName(tableName: string): boolean {\n\t\t// Basic SQL injection prevention\n\t\treturn (\n\t\t\t/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(tableName) && !SYSTEM_BLACKLISTED_TABLES.includes(tableName)\n\t\t);\n\t}\n\n\tasync getTableRowCount(tableName: string): Promise<number> {\n\t\ttry {\n\t\t\tconst query = sql`SELECT COUNT(*) as count FROM ${sql.identifier(tableName)}`;\n\t\t\tconst result = await db.execute(query);\n\t\t\treturn parseInt(result.rows[0].count as string);\n\t\t} catch (error) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate async getTableForeignKeys(tableName: string): Promise<ForeignKeyInfo[]> {\n\t\tconst query = sql`\n\t\t\tSELECT \n\t\t\t\tkcu.column_name,\n\t\t\t\tccu.table_name as referenced_table,\n\t\t\t\tccu.column_name as referenced_column,\n\t\t\t\ttc.constraint_name\n\t\t\tFROM information_schema.table_constraints tc\n\t\t\tJOIN information_schema.key_column_usage kcu \n\t\t\t\tON tc.constraint_name = kcu.constraint_name\n\t\t\tJOIN information_schema.constraint_column_usage ccu \n\t\t\t\tON tc.constraint_name = ccu.constraint_name\n\t\t\tWHERE tc.table_name = ${tableName}\n\t\t\t\tAND tc.constraint_type = 'FOREIGN KEY'\n\t\t`;\n\n\t\tconst result = await db.execute(query);\n\t\treturn result.rows.map((row: any) => ({\n\t\t\tcolumnName: row.column_name,\n\t\t\treferencedTable: row.referenced_table,\n\t\t\treferencedColumn: row.referenced_column,\n\t\t\tconstraintName: row.constraint_name\n\t\t}));\n\t}\n\n\tprivate async getTableIndexes(tableName: string): Promise<IndexInfo[]> {\n\t\tconst query = sql`\n\t\t\tSELECT \n\t\t\t\ti.relname as index_name,\n\t\t\t\tarray_agg(a.attname ORDER BY c.ordinality) as columns,\n\t\t\t\tix.indisunique as is_unique,\n\t\t\t\tix.indisprimary as is_primary\n\t\t\tFROM pg_class i\n\t\t\tJOIN pg_index ix ON ix.indexrelid = i.oid\n\t\t\tJOIN pg_class t ON ix.indrelid = t.oid\n\t\t\tJOIN unnest(ix.indkey) WITH ORDINALITY AS c(attnum, ordinality) ON true\n\t\t\tJOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = c.attnum\n\t\t\tWHERE t.relname = ${tableName}\n\t\t\t\tAND i.relkind = 'i'\n\t\t\tGROUP BY i.relname, ix.indisunique, ix.indisprimary\n\t\t`;\n\n\t\tconst result = await db.execute(query);\n\t\treturn result.rows.map((row: any) => ({\n\t\t\tname: row.index_name,\n\t\t\tcolumns: row.columns,\n\t\t\tisUnique: row.is_unique,\n\t\t\tisPrimary: row.is_primary\n\t\t}));\n\t}\n\n\tprivate async getTableConstraints(tableName: string): Promise<ConstraintInfo[]> {\n\t\tconst query = sql`\n\t\t\tSELECT \n\t\t\t\ttc.constraint_name as name,\n\t\t\t\ttc.constraint_type as type,\n\t\t\t\tarray_agg(kcu.column_name) as columns,\n\t\t\t\tcc.check_clause as definition\n\t\t\tFROM information_schema.table_constraints tc\n\t\t\tLEFT JOIN information_schema.key_column_usage kcu \n\t\t\t\tON tc.constraint_name = kcu.constraint_name\n\t\t\tLEFT JOIN information_schema.check_constraints cc \n\t\t\t\tON tc.constraint_name = cc.constraint_name\n\t\t\tWHERE tc.table_name = ${tableName}\n\t\t\tGROUP BY tc.constraint_name, tc.constraint_type, cc.check_clause\n\t\t`;\n\n\t\tconst result = await db.execute(query);\n\t\treturn result.rows.map((row: any) => ({\n\t\t\tname: row.name,\n\t\t\ttype: row.type,\n\t\t\tcolumns: row.columns || [],\n\t\t\tdefinition: row.definition || ''\n\t\t}));\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/database/query.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'saveToHistory' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":34,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Query Controller\n *\n * Handles SQL query execution requests with proper validation and audit logging.\n */\n\nimport type { Request, Response } from 'express';\nimport { QueryService } from './query.service';\nimport { logger } from '@server/src/core/logger';\nimport { adminCreateAuditLogEntry } from '../../shared/admin-operation-utils';\nimport { getUserId } from '../../admin.middleware';\nimport { z } from 'zod';\n\nconst queryService = new QueryService();\n\n// Request validation schemas\nconst executeQuerySchema = z.object({\n\tquery: z.string().min(1).max(50000), // Limit query size\n\tsaveToHistory: z.boolean().default(true)\n});\n\nconst queryHistorySchema = z.object({\n\tuserId: z.coerce.number().optional(),\n\tlimit: z.coerce.number().min(1).max(100).default(50)\n});\n\n/**\n * Execute a SQL query with safety checks\n */\nexport async function executeQuery(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { query, saveToHistory } = executeQuerySchema.parse(req.body);\n\n\t\t// Additional safeguard: only allow read-only/select queries\n\t\tconst READ_ONLY_REGEX = /^(\\s*)(SELECT|WITH|EXPLAIN)\\b/i;\n\t\tif (!READ_ONLY_REGEX.test(query)) {\n\t\t\tlogger.warn('QueryController', 'Blocked non-read SQL statement', {\n\t\t\t\tuserId,\n\t\t\t\tqueryPreview: query.slice(0, 100)\n\t\t\t});\n\t\t\treturn res.status(403).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Only read-only SELECT/EXPLAIN queries are permitted.'\n\t\t\t});\n\t\t}\n\n\t\t// Reject multi-statement queries to avoid stacked injections\n\t\tif (query.includes(';')) {\n\t\t\tlogger.warn('QueryController', 'Blocked multi-statement SQL', {\n\t\t\t\tuserId,\n\t\t\t\tqueryPreview: query.slice(0, 100)\n\t\t\t});\n\t\t\treturn res.status(403).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Multiple SQL statements are not allowed.'\n\t\t\t});\n\t\t}\n\n\t\t// Log query attempt\n\t\tlogger.info('QueryController', 'SQL query execution requested', {\n\t\t\tuserId,\n\t\t\tqueryLength: query.length,\n\t\t\tqueryPreview: query.substring(0, 100) + '...'\n\t\t});\n\n\t\tconst result = await queryService.executeQuery(query, userId);\n\n\t\t// Log query execution result\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: result.success ? 'database_query_executed' : 'database_query_failed',\n\t\t\tdetails: `SQL query ${result.success ? 'executed successfully' : 'failed'}: ${query.substring(0, 200)}${query.length > 200 ? '...' : ''}`,\n\t\t\tmetadata: {\n\t\t\t\tqueryLength: query.length,\n\t\t\t\texecutionTime: result.executionTime,\n\t\t\t\trowCount: result.rowCount,\n\t\t\t\tsuccess: result.success,\n\t\t\t\terror: result.error\n\t\t\t}\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: result\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('QueryController', 'Error executing query', { error: error.message });\n\t\tres.status(400).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Invalid query request'\n\t\t});\n\t}\n}\n\n/**\n * Validate a SQL query without executing it\n */\nexport async function validateQuery(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { query } = z.object({ query: z.string().min(1) }).parse(req.body);\n\n\t\tconst validation = queryService.validateQuery(query);\n\n\t\t// Log validation request\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_query_validated',\n\t\t\tdetails: `Query validation: ${validation.isValid ? 'valid' : 'invalid'}`,\n\t\t\tmetadata: {\n\t\t\t\tqueryLength: query.length,\n\t\t\t\tisValid: validation.isValid,\n\t\t\t\terrors: validation.errors,\n\t\t\t\twarnings: validation.warnings\n\t\t\t}\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: validation\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('QueryController', 'Error validating query', { error: error.message });\n\t\tres.status(400).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Invalid validation request'\n\t\t});\n\t}\n}\n\n/**\n * Get query execution history\n */\nexport async function getQueryHistory(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { userId: targetUserId, limit } = queryHistorySchema.parse(req.query);\n\n\t\t// Only allow users to see their own history unless they're super admin\n\t\tconst historyUserId = targetUserId || userId;\n\n\t\tconst history = queryService.getQueryHistory(historyUserId).slice(0, limit);\n\n\t\t// Log access\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_query_history_viewed',\n\t\t\tdetails: `Viewed query history (${history.length} entries)`,\n\t\t\tmetadata: {\n\t\t\t\ttargetUserId: historyUserId,\n\t\t\t\tentryCount: history.length\n\t\t\t}\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: history\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('QueryController', 'Error getting query history', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to retrieve query history'\n\t\t});\n\t}\n}\n\n/**\n * Clear query history\n */\nexport async function clearQueryHistory(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { userId: targetUserId } = z\n\t\t\t.object({\n\t\t\t\tuserId: z.coerce.number().optional()\n\t\t\t})\n\t\t\t.parse(req.body);\n\n\t\t// Only allow users to clear their own history unless they're super admin\n\t\tconst clearUserId = targetUserId || userId;\n\n\t\tqueryService.clearHistory(clearUserId);\n\n\t\t// Log clearing\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_query_history_cleared',\n\t\t\tdetails: `Cleared query history for user ${clearUserId}`,\n\t\t\tmetadata: {\n\t\t\t\ttargetUserId: clearUserId\n\t\t\t}\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: 'Query history cleared'\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('QueryController', 'Error clearing query history', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to clear query history'\n\t\t});\n\t}\n}\n\n/**\n * Get suggested queries for common operations\n */\nexport async function getSuggestedQueries(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\tconst suggestions = queryService.getSuggestedQueries();\n\n\t\t// Log access\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_query_suggestions_viewed',\n\t\t\tdetails: `Viewed query suggestions (${suggestions.length} available)`\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: suggestions\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('QueryController', 'Error getting suggested queries', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to retrieve suggested queries'\n\t\t});\n\t}\n}\n\n/**\n * Export query results as CSV\n */\nexport async function exportQueryResults(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { query } = z.object({ query: z.string().min(1) }).parse(req.body);\n\n\t\t// Execute query\n\t\tconst result = await queryService.executeQuery(query, userId);\n\n\t\tif (!result.success) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: result.error\n\t\t\t});\n\t\t}\n\n\t\t// Convert to CSV\n\t\tconst csvData = queryService.formatResultAsCSV(result);\n\n\t\t// Log export\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_query_exported',\n\t\t\tdetails: `Exported query results as CSV (${result.rowCount} rows)`,\n\t\t\tmetadata: {\n\t\t\t\tqueryLength: query.length,\n\t\t\t\trowCount: result.rowCount,\n\t\t\t\texportSize: csvData.length\n\t\t\t}\n\t\t});\n\n\t\tres.setHeader('Content-Type', 'text/csv');\n\t\tres.setHeader('Content-Disposition', `attachment; filename=\"query_results_${Date.now()}.csv\"`);\n\t\tres.send(csvData);\n\t} catch (error: any) {\n\t\tlogger.error('QueryController', 'Error exporting query results', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to export query results'\n\t\t});\n\t}\n}\n\n/**\n * Get query performance metrics\n */\nexport async function getQueryMetrics(req: Request, res: Response) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\tconst history = queryService.getQueryHistory();\n\n\t\t// Calculate metrics\n\t\tconst totalQueries = history.length;\n\t\tconst successfulQueries = history.filter((h) => h.success).length;\n\t\tconst failedQueries = totalQueries - successfulQueries;\n\t\tconst avgExecutionTime =\n\t\t\thistory.length > 0\n\t\t\t\t? history.reduce((sum, h) => sum + h.executionTime, 0) / history.length\n\t\t\t\t: 0;\n\t\tconst totalRowsReturned = history.reduce((sum, h) => sum + h.rowCount, 0);\n\n\t\tconst metrics = {\n\t\t\ttotalQueries,\n\t\t\tsuccessfulQueries,\n\t\t\tfailedQueries,\n\t\t\tsuccessRate: totalQueries > 0 ? ((successfulQueries / totalQueries) * 100).toFixed(2) : 0,\n\t\t\tavgExecutionTime: Math.round(avgExecutionTime),\n\t\t\ttotalRowsReturned,\n\t\t\trecentActivity: history.slice(0, 10)\n\t\t};\n\n\t\t// Log access\n\t\tawait adminCreateAuditLogEntry({\n\t\t\tadminUserId: userId,\n\t\t\taction: 'database_query_metrics_viewed',\n\t\t\tdetails: 'Viewed query performance metrics'\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: metrics\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('QueryController', 'Error getting query metrics', { error: error.message });\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\terror: 'Failed to retrieve query metrics'\n\t\t});\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/database/query.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/dev/seeding.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/dgt-packages/dgt-packages.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/dgt-packages/dgt-packages.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/dgt-packages/dgt-packages.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/economy/economy.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/economy/economy.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/email-templates/email-templates.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":39,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":79,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":79,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":99,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":99,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":123,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":123,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":158,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":158,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":186,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":186,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":209,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":209,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":232,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":232,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":269,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":269,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":294,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":294,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":317,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":317,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":317,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":317,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { z } from 'zod';\nimport { emailTemplateService, emailTemplateSchema } from './email-templates.service';\nimport { formatAdminResponse, AdminOperationBoundary } from '../../shared';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\n\n// Query parameters schema for filtering\nconst filterTemplatesSchema = z.object({\n\tcategory: z.enum(['auth', 'notification', 'marketing', 'transactional', 'general']).optional(),\n\tisActive: z.coerce.boolean().optional(),\n\tsearch: z.string().optional(),\n\tpage: z.coerce.number().min(1).default(1),\n\tlimit: z.coerce.number().min(1).max(100).default(20)\n});\n\nconst previewTemplateSchema = z\n\t.object({\n\t\tvariables: z.record(z.any()).default({}),\n\t\ttemplateId: z.coerce.number().optional(),\n\t\ttemplateKey: z.string().optional()\n\t})\n\t.refine((data) => data.templateId || data.templateKey, {\n\t\tmessage: 'Either templateId or templateKey must be provided'\n\t});\n\nconst sendEmailSchema = z.object({\n\ttemplateKey: z.string().min(1),\n\trecipientEmail: z.string().email(),\n\tvariables: z.record(z.any()).default({}),\n\trecipientUserId: z.string().uuid().optional()\n});\n\nexport class EmailTemplateController {\n\t/**\n\t * GET /api/admin/email-templates\n\t * Get all email templates with filtering\n\t */\n\tasync getAllTemplates(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'FETCH_EMAIL_TEMPLATES',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst filters = filterTemplatesSchema.parse(req.query);\n\n\t\t\tconst templates = await emailTemplateService.getAllTemplates({\n\t\t\t\tcategory: filters.category,\n\t\t\t\tisActive: filters.isActive,\n\t\t\t\tsearch: filters.search\n\t\t\t});\n\n\t\t\t// Pagination\n\t\t\tconst startIndex = (filters.page - 1) * filters.limit;\n\t\t\tconst endIndex = startIndex + filters.limit;\n\t\t\tconst paginatedTemplates = templates.slice(startIndex, endIndex);\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\ttemplates: paginatedTemplates,\n\t\t\t\t\tpagination: {\n\t\t\t\t\t\tpage: filters.page,\n\t\t\t\t\t\tlimit: filters.limit,\n\t\t\t\t\t\ttotal: templates.length,\n\t\t\t\t\t\ttotalPages: Math.ceil(templates.length / filters.limit)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'FETCH_EMAIL_TEMPLATES',\n\t\t\t\t'emailTemplate'\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/email-templates/:id\n\t * Get a single email template by ID or key\n\t */\n\tasync getTemplate(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'FETCH_EMAIL_TEMPLATE',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = req.params;\n\t\t\tconst templateId = isNaN(id) ? id : id;\n\n\t\t\tconst template = await emailTemplateService.getTemplate(templateId);\n\n\t\t\treturn formatAdminResponse({ template }, 'FETCH_EMAIL_TEMPLATE', 'emailTemplate');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/email-templates\n\t * Create a new email template\n\t */\n\tasync createTemplate(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'CREATE_EMAIL_TEMPLATE',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst templateData = emailTemplateSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst template = await emailTemplateService.createTemplate(templateData, adminId);\n\n\t\t\treturn formatAdminResponse({ template }, 'CREATE_EMAIL_TEMPLATE', 'emailTemplate');\n\t\t});\n\t}\n\n\t/**\n\t * PUT /api/admin/email-templates/:id\n\t * Update an email template\n\t */\n\tasync updateTemplate(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'EMAIL_TEMPLATE_OPERATION',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = req.params;\n\t\t\tconst templateId = id;\n\t\t\tconst updateData = emailTemplateSchema.partial().parse(req.body);\n\t\t\tconst { changeDescription } = req.body;\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tif (isNaN(templateId)) {\n\t\t\t\tthrow new AdminError('Invalid template ID', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst template = await emailTemplateService.updateTemplate(\n\t\t\t\ttemplateId,\n\t\t\t\tupdateData,\n\t\t\t\tadminId,\n\t\t\t\tchangeDescription\n\t\t\t);\n\n\t\t\treturn formatAdminResponse({ template }, 'UPDATE_EMAIL_TEMPLATE', 'emailTemplate');\n\t\t});\n\t}\n\n\t/**\n\t * DELETE /api/admin/email-templates/:id\n\t * Delete (deactivate) an email template\n\t */\n\tasync deleteTemplate(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'EMAIL_TEMPLATE_OPERATION',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = req.params;\n\t\t\tconst templateId = id;\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tif (isNaN(templateId)) {\n\t\t\t\tthrow new AdminError('Invalid template ID', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst result = await emailTemplateService.deleteTemplate(templateId, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'DELETE_EMAIL_TEMPLATE', 'emailTemplate');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/email-templates/preview\n\t * Preview template with sample data\n\t */\n\tasync previewTemplate(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'EMAIL_TEMPLATE_OPERATION',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { variables, templateId, templateKey } = previewTemplateSchema.parse(req.body);\n\n\t\t\tconst identifier = templateId || templateKey;\n\t\t\tif (!identifier) {\n\t\t\t\tthrow new AdminError('Template ID or key required', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst preview = await emailTemplateService.previewTemplate(identifier, variables);\n\n\t\t\treturn formatAdminResponse(preview, 'PREVIEW_EMAIL_TEMPLATE', 'emailTemplate');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/email-templates/:id/versions\n\t * Get template version history\n\t */\n\tasync getTemplateVersions(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'EMAIL_TEMPLATE_OPERATION',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = req.params;\n\t\t\tconst templateId = id;\n\n\t\t\tif (isNaN(templateId)) {\n\t\t\t\tthrow new AdminError('Invalid template ID', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst versions = await emailTemplateService.getTemplateVersions(templateId);\n\n\t\t\treturn formatAdminResponse({ versions }, 'FETCH_EMAIL_TEMPLATE_VERSIONS', 'emailTemplate');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/email-templates/:id/restore/:versionId\n\t * Restore a previous template version\n\t */\n\tasync restoreVersion(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'EMAIL_TEMPLATE_OPERATION',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id, versionId } = req.params;\n\t\t\tconst templateId = id;\n\t\t\tconst versionNumber = versionId;\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tif (isNaN(templateId) || isNaN(versionNumber)) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Invalid template or version ID',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst template = await emailTemplateService.restoreVersion(\n\t\t\t\ttemplateId,\n\t\t\t\tversionNumber,\n\t\t\t\tadminId\n\t\t\t);\n\n\t\t\treturn formatAdminResponse({ template }, 'RESTORE_EMAIL_TEMPLATE_VERSION', 'emailTemplate');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/email-templates/:id/stats\n\t * Get template usage statistics\n\t */\n\tasync getTemplateStats(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'EMAIL_TEMPLATE_OPERATION',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = req.params;\n\t\t\tconst { days } = req.query;\n\t\t\tconst templateId = id;\n\t\t\tconst statsDays = days ? Number(days) : 30;\n\n\t\t\tif (isNaN(templateId)) {\n\t\t\t\tthrow new AdminError('Invalid template ID', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst stats = await emailTemplateService.getTemplateStats(templateId, statsDays);\n\n\t\t\treturn formatAdminResponse({ stats }, 'FETCH_EMAIL_TEMPLATE_STATS', 'emailTemplate');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/email-templates/send\n\t * Send email using template (for testing)\n\t */\n\tasync sendEmail(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'EMAIL_TEMPLATE_OPERATION',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\t\treturn boundary.execute(async () => {\n\t\t\tconst emailData = sendEmailSchema.parse(req.body);\n\n\t\t\tconst result = await emailTemplateService.sendEmail(\n\t\t\t\temailData.templateKey,\n\t\t\t\temailData.recipientEmail,\n\t\t\t\temailData.variables,\n\t\t\t\temailData.recipientUserId\n\t\t\t);\n\n\t\t\treturn formatAdminResponse(result, 'SEND_EMAIL_TEMPLATE', 'emailTemplate');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/email-templates/categories\n\t * Get available template categories\n\t */\n\tasync getCategories(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'EMAIL_TEMPLATE_OPERATION',\n\t\t\tentityType: 'emailTemplate'\n\t\t});\n\t\treturn boundary.execute(async () => {\n\t\t\tconst categories = [\n\t\t\t\t{\n\t\t\t\t\tvalue: 'auth',\n\t\t\t\t\tlabel: 'Authentication',\n\t\t\t\t\tdescription: 'Login, registration, password reset emails'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tvalue: 'notification',\n\t\t\t\t\tlabel: 'Notifications',\n\t\t\t\t\tdescription: 'System notifications and alerts'\n\t\t\t\t},\n\t\t\t\t{ value: 'marketing', label: 'Marketing', description: 'Promotional emails and campaigns' },\n\t\t\t\t{\n\t\t\t\t\tvalue: 'transactional',\n\t\t\t\t\tlabel: 'Transactional',\n\t\t\t\t\tdescription: 'Purchase confirmations, receipts'\n\t\t\t\t},\n\t\t\t\t{ value: 'general', label: 'General', description: 'Miscellaneous email templates' }\n\t\t\t];\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{ categories },\n\t\t\t\t'FETCH_EMAIL_TEMPLATE_CATEGORIES',\n\t\t\t\t'emailTemplate'\n\t\t\t);\n\t\t});\n\t}\n}\n\n// Export controller instance\nexport const emailTemplateController = new EmailTemplateController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/email-templates/email-templates.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/email-templates/email-templates.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'template' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":244,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":244,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'bodyHtml' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":447,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":447,"endColumn":18},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":453,"column":12,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":453,"endColumn":14},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":454,"column":12,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":454,"endColumn":14},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":455,"column":12,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":455,"endColumn":14},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":456,"column":12,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":456,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Email Template Service\n *\n * Manages email templates with Markdown support, variable interpolation,\n * and version control for the admin panel\n */\n\nimport { db } from '@db';\nimport { emailTemplates, emailTemplateVersions, emailTemplateLogs } from '@schema';\nimport { eq, desc, and, ilike, or } from 'drizzle-orm';\nimport { marked } from 'marked';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { adminCacheService, AdminCacheKeys } from '../../shared/admin-cache.service';\nimport { z } from 'zod';\nimport type { TemplateId } from '@shared/types/ids';\nimport { logger } from '../../../../core/logger';\n\n// Template variable schema\nconst templateVariableSchema = z.object({\n\tname: z.string().min(1).max(50),\n\tdescription: z.string().optional(),\n\trequired: z.boolean().default(false),\n\ttype: z.enum(['string', 'number', 'boolean', 'date']).default('string'),\n\tdefaultValue: z.any().optional()\n});\n\n// Create/Update template schema\nexport const emailTemplateSchema = z.object({\n\tkey: z\n\t\t.string()\n\t\t.min(1)\n\t\t.max(100)\n\t\t.regex(/^[a-z0-9_]+$/, 'Key must be lowercase alphanumeric with underscores'),\n\tname: z.string().min(1).max(255),\n\tdescription: z.string().optional(),\n\tcategory: z\n\t\t.enum(['auth', 'notification', 'marketing', 'transactional', 'general'])\n\t\t.default('general'),\n\tsubject: z.string().min(1),\n\tbodyMarkdown: z.string().min(1),\n\tvariables: z.array(templateVariableSchema).default([]),\n\tdefaultValues: z.record(z.any()).default({}),\n\tisActive: z.boolean().default(true),\n\trequiresApproval: z.boolean().default(false)\n});\n\nexport type CreateEmailTemplateInput = z.infer<typeof emailTemplateSchema>;\nexport type UpdateEmailTemplateInput = Partial<CreateEmailTemplateInput>;\n\nexport class EmailTemplateService {\n\t/**\n\t * Get all email templates with filtering\n\t */\n\tasync getAllTemplates(filters?: { category?: string; isActive?: boolean; search?: string }) {\n\t\ttry {\n\t\t\tlet query = db.select().from(emailTemplates);\n\n\t\t\tif (filters) {\n\t\t\t\tconst conditions = [];\n\n\t\t\t\tif (filters.category) {\n\t\t\t\t\tconditions.push(eq(emailTemplates.category, filters.category));\n\t\t\t\t}\n\n\t\t\t\tif (filters.isActive !== undefined) {\n\t\t\t\t\tconditions.push(eq(emailTemplates.isActive, filters.isActive));\n\t\t\t\t}\n\n\t\t\t\tif (filters.search) {\n\t\t\t\t\tconditions.push(\n\t\t\t\t\t\tor(\n\t\t\t\t\t\t\tilike(emailTemplates.name, `%${filters.search}%`),\n\t\t\t\t\t\t\tilike(emailTemplates.key, `%${filters.search}%`),\n\t\t\t\t\t\t\tilike(emailTemplates.description, `%${filters.search}%`)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (conditions.length > 0) {\n\t\t\t\t\tquery = query.where(and(...conditions));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst templates = await query.orderBy(desc(emailTemplates.updatedAt));\n\n\t\t\treturn templates;\n\t\t} catch (error) {\n\t\t\tthrow new AdminError('Failed to fetch email templates', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get a single template by ID or key\n\t */\n\tasync getTemplate(idOrKey: number | string) {\n\t\ttry {\n\t\t\tconst isId = typeof idOrKey === 'number';\n\n\t\t\tconst [template] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(emailTemplates)\n\t\t\t\t.where(isId ? eq(emailTemplates.id, idOrKey) : eq(emailTemplates.key, idOrKey as string));\n\n\t\t\tif (!template) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`Email template not found: ${idOrKey}`,\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn template;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to fetch email template', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create a new email template\n\t */\n\tasync createTemplate(data: CreateEmailTemplateInput, adminId: string) {\n\t\ttry {\n\t\t\t// Check if key already exists\n\t\t\tconst [existing] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(emailTemplates)\n\t\t\t\t.where(eq(emailTemplates.key, data.key));\n\n\t\t\tif (existing) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`Template with key '${data.key}' already exists`,\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.DUPLICATE_ENTRY\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Generate HTML from markdown\n\t\t\tconst bodyHtml = await this.renderMarkdown(data.bodyMarkdown);\n\t\t\tconst bodyPlainText = this.stripHtml(bodyHtml);\n\n\t\t\t// Create template\n\t\t\tconst [template] = await db\n\t\t\t\t.insert(emailTemplates)\n\t\t\t\t.values({\n\t\t\t\t\t...data,\n\t\t\t\t\tbodyHtml,\n\t\t\t\t\tbodyPlainText,\n\t\t\t\t\tcreatedBy: adminId,\n\t\t\t\t\tupdatedBy: adminId\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Invalidate cache\n\t\t\tawait adminCacheService.invalidateEntity('emailTemplate');\n\n\t\t\treturn template;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to create email template', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update an email template with version control\n\t */\n\tasync updateTemplate(\n\t\tid: Id<'id'>,\n\t\tdata: UpdateEmailTemplateInput,\n\t\tadminId: string,\n\t\tchangeDescription?: string\n\t) {\n\t\ttry {\n\t\t\t// Get current template\n\t\t\tconst currentTemplate = await this.getTemplate(id);\n\n\t\t\t// If body changed, regenerate HTML\n\t\t\tlet bodyHtml = currentTemplate.bodyHtml;\n\t\t\tlet bodyPlainText = currentTemplate.bodyPlainText;\n\n\t\t\tif (data.bodyMarkdown) {\n\t\t\t\tbodyHtml = await this.renderMarkdown(data.bodyMarkdown);\n\t\t\t\tbodyPlainText = this.stripHtml(bodyHtml);\n\t\t\t}\n\n\t\t\t// Create version history if content changed\n\t\t\tif (\n\t\t\t\t(data.subject && data.subject !== currentTemplate.subject) ||\n\t\t\t\t(data.bodyMarkdown && data.bodyMarkdown !== currentTemplate.bodyMarkdown) ||\n\t\t\t\t(data.variables &&\n\t\t\t\t\tJSON.stringify(data.variables) !== JSON.stringify(currentTemplate.variables))\n\t\t\t) {\n\t\t\t\tawait db.insert(emailTemplateVersions).values({\n\t\t\t\t\ttemplateId: id,\n\t\t\t\t\tversion: currentTemplate.version,\n\t\t\t\t\tsubject: currentTemplate.subject,\n\t\t\t\t\tbodyMarkdown: currentTemplate.bodyMarkdown,\n\t\t\t\t\tbodyHtml: currentTemplate.bodyHtml,\n\t\t\t\t\tvariables: currentTemplate.variables,\n\t\t\t\t\tchangeDescription: changeDescription || 'Template updated',\n\t\t\t\t\tcreatedBy: adminId\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Update template\n\t\t\tconst [updatedTemplate] = await db\n\t\t\t\t.update(emailTemplates)\n\t\t\t\t.set({\n\t\t\t\t\t...data,\n\t\t\t\t\t...(data.bodyMarkdown && { bodyHtml, bodyPlainText }),\n\t\t\t\t\tversion: currentTemplate.version + 1,\n\t\t\t\t\tupdatedBy: adminId,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(emailTemplates.id, id))\n\t\t\t\t.returning();\n\n\t\t\t// Invalidate cache\n\t\t\tawait adminCacheService.invalidateEntity('emailTemplate');\n\n\t\t\treturn updatedTemplate;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to update email template', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Delete an email template (soft delete by deactivating)\n\t */\n\tasync deleteTemplate(id: Id<'id'>, adminId: string) {\n\t\ttry {\n\t\t\tconst template = await this.getTemplate(id);\n\n\t\t\t// Instead of hard delete, deactivate it\n\t\t\tawait db\n\t\t\t\t.update(emailTemplates)\n\t\t\t\t.set({\n\t\t\t\t\tisActive: false,\n\t\t\t\t\tupdatedBy: adminId,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(emailTemplates.id, id));\n\n\t\t\t// Invalidate cache\n\t\t\tawait adminCacheService.invalidateEntity('emailTemplate');\n\n\t\t\treturn { success: true };\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to delete email template', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Preview template with sample data\n\t */\n\tasync previewTemplate(idOrKey: number | string, sampleData: Record<string, any> = {}) {\n\t\ttry {\n\t\t\tconst template = await this.getTemplate(idOrKey);\n\n\t\t\t// Merge with default values\n\t\t\tconst variables = {\n\t\t\t\t...template.defaultValues,\n\t\t\t\t...sampleData\n\t\t\t};\n\n\t\t\t// Interpolate variables\n\t\t\tconst subject = this.interpolateVariables(template.subject, variables);\n\t\t\tconst bodyHtml = this.interpolateVariables(template.bodyHtml || '', variables);\n\t\t\tconst bodyPlainText = this.interpolateVariables(template.bodyPlainText || '', variables);\n\n\t\t\treturn {\n\t\t\t\ttemplate,\n\t\t\t\tpreview: {\n\t\t\t\t\tsubject,\n\t\t\t\t\tbodyHtml,\n\t\t\t\t\tbodyPlainText,\n\t\t\t\t\tvariables\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to preview email template', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get template version history\n\t */\n\tasync getTemplateVersions(templateId: TemplateId) {\n\t\ttry {\n\t\t\tconst versions = await db\n\t\t\t\t.select()\n\t\t\t\t.from(emailTemplateVersions)\n\t\t\t\t.where(eq(emailTemplateVersions.templateId, templateId))\n\t\t\t\t.orderBy(desc(emailTemplateVersions.version));\n\n\t\t\treturn versions;\n\t\t} catch (error) {\n\t\t\tthrow new AdminError('Failed to fetch template versions', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Restore a previous version\n\t */\n\tasync restoreVersion(templateId: TemplateId, versionId: Id<'version'>, adminId: string) {\n\t\ttry {\n\t\t\t// Get the version to restore\n\t\t\tconst [version] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(emailTemplateVersions)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(emailTemplateVersions.id, versionId),\n\t\t\t\t\t\teq(emailTemplateVersions.templateId, templateId)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tif (!version) {\n\t\t\t\tthrow new AdminError('Template version not found', 404, AdminErrorCodes.NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Update template with version data\n\t\t\treturn await this.updateTemplate(\n\t\t\t\ttemplateId,\n\t\t\t\t{\n\t\t\t\t\tsubject: version.subject,\n\t\t\t\t\tbodyMarkdown: version.bodyMarkdown,\n\t\t\t\t\tvariables: version.variables as any\n\t\t\t\t},\n\t\t\t\tadminId,\n\t\t\t\t`Restored to version ${version.version}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to restore template version', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get template usage statistics\n\t */\n\tasync getTemplateStats(templateId: TemplateId, days: number = 30) {\n\t\ttry {\n\t\t\tconst startDate = new Date();\n\t\t\tstartDate.setDate(startDate.getDate() - days);\n\n\t\t\tconst logs = await db\n\t\t\t\t.select()\n\t\t\t\t.from(emailTemplateLogs)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(emailTemplateLogs.templateId, templateId),\n\t\t\t\t\t\teq(emailTemplateLogs.sentAt, startDate.toISOString())\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tconst stats = {\n\t\t\t\ttotalSent: logs.length,\n\t\t\t\tsuccessful: logs.filter((l) => l.status === 'sent').length,\n\t\t\t\tfailed: logs.filter((l) => l.status === 'failed').length,\n\t\t\t\tbounced: logs.filter((l) => l.status === 'bounced').length,\n\t\t\t\topened: logs.filter((l) => l.openedAt).length,\n\t\t\t\tclicked: logs.filter((l) => l.clickedAt).length,\n\t\t\t\topenRate: 0,\n\t\t\t\tclickRate: 0\n\t\t\t};\n\n\t\t\tif (stats.totalSent > 0) {\n\t\t\t\tstats.openRate = (stats.opened / stats.totalSent) * 100;\n\t\t\t\tstats.clickRate = (stats.clicked / stats.totalSent) * 100;\n\t\t\t}\n\n\t\t\treturn stats;\n\t\t} catch (error) {\n\t\t\tthrow new AdminError('Failed to fetch template statistics', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t// Private helper methods\n\n\tprivate async renderMarkdown(markdown: string): Promise<string> {\n\t\t// Configure marked for security\n\t\tmarked.setOptions({\n\t\t\tbreaks: true,\n\t\t\tgfm: true,\n\t\t\tsanitize: false // We'll sanitize on the frontend\n\t\t});\n\n\t\treturn marked(markdown);\n\t}\n\n\tprivate stripHtml(html: string): string {\n\t\treturn html.replace(/<[^>]*>?/gm, '');\n\t}\n\n\tprivate interpolateVariables(text: string, variables: Record<string, any>): string {\n\t\treturn text.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n\t\t\treturn variables[key] !== undefined ? String(variables[key]) : match;\n\t\t});\n\t}\n\n\t/**\n\t * Send email using template (integrate with your email service)\n\t */\n\tasync sendEmail(\n\t\ttemplateKey: string,\n\t\trecipientEmail: string,\n\t\tvariables: Record<string, any>,\n\t\trecipientUserId?: string\n\t) {\n\t\ttry {\n\t\t\tconst template = await this.getTemplate(templateKey);\n\n\t\t\tif (!template.isActive) {\n\t\t\t\tthrow new AdminError('Template is not active', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\t// Interpolate variables\n\t\t\tconst subject = this.interpolateVariables(template.subject, variables);\n\t\t\tconst bodyHtml = this.interpolateVariables(template.bodyHtml || '', variables);\n\t\t\tconst bodyPlainText = this.interpolateVariables(template.bodyPlainText || '', variables);\n\n\t\t\t// TODO: Integrate with your email service (SendGrid, AWS SES, etc.)\n\t\t\t// For now, just log it\n\t\t\tlogger.info('Sending email:', {\n            \t\t\t\tto: recipientEmail,\n            \t\t\t\tsubject,\n            \t\t\t\ttemplate: templateKey\n            \t\t\t});\n\n\t\t\t// Log email send\n\t\t\tawait db.insert(emailTemplateLogs).values({\n\t\t\t\ttemplateId: template.id,\n\t\t\t\trecipientEmail,\n\t\t\t\trecipientUserId,\n\t\t\t\tsubject,\n\t\t\t\tvariablesUsed: variables,\n\t\t\t\tstatus: 'sent'\n\t\t\t});\n\n\t\t\t// Update template usage\n\t\t\tawait db\n\t\t\t\t.update(emailTemplates)\n\t\t\t\t.set({\n\t\t\t\t\tlastUsedAt: new Date(),\n\t\t\t\t\tuseCount: template.useCount + 1\n\t\t\t\t})\n\t\t\t\t.where(eq(emailTemplates.id, template.id));\n\n\t\t\treturn { success: true, subject, preview: bodyPlainText.substring(0, 100) };\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tthrow new AdminError('Failed to send email', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const emailTemplateService = new EmailTemplateService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/emojis/emojis.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleValidationError' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { emojiService } from './emojis.service';\nimport {\n\tCreateEmojiSchema,\n\tUpdateEmojiSchema,\n\tListEmojisQuerySchema,\n\tBulkDeleteEmojisSchema\n} from './emojis.validators';\nimport {\n\tvalidateRequestBody,\n\tvalidateQueryParams,\n\tvalidateNumberParam\n} from '../../admin.validation';\nimport { logger } from '../../../../core/logger';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\n\n// Removed redundant getUserId helper - use userService.getUserFromRequest(req)?.id directly\n\n/**\n * Helper function to handle validation errors\n */\nfunction handleValidationError(error: any, res: Response) {\n\tif (error.name === 'ZodError') {\n\t\treturn res.status(400).json({\n\t\t\terror: 'Validation failed',\n\t\t\tcode: AdminErrorCodes.VALIDATION_ERROR,\n\t\t\tdetails: error.errors\n\t\t});\n\t}\n\treturn null;\n}\n\n/**\n * GET /api/admin/emojis\n * Get all emojis with filtering and pagination\n */\nexport const getAllEmojis = async (req: Request, res: Response) => {\n\ttry {\n\t\tlogger.info('EMOJI_CONTROLLER', 'GET /api/admin/emojis requested', { query: req.query });\n\n\t\tconst query = validateQueryParams(req, res, ListEmojisQuerySchema);\n\t\tif (!query) return;\n\t\tconst result = await emojiService.getAll(query);\n\n\t\tlogger.info('EMOJI_CONTROLLER', `Successfully fetched ${result.emojis.length} emojis`);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: result.emojis,\n\t\t\tpagination: result.pagination\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('EMOJI_CONTROLLER', 'Error fetching emojis:', error);\n\n\t\tif (error instanceof AdminError) {\n\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\terror: error.message,\n\t\t\t\tcode: error.code,\n\t\t\t\tdetails: error.details\n\t\t\t});\n\t\t}\n\n\t\treturn res.status(500).json({\n\t\t\terror: 'Internal server error while fetching emojis',\n\t\t\tcode: AdminErrorCodes.INTERNAL_ERROR\n\t\t});\n\t}\n};\n\n/**\n * GET /api/admin/emojis/:id\n * Get a single emoji by ID\n */\nexport const getEmojiById = async (req: Request, res: Response) => {\n\ttry {\n\t\tlogger.info('EMOJI_CONTROLLER', `GET /api/admin/emojis/${req.params.id} requested`);\n\n\t\tconst id = validateNumberParam(req, res, 'id');\n\t\tif (id === null) return;\n\t\tconst emoji = await emojiService.getById(id);\n\n\t\tif (!emoji) {\n\t\t\treturn res.status(404).json({\n\t\t\t\terror: `Emoji with ID ${id} not found`,\n\t\t\t\tcode: AdminErrorCodes.NOT_FOUND\n\t\t\t});\n\t\t}\n\n\t\tlogger.info('EMOJI_CONTROLLER', `Successfully fetched emoji: ${emoji.name}`);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: emoji\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('EMOJI_CONTROLLER', 'Error fetching emoji by ID:', error);\n\n\t\tif (error instanceof AdminError) {\n\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\terror: error.message,\n\t\t\t\tcode: error.code,\n\t\t\t\tdetails: error.details\n\t\t\t});\n\t\t}\n\n\t\treturn res.status(500).json({\n\t\t\terror: 'Internal server error while fetching emoji',\n\t\t\tcode: AdminErrorCodes.INTERNAL_ERROR\n\t\t});\n\t}\n};\n\n/**\n * POST /api/admin/emojis\n * Create a new emoji\n */\nexport const createEmoji = async (req: Request, res: Response) => {\n\ttry {\n\t\tlogger.info('EMOJI_CONTROLLER', 'POST /api/admin/emojis requested', { body: req.body });\n\n\t\tconst data = validateRequestBody(req, res, CreateEmojiSchema);\n\t\tif (!data) return;\n\t\tconst emojiData = {\n\t\t\t...data,\n\t\t\tcreatedBy: userService.getUserFromRequest(req)\n\t\t};\n\n\t\tconst newEmoji = await emojiService.create(emojiData);\n\n\t\tlogger.info(\n\t\t\t'EMOJI_CONTROLLER',\n\t\t\t`Successfully created emoji: ${newEmoji.name} (ID: ${newEmoji.id})`\n\t\t);\n\n\t\treturn res.status(201).json({\n\t\t\tsuccess: true,\n\t\t\tmessage: `Emoji '${newEmoji.name}' created successfully`,\n\t\t\tdata: newEmoji\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('EMOJI_CONTROLLER', 'Error creating emoji:', error);\n\n\t\tif (error instanceof AdminError) {\n\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\terror: error.message,\n\t\t\t\tcode: error.code,\n\t\t\t\tdetails: error.details\n\t\t\t});\n\t\t}\n\n\t\t// Handle specific database constraint errors\n\t\tif (error instanceof Error) {\n\t\t\tif (error.message.includes('already exists')) {\n\t\t\t\treturn res.status(409).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: AdminErrorCodes.DUPLICATE_RESOURCE\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn res.status(500).json({\n\t\t\terror: 'Internal server error while creating emoji',\n\t\t\tcode: AdminErrorCodes.INTERNAL_ERROR\n\t\t});\n\t}\n};\n\n/**\n * PUT /api/admin/emojis/:id\n * Update an existing emoji\n */\nexport const updateEmoji = async (req: Request, res: Response) => {\n\ttry {\n\t\tlogger.info('EMOJI_CONTROLLER', `PUT /api/admin/emojis/${req.params.id} requested`, {\n\t\t\tbody: req.body\n\t\t});\n\n\t\tconst id = validateNumberParam(req, res, 'id');\n\t\tif (id === null) return;\n\n\t\tconst dataUpdate = validateRequestBody(req, res, UpdateEmojiSchema);\n\t\tif (!dataUpdate) return;\n\n\t\tif (Object.keys(dataUpdate).length === 0) {\n\t\t\treturn res.status(400).json({\n\t\t\t\terror: 'No fields provided for update',\n\t\t\t\tcode: AdminErrorCodes.VALIDATION_ERROR\n\t\t\t});\n\t\t}\n\n\t\tconst updateData = dataUpdate;\n\n\t\tconst updatedEmoji = await emojiService.update(id, updateData);\n\n\t\tlogger.info('EMOJI_CONTROLLER', `Successfully updated emoji: ${updatedEmoji.name} (ID: ${id})`);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: `Emoji '${updatedEmoji.name}' updated successfully`,\n\t\t\tdata: updatedEmoji\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('EMOJI_CONTROLLER', 'Error updating emoji:', error);\n\n\t\tif (error instanceof AdminError) {\n\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\terror: error.message,\n\t\t\t\tcode: error.code,\n\t\t\t\tdetails: error.details\n\t\t\t});\n\t\t}\n\n\t\t// Handle specific errors\n\t\tif (error instanceof Error) {\n\t\t\tif (error.message.includes('not found')) {\n\t\t\t\treturn res.status(404).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: AdminErrorCodes.NOT_FOUND\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (error.message.includes('already uses this')) {\n\t\t\t\treturn res.status(409).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: AdminErrorCodes.DUPLICATE_RESOURCE\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn res.status(500).json({\n\t\t\terror: 'Internal server error while updating emoji',\n\t\t\tcode: AdminErrorCodes.INTERNAL_ERROR\n\t\t});\n\t}\n};\n\n/**\n * DELETE /api/admin/emojis/:id\n * Soft delete an emoji\n */\nexport const deleteEmoji = async (req: Request, res: Response) => {\n\ttry {\n\t\tlogger.info('EMOJI_CONTROLLER', `DELETE /api/admin/emojis/${req.params.id} requested`);\n\n\t\tconst id = validateNumberParam(req, res, 'id');\n\t\tif (id === null) return;\n\t\tconst deletedEmoji = await emojiService.delete(id);\n\n\t\tlogger.info('EMOJI_CONTROLLER', `Successfully deleted emoji (ID: ${id})`);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: `Emoji deleted successfully`,\n\t\t\tdata: { id: deletedEmoji.id, name: deletedEmoji.name }\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('EMOJI_CONTROLLER', 'Error deleting emoji:', error);\n\n\t\tif (error instanceof AdminError) {\n\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\terror: error.message,\n\t\t\t\tcode: error.code,\n\t\t\t\tdetails: error.details\n\t\t\t});\n\t\t}\n\n\t\t// Handle specific errors\n\t\tif (error instanceof Error) {\n\t\t\tif (error.message.includes('not found')) {\n\t\t\t\treturn res.status(404).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: AdminErrorCodes.NOT_FOUND\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (error.message.includes('already deleted')) {\n\t\t\t\treturn res.status(409).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: AdminErrorCodes.INVALID_OPERATION\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn res.status(500).json({\n\t\t\terror: 'Internal server error while deleting emoji',\n\t\t\tcode: AdminErrorCodes.INTERNAL_ERROR\n\t\t});\n\t}\n};\n\n/**\n * POST /api/admin/emojis/bulk-delete\n * Bulk delete multiple emojis\n */\nexport const bulkDeleteEmojis = async (req: Request, res: Response) => {\n\ttry {\n\t\tlogger.info('EMOJI_CONTROLLER', 'POST /api/admin/emojis/bulk-delete requested', {\n\t\t\tbody: req.body\n\t\t});\n\n\t\tconst dataBulk = validateRequestBody(req, res, BulkDeleteEmojisSchema);\n\t\tif (!dataBulk) return;\n\n\t\tconst { ids } = dataBulk;\n\t\tconst deletedEmojis = await emojiService.bulkDelete(ids);\n\n\t\tlogger.info('EMOJI_CONTROLLER', `Successfully bulk deleted ${deletedEmojis.length} emojis`);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: `Successfully deleted ${deletedEmojis.length} emoji(s)`,\n\t\t\tdata: {\n\t\t\t\tdeleted: deletedEmojis,\n\t\t\t\tcount: deletedEmojis.length\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('EMOJI_CONTROLLER', 'Error bulk deleting emojis:', error);\n\n\t\tif (error instanceof AdminError) {\n\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\terror: error.message,\n\t\t\t\tcode: error.code,\n\t\t\t\tdetails: error.details\n\t\t\t});\n\t\t}\n\n\t\treturn res.status(500).json({\n\t\t\terror: 'Internal server error while bulk deleting emojis',\n\t\t\tcode: AdminErrorCodes.INTERNAL_ERROR\n\t\t});\n\t}\n};\n\n/**\n * GET /api/admin/emojis/categories\n * Get all emoji categories\n */\nexport const getEmojiCategories = async (req: Request, res: Response) => {\n\ttry {\n\t\tlogger.info('EMOJI_CONTROLLER', 'GET /api/admin/emojis/categories requested');\n\n\t\tconst categories = await emojiService.getCategories();\n\n\t\tlogger.info('EMOJI_CONTROLLER', `Successfully fetched ${categories.length} emoji categories`);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: categories\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('EMOJI_CONTROLLER', 'Error fetching emoji categories:', error);\n\n\t\tif (error instanceof AdminError) {\n\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\terror: error.message,\n\t\t\t\tcode: error.code,\n\t\t\t\tdetails: error.details\n\t\t\t});\n\t\t}\n\n\t\treturn res.status(500).json({\n\t\t\terror: 'Internal server error while fetching emoji categories',\n\t\t\tcode: AdminErrorCodes.INTERNAL_ERROR\n\t\t});\n\t}\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/emojis/emojis.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/emojis/emojis.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ilike' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { customEmojis, users } from '@schema';\nimport { and, asc, desc, eq, ilike, inArray, sql } from 'drizzle-orm';\nimport { logger } from '../../../../core/logger';\n\nexport interface ListEmojisOptions {\n\tcategory?: string;\n\ttype?: 'static' | 'lottie';\n\tunlockType?: 'free' | 'purchase' | 'path_unlock' | 'admin_grant';\n\tisLocked?: boolean;\n\tincludeDeleted?: boolean;\n\tlimit?: number;\n\toffset?: number;\n\tsortBy?: 'name' | 'createdAt' | 'category' | 'type';\n\tsortOrder?: 'asc' | 'desc';\n}\n\nexport interface CreateEmojiData {\n\tname: string;\n\tcode: string;\n\ttype: 'static' | 'lottie';\n\turl: string;\n\tpreviewUrl?: string;\n\tcategory?: string;\n\tisLocked?: boolean;\n\tunlockType?: 'free' | 'purchase' | 'path_unlock' | 'admin_grant';\n\tpriceDgt?: number;\n\trequiredPath?: string;\n\trequiredPathXP?: number;\n\txpValue?: number;\n\tcloutValue?: number;\n\tcreatedBy?: number;\n}\n\nexport interface UpdateEmojiData {\n\tname?: string;\n\tcode?: string;\n\ttype?: 'static' | 'lottie';\n\turl?: string;\n\tpreviewUrl?: string;\n\tcategory?: string;\n\tisLocked?: boolean;\n\tunlockType?: 'free' | 'purchase' | 'path_unlock' | 'admin_grant';\n\tpriceDgt?: number;\n\trequiredPath?: string;\n\trequiredPathXP?: number;\n\txpValue?: number;\n\tcloutValue?: number;\n}\n\n// Helper function to normalize field names from frontend\nfunction normalizeEmojiData(rawData: any): CreateEmojiData {\n\treturn {\n\t\tname: rawData.name,\n\t\tcode: rawData.code,\n\t\ttype: rawData.type,\n\t\turl: rawData.url,\n\t\tpreviewUrl: rawData.previewUrl || rawData.preview_url,\n\t\tcategory: rawData.category,\n\t\tisLocked: rawData.isLocked !== undefined ? rawData.isLocked : rawData.is_locked,\n\t\tunlockType: rawData.unlockType || rawData.unlock_type,\n\t\tpriceDgt: rawData.priceDgt || rawData.price_dgt,\n\t\trequiredPath: rawData.requiredPath || rawData.required_path,\n\t\trequiredPathXP: rawData.requiredPathXP || rawData.required_path_xp,\n\t\txpValue: rawData.xpValue || rawData.xp_value,\n\t\tcloutValue: rawData.cloutValue || rawData.clout_value,\n\t\tcreatedBy: rawData.createdBy || rawData.created_by\n\t};\n}\n\nexport const emojiService = {\n\t/**\n\t * Get all emojis with filtering and pagination\n\t */\n\tasync getAll(options: ListEmojisOptions = {}) {\n\t\ttry {\n\t\t\tlogger.info('EMOJI_SERVICE', 'Fetching emojis with options:', options);\n\n\t\t\tconst {\n\t\t\t\tcategory,\n\t\t\t\ttype,\n\t\t\t\tunlockType,\n\t\t\t\tisLocked,\n\t\t\t\tincludeDeleted = false,\n\t\t\t\tlimit = 50,\n\t\t\t\toffset = 0,\n\t\t\t\tsortBy = 'createdAt',\n\t\t\t\tsortOrder = 'desc'\n\t\t\t} = options;\n\n\t\t\t// Build WHERE conditions\n\t\t\tconst conditions = [];\n\n\t\t\tif (!includeDeleted) {\n\t\t\t\tconditions.push(eq(customEmojis.isDeleted, false));\n\t\t\t}\n\n\t\t\tif (category) {\n\t\t\t\tconditions.push(eq(customEmojis.category, category));\n\t\t\t}\n\n\t\t\tif (type) {\n\t\t\t\tconditions.push(eq(customEmojis.type, type));\n\t\t\t}\n\n\t\t\tif (unlockType) {\n\t\t\t\tconditions.push(eq(customEmojis.unlockType, unlockType));\n\t\t\t}\n\n\t\t\tif (isLocked !== undefined) {\n\t\t\t\tconditions.push(eq(customEmojis.isLocked, isLocked));\n\t\t\t}\n\n\t\t\t// Build ORDER BY\n\t\t\tconst sortColumn = customEmojis[sortBy];\n\t\t\tconst orderBy = sortOrder === 'asc' ? asc(sortColumn) : desc(sortColumn);\n\n\t\t\t// Execute query with joins to get creator info\n\t\t\tconst emojis = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: customEmojis.id,\n\t\t\t\t\tname: customEmojis.name,\n\t\t\t\t\tcode: customEmojis.code,\n\t\t\t\t\ttype: customEmojis.type,\n\t\t\t\t\turl: customEmojis.url,\n\t\t\t\t\tpreviewUrl: customEmojis.previewUrl,\n\t\t\t\t\tcategory: customEmojis.category,\n\t\t\t\t\tisLocked: customEmojis.isLocked,\n\t\t\t\t\tunlockType: customEmojis.unlockType,\n\t\t\t\t\tpriceDgt: customEmojis.priceDgt,\n\t\t\t\t\trequiredPath: customEmojis.requiredPath,\n\t\t\t\t\trequiredPathXP: customEmojis.requiredPathXP,\n\t\t\t\t\txpValue: customEmojis.xpValue,\n\t\t\t\t\tcloutValue: customEmojis.cloutValue,\n\t\t\t\t\tcreatedAt: customEmojis.createdAt,\n\t\t\t\t\tupdatedAt: customEmojis.updatedAt,\n\t\t\t\t\tcreatedBy: customEmojis.createdBy,\n\t\t\t\t\tisDeleted: customEmojis.isDeleted,\n\t\t\t\t\tdeletedAt: customEmojis.deletedAt,\n\t\t\t\t\tcreatorUsername: users.username\n\t\t\t\t})\n\t\t\t\t.from(customEmojis)\n\t\t\t\t.leftJoin(users, eq(customEmojis.createdBy, users.id))\n\t\t\t\t.where(conditions.length > 0 ? and(...conditions) : undefined)\n\t\t\t\t.orderBy(orderBy)\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\t// Get total count for pagination\n\t\t\tconst totalCountResult = await db\n\t\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t\t.from(customEmojis)\n\t\t\t\t.where(conditions.length > 0 ? and(...conditions) : undefined);\n\n\t\t\tconst totalCount = totalCountResult[0]?.count || 0;\n\n\t\t\tlogger.info('EMOJI_SERVICE', `Fetched ${emojis.length} emojis (${totalCount} total)`);\n\n\t\t\treturn {\n\t\t\t\temojis,\n\t\t\t\tpagination: {\n\t\t\t\t\ttotal: totalCount,\n\t\t\t\t\tlimit,\n\t\t\t\t\toffset,\n\t\t\t\t\thasMore: offset + limit < totalCount\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('EMOJI_SERVICE', 'Error fetching emojis:', error);\n\t\t\tthrow error;\n\t\t}\n\t},\n\n\t/**\n\t * Get a single emoji by ID\n\t */\n\tasync getById(id: Id<'id'>) {\n\t\ttry {\n\t\t\tlogger.info('EMOJI_SERVICE', `Fetching emoji with ID: ${id}`);\n\n\t\t\tconst result = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: customEmojis.id,\n\t\t\t\t\tname: customEmojis.name,\n\t\t\t\t\tcode: customEmojis.code,\n\t\t\t\t\ttype: customEmojis.type,\n\t\t\t\t\turl: customEmojis.url,\n\t\t\t\t\tpreviewUrl: customEmojis.previewUrl,\n\t\t\t\t\tcategory: customEmojis.category,\n\t\t\t\t\tisLocked: customEmojis.isLocked,\n\t\t\t\t\tunlockType: customEmojis.unlockType,\n\t\t\t\t\tpriceDgt: customEmojis.priceDgt,\n\t\t\t\t\trequiredPath: customEmojis.requiredPath,\n\t\t\t\t\trequiredPathXP: customEmojis.requiredPathXP,\n\t\t\t\t\txpValue: customEmojis.xpValue,\n\t\t\t\t\tcloutValue: customEmojis.cloutValue,\n\t\t\t\t\tcreatedAt: customEmojis.createdAt,\n\t\t\t\t\tupdatedAt: customEmojis.updatedAt,\n\t\t\t\t\tcreatedBy: customEmojis.createdBy,\n\t\t\t\t\tisDeleted: customEmojis.isDeleted,\n\t\t\t\t\tdeletedAt: customEmojis.deletedAt,\n\t\t\t\t\tcreatorUsername: users.username\n\t\t\t\t})\n\t\t\t\t.from(customEmojis)\n\t\t\t\t.leftJoin(users, eq(customEmojis.createdBy, users.id))\n\t\t\t\t.where(eq(customEmojis.id, id))\n\t\t\t\t.limit(1);\n\n\t\t\tconst emoji = result[0] || null;\n\n\t\t\tif (emoji) {\n\t\t\t\tlogger.info('EMOJI_SERVICE', `Found emoji: ${emoji.name}`);\n\t\t\t} else {\n\t\t\t\tlogger.warn('EMOJI_SERVICE', `Emoji with ID ${id} not found`);\n\t\t\t}\n\n\t\t\treturn emoji;\n\t\t} catch (error) {\n\t\t\tlogger.error('EMOJI_SERVICE', `Error fetching emoji with ID ${id}:`, error);\n\t\t\tthrow error;\n\t\t}\n\t},\n\n\t/**\n\t * Create a new emoji\n\t */\n\tasync create(rawEmojiData: any) {\n\t\ttry {\n\t\t\t// Normalize field names from frontend (handle both camelCase and snake_case)\n\t\t\tconst emojiData = normalizeEmojiData(rawEmojiData);\n\n\t\t\tlogger.info('EMOJI_SERVICE', 'Creating emoji:', {\n\t\t\t\tname: emojiData.name,\n\t\t\t\ttype: emojiData.type\n\t\t\t});\n\n\t\t\t// Check if emoji with this name or code already exists\n\t\t\tconst existing = await db\n\t\t\t\t.select({ id: customEmojis.id, name: customEmojis.name, code: customEmojis.code })\n\t\t\t\t.from(customEmojis)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(customEmojis.isDeleted, false),\n\t\t\t\t\t\tsql`(${customEmojis.name} = ${emojiData.name} OR ${customEmojis.code} = ${emojiData.code})`\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.limit(1);\n\n\t\t\tif (existing.length > 0) {\n\t\t\t\tconst conflict = existing[0];\n\t\t\t\tconst conflictType = conflict.name === emojiData.name ? 'name' : 'code';\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Emoji with this ${conflictType} already exists: ${conflict[conflictType]}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst result = await db\n\t\t\t\t.insert(customEmojis)\n\t\t\t\t.values({\n\t\t\t\t\t...emojiData,\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\tconst newEmoji = result[0];\n\t\t\tlogger.info(\n\t\t\t\t'EMOJI_SERVICE',\n\t\t\t\t`Successfully created emoji: ${newEmoji.name} (ID: ${newEmoji.id})`\n\t\t\t);\n\n\t\t\treturn newEmoji;\n\t\t} catch (error) {\n\t\t\tlogger.error('EMOJI_SERVICE', 'Error creating emoji:', error);\n\t\t\tthrow error;\n\t\t}\n\t},\n\n\t/**\n\t * Update an existing emoji\n\t */\n\tasync update(id: Id<'id'>, emojiData: UpdateEmojiData) {\n\t\ttry {\n\t\t\tlogger.info('EMOJI_SERVICE', `Updating emoji with ID: ${id}`, emojiData);\n\n\t\t\t// Check if emoji exists and is not deleted\n\t\t\tconst existing = await this.getById(id);\n\t\t\tif (!existing || existing.isDeleted) {\n\t\t\t\tthrow new Error(`Emoji with ID ${id} not found`);\n\t\t\t}\n\n\t\t\t// Check for name/code conflicts if they're being updated\n\t\t\tif (emojiData.name || emojiData.code) {\n\t\t\t\tconst conditions = [];\n\t\t\t\tif (emojiData.name) conditions.push(eq(customEmojis.name, emojiData.name));\n\t\t\t\tif (emojiData.code) conditions.push(eq(customEmojis.code, emojiData.code));\n\n\t\t\t\tconst conflicting = await db\n\t\t\t\t\t.select({ id: customEmojis.id, name: customEmojis.name, code: customEmojis.code })\n\t\t\t\t\t.from(customEmojis)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(customEmojis.isDeleted, false),\n\t\t\t\t\t\t\tsql`${customEmojis.id} != ${id}`,\n\t\t\t\t\t\t\tsql`(${conditions.join(' OR ')})`\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tif (conflicting.length > 0) {\n\t\t\t\t\tconst conflict = conflicting[0];\n\t\t\t\t\tconst conflictType = conflict.name === emojiData.name ? 'name' : 'code';\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Another emoji already uses this ${conflictType}: ${conflict[conflictType]}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = await db\n\t\t\t\t.update(customEmojis)\n\t\t\t\t.set({\n\t\t\t\t\t...emojiData,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(customEmojis.id, id))\n\t\t\t\t.returning();\n\n\t\t\tconst updatedEmoji = result[0];\n\t\t\tif (!updatedEmoji) {\n\t\t\t\tthrow new Error(`Failed to update emoji with ID ${id}`);\n\t\t\t}\n\n\t\t\tlogger.info('EMOJI_SERVICE', `Successfully updated emoji: ${updatedEmoji.name} (ID: ${id})`);\n\t\t\treturn updatedEmoji;\n\t\t} catch (error) {\n\t\t\tlogger.error('EMOJI_SERVICE', `Error updating emoji with ID ${id}:`, error);\n\t\t\tthrow error;\n\t\t}\n\t},\n\n\t/**\n\t * Soft delete an emoji\n\t */\n\tasync delete(id: Id<'id'>) {\n\t\ttry {\n\t\t\tlogger.info('EMOJI_SERVICE', `Deleting emoji with ID: ${id}`);\n\n\t\t\t// Check if emoji exists and is not already deleted\n\t\t\tconst existing = await this.getById(id);\n\t\t\tif (!existing) {\n\t\t\t\tthrow new Error(`Emoji with ID ${id} not found`);\n\t\t\t}\n\t\t\tif (existing.isDeleted) {\n\t\t\t\tthrow new Error(`Emoji with ID ${id} is already deleted`);\n\t\t\t}\n\n\t\t\tconst result = await db\n\t\t\t\t.update(customEmojis)\n\t\t\t\t.set({\n\t\t\t\t\tisDeleted: true,\n\t\t\t\t\tdeletedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(customEmojis.id, id))\n\t\t\t\t.returning();\n\n\t\t\tconst deletedEmoji = result[0];\n\t\t\tif (!deletedEmoji) {\n\t\t\t\tthrow new Error(`Failed to delete emoji with ID ${id}`);\n\t\t\t}\n\n\t\t\tlogger.info('EMOJI_SERVICE', `Successfully deleted emoji: ${existing.name} (ID: ${id})`);\n\t\t\treturn deletedEmoji;\n\t\t} catch (error) {\n\t\t\tlogger.error('EMOJI_SERVICE', `Error deleting emoji with ID ${id}:`, error);\n\t\t\tthrow error;\n\t\t}\n\t},\n\n\t/**\n\t * Bulk delete multiple emojis\n\t */\n\tasync bulkDelete(ids: number[]) {\n\t\ttry {\n\t\t\tlogger.info('EMOJI_SERVICE', `Bulk deleting emojis with IDs: [${ids.join(', ')}]`);\n\n\t\t\tconst result = await db\n\t\t\t\t.update(customEmojis)\n\t\t\t\t.set({\n\t\t\t\t\tisDeleted: true,\n\t\t\t\t\tdeletedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(and(inArray(customEmojis.id, ids), eq(customEmojis.isDeleted, false)))\n\t\t\t\t.returning({ id: customEmojis.id, name: customEmojis.name });\n\n\t\t\tlogger.info('EMOJI_SERVICE', `Successfully bulk deleted ${result.length} emojis`);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error('EMOJI_SERVICE', 'Error bulk deleting emojis:', error);\n\t\t\tthrow error;\n\t\t}\n\t},\n\n\t/**\n\t * Get unique categories\n\t */\n\tasync getCategories() {\n\t\ttry {\n\t\t\tconst result = await db\n\t\t\t\t.selectDistinct({ category: customEmojis.category })\n\t\t\t\t.from(customEmojis)\n\t\t\t\t.where(eq(customEmojis.isDeleted, false))\n\t\t\t\t.orderBy(asc(customEmojis.category));\n\n\t\t\tconst categories = result.map((r) => r.category).filter(Boolean);\n\t\t\tlogger.info('EMOJI_SERVICE', `Found ${categories.length} emoji categories`);\n\n\t\t\treturn categories;\n\t\t} catch (error) {\n\t\t\tlogger.error('EMOJI_SERVICE', 'Error fetching emoji categories:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/emojis/emojis.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/forum/forum.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport type { CategoryId, TagId, ThreadId, EntityId } from '@shared/types/ids';\nimport { adminForumService } from './forum.service';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { getUserId } from '../../admin.middleware';\nimport { adminController } from '../../admin.controller';\nimport {\n\tCategorySchema,\n\tPrefixSchema,\n\tTagSchema,\n\tModerateThreadSchema,\n\tPaginationSchema,\n\tcreateEntitySchema,\n\tupdateEntitySchema,\n\ttype ModerateThreadInput\n} from './forum.validators';\nimport { logger } from '@server/src/core/logger';\nimport { validateRequestBody, validateQueryParams } from '../../admin.validation';\n\nexport class AdminForumController {\n\tasync getAllCategories(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst categories = await adminForumService.getAllCategories();\n\t\t\tres.json(categories);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to fetch categories' });\n\t\t}\n\t}\n\n\tasync getCategoryById(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst categoryId = req.params.id as CategoryId;\n\n\t\t\tconst category = await adminForumService.getCategoryById(categoryId);\n\t\t\tres.json(category);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to fetch category' });\n\t\t}\n\t}\n\n\tasync createCategory(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, CategorySchema);\n\t\t\tif (!data) return;\n\t\t\tconst category = await adminForumService.createCategory(data);\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t'CREATE_CATEGORY',\n\t\t\t\t'category',\n\t\t\t\tcategory.id.toString(),\n\t\t\t\tdata\n\t\t\t);\n\t\t\tres.status(201).json(category);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to create category' });\n\t\t}\n\t}\n\n\tasync updateCategory(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst categoryId = req.params.id as CategoryId;\n\n\t\t\tconst data = validateRequestBody(req, res, CategorySchema);\n\t\t\tif (!data) return;\n\t\t\tconst category = await adminForumService.updateCategory(categoryId, data);\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t'UPDATE_CATEGORY',\n\t\t\t\t'category',\n\t\t\t\tcategoryId.toString(),\n\t\t\t\tdata\n\t\t\t);\n\t\t\tres.json(category);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to update category' });\n\t\t}\n\t}\n\n\tasync deleteCategory(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst categoryId = req.params.id as CategoryId;\n\n\t\t\tconst result = await adminForumService.deleteCategory(categoryId);\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t'DELETE_CATEGORY',\n\t\t\t\t'category',\n\t\t\t\tcategoryId.toString(),\n\t\t\t\t{}\n\t\t\t);\n\t\t\tres.json(result);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to delete category' });\n\t\t}\n\t}\n\n\tasync getAllPrefixes(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst prefixes = await adminForumService.getAllPrefixes();\n\t\t\tres.json(prefixes);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to fetch thread prefixes' });\n\t\t}\n\t}\n\n\tasync createPrefix(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst dataPrefix = validateRequestBody(req, res, PrefixSchema);\n\t\t\tif (!dataPrefix) return;\n\t\t\tconst prefix = await adminForumService.createPrefix(dataPrefix);\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t'CREATE_THREAD_PREFIX',\n\t\t\t\t'thread_prefix',\n\t\t\t\tprefix.id.toString(),\n\t\t\t\tdataPrefix\n\t\t\t);\n\t\t\tres.status(201).json(prefix);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to create thread prefix' });\n\t\t}\n\t}\n\n\t// Tag Management\n\n\tasync getAllTags(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst tags = await adminForumService.getAllTags();\n\t\t\tres.json(tags);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to fetch tags' });\n\t\t}\n\t}\n\n\tasync createTag(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst dataTag = validateRequestBody(req, res, TagSchema);\n\t\t\tif (!dataTag) return;\n\t\t\tconst tag = await adminForumService.createTag(dataTag);\n\t\t\tawait adminController.logAction(req, 'CREATE_TAG', 'tag', tag.id.toString(), dataTag);\n\t\t\tres.status(201).json(tag);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to create tag' });\n\t\t}\n\t}\n\n\tasync updateTag(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst tagId = req.params.id as TagId;\n\n\t\t\tconst dataTagU = validateRequestBody(req, res, TagSchema);\n\t\t\tif (!dataTagU) return;\n\t\t\tconst tag = await adminForumService.updateTag(tagId, dataTagU);\n\t\t\tawait adminController.logAction(req, 'UPDATE_TAG', 'tag', tagId.toString(), dataTagU);\n\t\t\tres.json(tag);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to update tag' });\n\t\t}\n\t}\n\n\tasync deleteTag(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst tagId = req.params.id as TagId;\n\n\t\t\tconst result = await adminForumService.deleteTag(tagId);\n\t\t\tawait adminController.logAction(req, 'DELETE_TAG', 'tag', tagId.toString(), {});\n\t\t\tres.json(result);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to delete tag' });\n\t\t}\n\t}\n\n\tasync moderateThread(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst threadId = req.params.id as ThreadId;\n\n\t\t\tconst dataMod = validateRequestBody(req, res, ModerateThreadSchema);\n\t\t\tif (!dataMod) return;\n\t\t\tconst thread = await adminForumService.moderateThread(\n\t\t\t\tthreadId,\n\t\t\t\tdataMod,\n\t\t\t\tuserService.getUserFromRequest(req),\n\t\t\t\tthis.determineModerationType(dataMod)\n\t\t\t);\n\t\t\tconst moderationType = this.determineModerationType(dataMod);\n\t\t\tawait adminController.logAction(req, moderationType, 'thread', threadId.toString(), dataMod);\n\t\t\tres.json(thread);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to moderate thread' });\n\t\t}\n\t}\n\n\tprivate determineModerationType(data: ModerateThreadInput): string {\n\t\tif (data.isLocked === true) return 'LOCK_THREAD';\n\t\tif (data.isLocked === false) return 'UNLOCK_THREAD';\n\t\tif (data.isSticky === true) return 'PIN_THREAD';\n\t\tif (data.isSticky === false) return 'UNPIN_THREAD';\n\t\tif (data.isHidden === true) return 'HIDE_THREAD';\n\t\tif (data.isHidden === false) return 'UNHIDE_THREAD';\n\t\tif (data.categoryId) return 'MOVE_THREAD';\n\t\tif (data.prefixId) return 'UPDATE_PREFIX';\n\n\t\treturn 'MODERATE_THREAD';\n\t}\n\n\t// Forum entity management methods\n\tasync getAllEntities(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst pagination = validateQueryParams(req, res, PaginationSchema) || undefined;\n\t\t\tconst entities = await adminForumService.getAllEntities(pagination);\n\t\t\tres.json(entities);\n\t\t} catch (error) {\n\t\t\tlogger.error('AdminForumController', 'Error getting all entities', { err: error });\n\t\t\tres.status(500).json({ message: 'Failed to get forum entities' });\n\t\t}\n\t}\n\n\tasync getEntityById(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst entityId = req.params.id as EntityId;\n\n\t\t\tconst entity = await adminForumService.getEntityById(entityId);\n\t\t\tif (!entity) {\n\t\t\t\treturn res.status(404).json({ message: 'Entity not found' });\n\t\t\t}\n\n\t\t\tres.json(entity);\n\t\t} catch (error) {\n\t\t\tlogger.error('AdminForumController', 'Error getting entity by ID', { err: error });\n\t\t\tres.status(500).json({ message: 'Failed to get entity' });\n\t\t}\n\t}\n\n\tasync createEntity(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst dataEnt = validateRequestBody(req, res, createEntitySchema);\n\t\t\tif (!dataEnt) return;\n\t\t\tconst entity = await adminForumService.createEntity(dataEnt);\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t'CREATE_FORUM_ENTITY',\n\t\t\t\t'forum_entity',\n\t\t\t\tentity.id.toString(),\n\t\t\t\tdataEnt\n\t\t\t);\n\t\t\tres.status(201).json(entity);\n\t\t} catch (error) {\n\t\t\tlogger.error('AdminForumController', 'Error creating entity', { err: error });\n\t\t\tres.status(500).json({ message: 'Failed to create entity' });\n\t\t}\n\t}\n\n\tasync updateEntity(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst entityId = req.params.id as EntityId;\n\n\t\t\tconst dataEntU = validateRequestBody(req, res, updateEntitySchema);\n\t\t\tif (!dataEntU) return;\n\t\t\tconst entity = await adminForumService.updateEntity(entityId, dataEntU);\n\t\t\tif (!entity) {\n\t\t\t\treturn res.status(404).json({ message: 'Entity not found' });\n\t\t\t}\n\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t'UPDATE_FORUM_ENTITY',\n\t\t\t\t'forum_entity',\n\t\t\t\tentityId.toString(),\n\t\t\t\tdataEntU\n\t\t\t);\n\t\t\tres.json(entity);\n\t\t} catch (error) {\n\t\t\tlogger.error('AdminForumController', 'Error updating entity', { err: error });\n\t\t\tres.status(500).json({ message: 'Failed to update entity' });\n\t\t}\n\t}\n\n\tasync deleteEntity(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst entityId = req.params.id as EntityId;\n\n\t\t\tconst result = await adminForumService.deleteEntity(entityId);\n\t\t\tif (!result) {\n\t\t\t\treturn res.status(404).json({ message: 'Entity not found' });\n\t\t\t}\n\n\t\t\tres.json({ message: 'Entity deleted successfully' });\n\t\t} catch (error) {\n\t\t\tlogger.error('AdminForumController', 'Error deleting entity', { err: error });\n\t\t\tres.status(500).json({ message: 'Failed to delete entity' });\n\t\t}\n\t}\n}\n\nexport const adminForumController = new AdminForumController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/forum/forum.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/forum/forum.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'posts' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'not' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errorMessage' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":274,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":274,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin Forum Service\n *\n * Handles business logic for forum management.\n */\n\nimport { db } from '@db';\nimport { forumStructure, threads, posts, threadPrefixes, tags } from '@schema';\nimport { eq, and, sql, count, desc, asc, isNull, not, ne } from 'drizzle-orm';\nimport { AdminError } from '../../admin.errors';\nimport type {\n\tCategoryInput,\n\tPrefixInput,\n\tTagInput,\n\tModerateThreadInput,\n\tPaginationInput\n} from './forum.validators';\nimport { ThreadId } from \"@shared/types\";\nimport { logger } from '../../../../core/logger';\n\nexport class AdminForumService {\n\tasync getAllCategories() {\n\t\ttry {\n\t\t\tconst allCategories = await db\n\t\t\t\t.select()\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.orderBy(\n\t\t\t\t\tasc(forumStructure.parentId),\n\t\t\t\t\tasc(forumStructure.position),\n\t\t\t\t\tasc(forumStructure.name)\n\t\t\t\t);\n\n\t\t\t// Get thread counts for each category\n\t\t\tconst threadCountsResult = await db\n\t\t\t\t.select({\n\t\t\t\t\tcategoryId: threads.categoryId,\n\t\t\t\t\tthreadCount: count()\n\t\t\t\t})\n\t\t\t\t.from(threads)\n\t\t\t\t.groupBy(threads.categoryId);\n\n\t\t\tconst countMap = new Map<number, number>();\n\t\t\tthreadCountsResult.forEach((row) => {\n\t\t\t\tif (row.categoryId !== null) {\n\t\t\t\t\tcountMap.set(row.categoryId, Number(row.threadCount));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn allCategories.map((category) => ({\n\t\t\t\t...category,\n\t\t\t\tthreadCount: countMap.get(category.id) || 0\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching categories:', error);\n\t\t\tthrow AdminError.database('Failed to fetch categories');\n\t\t}\n\t}\n\n\tasync getCategoryById(id: Id<'id'>) {\n\t\ttry {\n\t\t\tconst [category] = await db.select().from(forumStructure).where(eq(forumStructure.id, id));\n\n\t\t\tif (!category) {\n\t\t\t\tthrow AdminError.notFound('Category', id);\n\t\t\t}\n\n\t\t\t// Get thread count\n\t\t\tconst [threadCountResult] = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(threads)\n\t\t\t\t.where(eq(threads.categoryId, id));\n\n\t\t\treturn {\n\t\t\t\t...category,\n\t\t\t\tthreadCount: Number(threadCountResult?.count) || 0\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\t\t\tlogger.error('Error fetching category:', error);\n\t\t\tthrow AdminError.database('Failed to fetch category');\n\t\t}\n\t}\n\n\tasync createCategory(data: CategoryInput) {\n\t\ttry {\n\t\t\t// Check for duplicate slug\n\t\t\tconst [existingCategory] = await db\n\t\t\t\t.select({ id: forumStructure.id })\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(eq(forumStructure.slug, data.slug));\n\n\t\t\tif (existingCategory) {\n\t\t\t\tthrow AdminError.duplicate('Category', 'slug', data.slug);\n\t\t\t}\n\n\t\t\t// If this has a parent, verify parent exists\n\t\t\tif (data.parentId) {\n\t\t\t\tconst [parentCategory] = await db\n\t\t\t\t\t.select({ id: forumStructure.id })\n\t\t\t\t\t.from(forumStructure)\n\t\t\t\t\t.where(eq(forumStructure.id, data.parentId));\n\n\t\t\t\tif (!parentCategory) {\n\t\t\t\t\tthrow AdminError.notFound('Parent category', data.parentId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst [newCategory] = await db\n\t\t\t\t.insert(forumStructure)\n\t\t\t\t.values({\n\t\t\t\t\tname: data.name,\n\t\t\t\t\tdescription: data.description,\n\t\t\t\t\tslug: data.slug,\n\t\t\t\t\tparentId: data.parentId,\n\t\t\t\t\tposition: data.position ?? 0,\n\t\t\t\t\ticon: data.icon,\n\t\t\t\t\tisHidden: data.isHidden,\n\t\t\t\t\tallowThreads: data.allowThreads,\n\t\t\t\t\tviewPermission: data.viewPermission,\n\t\t\t\t\tpostPermission: data.postPermission\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\treturn newCategory;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\t\t\tlogger.error('Error creating category:', error);\n\t\t\tthrow AdminError.database('Failed to create category');\n\t\t}\n\t}\n\n\tasync updateCategory(id: Id<'id'>, data: CategoryInput) {\n\t\ttry {\n\t\t\t// Check category exists\n\t\t\tconst [existingCategory] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(eq(forumStructure.id, id));\n\n\t\t\tif (!existingCategory) {\n\t\t\t\tthrow AdminError.notFound('Category', id);\n\t\t\t}\n\n\t\t\t// Check for slug conflicts\n\t\t\tif (data.slug && data.slug !== existingCategory.slug) {\n\t\t\t\tconst [slugConflict] = await db\n\t\t\t\t\t.select({ id: forumStructure.id })\n\t\t\t\t\t.from(forumStructure)\n\t\t\t\t\t.where(and(eq(forumStructure.slug, data.slug), ne(forumStructure.id, id)));\n\n\t\t\t\tif (slugConflict) {\n\t\t\t\t\tthrow AdminError.duplicate('Category', 'slug', data.slug);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Prevent category from being its own parent\n\t\t\tif (data.parentId === id) {\n\t\t\t\tthrow AdminError.validation('Category cannot be its own parent');\n\t\t\t}\n\n\t\t\t// If updating parent, verify parent exists\n\t\t\tif (data.parentId && data.parentId !== existingCategory.parentId) {\n\t\t\t\tconst [parentCategory] = await db\n\t\t\t\t\t.select({ id: forumStructure.id })\n\t\t\t\t\t.from(forumStructure)\n\t\t\t\t\t.where(eq(forumStructure.id, data.parentId));\n\n\t\t\t\tif (!parentCategory) {\n\t\t\t\t\tthrow AdminError.notFound('Parent category', data.parentId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst [updatedCategory] = await db\n\t\t\t\t.update(forumStructure)\n\t\t\t\t.set({\n\t\t\t\t\tname: data.name,\n\t\t\t\t\tdescription: data.description,\n\t\t\t\t\tslug: data.slug,\n\t\t\t\t\tparentId: data.parentId,\n\t\t\t\t\tposition: data.position ?? 0,\n\t\t\t\t\ticon: data.icon,\n\t\t\t\t\tisHidden: data.isHidden,\n\t\t\t\t\tallowThreads: data.allowThreads,\n\t\t\t\t\tviewPermission: data.viewPermission,\n\t\t\t\t\tpostPermission: data.postPermission,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(forumStructure.id, id))\n\t\t\t\t.returning();\n\n\t\t\treturn updatedCategory;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\t\t\tlogger.error('Error updating category:', error);\n\t\t\tthrow AdminError.database('Failed to update category');\n\t\t}\n\t}\n\n\tasync deleteCategory(id: Id<'id'>) {\n\t\ttry {\n\t\t\t// Check category exists\n\t\t\tconst [existingCategory] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(eq(forumStructure.id, id));\n\n\t\t\tif (!existingCategory) {\n\t\t\t\tthrow AdminError.notFound('Category', id);\n\t\t\t}\n\n\t\t\t// Check for child categories\n\t\t\tconst [childCount] = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(eq(forumStructure.parentId, id));\n\n\t\t\tif (Number(childCount?.count) > 0) {\n\t\t\t\tthrow AdminError.validation('Cannot delete category with child categories');\n\t\t\t}\n\n\t\t\t// Check if category has threads\n\t\t\tconst [threadCount] = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(threads)\n\t\t\t\t.where(eq(threads.categoryId, id));\n\n\t\t\tif (Number(threadCount?.count) > 0) {\n\t\t\t\tthrow AdminError.validation('Cannot delete category with threads');\n\t\t\t}\n\n\t\t\t// Delete the category\n\t\t\tawait db.delete(forumStructure).where(eq(forumStructure.id, id));\n\n\t\t\treturn { success: true, message: 'Category deleted successfully' };\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\t\t\tlogger.error('Error deleting category:', error);\n\t\t\tthrow AdminError.database('Failed to delete category');\n\t\t}\n\t}\n\n\t// Thread Prefix Management\n\n\tasync getAllPrefixes() {\n\t\ttry {\n\t\t\tconst prefixes = await db\n\t\t\t\t.select()\n\t\t\t\t.from(threadPrefixes)\n\t\t\t\t.orderBy(asc(threadPrefixes.position), asc(threadPrefixes.name));\n\n\t\t\treturn prefixes;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching prefixes:', error);\n\t\t\tthrow AdminError.database('Failed to fetch thread prefixes');\n\t\t}\n\t}\n\n\tasync createPrefix(data: PrefixInput) {\n\t\ttry {\n\t\t\t// Check for duplicate name\n\t\t\tconst [existingPrefix] = await db\n\t\t\t\t.select({ id: threadPrefixes.id })\n\t\t\t\t.from(threadPrefixes)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(threadPrefixes.name, data.name),\n\t\t\t\t\t\tdata.categoryId\n\t\t\t\t\t\t\t? eq(threadPrefixes.categoryId, data.categoryId)\n\t\t\t\t\t\t\t: isNull(threadPrefixes.categoryId)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tif (existingPrefix) {\n\t\t\t\tconst errorMessage = data.categoryId\n\t\t\t\t\t? 'A prefix with this name already exists for this category'\n\t\t\t\t\t: 'A global prefix with this name already exists';\n\t\t\t\tthrow AdminError.duplicate('Prefix', 'name', data.name);\n\t\t\t}\n\n\t\t\t// If category-specific, verify category exists\n\t\t\tif (data.categoryId) {\n\t\t\t\tconst [category] = await db\n\t\t\t\t\t.select({ id: forumStructure.id })\n\t\t\t\t\t.from(forumStructure)\n\t\t\t\t\t.where(eq(forumStructure.id, data.categoryId));\n\n\t\t\t\tif (!category) {\n\t\t\t\t\tthrow AdminError.notFound('Category', data.categoryId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst [newPrefix] = await db\n\t\t\t\t.insert(threadPrefixes)\n\t\t\t\t.values({\n\t\t\t\t\tname: data.name,\n\t\t\t\t\tcolor: data.color,\n\t\t\t\t\ticon: data.icon,\n\t\t\t\t\tcategoryId: data.categoryId,\n\t\t\t\t\tisHidden: data.isHidden,\n\t\t\t\t\tposition: data.position ?? 0\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\treturn newPrefix;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\t\t\tlogger.error('Error creating thread prefix:', error);\n\t\t\tthrow AdminError.database('Failed to create thread prefix');\n\t\t}\n\t}\n\n\t// Tag Management\n\n\tasync getAllTags() {\n\t\ttry {\n\t\t\tconst allTags = await db.select().from(tags).orderBy(asc(tags.name));\n\n\t\t\treturn allTags;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching tags:', error);\n\t\t\tthrow AdminError.database('Failed to fetch tags');\n\t\t}\n\t}\n\n\tasync createTag(data: TagInput) {\n\t\ttry {\n\t\t\t// Check for duplicate name\n\t\t\tconst [existingName] = await db\n\t\t\t\t.select({ id: tags.id })\n\t\t\t\t.from(tags)\n\t\t\t\t.where(eq(tags.name, data.name));\n\n\t\t\tif (existingName) {\n\t\t\t\tthrow AdminError.duplicate('Tag', 'name', data.name);\n\t\t\t}\n\n\t\t\t// Check for duplicate slug\n\t\t\tconst [existingSlug] = await db\n\t\t\t\t.select({ id: tags.id })\n\t\t\t\t.from(tags)\n\t\t\t\t.where(eq(tags.slug, data.slug));\n\n\t\t\tif (existingSlug) {\n\t\t\t\tthrow AdminError.duplicate('Tag', 'slug', data.slug);\n\t\t\t}\n\n\t\t\tconst [newTag] = await db\n\t\t\t\t.insert(tags)\n\t\t\t\t.values({\n\t\t\t\t\tname: data.name,\n\t\t\t\t\tslug: data.slug,\n\t\t\t\t\tdescription: data.description\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\treturn newTag;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\t\t\tlogger.error('Error creating tag:', error);\n\t\t\tthrow AdminError.database('Failed to create tag');\n\t\t}\n\t}\n\n\tasync updateTag(id: Id<'id'>, data: TagInput) {\n\t\ttry {\n\t\t\t// Check tag exists\n\t\t\tconst [existingTag] = await db.select().from(tags).where(eq(tags.id, id));\n\n\t\t\tif (!existingTag) {\n\t\t\t\tthrow AdminError.notFound('Tag', id);\n\t\t\t}\n\n\t\t\t// Check for name conflicts\n\t\t\tif (data.name && data.name !== existingTag.name) {\n\t\t\t\tconst [nameConflict] = await db\n\t\t\t\t\t.select({ id: tags.id })\n\t\t\t\t\t.from(tags)\n\t\t\t\t\t.where(and(eq(tags.name, data.name), ne(tags.id, id)));\n\n\t\t\t\tif (nameConflict) {\n\t\t\t\t\tthrow AdminError.duplicate('Tag', 'name', data.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for slug conflicts\n\t\t\tif (data.slug && data.slug !== existingTag.slug) {\n\t\t\t\tconst [slugConflict] = await db\n\t\t\t\t\t.select({ id: tags.id })\n\t\t\t\t\t.from(tags)\n\t\t\t\t\t.where(and(eq(tags.slug, data.slug), ne(tags.id, id)));\n\n\t\t\t\tif (slugConflict) {\n\t\t\t\t\tthrow AdminError.duplicate('Tag', 'slug', data.slug);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst [updatedTag] = await db\n\t\t\t\t.update(tags)\n\t\t\t\t.set({\n\t\t\t\t\tname: data.name,\n\t\t\t\t\tslug: data.slug,\n\t\t\t\t\tdescription: data.description\n\t\t\t\t})\n\t\t\t\t.where(eq(tags.id, id))\n\t\t\t\t.returning();\n\n\t\t\treturn updatedTag;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\t\t\tlogger.error('Error updating tag:', error);\n\t\t\tthrow AdminError.database('Failed to update tag');\n\t\t}\n\t}\n\n\tasync deleteTag(id: Id<'id'>) {\n\t\ttry {\n\t\t\t// Check tag exists\n\t\t\tconst [existingTag] = await db.select().from(tags).where(eq(tags.id, id));\n\n\t\t\tif (!existingTag) {\n\t\t\t\tthrow AdminError.notFound('Tag', id);\n\t\t\t}\n\n\t\t\t// Delete the tag\n\t\t\tawait db.delete(tags).where(eq(tags.id, id));\n\n\t\t\treturn { success: true, message: 'Tag deleted successfully' };\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\t\t\tlogger.error('Error deleting tag:', error);\n\t\t\tthrow AdminError.database('Failed to delete tag');\n\t\t}\n\t}\n\n\t// Thread moderation\n\n\tasync moderateThread(threadId: ThreadId, data: ModerateThreadInput) {\n\t\ttry {\n\t\t\t// Check thread exists\n\t\t\tconst [existingThread] = await db.select().from(threads).where(eq(threads.id, threadId));\n\n\t\t\tif (!existingThread) {\n\t\t\t\tthrow AdminError.notFound('Thread', threadId);\n\t\t\t}\n\n\t\t\t// If changing category, verify category exists and allows threads\n\t\t\tif (data.categoryId && data.categoryId !== existingThread.categoryId) {\n\t\t\t\tconst [category] = await db\n\t\t\t\t\t.select({ id: forumStructure.id, allowThreads: forumStructure.allowThreads })\n\t\t\t\t\t.from(forumStructure)\n\t\t\t\t\t.where(eq(forumStructure.id, data.categoryId));\n\n\t\t\t\tif (!category) {\n\t\t\t\t\tthrow AdminError.notFound('Target category', data.categoryId);\n\t\t\t\t}\n\n\t\t\t\tif (!category.allowThreads) {\n\t\t\t\t\tthrow AdminError.validation('Target category does not allow threads');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If changing prefix, verify prefix exists\n\t\t\tif (data.prefixId && data.prefixId !== existingThread.prefixId) {\n\t\t\t\tconst [prefix] = await db\n\t\t\t\t\t.select({ id: threadPrefixes.id })\n\t\t\t\t\t.from(threadPrefixes)\n\t\t\t\t\t.where(eq(threadPrefixes.id, data.prefixId));\n\n\t\t\t\tif (!prefix) {\n\t\t\t\t\tthrow AdminError.notFound('Thread prefix', data.prefixId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst [updatedThread] = await db\n\t\t\t\t.update(threads)\n\t\t\t\t.set({\n\t\t\t\t\tisLocked: data.isLocked !== undefined ? data.isLocked : existingThread.isLocked,\n\t\t\t\t\tisSticky: data.isSticky !== undefined ? data.isSticky : existingThread.isSticky,\n\t\t\t\t\tisHidden: data.isHidden !== undefined ? data.isHidden : existingThread.isHidden,\n\t\t\t\t\tprefixId: data.prefixId !== undefined ? data.prefixId : existingThread.prefixId,\n\t\t\t\t\tcategoryId: data.categoryId !== undefined ? data.categoryId : existingThread.categoryId,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(threads.id, threadId))\n\t\t\t\t.returning();\n\n\t\t\treturn updatedThread;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\t\t\tlogger.error('Error moderating thread:', error);\n\t\t\tthrow AdminError.database('Failed to moderate thread');\n\t\t}\n\t}\n\n\t// Forum entity management methods\n\tasync getAllEntities() {\n\t\tconst entities = await db\n\t\t\t.select()\n\t\t\t.from(forumStructure)\n\t\t\t.orderBy(forumStructure.position, forumStructure.name);\n\n\t\treturn entities;\n\t}\n\n\tasync getEntityById(id: Id<'id'>) {\n\t\tconst [entity] = await db\n\t\t\t.select()\n\t\t\t.from(forumStructure)\n\t\t\t.where(eq(forumStructure.id, id))\n\t\t\t.limit(1);\n\n\t\treturn entity;\n\t}\n\n\tasync createEntity(data: any) {\n\t\tconst [entity] = await db.insert(forumStructure).values(data).returning();\n\n\t\treturn entity;\n\t}\n\n\tasync updateEntity(id: Id<'id'>, data: any) {\n\t\tconst [entity] = await db\n\t\t\t.update(forumStructure)\n\t\t\t.set({\n\t\t\t\t...data,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(forumStructure.id, id))\n\t\t\t.returning();\n\n\t\treturn entity;\n\t}\n\n\tasync deleteEntity(id: Id<'id'>) {\n\t\t// Check if entity has children\n\t\tconst children = await db\n\t\t\t.select({ id: forumStructure.id })\n\t\t\t.from(forumStructure)\n\t\t\t.where(eq(forumStructure.parentId, id))\n\t\t\t.limit(1);\n\n\t\tif (children.length > 0) {\n\t\t\tthrow new Error('Cannot delete entity with children');\n\t\t}\n\n\t\t// Check if entity has threads (only for forums)\n\t\tconst entity = await this.getEntityById(id);\n\t\tif (entity && entity.type === 'forum') {\n\t\t\tconst threadCount = await db\n\t\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t\t.from(threads)\n\t\t\t\t.where(eq(threads.categoryId, id));\n\n\t\t\tif (threadCount[0].count > 0) {\n\t\t\t\tthrow new Error('Cannot delete forum with threads');\n\t\t\t}\n\t\t}\n\n\t\tconst result = await db.delete(forumStructure).where(eq(forumStructure.id, id));\n\n\t\treturn result.rowCount > 0;\n\t}\n}\n\nexport const adminForumService = new AdminForumService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/forum/forum.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/forumPrefix/forumPrefix.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { threadPrefixes } from '@schema';\nimport { eq, not, and, asc, desc } from 'drizzle-orm';\nimport { AdminError } from '../../admin.errors';\nimport type { CategoryId } from '@shared/types/ids';\n\ninterface UpdatePrefixInput {\n\tname?: string;\n\tcolor?: string | null;\n\tisActive?: boolean;\n\tposition?: number;\n\tcategoryId?: CategoryId | null;\n}\n\nexport class ForumPrefixService {\n\tasync updatePrefix(id: Id<'id'>, data: UpdatePrefixInput) {\n\t\tconst [existing] = await db.select().from(threadPrefixes).where(eq(threadPrefixes.id, id));\n\n\t\tif (!existing) throw AdminError.notFound('Thread Prefix', id);\n\n\t\t// Prevent duplicate names within same scope\n\t\tif (data.name && data.name !== existing.name) {\n\t\t\tconst [dupe] = await db\n\t\t\t\t.select({ id: threadPrefixes.id })\n\t\t\t\t.from(threadPrefixes)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(threadPrefixes.name, data.name),\n\t\t\t\t\t\tdata.categoryId\n\t\t\t\t\t\t\t? eq(threadPrefixes.categoryId, data.categoryId)\n\t\t\t\t\t\t\t: not(threadPrefixes.categoryId.isNotNull())\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tif (dupe) throw AdminError.duplicate('Thread Prefix', 'name', data.name);\n\t\t}\n\n\t\tconst [updated] = await db\n\t\t\t.update(threadPrefixes)\n\t\t\t.set({ ...data, updatedAt: new Date() })\n\t\t\t.where(eq(threadPrefixes.id, id))\n\t\t\t.returning();\n\n\t\treturn updated;\n\t}\n\n\tasync deletePrefix(id: Id<'id'>) {\n\t\tconst [deleted] = await db.delete(threadPrefixes).where(eq(threadPrefixes.id, id)).returning();\n\n\t\tif (!deleted) throw AdminError.notFound('Thread Prefix', id);\n\t\treturn { success: true };\n\t}\n\n\t/**\n\t * Reorders prefixes within the same category/global scope.\n\t * Accepts an array of prefix IDs in the desired order.\n\t */\n\tasync reorderPrefixes(prefixIds: number[]) {\n\t\tif (!prefixIds.length) return { success: true };\n\n\t\t// Fetch all prefixes involved to ensure same scope\n\t\tconst records = await db.select().from(threadPrefixes).where(threadPrefixes.id.in(prefixIds));\n\n\t\tif (records.length !== prefixIds.length)\n\t\t\tthrow AdminError.validation('One or more prefixes not found');\n\n\t\t// Use transaction to update positions\n\t\tawait db.transaction(async (trx) => {\n\t\t\tfor (let i = 0; i < prefixIds.length; i++) {\n\t\t\t\tawait trx\n\t\t\t\t\t.update(threadPrefixes)\n\t\t\t\t\t.set({ position: i })\n\t\t\t\t\t.where(eq(threadPrefixes.id, prefixIds[i]));\n\t\t\t}\n\t\t});\n\t\treturn { success: true };\n\t}\n}\n\nexport const forumPrefixService = new ForumPrefixService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/moderator-notes/moderator-notes.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'moderatorNoteTypeEnum' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Router } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { z } from 'zod';\nimport { db } from '@db';\nimport { moderatorNotes, moderatorNoteTypeEnum } from '@schema';\nimport { eq, and, desc } from 'drizzle-orm';\nimport { isAdminOrModerator } from '../../../auth/middleware/auth.middleware';\nimport { getUserIdFromRequest } from '@server/src/utils/auth';\nimport { logger } from '@server/src/core/logger';\nimport type { EntityId } from '@shared/types/ids';\n\nconst router = Router();\n\n// Validation schemas\nconst createModeratorNoteSchema = z.object({\n\ttype: z.enum(['thread', 'post', 'user']),\n\titemId: z.union([z.string(), z.number()]).transform(String),\n\tnote: z.string().min(1).max(1000)\n});\n\nconst getModeratorNotesSchema = z.object({\n\ttype: z.enum(['thread', 'post', 'user']),\n\titemId: z.union([z.string(), z.number()]).transform(String)\n});\n\n// Create a new moderator note\nrouter.post('/', isAdminOrModerator, async (req, res) => {\n\ttry {\n\t\tconst validatedData = createModeratorNoteSchema.parse(req.body);\n\t\tconst userId = getUserIdFromRequest(req);\n\n\t\tif (!userId) {\n\t\t\treturn res.status(401).json({ error: 'Unauthorized' });\n\t\t}\n\n\t\tconst [note] = await db\n\t\t\t.insert(moderatorNotes)\n\t\t\t.values({\n\t\t\t\t...validatedData,\n\t\t\t\tcreatedBy: userId\n\t\t\t})\n\t\t\t.returning();\n\n\t\tlogger.info('ModeratorNotes', 'Created moderator note', {\n\t\t\tnoteId: note.id,\n\t\t\ttype: note.type,\n\t\t\titemId: note.itemId,\n\t\t\tcreatedBy: userId\n\t\t});\n\n\t\tres.status(201).json(note);\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn res.status(400).json({\n\t\t\t\terror: 'Invalid request data',\n\t\t\t\tdetails: error.flatten()\n\t\t\t});\n\t\t}\n\n\t\tlogger.error('ModeratorNotes', 'Error creating moderator note', {\n\t\t\terror,\n\t\t\tbody: req.body\n\t\t});\n\n\t\tres.status(500).json({ error: 'Internal server error' });\n\t}\n});\n\n// Get moderator notes for a specific item\nrouter.get('/', isAdminOrModerator, async (req, res) => {\n\ttry {\n\t\tconst validatedQuery = getModeratorNotesSchema.parse(req.query);\n\n\t\tconst notes = await db\n\t\t\t.select()\n\t\t\t.from(moderatorNotes)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(moderatorNotes.type, validatedQuery.type as any),\n\t\t\t\t\teq(moderatorNotes.itemId, validatedQuery.itemId)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(desc(moderatorNotes.createdAt));\n\n\t\tres.json(notes);\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn res.status(400).json({\n\t\t\t\terror: 'Invalid query parameters',\n\t\t\t\tdetails: error.flatten()\n\t\t\t});\n\t\t}\n\n\t\tlogger.error('ModeratorNotes', 'Error fetching moderator notes', {\n\t\t\terror,\n\t\t\tquery: req.query\n\t\t});\n\n\t\tres.status(500).json({ error: 'Internal server error' });\n\t}\n});\n\n// Delete a moderator note (admin only)\nrouter.delete('/:id', isAdminOrModerator, async (req, res) => {\n\ttry {\n\t\tconst noteId = req.params.id as EntityId;\n\t\tconst userId = getUserIdFromRequest(req);\n\n\t\t// Check if note exists and user can delete it\n\t\tconst [existingNote] = await db\n\t\t\t.select()\n\t\t\t.from(moderatorNotes)\n\t\t\t.where(eq(moderatorNotes.id, noteId))\n\t\t\t.limit(1);\n\n\t\tif (!existingNote) {\n\t\t\treturn res.status(404).json({ error: 'Note not found' });\n\t\t}\n\n\t\t// Only allow deletion by the creator or admins\n\t\tconst isAdmin = userService.getUserFromRequest(req)?.role === 'admin';\n\t\tif (existingNote.createdBy !== userId && !isAdmin) {\n\t\t\treturn res.status(403).json({ error: 'You can only delete your own notes' });\n\t\t}\n\n\t\tawait db.delete(moderatorNotes).where(eq(moderatorNotes.id, noteId));\n\n\t\tlogger.info('ModeratorNotes', 'Deleted moderator note', {\n\t\t\tnoteId,\n\t\t\tdeletedBy: userId\n\t\t});\n\n\t\tres.status(204).send();\n\t} catch (error) {\n\t\tlogger.error('ModeratorNotes', 'Error deleting moderator note', {\n\t\t\terror,\n\t\t\tnoteId: req.params.id\n\t\t});\n\n\t\tres.status(500).json({ error: 'Internal server error' });\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/permissions/permissions.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/permissions/permissions.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/permissions/permissions.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/referrals/referrals.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/referrals/referrals.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/referrals/referrals.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { eq, sql } from 'drizzle-orm';\nimport type { UserId } from '@shared/types/ids';\nimport { db } from '../../../../core/db';\nimport { referralSources } from '@schema/system/referralSources';\nimport { userReferrals } from '@schema/system/userReferrals';\nimport { users } from '@schema/user/users';\nimport { EntityId } from \"@shared/types\";\nimport { logger } from '../../../../core/logger';\n\n/**\n * Service for managing referral sources and user referrals\n */\nexport class ReferralsService {\n\t/**\n\t * Create a new referral source\n\t *\n\t * @param name Display name of the referral source\n\t * @param slug Unique slug for the referral source\n\t * @param metadata Optional metadata for the referral source\n\t * @param createdBy User ID of the admin who created the source\n\t * @returns The created referral source\n\t */\n\tasync createReferralSource(\n\t\tname: string,\n\t\tslug: string,\n\t\tmetadata: Record<string, any> = {},\n\t\tcreatedBy?: number\n\t) {\n\t\ttry {\n\t\t\tconst [source] = await db\n\t\t\t\t.insert(referralSources)\n\t\t\t\t.values({\n\t\t\t\t\tname,\n\t\t\t\t\tslug,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tcreatedBy\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\treturn source;\n\t\t} catch (error) {\n\t\t\tif (error.message?.includes('unique constraint')) {\n\t\t\t\tif (error.message.includes('referral_sources_slug_unique')) {\n\t\t\t\t\tthrow new Error(`Referral source with slug \"${slug}\" already exists`);\n\t\t\t\t} else if (error.message.includes('referral_sources_name_unique')) {\n\t\t\t\t\tthrow new Error(`Referral source with name \"${name}\" already exists`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Record a user referral\n\t *\n\t * @param params Parameters for recording a user referral\n\t * @returns The created user referral or null if already exists\n\t */\n\tasync recordUserReferral(params: {\n\t\tuserId: UserId;\n\t\treferredByUserId?: EntityId;\n\t\tsourceSlug: string;\n\t}) {\n\t\tconst { userId, referredByUserId, sourceSlug } = params;\n\n\t\t// First, find the referral source by slug\n\t\tconst source = await db.query.referralSources.findFirst({\n\t\t\twhere: eq(referralSources.slug, sourceSlug)\n\t\t});\n\n\t\tif (!source) {\n\t\t\tthrow new Error(`Referral source with slug \"${sourceSlug}\" not found`);\n\t\t}\n\n\t\ttry {\n\t\t\t// Insert with ON CONFLICT DO NOTHING\n\t\t\tconst result = await db\n\t\t\t\t.insert(userReferrals)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\treferredByUserId,\n\t\t\t\t\treferralSourceId: source.id\n\t\t\t\t})\n\t\t\t\t.onConflictDoNothing({ target: [userReferrals.userId] })\n\t\t\t\t.returning();\n\n\t\t\treturn result[0] || null;\n\t\t} catch (error) {\n\t\t\t// Log error but don't throw, as we want to silently handle duplicates\n\t\t\tlogger.error('Error recording user referral:', error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get all referral sources\n\t */\n\tasync getAllReferralSources() {\n\t\treturn db.query.referralSources.findMany({\n\t\t\torderBy: (sources) => [sources.name]\n\t\t});\n\t}\n\n\t/**\n\t * Get referral source statistics\n\t */\n\tasync getReferralSourceStats() {\n\t\tconst stats = await db.execute(sql`\n      SELECT \n        rs.name AS source_name, \n        rs.slug AS source_slug,\n        COUNT(ur.id) AS referral_count\n      FROM \n        referral_sources rs\n      LEFT JOIN \n        user_referrals ur ON rs.id = ur.referral_source_id\n      GROUP BY \n        rs.id, rs.name, rs.slug\n      ORDER BY \n        referral_count DESC\n    `);\n\n\t\treturn stats.rows;\n\t}\n\n\t/**\n\t * Get user-to-user referral statistics\n\t */\n\tasync getUserReferralStats() {\n\t\tconst stats = await db.execute(sql`\n      SELECT \n        u.username AS user_username,\n        u.id AS user_id,\n        ref_user.username AS referred_by_username,\n        ref_user.id AS referred_by_id,\n        rs.name AS source_name,\n        rs.slug AS source_slug,\n        ur.created_at AS referral_date\n      FROM \n        user_referrals ur\n      JOIN \n        users u ON ur.user_id = u.id\n      LEFT JOIN \n        users ref_user ON ur.referred_by_user_id = ref_user.id\n      LEFT JOIN \n        referral_sources rs ON ur.referral_source_id = rs.id\n      ORDER BY \n        ur.created_at DESC\n    `);\n\n\t\treturn stats.rows;\n\t}\n\n\t/**\n\t * Get referral count by user\n\t */\n\tasync getReferralCountByUser() {\n\t\tconst stats = await db.execute(sql`\n      SELECT \n        u.username AS referrer_username,\n        u.id AS referrer_id,\n        COUNT(ur.id) AS referral_count\n      FROM \n        users u\n      JOIN \n        user_referrals ur ON u.id = ur.referred_by_user_id\n      GROUP BY \n        u.id, u.username\n      ORDER BY \n        referral_count DESC\n      LIMIT 50\n    `);\n\n\t\treturn stats.rows;\n\t}\n}\n\nexport const referralsService = new ReferralsService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/referrals/referrals.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/reports/reports.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport type { ReportId, MessageId } from '@shared/types/ids';\nimport { adminReportsService } from './reports.service';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { getUserId } from '../../admin.middleware';\nimport { adminController } from '../../admin.controller';\nimport {\n\tGetReportsQuerySchema,\n\tReportActionSchema,\n\tBanUserSchema,\n\tDeleteContentSchema\n} from './reports.validators';\nimport { validateRequestBody, validateQueryParams } from '../../admin.validation';\n\nexport class AdminReportsController {\n\tasync getReports(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst query = validateQueryParams(req, res, GetReportsQuerySchema);\n\t\t\tif (!query) return;\n\t\t\tconst result = await adminReportsService.getReports(query);\n\t\t\tres.json(result);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to fetch reports' });\n\t\t}\n\t}\n\n\tasync getReportById(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst reportId = req.params.id as ReportId;\n\n\t\t\tconst report = await adminReportsService.getReportById(reportId);\n\t\t\tres.json(report);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to fetch report details' });\n\t\t}\n\t}\n\n\tasync resolveReport(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst reportId = req.params.id as ReportId;\n\n\t\t\tconst body = validateRequestBody(req, res, ReportActionSchema);\n\t\t\tif (!body) return;\n\t\t\tconst adminId = userService.getUserFromRequest(req);\n\t\t\tconst updatedReport = await adminReportsService.updateReportStatus(\n\t\t\t\treportId,\n\t\t\t\t'resolved',\n\t\t\t\tadminId,\n\t\t\t\tbody.notes\n\t\t\t);\n\n\t\t\tawait adminController.logAction(req, 'RESOLVE_REPORT', 'report', reportId.toString(), {\n\t\t\t\tnotes: body.notes,\n\t\t\t\tfinalStatus: 'resolved'\n\t\t\t});\n\t\t\tres.json({ message: 'Report resolved successfully', data: updatedReport });\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to resolve report' });\n\t\t}\n\t}\n\n\tasync dismissReport(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst reportId = req.params.id as ReportId;\n\n\t\t\tconst body = validateRequestBody(req, res, ReportActionSchema);\n\t\t\tif (!body) return;\n\t\t\tconst adminId = userService.getUserFromRequest(req);\n\t\t\tconst updatedReport = await adminReportsService.updateReportStatus(\n\t\t\t\treportId,\n\t\t\t\t'dismissed',\n\t\t\t\tadminId,\n\t\t\t\tbody.notes\n\t\t\t);\n\n\t\t\tawait adminController.logAction(req, 'DISMISS_REPORT', 'report', reportId.toString(), {\n\t\t\t\tnotes: body.notes,\n\t\t\t\tfinalStatus: 'dismissed'\n\t\t\t});\n\t\t\tres.json({ message: 'Report dismissed successfully', data: updatedReport });\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to dismiss report' });\n\t\t}\n\t}\n\n\tasync banUser(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst userIdToBan = req.params.userId as string; // User ID as string\n\n\t\t\tconst body = validateRequestBody(req, res, BanUserSchema);\n\t\t\tif (!body) return;\n\t\t\tconst adminId = userService.getUserFromRequest(req);\n\t\t\tconst banResult = await adminReportsService.banUser(userIdToBan, body, adminId);\n\n\t\t\tawait adminController.logAction(req, 'BAN_USER', 'user', userIdToBan.toString(), {\n\t\t\t\treason: body.reason,\n\t\t\t\tduration: body.duration\n\t\t\t});\n\t\t\tres.json({ message: 'User banned successfully', data: banResult });\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to ban user' });\n\t\t}\n\t}\n\n\tasync deleteContent(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst contentType = req.params.contentType as 'post' | 'thread' | 'message';\n\t\t\tconst contentId = req.params.contentId as MessageId;\n\n\t\t\tif (!['post', 'thread', 'message'].includes(contentType)) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Invalid content type for deletion',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst body = validateRequestBody(req, res, DeleteContentSchema);\n\t\t\tif (!body) return;\n\t\t\tconst adminId = userService.getUserFromRequest(req);\n\t\t\tconst deleteResult = await adminReportsService.deleteContent(\n\t\t\t\tcontentType,\n\t\t\t\tcontentId,\n\t\t\t\tbody,\n\t\t\t\tadminId\n\t\t\t);\n\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t`DELETE_${contentType.toUpperCase()}`,\n\t\t\t\tcontentType,\n\t\t\t\tcontentId.toString(),\n\t\t\t\t{ reason: body.reason }\n\t\t\t);\n\t\t\tres.json(deleteResult);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to delete content' });\n\t\t}\n\t}\n}\n\nexport const adminReportsController = new AdminReportsController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/reports/reports.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/reports/reports.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'auditLogs' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'like' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin Reports Service\n *\n * Handles business logic for reports and content moderation.\n */\n\nimport { db } from '@db';\nimport {\n\tusers,\n\treportedContent,\n\tcontentModerationActions,\n\tuserBans,\n\tposts,\n\tthreads,\n\tshoutboxMessages,\n\tauditLogs\n} from '@schema';\nimport { eq, and, like, ilike, or, desc, sql, asc, inArray } from 'drizzle-orm';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport type {\n\tGetReportsQueryInput,\n\tReportActionInput,\n\tBanUserInput,\n\tDeleteContentInput\n} from './reports.validators';\nimport type { ReportId, AdminUserId, AuthorId, ContentId } from '@shared/types/ids';\nimport { logger } from '../../../../core/logger';\n\nasync function getContentPreview(type: string, contentId: ContentId): Promise<string | null> {\n\ttry {\n\t\tswitch (type) {\n\t\t\tcase 'post': {\n\t\t\t\tconst [post] = await db\n\t\t\t\t\t.select({ content: posts.content })\n\t\t\t\t\t.from(posts)\n\t\t\t\t\t.where(eq(posts.id, contentId));\n\t\t\t\treturn post?.content || 'Content not found';\n\t\t\t}\n\t\t\tcase 'thread': {\n\t\t\t\tconst [thread] = await db\n\t\t\t\t\t.select({ title: threads.title })\n\t\t\t\t\t.from(threads)\n\t\t\t\t\t.where(eq(threads.id, contentId));\n\t\t\t\treturn thread?.title || 'Content not found';\n\t\t\t}\n\t\t\tcase 'message': {\n\t\t\t\tconst [message] = await db\n\t\t\t\t\t.select({ content: shoutboxMessages.content })\n\t\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t\t.where(eq(shoutboxMessages.id, contentId));\n\t\t\t\treturn message?.content || 'Content not found';\n\t\t\t}\n\t\t\tcase 'user':\n\t\t\t\treturn 'User profile reported'; // Or fetch user profile snippet\n\t\t\tdefault:\n\t\t\t\treturn 'Unknown content type';\n\t\t}\n\t} catch (error) {\n\t\tlogger.error(`Error getting content preview for ${type} ${contentId}:`, error);\n\t\treturn 'Error retrieving content preview';\n\t}\n}\n\nexport class AdminReportsService {\n\tasync getReports(params: GetReportsQueryInput) {\n\t\tconst { page, limit, status, type, search, sortBy, sortOrder } = params;\n\t\tconst offset = (page - 1) * limit;\n\n\t\tlet query = db\n\t\t\t.select({\n\t\t\t\tid: reportedContent.id,\n\t\t\t\tcontentType: reportedContent.contentType,\n\t\t\t\tcontentId: reportedContent.contentId,\n\t\t\t\treason: reportedContent.reason,\n\t\t\t\tstatus: reportedContent.status,\n\t\t\t\tcreatedAt: reportedContent.createdAt,\n\t\t\t\tresolvedAt: reportedContent.resolvedAt,\n\t\t\t\treporterId: reportedContent.reporterId,\n\t\t\t\treportedUserId: reportedContent.reportedUserId, // User who authored the content\n\t\t\t\tresolvedById: reportedContent.resolvedById,\n\t\t\t\tnotes: reportedContent.notes\n\t\t\t})\n\t\t\t.from(reportedContent)\n\t\t\t.leftJoin(users, eq(reportedContent.reportedUserId, users.id)) // Join with users who created the content\n\t\t\t.$dynamic(); // Required for conditional where clauses with Drizzle\n\n\t\tconst conditions = [];\n\t\tif (status && status !== 'all') {\n\t\t\tconditions.push(eq(reportedContent.status, status));\n\t\t}\n\t\tif (type && type !== 'all') {\n\t\t\tconditions.push(eq(reportedContent.contentType, type));\n\t\t}\n\t\tif (search) {\n\t\t\tconst searchTerm = `%${search}%`;\n\t\t\tconditions.push(\n\t\t\t\tor(\n\t\t\t\t\tilike(reportedContent.reason, searchTerm),\n\t\t\t\t\tilike(reportedContent.notes, searchTerm),\n\t\t\t\t\tilike(users.username, searchTerm) // Search by reported user's username\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tif (conditions.length > 0) {\n\t\t\tquery = query.where(and(...conditions));\n\t\t}\n\n\t\tconst countQuery = db\n\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t.from(reportedContent)\n\t\t\t.leftJoin(users, eq(reportedContent.reportedUserId, users.id))\n\t\t\t.$dynamic();\n\t\tif (conditions.length > 0) {\n\t\t\tcountQuery.where(and(...conditions));\n\t\t}\n\t\tconst [totalResult] = await countQuery;\n\t\tconst totalReports = Number(totalResult?.count) || 0;\n\n\t\tconst sortColumn = sortBy === 'reporter' ? users.username : reportedContent.createdAt; // Example, adapt as needed\n\t\tconst sortDirection = sortOrder === 'asc' ? asc : desc;\n\n\t\tconst reportsData = await query.orderBy(sortDirection(sortColumn)).limit(limit).offset(offset);\n\n\t\t// Enhance reports with usernames and previews\n\t\tconst enhancedReports = await Promise.all(\n\t\t\treportsData.map(async (report) => {\n\t\t\t\tlet reporterUsername: string | null = null;\n\t\t\t\tlet reportedUsername: string | null = null;\n\t\t\t\tlet resolvedByUsername: string | null = null;\n\n\t\t\t\tif (report.reporterId) {\n\t\t\t\t\tconst [rUser] = await db\n\t\t\t\t\t\t.select({ username: users.username })\n\t\t\t\t\t\t.from(users)\n\t\t\t\t\t\t.where(eq(users.id, report.reporterId));\n\t\t\t\t\treporterUsername = rUser?.username || 'Unknown';\n\t\t\t\t}\n\t\t\t\tif (report.reportedUserId) {\n\t\t\t\t\tconst [ruUser] = await db\n\t\t\t\t\t\t.select({ username: users.username })\n\t\t\t\t\t\t.from(users)\n\t\t\t\t\t\t.where(eq(users.id, report.reportedUserId));\n\t\t\t\t\treportedUsername = ruUser?.username || 'System/Unknown';\n\t\t\t\t}\n\t\t\t\tif (report.resolvedById) {\n\t\t\t\t\tconst [resUser] = await db\n\t\t\t\t\t\t.select({ username: users.username })\n\t\t\t\t\t\t.from(users)\n\t\t\t\t\t\t.where(eq(users.id, report.resolvedById));\n\t\t\t\t\tresolvedByUsername = resUser?.username || 'Unknown';\n\t\t\t\t}\n\n\t\t\t\tconst preview = await getContentPreview(report.contentType, report.contentId);\n\t\t\t\treturn {\n\t\t\t\t\t...report,\n\t\t\t\t\treporterUsername,\n\t\t\t\t\treportedUsername,\n\t\t\t\t\tresolvedByUsername,\n\t\t\t\t\tcontentPreview: preview\n\t\t\t\t};\n\t\t\t})\n\t\t);\n\n\t\treturn {\n\t\t\tdata: enhancedReports,\n\t\t\tpagination: {\n\t\t\t\ttotal: totalReports,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\ttotalPages: Math.ceil(totalReports / limit)\n\t\t\t}\n\t\t};\n\t}\n\n\tasync getReportById(reportId: ReportId) {\n\t\tconst [report] = await db\n\t\t\t.select()\n\t\t\t.from(reportedContent)\n\t\t\t.where(eq(reportedContent.id, reportId));\n\t\tif (!report) {\n\t\t\tthrow new AdminError('Report not found', 404, AdminErrorCodes.NOT_FOUND);\n\t\t}\n\n\t\tlet reporterUsername: string | null = null;\n\t\tlet reportedUsername: string | null = null;\n\t\tlet resolvedByUsername: string | null = null;\n\n\t\tif (report.reporterId) {\n\t\t\tconst [rUser] = await db\n\t\t\t\t.select({ username: users.username })\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, report.reporterId));\n\t\t\treporterUsername = rUser?.username || 'Unknown';\n\t\t}\n\t\t// reportedUserId might be null if the content itself represents a user report\n\t\tif (report.reportedUserId) {\n\t\t\tconst [ruUser] = await db\n\t\t\t\t.select({ username: users.username })\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, report.reportedUserId));\n\t\t\treportedUsername = ruUser?.username || 'System/Unknown';\n\t\t}\n\t\tif (report.resolvedById) {\n\t\t\tconst [resUser] = await db\n\t\t\t\t.select({ username: users.username })\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, report.resolvedById));\n\t\t\tresolvedByUsername = resUser?.username || 'Unknown';\n\t\t}\n\n\t\tconst contentPreview = await getContentPreview(report.contentType, report.contentId);\n\t\treturn { ...report, reporterUsername, reportedUsername, resolvedByUsername, contentPreview };\n\t}\n\n\tasync updateReportStatus(\n\t\treportId: ReportId,\n\t\tnewStatus: 'resolved' | 'dismissed',\n\t\tadminUserId: AdminUserId,\n\t\tnotes?: string\n\t) {\n\t\tconst [existingReport] = await db\n\t\t\t.select()\n\t\t\t.from(reportedContent)\n\t\t\t.where(eq(reportedContent.id, reportId));\n\t\tif (!existingReport) {\n\t\t\tthrow new AdminError('Report not found', 404, AdminErrorCodes.NOT_FOUND);\n\t\t}\n\t\tif (existingReport.status !== 'pending') {\n\t\t\tthrow new AdminError(\n\t\t\t\t`Report is already ${existingReport.status}`,\n\t\t\t\t400,\n\t\t\t\tAdminErrorCodes.OPERATION_FAILED\n\t\t\t);\n\t\t}\n\n\t\tconst [updatedReport] = await db\n\t\t\t.update(reportedContent)\n\t\t\t.set({\n\t\t\t\tstatus: newStatus,\n\t\t\t\tresolvedAt: new Date(),\n\t\t\t\tresolvedById: adminUserId,\n\t\t\t\tnotes: notes || null\n\t\t\t})\n\t\t\t.where(eq(reportedContent.id, reportId))\n\t\t\t.returning();\n\n\t\t// Log moderation action\n\t\tawait db.insert(contentModerationActions).values({\n\t\t\tmoderatorId: adminUserId, // Changed from userId to moderatorId\n\t\t\taction: newStatus === 'resolved' ? 'resolve_report' : 'dismiss_report',\n\t\t\tcontentType: existingReport.contentType,\n\t\t\tcontentId: existingReport.contentId,\n\t\t\ttargetUserId: existingReport.reportedUserId, // Assuming reportedUserId is the author of content\n\t\t\treason: notes || 'No reason provided'\n\t\t\t// reportId: reportId // contentModerationActions might not have reportId, check schema\n\t\t});\n\n\t\treturn updatedReport;\n\t}\n\n\tasync banUser(userIdToBan: number, input: BanUserInput, adminUserId: AdminUserId) {\n\t\tconst { reason, duration } = input;\n\t\tconst [user] = await db.select().from(users).where(eq(users.id, userIdToBan));\n\t\tif (!user) {\n\t\t\tthrow new AdminError('User to ban not found', 404, AdminErrorCodes.USER_NOT_FOUND);\n\t\t}\n\n\t\tconst [existingBan] = await db\n\t\t\t.select()\n\t\t\t.from(userBans)\n\t\t\t.where(and(eq(userBans.userId, userIdToBan), eq(userBans.isActive, true)));\n\t\tif (existingBan) {\n\t\t\tthrow new AdminError('User is already actively banned', 400, AdminErrorCodes.DUPLICATE_ENTRY);\n\t\t}\n\n\t\tlet expiresAt: Date | null = null;\n\t\tlet isPermanent = false;\n\t\tif (!duration || duration.toLowerCase() === 'permanent') {\n\t\t\tisPermanent = true;\n\t\t} else {\n\t\t\tconst match = duration.match(/^(\\d+)([dhm])$/i);\n\t\t\tif (!match)\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Invalid ban duration format. Use N[d|h|m] or permanent.',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t);\n\t\t\tconst value = parseInt(match[1]);\n\t\t\tconst unit = match[2].toLowerCase();\n\t\t\texpiresAt = new Date();\n\t\t\tif (unit === 'd') expiresAt.setDate(expiresAt.getDate() + value);\n\t\t\telse if (unit === 'h') expiresAt.setHours(expiresAt.getHours() + value);\n\t\t\telse if (unit === 'm') expiresAt.setMinutes(expiresAt.getMinutes() + value);\n\t\t}\n\n\t\tconst [ban] = await db\n\t\t\t.insert(userBans)\n\t\t\t.values({\n\t\t\t\tuserId: userIdToBan,\n\t\t\t\treason,\n\t\t\t\tbannedBy: adminUserId,\n\t\t\t\tisActive: true,\n\t\t\t\tisPermanent,\n\t\t\t\texpiresAt\n\t\t\t})\n\t\t\t.returning();\n\n\t\tawait db.update(users).set({ isBanned: true }).where(eq(users.id, userIdToBan));\n\n\t\t// Log moderation action\n\t\tawait db.insert(contentModerationActions).values({\n\t\t\tmoderatorId: adminUserId,\n\t\t\taction: 'ban_user',\n\t\t\ttargetUserId: userIdToBan,\n\t\t\treason\n\t\t\t// details: JSON.stringify({ duration, isPermanent, expiresAt }) // Check schema for details field\n\t\t});\n\t\treturn ban;\n\t}\n\n\tasync deleteContent(\n\t\tcontentType: 'post' | 'thread' | 'message',\n\t\tcontentId: ContentId,\n\t\tinput: DeleteContentInput,\n\t\tadminUserId: AdminUserId\n\t) {\n\t\tconst { reason } = input;\n\t\tlet contentAuthorId: AuthorId | null = null;\n\n\t\tif (contentType === 'post') {\n\t\t\tconst [postData] = await db\n\t\t\t\t.select({ userId: posts.userId })\n\t\t\t\t.from(posts)\n\t\t\t\t.where(eq(posts.id, contentId));\n\t\t\tif (!postData) throw new AdminError('Post not found', 404, AdminErrorCodes.NOT_FOUND);\n\t\t\tcontentAuthorId = postData.userId;\n\t\t\tawait db\n\t\t\t\t.update(posts)\n\t\t\t\t.set({\n\t\t\t\t\tisDeleted: true,\n\t\t\t\t\tcontent: '[Post removed by moderator]',\n\t\t\t\t\tdeletedAt: new Date(),\n\t\t\t\t\tdeletedBy: adminUserId\n\t\t\t\t\t// deletionReason: reason // Check schema for deletionReason field\n\t\t\t\t})\n\t\t\t\t.where(eq(posts.id, contentId));\n\t\t} else if (contentType === 'thread') {\n\t\t\tconst [threadData] = await db\n\t\t\t\t.select({ userId: threads.userId })\n\t\t\t\t.from(threads)\n\t\t\t\t.where(eq(threads.id, contentId));\n\t\t\tif (!threadData) throw new AdminError('Thread not found', 404, AdminErrorCodes.NOT_FOUND);\n\t\t\tcontentAuthorId = threadData.userId;\n\t\t\tawait db\n\t\t\t\t.update(threads)\n\t\t\t\t.set({\n\t\t\t\t\tisDeleted: true,\n\t\t\t\t\ttitle: '[Thread removed by moderator]',\n\t\t\t\t\t// content: '[Content removed by moderator]', // Check schema for content field on threads\n\t\t\t\t\tdeletedAt: new Date(),\n\t\t\t\t\tdeletedBy: adminUserId\n\t\t\t\t\t// deletionReason: reason\n\t\t\t\t})\n\t\t\t\t.where(eq(threads.id, contentId));\n\t\t} else if (contentType === 'message') {\n\t\t\tconst [msgData] = await db\n\t\t\t\t.select({ userId: shoutboxMessages.userId })\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.where(eq(shoutboxMessages.id, contentId));\n\t\t\tif (!msgData)\n\t\t\t\tthrow new AdminError('Shoutbox message not found', 404, AdminErrorCodes.NOT_FOUND);\n\t\t\tcontentAuthorId = msgData.userId;\n\t\t\tawait db\n\t\t\t\t.update(shoutboxMessages)\n\t\t\t\t.set({\n\t\t\t\t\tisDeleted: true,\n\t\t\t\t\tcontent: '[Message removed by moderator]'\n\t\t\t\t\t// deletedAt: new Date(), // Check schema for deletedAt on shoutboxMessages\n\t\t\t\t\t// deletedBy: adminUserId,\n\t\t\t\t\t// deletionReason: reason\n\t\t\t\t})\n\t\t\t\t.where(eq(shoutboxMessages.id, contentId));\n\t\t} else {\n\t\t\tthrow new AdminError(\n\t\t\t\t'Invalid content type for deletion',\n\t\t\t\t400,\n\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t);\n\t\t}\n\n\t\t// Log moderation action\n\t\tif (contentAuthorId !== null) {\n\t\t\tawait db.insert(contentModerationActions).values({\n\t\t\t\tmoderatorId: adminUserId,\n\t\t\t\taction: `delete_${contentType}`,\n\t\t\t\tcontentType,\n\t\t\t\tcontentId,\n\t\t\t\ttargetUserId: contentAuthorId,\n\t\t\t\treason\n\t\t\t});\n\t\t}\n\t\treturn { success: true, message: `${contentType} deleted successfully.` };\n\t}\n}\n\nexport const adminReportsService = new AdminReportsService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/reports/reports.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/roles/roles.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/roles/roles.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/roles/roles.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/roles/roles.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/settings/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/settings/services/settings-command.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settingsQueryService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'existingFlag' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":269,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":269,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Settings Command Service\n *\n * Handles all write operations for settings management\n * Focused on create, update, delete operations with proper validation\n */\n\nimport { db } from '@db';\nimport { siteSettings, featureFlags } from '@schema';\nimport { eq } from 'drizzle-orm';\nimport { logger } from '@server/src/core/logger';\nimport { AdminError, AdminErrorCodes } from '../../../admin.errors';\nimport { adminCacheService } from '../../../shared/admin-cache.service';\nimport { settingsQueryService } from './settings-query.service';\nimport { settingsValidationService } from './settings-validation.service';\nimport type {\n\tUpdateSettingInput,\n\tUpdateSettingsInput,\n\tCreateSettingInput,\n\tUpdateSettingMetadataInput\n} from '../settings.validators';\n\n// For the feature flag input type\nexport type ToggleFeatureFlagInput = {\n\tkey: string;\n\tenabled?: boolean;\n\trolloutPercentage?: number;\n};\n\nexport class SettingsCommandService {\n\t/**\n\t * Update a single setting value\n\t */\n\tasync updateSetting(data: UpdateSettingInput) {\n\t\ttry {\n\t\t\tconst { key, value, description } = data;\n\n\t\t\t// Validate setting exists\n\t\t\tawait settingsValidationService.validateSettingExists(key);\n\n\t\t\t// Validate the new value\n\t\t\tawait settingsValidationService.validateSettingValue(key, value);\n\n\t\t\t// Prepare update data\n\t\t\tconst updateData: any = {\n\t\t\t\tvalue: String(value),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t};\n\n\t\t\tif (description !== undefined) {\n\t\t\t\tupdateData.description = description;\n\t\t\t}\n\n\t\t\t// Update the setting\n\t\t\tconst [updatedSetting] = await db\n\t\t\t\t.update(siteSettings)\n\t\t\t\t.set(updateData)\n\t\t\t\t.where(eq(siteSettings.key, key))\n\t\t\t\t.returning();\n\n\t\t\t// Invalidate cache after successful update\n\t\t\tawait adminCacheService.invalidateEntity('setting', key);\n\n\t\t\tlogger.info('SettingsCommandService', 'Setting updated successfully', {\n\t\t\t\tkey,\n\t\t\t\toldValue: 'redacted',\n\t\t\t\tnewValue: 'redacted'\n\t\t\t});\n\n\t\t\treturn updatedSetting;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsCommandService', 'Error updating setting', {\n\t\t\t\terror: error.message,\n\t\t\t\tkey: data.key\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to update setting', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Update multiple settings in a transaction\n\t */\n\tasync updateSettings(data: UpdateSettingsInput) {\n\t\ttry {\n\t\t\tconst { settings } = data;\n\n\t\t\tif (!settings || settings.length === 0) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'No settings provided for update',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Validate all settings before updating\n\t\t\tfor (const setting of settings) {\n\t\t\t\tawait settingsValidationService.validateSettingExists(setting.key);\n\t\t\t\tawait settingsValidationService.validateSettingValue(setting.key, setting.value);\n\t\t\t}\n\n\t\t\tconst updatedSettings = [];\n\n\t\t\t// Use transaction for multiple updates\n\t\t\tawait db.transaction(async (tx) => {\n\t\t\t\tfor (const setting of settings) {\n\t\t\t\t\tconst [updated] = await tx\n\t\t\t\t\t\t.update(siteSettings)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tvalue: String(setting.value),\n\t\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(eq(siteSettings.key, setting.key))\n\t\t\t\t\t\t.returning();\n\n\t\t\t\t\tupdatedSettings.push(updated);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlogger.info('SettingsCommandService', 'Bulk settings update completed', {\n\t\t\t\tsettingsCount: settings.length,\n\t\t\t\tkeys: settings.map((s) => s.key)\n\t\t\t});\n\n\t\t\treturn updatedSettings;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsCommandService', 'Error updating multiple settings', {\n\t\t\t\terror: error.message,\n\t\t\t\tsettingsCount: data.settings?.length\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to update settings', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Create a new setting\n\t */\n\tasync createSetting(data: CreateSettingInput) {\n\t\ttry {\n\t\t\tconst { key, name, value, type, group, description, isPublic } = data;\n\n\t\t\t// Validate setting doesn't already exist\n\t\t\tawait settingsValidationService.validateSettingNotExists(key);\n\n\t\t\t// Validate the setting data\n\t\t\tawait settingsValidationService.validateNewSettingData(data);\n\n\t\t\t// Create the setting\n\t\t\tconst [newSetting] = await db\n\t\t\t\t.insert(siteSettings)\n\t\t\t\t.values({\n\t\t\t\t\tkey,\n\t\t\t\t\tname,\n\t\t\t\t\tvalue: String(value),\n\t\t\t\t\ttype: type || 'string',\n\t\t\t\t\tgroup: group || null,\n\t\t\t\t\tdescription: description || null,\n\t\t\t\t\tisPublic: isPublic ?? false,\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\tlogger.info('SettingsCommandService', 'Setting created successfully', {\n\t\t\t\tkey,\n\t\t\t\ttype: type || 'string',\n\t\t\t\tgroup: group || 'none'\n\t\t\t});\n\n\t\t\treturn newSetting;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsCommandService', 'Error creating setting', {\n\t\t\t\terror: error.message,\n\t\t\t\tkey: data.key\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to create setting', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Update setting metadata (name, description, type, etc.)\n\t */\n\tasync updateSettingMetadata(key: string, data: UpdateSettingMetadataInput) {\n\t\ttry {\n\t\t\t// Validate setting exists\n\t\t\tawait settingsValidationService.validateSettingExists(key);\n\n\t\t\t// Validate metadata\n\t\t\tawait settingsValidationService.validateSettingMetadata(data);\n\n\t\t\t// Prepare update data\n\t\t\tconst updateData: any = {\n\t\t\t\tupdatedAt: new Date()\n\t\t\t};\n\n\t\t\tif (data.name !== undefined) updateData.name = data.name;\n\t\t\tif (data.description !== undefined) updateData.description = data.description;\n\t\t\tif (data.type !== undefined) updateData.type = data.type;\n\t\t\tif (data.group !== undefined) updateData.group = data.group;\n\t\t\tif (data.isPublic !== undefined) updateData.isPublic = data.isPublic;\n\n\t\t\t// Update metadata\n\t\t\tconst [updatedSetting] = await db\n\t\t\t\t.update(siteSettings)\n\t\t\t\t.set(updateData)\n\t\t\t\t.where(eq(siteSettings.key, key))\n\t\t\t\t.returning();\n\n\t\t\tlogger.info('SettingsCommandService', 'Setting metadata updated', {\n\t\t\t\tkey,\n\t\t\t\tupdatedFields: Object.keys(updateData).filter((k) => k !== 'updatedAt')\n\t\t\t});\n\n\t\t\treturn updatedSetting;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsCommandService', 'Error updating setting metadata', {\n\t\t\t\terror: error.message,\n\t\t\t\tkey\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to update setting metadata', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Delete a setting\n\t */\n\tasync deleteSetting(key: string) {\n\t\ttry {\n\t\t\t// Validate setting exists and can be deleted\n\t\t\tawait settingsValidationService.validateSettingCanBeDeleted(key);\n\n\t\t\t// Delete the setting\n\t\t\tconst [deletedSetting] = await db\n\t\t\t\t.delete(siteSettings)\n\t\t\t\t.where(eq(siteSettings.key, key))\n\t\t\t\t.returning();\n\n\t\t\tif (!deletedSetting) {\n\t\t\t\tthrow new AdminError(`Setting with key \"${key}\" not found`, 404, AdminErrorCodes.NOT_FOUND);\n\t\t\t}\n\n\t\t\tlogger.info('SettingsCommandService', 'Setting deleted successfully', { key });\n\n\t\t\treturn { success: true, deletedSetting };\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsCommandService', 'Error deleting setting', {\n\t\t\t\terror: error.message,\n\t\t\t\tkey\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to delete setting', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Toggle feature flag status\n\t */\n\tasync updateFeatureFlag({ key, enabled, rolloutPercentage }: ToggleFeatureFlagInput) {\n\t\ttry {\n\t\t\t// Validate feature flag exists\n\t\t\tconst existingFlag = await this.getFeatureFlag(key);\n\n\t\t\t// Validate rollout percentage\n\t\t\tif (rolloutPercentage !== undefined && (rolloutPercentage < 0 || rolloutPercentage > 100)) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Rollout percentage must be between 0 and 100',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Prepare update data\n\t\t\tconst updateData: any = {\n\t\t\t\tupdatedAt: new Date()\n\t\t\t};\n\n\t\t\tif (enabled !== undefined) updateData.enabled = enabled;\n\t\t\tif (rolloutPercentage !== undefined) updateData.rolloutPercentage = rolloutPercentage;\n\n\t\t\t// Update feature flag\n\t\t\tconst [updatedFlag] = await db\n\t\t\t\t.update(featureFlags)\n\t\t\t\t.set(updateData)\n\t\t\t\t.where(eq(featureFlags.key, key))\n\t\t\t\t.returning();\n\n\t\t\tlogger.info('SettingsCommandService', 'Feature flag updated', {\n\t\t\t\tkey,\n\t\t\t\tenabled: updateData.enabled,\n\t\t\t\trolloutPercentage: updateData.rolloutPercentage\n\t\t\t});\n\n\t\t\treturn updatedFlag;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsCommandService', 'Error updating feature flag', {\n\t\t\t\terror: error.message,\n\t\t\t\tkey\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to update feature flag', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Private helper to get feature flag\n\t */\n\tprivate async getFeatureFlag(key: string) {\n\t\tconst [flag] = await db.select().from(featureFlags).where(eq(featureFlags.key, key));\n\n\t\tif (!flag) {\n\t\t\tthrow new AdminError(`Feature flag \"${key}\" not found`, 404, AdminErrorCodes.NOT_FOUND);\n\t\t}\n\n\t\treturn flag;\n\t}\n}\n\n// Export singleton instance\nexport const settingsCommandService = new SettingsCommandService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/settings/services/settings-group.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Settings Group Service\n *\n * Handles setting group management operations\n * Focused on organizing settings into logical groups for better admin UX\n */\n\nimport { db } from '@db';\nimport { siteSettings } from '@schema';\nimport { eq, sql, and, ne } from 'drizzle-orm';\nimport { logger } from '@server/src/core/logger';\nimport { AdminError, AdminErrorCodes } from '../../../admin.errors';\nimport type { SettingGroupInput } from '../settings.validators';\n\nexport class SettingsGroupService {\n\t/**\n\t * Get all setting groups with their setting counts\n\t */\n\tasync getAllSettingGroups() {\n\t\ttry {\n\t\t\t// Get groups with setting counts\n\t\t\tconst groupStats = await db\n\t\t\t\t.select({\n\t\t\t\t\tgroup: siteSettings.group,\n\t\t\t\t\tcount: sql<number>`count(*)::integer`,\n\t\t\t\t\tpublicCount: sql<number>`sum(case when ${siteSettings.isPublic} then 1 else 0 end)::integer`\n\t\t\t\t})\n\t\t\t\t.from(siteSettings)\n\t\t\t\t.where(ne(siteSettings.group, null))\n\t\t\t\t.groupBy(siteSettings.group)\n\t\t\t\t.orderBy(siteSettings.group);\n\n\t\t\t// Format the results\n\t\t\tconst groups = groupStats.map((stat) => ({\n\t\t\t\tkey: stat.group,\n\t\t\t\tname: this.formatGroupName(stat.group),\n\t\t\t\tsettingsCount: stat.count,\n\t\t\t\tpublicSettingsCount: stat.publicCount,\n\t\t\t\tprivateSettingsCount: stat.count - stat.publicCount\n\t\t\t}));\n\n\t\t\t// Add ungrouped settings count\n\t\t\tconst [ungroupedCount] = await db\n\t\t\t\t.select({\n\t\t\t\t\tcount: sql<number>`count(*)::integer`\n\t\t\t\t})\n\t\t\t\t.from(siteSettings)\n\t\t\t\t.where(eq(siteSettings.group, null));\n\n\t\t\tif (ungroupedCount.count > 0) {\n\t\t\t\tgroups.push({\n\t\t\t\t\tkey: null,\n\t\t\t\t\tname: 'Ungrouped',\n\t\t\t\t\tsettingsCount: ungroupedCount.count,\n\t\t\t\t\tpublicSettingsCount: 0,\n\t\t\t\t\tprivateSettingsCount: ungroupedCount.count\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn groups;\n\t\t} catch (error) {\n\t\t\tlogger.error('SettingsGroupService', 'Error fetching setting groups', {\n\t\t\t\terror: error.message\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to fetch setting groups', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Create a new setting group\n\t */\n\tasync createSettingGroup(data: SettingGroupInput) {\n\t\ttry {\n\t\t\tconst { groupKey, name, description } = data;\n\n\t\t\t// Validate group doesn't already exist\n\t\t\tawait this.validateGroupNotExists(groupKey);\n\n\t\t\t// Validate group key format\n\t\t\tif (!/^[a-z0-9_]+$/.test(groupKey)) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Group key must contain only lowercase letters, numbers, and underscores',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Since we don't have a separate groups table, we create a placeholder setting\n\t\t\t// This is a design choice - groups are implicit based on settings that reference them\n\t\t\tconst groupInfo = {\n\t\t\t\tgroup: groupKey,\n\t\t\t\tname: name || this.formatGroupName(groupKey),\n\t\t\t\tdescription,\n\t\t\t\tcreatedAt: new Date()\n\t\t\t};\n\n\t\t\tlogger.info('SettingsGroupService', 'Setting group created', {\n\t\t\t\tgroupKey,\n\t\t\t\tname: groupInfo.name\n\t\t\t});\n\n\t\t\treturn groupInfo;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsGroupService', 'Error creating setting group', {\n\t\t\t\terror: error.message,\n\t\t\t\tgroupKey: data.groupKey\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to create setting group', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Update a setting group (rename all settings in the group)\n\t */\n\tasync updateSettingGroup(oldGroupKey: string, data: SettingGroupInput) {\n\t\ttry {\n\t\t\tconst { groupKey: newGroupKey, name } = data;\n\n\t\t\t// Validate old group exists\n\t\t\tawait this.validateGroupExists(oldGroupKey);\n\n\t\t\t// If changing group key, validate new key doesn't exist\n\t\t\tif (newGroupKey !== oldGroupKey) {\n\t\t\t\tawait this.validateGroupNotExists(newGroupKey);\n\n\t\t\t\t// Update all settings in the group\n\t\t\t\tawait db\n\t\t\t\t\t.update(siteSettings)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tgroup: newGroupKey,\n\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(siteSettings.group, oldGroupKey));\n\n\t\t\t\tlogger.info('SettingsGroupService', 'Setting group key updated', {\n\t\t\t\t\toldGroupKey,\n\t\t\t\t\tnewGroupKey,\n\t\t\t\t\tname\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tgroup: newGroupKey,\n\t\t\t\tname: name || this.formatGroupName(newGroupKey),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsGroupService', 'Error updating setting group', {\n\t\t\t\terror: error.message,\n\t\t\t\toldGroupKey,\n\t\t\t\tnewGroupKey: data.groupKey\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to update setting group', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Delete a setting group (move all settings to another group or ungrouped)\n\t */\n\tasync deleteSettingGroup(groupKey: string, newGroupKey?: string) {\n\t\ttry {\n\t\t\t// Validate group exists\n\t\t\tawait this.validateGroupExists(groupKey);\n\n\t\t\t// If moving to another group, validate it exists\n\t\t\tif (newGroupKey) {\n\t\t\t\tawait this.validateGroupExists(newGroupKey);\n\t\t\t}\n\n\t\t\t// Update all settings in the group\n\t\t\tawait db\n\t\t\t\t.update(siteSettings)\n\t\t\t\t.set({\n\t\t\t\t\tgroup: newGroupKey || null,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(siteSettings.group, groupKey));\n\n\t\t\tlogger.info('SettingsGroupService', 'Setting group deleted', {\n\t\t\t\tdeletedGroup: groupKey,\n\t\t\t\tmovedToGroup: newGroupKey || 'ungrouped'\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdeletedGroup: groupKey,\n\t\t\t\tmovedToGroup: newGroupKey || null\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsGroupService', 'Error deleting setting group', {\n\t\t\t\terror: error.message,\n\t\t\t\tgroupKey,\n\t\t\t\tnewGroupKey\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to delete setting group', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Move settings between groups\n\t */\n\tasync moveSettingsToGroup(settingKeys: string[], targetGroupKey: string | null) {\n\t\ttry {\n\t\t\tif (!settingKeys || settingKeys.length === 0) {\n\t\t\t\tthrow new AdminError('No settings provided for move', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\t// Validate target group exists (if not null)\n\t\t\tif (targetGroupKey) {\n\t\t\t\tawait this.validateGroupExists(targetGroupKey);\n\t\t\t}\n\n\t\t\t// Update the settings\n\t\t\tconst results = await db\n\t\t\t\t.update(siteSettings)\n\t\t\t\t.set({\n\t\t\t\t\tgroup: targetGroupKey,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(sql`${siteSettings.key} = ANY(${settingKeys})`)\n\t\t\t\t.returning({ key: siteSettings.key });\n\n\t\t\tif (results.length !== settingKeys.length) {\n\t\t\t\tlogger.warn('SettingsGroupService', 'Not all settings were found for group move', {\n\t\t\t\t\trequested: settingKeys.length,\n\t\t\t\t\tmoved: results.length\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlogger.info('SettingsGroupService', 'Settings moved to group', {\n\t\t\t\tsettingsCount: results.length,\n\t\t\t\ttargetGroup: targetGroupKey || 'ungrouped'\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmovedCount: results.length,\n\t\t\t\ttargetGroup: targetGroupKey\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsGroupService', 'Error moving settings to group', {\n\t\t\t\terror: error.message,\n\t\t\t\tsettingsCount: settingKeys?.length,\n\t\t\t\ttargetGroupKey\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to move settings to group', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Get settings for a specific group\n\t */\n\tasync getSettingsInGroup(groupKey: string | null) {\n\t\ttry {\n\t\t\tconst settings = await db\n\t\t\t\t.select()\n\t\t\t\t.from(siteSettings)\n\t\t\t\t.where(groupKey ? eq(siteSettings.group, groupKey) : eq(siteSettings.group, null))\n\t\t\t\t.orderBy(siteSettings.key);\n\n\t\t\treturn settings;\n\t\t} catch (error) {\n\t\t\tlogger.error('SettingsGroupService', 'Error fetching settings in group', {\n\t\t\t\terror: error.message,\n\t\t\t\tgroupKey\n\t\t\t});\n\t\t\tthrow new AdminError('Failed to fetch group settings', 500, AdminErrorCodes.DB_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Validate that a group exists\n\t */\n\tprivate async validateGroupExists(groupKey: string) {\n\t\tconst [setting] = await db\n\t\t\t.select({ group: siteSettings.group })\n\t\t\t.from(siteSettings)\n\t\t\t.where(eq(siteSettings.group, groupKey))\n\t\t\t.limit(1);\n\n\t\tif (!setting) {\n\t\t\tthrow new AdminError(`Setting group \"${groupKey}\" not found`, 404, AdminErrorCodes.NOT_FOUND);\n\t\t}\n\t}\n\n\t/**\n\t * Validate that a group does not exist\n\t */\n\tprivate async validateGroupNotExists(groupKey: string) {\n\t\tconst [setting] = await db\n\t\t\t.select({ group: siteSettings.group })\n\t\t\t.from(siteSettings)\n\t\t\t.where(eq(siteSettings.group, groupKey))\n\t\t\t.limit(1);\n\n\t\tif (setting) {\n\t\t\tthrow new AdminError(\n\t\t\t\t`Setting group \"${groupKey}\" already exists`,\n\t\t\t\t409,\n\t\t\t\tAdminErrorCodes.DUPLICATE_ENTRY\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Format group key into a display name\n\t */\n\tprivate formatGroupName(groupKey: string): string {\n\t\treturn groupKey\n\t\t\t.split('_')\n\t\t\t.map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n\t\t\t.join(' ');\n\t}\n}\n\n// Export singleton instance\nexport const settingsGroupService = new SettingsGroupService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/settings/services/settings-query.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/settings/services/settings-validation.service.ts","messages":[{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":276,"column":5,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":276,"endColumn":39},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":287,"column":5,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":287,"endColumn":40},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":298,"column":5,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":298,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Settings Validation Service\n *\n * Handles business logic validation for settings operations\n * Focused on data integrity, business rules, and constraint validation\n */\n\nimport { logger } from '@server/src/core/logger';\nimport { AdminError, AdminErrorCodes } from '../../../admin.errors';\nimport { settingsQueryService } from './settings-query.service';\nimport type { CreateSettingInput, UpdateSettingMetadataInput } from '../settings.validators';\n\nexport class SettingsValidationService {\n\t// Critical settings that cannot be deleted\n\tprivate readonly PROTECTED_SETTINGS = [\n\t\t'site_name',\n\t\t'site_description',\n\t\t'maintenance_mode',\n\t\t'registration_enabled',\n\t\t'api_rate_limit'\n\t];\n\n\t// Settings that require specific value formats\n\tprivate readonly VALUE_PATTERNS = {\n\t\temail: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n\t\turl: /^https?:\\/\\/.+/,\n\t\tnumber: /^\\d+(\\.\\d+)?$/,\n\t\tboolean: /^(true|false)$/i,\n\t\tjson: (value: string) => {\n\t\t\ttry {\n\t\t\t\tJSON.parse(value);\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Validate that a setting exists\n\t */\n\tasync validateSettingExists(key: string) {\n\t\tif (!key || typeof key !== 'string') {\n\t\t\tthrow new AdminError('Setting key is required', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t}\n\n\t\tconst exists = await settingsQueryService.settingExists(key);\n\t\tif (!exists) {\n\t\t\tthrow new AdminError(`Setting with key \"${key}\" not found`, 404, AdminErrorCodes.NOT_FOUND);\n\t\t}\n\t}\n\n\t/**\n\t * Validate that a setting does not exist (for creation)\n\t */\n\tasync validateSettingNotExists(key: string) {\n\t\tif (!key || typeof key !== 'string') {\n\t\t\tthrow new AdminError('Setting key is required', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t}\n\n\t\tconst exists = await settingsQueryService.settingExists(key);\n\t\tif (exists) {\n\t\t\tthrow new AdminError(\n\t\t\t\t`Setting with key \"${key}\" already exists`,\n\t\t\t\t409,\n\t\t\t\tAdminErrorCodes.DUPLICATE_ENTRY\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Validate setting value based on its type and constraints\n\t */\n\tasync validateSettingValue(key: string, value: any) {\n\t\ttry {\n\t\t\t// Get the setting to check its type and constraints\n\t\t\tconst setting = await settingsQueryService.getSettingByKey(key);\n\n\t\t\t// Convert value to string for validation\n\t\t\tconst stringValue = String(value);\n\n\t\t\t// Validate based on setting type\n\t\t\tswitch (setting.type) {\n\t\t\t\tcase 'boolean':\n\t\t\t\t\tif (!this.VALUE_PATTERNS.boolean.test(stringValue)) {\n\t\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t\t'Boolean settings must be \"true\" or \"false\"',\n\t\t\t\t\t\t\t400,\n\t\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'number':\n\t\t\t\t\tif (!this.VALUE_PATTERNS.number.test(stringValue)) {\n\t\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t\t'Number settings must contain valid numeric values',\n\t\t\t\t\t\t\t400,\n\t\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'email':\n\t\t\t\t\tif (!this.VALUE_PATTERNS.email.test(stringValue)) {\n\t\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t\t'Email settings must contain valid email addresses',\n\t\t\t\t\t\t\t400,\n\t\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'url':\n\t\t\t\t\tif (!this.VALUE_PATTERNS.url.test(stringValue)) {\n\t\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t\t'URL settings must start with http:// or https://',\n\t\t\t\t\t\t\t400,\n\t\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'json':\n\t\t\t\t\tif (!this.VALUE_PATTERNS.json(stringValue)) {\n\t\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t\t'JSON settings must contain valid JSON',\n\t\t\t\t\t\t\t400,\n\t\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'string':\n\t\t\t\tdefault:\n\t\t\t\t\t// String validation - check length constraints\n\t\t\t\t\tif (stringValue.length > 5000) {\n\t\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t\t'Setting value is too long (max 5000 characters)',\n\t\t\t\t\t\t\t400,\n\t\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Apply specific business rules for certain settings\n\t\t\tawait this.validateBusinessRules(key, stringValue);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) throw error;\n\n\t\t\tlogger.error('SettingsValidationService', 'Error validating setting value', {\n\t\t\t\terror: error.message,\n\t\t\t\tkey\n\t\t\t});\n\t\t\tthrow new AdminError(\n\t\t\t\t'Failed to validate setting value',\n\t\t\t\t500,\n\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Validate new setting creation data\n\t */\n\tasync validateNewSettingData(data: CreateSettingInput) {\n\t\tconst { key, name, value, type } = data;\n\n\t\t// Validate key format\n\t\tif (!/^[a-z0-9_]+$/.test(key)) {\n\t\t\tthrow new AdminError(\n\t\t\t\t'Setting key must contain only lowercase letters, numbers, and underscores',\n\t\t\t\t400,\n\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t);\n\t\t}\n\n\t\t// Validate key length\n\t\tif (key.length < 3 || key.length > 100) {\n\t\t\tthrow new AdminError(\n\t\t\t\t'Setting key must be between 3 and 100 characters',\n\t\t\t\t400,\n\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t);\n\t\t}\n\n\t\t// Validate name\n\t\tif (!name || name.trim().length < 3) {\n\t\t\tthrow new AdminError(\n\t\t\t\t'Setting name must be at least 3 characters',\n\t\t\t\t400,\n\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t);\n\t\t}\n\n\t\t// Validate type\n\t\tconst validTypes = ['string', 'number', 'boolean', 'email', 'url', 'json'];\n\t\tif (type && !validTypes.includes(type)) {\n\t\t\tthrow new AdminError(\n\t\t\t\t`Setting type must be one of: ${validTypes.join(', ')}`,\n\t\t\t\t400,\n\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t);\n\t\t}\n\n\t\t// Validate value against type\n\t\tif (type && value !== undefined) {\n\t\t\tawait this.validateValueForType(value, type);\n\t\t}\n\t}\n\n\t/**\n\t * Validate setting metadata update\n\t */\n\tasync validateSettingMetadata(data: UpdateSettingMetadataInput) {\n\t\t// Validate name if provided\n\t\tif (data.name !== undefined) {\n\t\t\tif (!data.name || data.name.trim().length < 3) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Setting name must be at least 3 characters',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Validate type if provided\n\t\tif (data.type !== undefined) {\n\t\t\tconst validTypes = ['string', 'number', 'boolean', 'email', 'url', 'json'];\n\t\t\tif (!validTypes.includes(data.type)) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`Setting type must be one of: ${validTypes.join(', ')}`,\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Validate description length\n\t\tif (data.description !== undefined && data.description.length > 1000) {\n\t\t\tthrow new AdminError(\n\t\t\t\t'Setting description cannot exceed 1000 characters',\n\t\t\t\t400,\n\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Validate that a setting can be deleted\n\t */\n\tasync validateSettingCanBeDeleted(key: string) {\n\t\t// Check if setting exists\n\t\tawait this.validateSettingExists(key);\n\n\t\t// Check if setting is protected\n\t\tif (this.PROTECTED_SETTINGS.includes(key)) {\n\t\t\tthrow new AdminError(\n\t\t\t\t`Setting \"${key}\" is protected and cannot be deleted`,\n\t\t\t\t403,\n\t\t\t\tAdminErrorCodes.FORBIDDEN\n\t\t\t);\n\t\t}\n\n\t\t// Additional business logic checks could go here\n\t\t// e.g., check if setting is referenced by other systems\n\t}\n\n\t/**\n\t * Apply business rules for specific settings\n\t */\n\tprivate async validateBusinessRules(key: string, value: string) {\n\t\tswitch (key) {\n\t\t\tcase 'api_rate_limit':\n\t\t\t\tconst rateLimit = parseInt(value);\n\t\t\t\tif (rateLimit < 10 || rateLimit > 10000) {\n\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t'API rate limit must be between 10 and 10000',\n\t\t\t\t\t\t400,\n\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'max_upload_size':\n\t\t\t\tconst uploadSize = parseInt(value);\n\t\t\t\tif (uploadSize < 1 || uploadSize > 100) {\n\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t'Max upload size must be between 1MB and 100MB',\n\t\t\t\t\t\t400,\n\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'session_timeout':\n\t\t\t\tconst timeout = parseInt(value);\n\t\t\t\tif (timeout < 300 || timeout > 86400) {\n\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t'Session timeout must be between 5 minutes and 24 hours',\n\t\t\t\t\t\t400,\n\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Add more business rules as needed\n\t\t}\n\t}\n\n\t/**\n\t * Validate value against a specific type\n\t */\n\tprivate async validateValueForType(value: any, type: string) {\n\t\tconst stringValue = String(value);\n\n\t\tswitch (type) {\n\t\t\tcase 'boolean':\n\t\t\t\tif (!this.VALUE_PATTERNS.boolean.test(stringValue)) {\n\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t'Boolean value must be \"true\" or \"false\"',\n\t\t\t\t\t\t400,\n\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'number':\n\t\t\t\tif (!this.VALUE_PATTERNS.number.test(stringValue)) {\n\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t'Number value must be a valid number',\n\t\t\t\t\t\t400,\n\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'email':\n\t\t\t\tif (!this.VALUE_PATTERNS.email.test(stringValue)) {\n\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t'Email value must be a valid email address',\n\t\t\t\t\t\t400,\n\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'url':\n\t\t\t\tif (!this.VALUE_PATTERNS.url.test(stringValue)) {\n\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t'URL value must start with http:// or https://',\n\t\t\t\t\t\t400,\n\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'json':\n\t\t\t\tif (!this.VALUE_PATTERNS.json(stringValue)) {\n\t\t\t\t\tthrow new AdminError(\n\t\t\t\t\t\t'JSON value must be valid JSON',\n\t\t\t\t\t\t400,\n\t\t\t\t\t\tAdminErrorCodes.VALIDATION_ERROR\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const settingsValidationService = new SettingsValidationService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/settings/settings.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/settings/settings.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/settings/settings.service.refactored.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/settings/settings.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/shop/rarity.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/shop/rarity.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/shop/shop.admin.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db'; // Adjust path to your db instance\nimport { products } from '@schema'; // Adjust path to your schema\nimport { eq, desc, and } from 'drizzle-orm';\nimport { ShopTransformer } from '../../transformers/shop.transformer';\nimport { logger } from '../../../../core/logger';\n\nexport const shopAdminController = {\n\t// List all products\n\tasync listProducts(req, res) {\n\t\t// TODO: Add pagination, filtering, sorting\n\t\tconst allProducts = await db.select().from(products).orderBy(desc(products.createdAt));\n\t\t\n\t\t// Transform products for admin view\n\t\tconst transformedProducts = allProducts.map(product => \n\t\t\tShopTransformer.toAdminShopItem(product)\n\t\t);\n\t\t\n\t\tres.json(transformedProducts);\n\t},\n\n\t// Create a new product\n\tasync createProduct(req, res) {\n\t\tconst {\n\t\t\tname,\n\t\t\tdescription,\n\t\t\tpriceDGT,\n\t\t\tpriceUSDT,\n\t\t\tcategory,\n\t\t\trarity,\n\t\t\timageUrl,\n\t\t\tpluginReward,\n\t\t\tstockLimit,\n\t\t\tpointsPrice,\n\t\t\teffectType\n\t\t} = req.body;\n\t\t// Basic validation (you'll want more robust validation, e.g., Zod)\n\t\tif (!name || typeof priceDGT === 'undefined') {\n\t\t\treturn res.status(400).json({ message: 'Name and DGT Price are required.' });\n\t\t}\n\n\t\ttry {\n\t\t\tconst newProduct = await db\n\t\t\t\t.insert(products)\n\t\t\t\t.values({\n\t\t\t\t\tname,\n\t\t\t\t\tslug: name.toLowerCase().replace(/\\s+/g, '-'), // Auto-generate slug\n\t\t\t\t\tdescription,\n\t\t\t\t\tprice: priceDGT, // Assuming priceDGT maps to the main 'price' field for DGT currency\n\t\t\t\t\t// priceUSDT: priceUSDT, // Need a separate column or store in metadata if using multiple real currencies\n\t\t\t\t\tpointsPrice: pointsPrice || priceDGT, // Or however you map DGT to pointsPrice\n\t\t\t\t\tcategory, // This should map to a categoryId if using productCategories table\n\t\t\t\t\t// rarity, // Rarity isn't directly in products schema, store in metadata or pluginReward\n\t\t\t\t\t// imageUrl, // imageUrl isn't directly in products schema, use productMedia or store in metadata\n\t\t\t\t\tpluginReward: pluginReward || {\n\t\t\t\t\t\ttype: effectType,\n\t\t\t\t\t\trarity: rarity,\n\t\t\t\t\t\timageUrl: imageUrl,\n\t\t\t\t\t\tpriceUSDT: priceUSDT\n\t\t\t\t\t}, // Consolidate extra fields here\n\t\t\t\t\tstock: stockLimit || 0, // Assuming stockLimit is the initial stock\n\t\t\t\t\tstockLimit,\n\t\t\t\t\tstatus: 'published' // Default to published, or make it a parameter\n\t\t\t\t})\n\t\t\t\t.returning();\n\t\t\tres.status(201).json(newProduct[0]);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error creating product:', error);\n\t\t\tres.status(500).json({ message: 'Error creating product', error: error.message });\n\t\t}\n\t},\n\n\t// Get a single product by ID\n\tasync getProductById(req, res) {\n\t\tconst { productId } = req.params;\n\t\ttry {\n\t\t\tconst product = await db\n\t\t\t\t.select()\n\t\t\t\t.from(products)\n\t\t\t\t.where(eq(products.id, productId))\n\t\t\t\t.limit(1);\n\t\t\tif (product.length === 0) {\n\t\t\t\treturn res.status(404).json({ message: 'Product not found' });\n\t\t\t}\n\t\t\t\n\t\t\t// Transform product for admin view\n\t\t\tconst transformedProduct = ShopTransformer.toAdminShopItem(product[0]);\n\t\t\t\n\t\t\tres.json(transformedProduct);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching product by ID:', error);\n\t\t\tres.status(500).json({ message: 'Error fetching product by ID', error: error.message });\n\t\t}\n\t},\n\n\t// Update an existing product\n\tasync updateProduct(req, res) {\n\t\tconst { productId } = req.params;\n\t\tconst updates = req.body;\n\n\t\tif (Object.keys(updates).length === 0) {\n\t\t\treturn res.status(400).json({ message: 'No update data provided.' });\n\t\t}\n\n\t\ttry {\n\t\t\t// Ensure pluginReward is an object if provided\n\t\t\tif (updates.pluginReward && typeof updates.pluginReward === 'string') {\n\t\t\t\ttry {\n\t\t\t\t\tupdates.pluginReward = JSON.parse(updates.pluginReward);\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn res.status(400).json({ message: 'Invalid pluginReward JSON format.' });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (updates.name && !updates.slug) {\n\t\t\t\tupdates.slug = updates.name.toLowerCase().replace(/\\s+/g, '-');\n\t\t\t}\n\n\t\t\tconst updatedProduct = await db\n\t\t\t\t.update(products)\n\t\t\t\t.set({ ...updates, updatedAt: new Date() })\n\t\t\t\t.where(eq(products.id, productId))\n\t\t\t\t.returning();\n\n\t\t\tif (updatedProduct.length === 0) {\n\t\t\t\treturn res.status(404).json({ message: 'Product not found' });\n\t\t\t}\n\t\t\t// Transform updated product for admin view\n\t\t\tconst transformedProduct = ShopTransformer.toAdminShopItem(updatedProduct[0]);\n\t\t\t\n\t\t\tres.json(transformedProduct);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error updating product:', error);\n\t\t\tres.status(500).json({ message: 'Error updating product', error: error.message });\n\t\t}\n\t},\n\n\t// Soft delete a product (mark as isDeleted or change status to archived)\n\tasync deleteProduct(req, res) {\n\t\tconst { productId } = req.params;\n\t\ttry {\n\t\t\tconst deletedProduct = await db\n\t\t\t\t.update(products)\n\t\t\t\t.set({ isDeleted: true, status: 'archived', deletedAt: new Date() })\n\t\t\t\t.where(eq(products.id, productId))\n\t\t\t\t.returning();\n\n\t\t\tif (deletedProduct.length === 0) {\n\t\t\t\treturn res.status(404).json({ message: 'Product not found' });\n\t\t\t}\n\t\t\tres\n\t\t\t\t.status(200)\n\t\t\t\t.json({ message: 'Product archived successfully', product: deletedProduct[0] });\n\t\t} catch (error) {\n\t\t\tlogger.error('Error deleting product:', error);\n\t\t\tres.status(500).json({ message: 'Error deleting product', error: error.message });\n\t\t}\n\t}\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/shop/shop.admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/shop/shopCategory.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/shop/shopCategory.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { cosmeticCategories } from '@schema';\nimport { eq, desc, asc } from 'drizzle-orm';\nimport { AdminError } from '../../admin.errors';\n\ninterface CategoryInput {\n\tname: string;\n\tslug: string;\n\tdescription?: string;\n\tbgColor?: string | null;\n\ttextColor?: string | null;\n\ticonUrl?: string | null;\n\tallowedRarities?: any;\n\tisActive?: boolean;\n\tpluginData?: any;\n}\n\nexport class ShopCategoryService {\n\tasync list() {\n\t\treturn db.select().from(cosmeticCategories).orderBy(asc(cosmeticCategories.name));\n\t}\n\n\tasync create(data: CategoryInput) {\n\t\tconst [exists] = await db\n\t\t\t.select({ id: cosmeticCategories.id })\n\t\t\t.from(cosmeticCategories)\n\t\t\t.where(eq(cosmeticCategories.slug, data.slug));\n\t\tif (exists) throw AdminError.duplicate('Cosmetic Category', 'slug', data.slug);\n\n\t\tconst [created] = await db.insert(cosmeticCategories).values(data).returning();\n\t\treturn created;\n\t}\n\n\tasync update(id: Id<'id'>, data: Partial<CategoryInput>) {\n\t\tconst [existing] = await db\n\t\t\t.select()\n\t\t\t.from(cosmeticCategories)\n\t\t\t.where(eq(cosmeticCategories.id, id));\n\t\tif (!existing) throw AdminError.notFound('Cosmetic Category', id);\n\n\t\tconst [updated] = await db\n\t\t\t.update(cosmeticCategories)\n\t\t\t.set({ ...data, updatedAt: new Date() })\n\t\t\t.where(eq(cosmeticCategories.id, id))\n\t\t\t.returning();\n\t\treturn updated;\n\t}\n\n\tasync delete(id: Id<'id'>) {\n\t\tconst [deleted] = await db\n\t\t\t.delete(cosmeticCategories)\n\t\t\t.where(eq(cosmeticCategories.id, id))\n\t\t\t.returning();\n\t\tif (!deleted) throw AdminError.notFound('Cosmetic Category', id);\n\t\treturn { success: true };\n\t}\n}\n\nexport const shopCategoryService = new ShopCategoryService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/social/social.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/social/social.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/social/social.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'db' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eq' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'drizzleSql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminUserId' is defined but never used.","line":27,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\n// TODO: Fix schema imports - temporarily disabled to get backend running\n// import { economySettings } from '../../../../../../db/schema/economy/settings';\nimport { eq, count, sql as drizzleSql } from 'drizzle-orm';\nimport { defaultSocialConfig } from '@shared/config/social.config';\nimport type { SocialConfig } from '@shared/config/social.config';\nimport { logger } from '../../../../core/logger';\n\nexport class SocialService {\n\tprivate static readonly CONFIG_KEY = 'social_config';\n\n\t/**\n\t * Get current social configuration from database or return defaults\n\t * TODO: Temporarily returning defaults until schema imports are fixed\n\t */\n\tstatic async getSocialConfig(): Promise<SocialConfig> {\n\t\t// TODO: Implement database storage once schema imports are fixed\n\t\treturn defaultSocialConfig;\n\t}\n\n\t/**\n\t * Update social configuration in database\n\t * TODO: Temporarily disabled until schema imports are fixed\n\t */\n\tstatic async updateSocialConfig(\n\t\tupdates: Partial<SocialConfig>,\n\t\tadminUserId: string\n\t): Promise<SocialConfig> {\n\t\tconst currentConfig = await this.getSocialConfig();\n\t\tconst newConfig = this.deepMerge(currentConfig, updates);\n\n\t\t// Validate the new configuration\n\t\tthis.validateConfig(newConfig);\n\n\t\t// TODO: Implement database storage once schema imports are fixed\n\t\tlogger.info('Social config update attempted (disabled):', newConfig);\n\n\t\treturn newConfig;\n\t}\n\n\t/**\n\t * Get social feature usage statistics\n\t * TODO: Temporarily returning mock data until schema imports are fixed\n\t */\n\tstatic async getSocialStats() {\n\t\t// TODO: Implement database queries once schema imports are fixed\n\t\treturn {\n\t\t\tmentions: { total: 0, unread: 0 },\n\t\t\tfollows: { total: 0 },\n\t\t\tfriendships: { accepted: 0, pending: 0, blocked: 0 },\n\t\t\tactiveUsers: { last24h: 0 },\n\t\t\tlastUpdated: new Date().toISOString()\n\t\t};\n\t}\n\n\t/**\n\t * Reset social configuration to defaults\n\t * TODO: Temporarily disabled until schema imports are fixed\n\t */\n\tstatic async resetToDefaults(adminUserId: string): Promise<SocialConfig> {\n\t\t// TODO: Implement database reset once schema imports are fixed\n\t\tlogger.info('Social config reset attempted (disabled) by:', adminUserId);\n\t\treturn defaultSocialConfig;\n\t}\n\n\t/**\n\t * Get current status of all social features\n\t */\n\tstatic async getFeatureStatus() {\n\t\tconst config = await this.getSocialConfig();\n\t\tconst stats = await this.getSocialStats();\n\n\t\treturn {\n\t\t\tmentions: {\n\t\t\t\tenabled: config.mentions.enabled,\n\t\t\t\tactiveUsers: stats.activeUsers.last24h,\n\t\t\t\ttotalMentions: stats.mentions.total,\n\t\t\t\tunreadMentions: stats.mentions.unread,\n\t\t\t\thealthStatus: this.getHealthStatus('mentions', config, stats)\n\t\t\t},\n\t\t\twhaleWatch: {\n\t\t\t\tenabled: config.whaleWatch.enabled,\n\t\t\t\ttotalFollows: stats.follows.total,\n\t\t\t\thealthStatus: this.getHealthStatus('whaleWatch', config, stats)\n\t\t\t},\n\t\t\tfriends: {\n\t\t\t\tenabled: config.friends.enabled,\n\t\t\t\ttotalFriendships: stats.friendships.accepted,\n\t\t\t\tpendingRequests: stats.friendships.pending,\n\t\t\t\thealthStatus: this.getHealthStatus('friends', config, stats)\n\t\t\t},\n\t\t\toverall: {\n\t\t\t\tstatus:\n\t\t\t\t\tconfig.mentions.enabled || config.whaleWatch.enabled || config.friends.enabled\n\t\t\t\t\t\t? 'active'\n\t\t\t\t\t\t: 'disabled',\n\t\t\t\tlastChecked: new Date().toISOString()\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Emergency disable all social features\n\t */\n\tstatic async emergencyDisable(adminUserId: string) {\n\t\tconst emergencyConfig = await this.getSocialConfig();\n\n\t\t// Disable all features\n\t\temergencyConfig.mentions.enabled = false;\n\t\temergencyConfig.whaleWatch.enabled = false;\n\t\temergencyConfig.friends.enabled = false;\n\t\temergencyConfig.adminOverrides.enableEmergencyDisable = true;\n\n\t\tawait this.updateSocialConfig(emergencyConfig, adminUserId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: 'All social features have been emergency disabled',\n\t\t\tdisabledAt: new Date().toISOString(),\n\t\t\tdisabledBy: adminUserId\n\t\t};\n\t}\n\n\t/**\n\t * Merge partial config updates with current config\n\t */\n\tprivate static deepMerge(target: any, source: any): any {\n\t\tconst result = { ...target };\n\n\t\tfor (const key in source) {\n\t\t\tif (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n\t\t\t\tresult[key] = this.deepMerge(target[key] || {}, source[key]);\n\t\t\t} else {\n\t\t\t\tresult[key] = source[key];\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Merge stored config with defaults to ensure all fields exist\n\t */\n\tprivate static mergeWithDefaults(storedConfig: any): SocialConfig {\n\t\treturn this.deepMerge(defaultSocialConfig, storedConfig);\n\t}\n\n\t/**\n\t * Validate configuration values\n\t */\n\tprivate static validateConfig(config: SocialConfig): void {\n\t\t// Validate mention settings\n\t\tif (config.mentions.minLevel < 1 || config.mentions.minLevel > 100) {\n\t\t\tthrow new Error('Mentions minimum level must be between 1 and 100');\n\t\t}\n\n\t\tif (config.mentions.settings.maxMentionsPerPost > 50) {\n\t\t\tthrow new Error('Maximum mentions per post cannot exceed 50');\n\t\t}\n\n\t\t// Validate whale watch settings\n\t\tif (config.whaleWatch.settings.maxFollowsPerUser > 10000) {\n\t\t\tthrow new Error('Maximum follows per user cannot exceed 10,000');\n\t\t}\n\n\t\t// Validate friends settings\n\t\tif (config.friends.settings.maxFriendsPerUser > 5000) {\n\t\t\tthrow new Error('Maximum friends per user cannot exceed 5,000');\n\t\t}\n\t}\n\n\t/**\n\t * Get health status for a specific feature\n\t */\n\tprivate static getHealthStatus(feature: string, config: SocialConfig, stats: any): string {\n\t\tif (!config[feature as keyof SocialConfig].enabled) {\n\t\t\treturn 'disabled';\n\t\t}\n\n\t\t// Simple health checks - can be expanded\n\t\tswitch (feature) {\n\t\t\tcase 'mentions':\n\t\t\t\treturn stats.mentions.total > 0 ? 'healthy' : 'inactive';\n\t\t\tcase 'whaleWatch':\n\t\t\t\treturn stats.follows.total > 0 ? 'healthy' : 'inactive';\n\t\t\tcase 'friends':\n\t\t\t\treturn stats.friendships.accepted > 0 ? 'healthy' : 'inactive';\n\t\t\tdefault:\n\t\t\t\treturn 'unknown';\n\t\t}\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/subscriptions/subscription.admin.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sum' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Admin Subscription Controller\n *\n * Admin interface for managing subscriptions, cosmetic drops, and subscription analytics\n */\n\nimport type { Request, Response } from 'express';\nimport { subscriptionService } from '../../../subscriptions/subscription.service';\nimport { logger } from '../../../../core/logger';\nimport { db } from '@db';\nimport { subscriptions, cosmeticDrops, users } from '@schema';\nimport { eq, sql, desc, count, sum } from 'drizzle-orm';\n\nexport class AdminSubscriptionController {\n\t/**\n\t * Get subscription analytics\n\t * GET /api/admin/subscriptions/analytics\n\t */\n\tasync getSubscriptionAnalytics(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\t// Get subscription statistics\n\t\t\tconst [\n\t\t\t\ttotalSubscriptions,\n\t\t\t\tvipPassCount,\n\t\t\t\tdegenPassCount,\n\t\t\t\tactiveSubscriptions,\n\t\t\t\tmonthlyRevenue,\n\t\t\t\tcosmeticDropStats\n\t\t\t] = await Promise.all([\n\t\t\t\t// Total subscriptions\n\t\t\t\tdb\n\t\t\t\t\t.select({ count: sql<number>`COUNT(*)` })\n\t\t\t\t\t.from(subscriptions)\n\t\t\t\t\t.where(eq(subscriptions.isDeleted, false)),\n\n\t\t\t\t// VIP Pass count\n\t\t\t\tdb\n\t\t\t\t\t.select({ count: sql<number>`COUNT(*)` })\n\t\t\t\t\t.from(subscriptions)\n\t\t\t\t\t.where(sql`${subscriptions.type} = 'vip_pass' AND ${subscriptions.isDeleted} = false`),\n\n\t\t\t\t// Degen Pass count\n\t\t\t\tdb\n\t\t\t\t\t.select({ count: sql<number>`COUNT(*)` })\n\t\t\t\t\t.from(subscriptions)\n\t\t\t\t\t.where(sql`${subscriptions.type} = 'degen_pass' AND ${subscriptions.isDeleted} = false`),\n\n\t\t\t\t// Active subscriptions\n\t\t\t\tdb\n\t\t\t\t\t.select({ count: sql<number>`COUNT(*)` })\n\t\t\t\t\t.from(subscriptions)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tsql`${subscriptions.status} IN ('active', 'lifetime') AND ${subscriptions.isDeleted} = false`\n\t\t\t\t\t),\n\n\t\t\t\t// Monthly revenue (current month)\n\t\t\t\tdb\n\t\t\t\t\t.select({ revenue: sql<number>`SUM(${subscriptions.pricePaid})` })\n\t\t\t\t\t.from(subscriptions)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tsql`EXTRACT(MONTH FROM ${subscriptions.createdAt}) = EXTRACT(MONTH FROM CURRENT_DATE) \n                        AND EXTRACT(YEAR FROM ${subscriptions.createdAt}) = EXTRACT(YEAR FROM CURRENT_DATE)\n                        AND ${subscriptions.isDeleted} = false`\n\t\t\t\t\t),\n\n\t\t\t\t// Cosmetic drop statistics\n\t\t\t\tdb\n\t\t\t\t\t.select({\n\t\t\t\t\t\ttotalDrops: sql<number>`COUNT(*)`,\n\t\t\t\t\t\ttotalValue: sql<number>`SUM(${cosmeticDrops.cosmeticValue})`\n\t\t\t\t\t})\n\t\t\t\t\t.from(cosmeticDrops)\n\t\t\t]);\n\n\t\t\tconst analytics = {\n\t\t\t\tsubscriptions: {\n\t\t\t\t\ttotal: totalSubscriptions[0]?.count || 0,\n\t\t\t\t\tvip_pass: vipPassCount[0]?.count || 0,\n\t\t\t\t\tdegen_pass: degenPassCount[0]?.count || 0,\n\t\t\t\t\tactive: activeSubscriptions[0]?.count || 0\n\t\t\t\t},\n\t\t\t\trevenue: {\n\t\t\t\t\tmonthly: monthlyRevenue[0]?.revenue || 0,\n\t\t\t\t\tcurrency: 'DGT'\n\t\t\t\t},\n\t\t\t\tcosmetics: {\n\t\t\t\t\ttotalDrops: cosmeticDropStats[0]?.totalDrops || 0,\n\t\t\t\t\ttotalValue: cosmeticDropStats[0]?.totalValue || 0\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: { analytics }\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ADMIN_SUBSCRIPTION', 'Error getting analytics:', error);\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to retrieve subscription analytics'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get all subscriptions with pagination\n\t * GET /api/admin/subscriptions\n\t */\n\tasync getAllSubscriptions(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst page = parseInt(req.query.page as string) || 1;\n\t\t\tconst limit = parseInt(req.query.limit as string) || 50;\n\t\t\tconst status = req.query.status as string;\n\t\t\tconst type = req.query.type as string;\n\n\t\t\tconst offset = (page - 1) * limit;\n\n\t\t\t// Build where conditions\n\t\t\tconst whereConditions = [eq(subscriptions.isDeleted, false)];\n\n\t\t\tif (status) {\n\t\t\t\twhereConditions.push(eq(subscriptions.status, status));\n\t\t\t}\n\n\t\t\tif (type) {\n\t\t\t\twhereConditions.push(eq(subscriptions.type, type));\n\t\t\t}\n\n\t\t\t// Get subscriptions with user information\n\t\t\tconst results = await db\n\t\t\t\t.select({\n\t\t\t\t\tsubscription: subscriptions,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: users.id,\n\t\t\t\t\t\tusername: users.username,\n\t\t\t\t\t\temail: users.email\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.from(subscriptions)\n\t\t\t\t.leftJoin(users, eq(subscriptions.userId, users.id))\n\t\t\t\t.where(sql`${whereConditions.join(' AND ')}`)\n\t\t\t\t.orderBy(desc(subscriptions.createdAt))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\t// Get total count\n\t\t\tconst [totalCount] = await db\n\t\t\t\t.select({ count: sql<number>`COUNT(*)` })\n\t\t\t\t.from(subscriptions)\n\t\t\t\t.where(sql`${whereConditions.join(' AND ')}`);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tsubscriptions: results,\n\t\t\t\t\tpagination: {\n\t\t\t\t\t\tpage,\n\t\t\t\t\t\tlimit,\n\t\t\t\t\t\ttotal: totalCount?.count || 0,\n\t\t\t\t\t\tpages: Math.ceil((totalCount?.count || 0) / limit)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ADMIN_SUBSCRIPTION', 'Error getting all subscriptions:', error);\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to retrieve subscriptions'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Process monthly cosmetic drops manually\n\t * POST /api/admin/subscriptions/process-cosmetics\n\t */\n\tasync processMonthlyCosmetics(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst results = await subscriptionService.processMonthlyCosmetics();\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tresults,\n\t\t\t\t\tmessage: `Cosmetic drops processed: ${results.processed} successful, ${results.failed} failed`\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ADMIN_SUBSCRIPTION', 'Error processing cosmetics:', error);\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to process monthly cosmetic drops'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get cosmetic drop history with pagination\n\t * GET /api/admin/subscriptions/cosmetic-drops\n\t */\n\tasync getCosmeticDropHistory(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst page = parseInt(req.query.page as string) || 1;\n\t\t\tconst limit = parseInt(req.query.limit as string) || 50;\n\t\t\tconst month = parseInt(req.query.month as string);\n\t\t\tconst year = parseInt(req.query.year as string);\n\n\t\t\tconst offset = (page - 1) * limit;\n\n\t\t\t// Build where conditions\n\t\t\tconst whereConditions = [];\n\n\t\t\tif (month && year) {\n\t\t\t\twhereConditions.push(eq(cosmeticDrops.dropMonth, month));\n\t\t\t\twhereConditions.push(eq(cosmeticDrops.dropYear, year));\n\t\t\t}\n\n\t\t\t// Get cosmetic drops with user information\n\t\t\tconst results = await db\n\t\t\t\t.select({\n\t\t\t\t\tdrop: cosmeticDrops,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: users.id,\n\t\t\t\t\t\tusername: users.username\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.from(cosmeticDrops)\n\t\t\t\t.leftJoin(users, eq(cosmeticDrops.userId, users.id))\n\t\t\t\t.where(whereConditions.length > 0 ? sql`${whereConditions.join(' AND ')}` : undefined)\n\t\t\t\t.orderBy(desc(cosmeticDrops.createdAt))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\t// Get total count\n\t\t\tconst [totalCount] = await db\n\t\t\t\t.select({ count: sql<number>`COUNT(*)` })\n\t\t\t\t.from(cosmeticDrops)\n\t\t\t\t.where(whereConditions.length > 0 ? sql`${whereConditions.join(' AND ')}` : undefined);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tdrops: results,\n\t\t\t\t\tpagination: {\n\t\t\t\t\t\tpage,\n\t\t\t\t\t\tlimit,\n\t\t\t\t\t\ttotal: totalCount?.count || 0,\n\t\t\t\t\t\tpages: Math.ceil((totalCount?.count || 0) / limit)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ADMIN_SUBSCRIPTION', 'Error getting cosmetic drops:', error);\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to retrieve cosmetic drop history'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Cancel a subscription (admin override)\n\t * POST /api/admin/subscriptions/:id/cancel\n\t */\n\tasync cancelSubscription(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\tconst { reason } = req.body;\n\t\t\tconst adminUserId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tconst subscriptionId = id;\n\t\t\tif (isNaN(subscriptionId)) {\n\t\t\t\tres.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Valid subscription ID required'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get subscription details\n\t\t\tconst subscription = await db\n\t\t\t\t.select()\n\t\t\t\t.from(subscriptions)\n\t\t\t\t.where(eq(subscriptions.id, subscriptionId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (subscription.length === 0) {\n\t\t\t\tres.status(404).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Subscription not found'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Cancel the subscription (admin override - can cancel VIP Pass)\n\t\t\tawait db\n\t\t\t\t.update(subscriptions)\n\t\t\t\t.set({\n\t\t\t\t\tstatus: 'cancelled',\n\t\t\t\t\tautoRenew: false,\n\t\t\t\t\tnotes: `Admin cancellation by ${adminUserId}: ${reason || 'No reason provided'}`,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(subscriptions.id, subscriptionId));\n\n\t\t\tlogger.info(\n\t\t\t\t'ADMIN_SUBSCRIPTION',\n\t\t\t\t`Subscription ${subscriptionId} cancelled by admin ${adminUserId}: ${reason}`\n\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tmessage: 'Subscription cancelled successfully'\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ADMIN_SUBSCRIPTION', 'Error cancelling subscription:', error);\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to cancel subscription'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Grant subscription to user (admin action)\n\t * POST /api/admin/subscriptions/grant\n\t */\n\tasync grantSubscription(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { userId, type, reason } = req.body;\n\t\t\tconst adminUserId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!userId || !type || !['vip_pass', 'degen_pass'].includes(type)) {\n\t\t\t\tres.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Valid userId and subscription type required'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if user already has this subscription type\n\t\t\tconst existingSubscription = await subscriptionService.getUserActiveSubscription(\n\t\t\t\tuserId,\n\t\t\t\ttype\n\t\t\t);\n\t\t\tif (existingSubscription) {\n\t\t\t\tres.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `User already has an active ${type.replace('_', ' ')} subscription`\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Grant the subscription\n\t\t\tconst endDate = type === 'vip_pass' ? null : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days\n\t\t\tconst nextBillingDate = type === 'vip_pass' ? null : endDate;\n\t\t\tconst status = type === 'vip_pass' ? 'lifetime' : 'active';\n\n\t\t\tconst [subscription] = await db\n\t\t\t\t.insert(subscriptions)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\ttype,\n\t\t\t\t\tstatus,\n\t\t\t\t\tpricePaid: 0, // Admin granted - no payment\n\t\t\t\t\tcurrency: 'DGT',\n\t\t\t\t\tstartDate: new Date(),\n\t\t\t\t\tendDate,\n\t\t\t\t\tnextBillingDate,\n\t\t\t\t\tautoRenew: type === 'degen_pass',\n\t\t\t\t\tbenefits: subscriptionService['getDefaultBenefits'](type),\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tgrantedBy: adminUserId,\n\t\t\t\t\t\tgrantReason: reason || 'Admin grant',\n\t\t\t\t\t\tsource: 'admin_grant'\n\t\t\t\t\t},\n\t\t\t\t\tnotes: `Admin grant by ${adminUserId}: ${reason || 'No reason provided'}`\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\tlogger.info(\n\t\t\t\t'ADMIN_SUBSCRIPTION',\n\t\t\t\t`${type} granted to user ${userId} by admin ${adminUserId}: ${reason}`\n\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tsubscription,\n\t\t\t\t\tmessage: `${type.replace('_', ' ')} granted successfully`\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ADMIN_SUBSCRIPTION', 'Error granting subscription:', error);\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to grant subscription'\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport const adminSubscriptionController = new AdminSubscriptionController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/subscriptions/subscription.admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/titles/titles.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/titles/titles.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/titles/titles.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNotNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { titles as titlesTable, roles as rolesTable } from '@schema';\nimport type { CreateTitleInput, UpdateTitleInput } from './titles.validators';\nimport { eq, desc, asc, isNull, isNotNull } from 'drizzle-orm';\n\nexport class AdminTitlesService {\n\tasync list() {\n\t\t// Get titles with their associated role information\n\t\tconst titles = await db\n\t\t\t.select({\n\t\t\t\tid: titlesTable.id,\n\t\t\t\tname: titlesTable.name,\n\t\t\t\tdescription: titlesTable.description,\n\t\t\t\ticonUrl: titlesTable.iconUrl,\n\t\t\t\trarity: titlesTable.rarity,\n\t\t\t\temoji: titlesTable.emoji,\n\t\t\t\tfontFamily: titlesTable.fontFamily,\n\t\t\t\tfontSize: titlesTable.fontSize,\n\t\t\t\tfontWeight: titlesTable.fontWeight,\n\t\t\t\ttextColor: titlesTable.textColor,\n\t\t\t\tbackgroundColor: titlesTable.backgroundColor,\n\t\t\t\tborderColor: titlesTable.borderColor,\n\t\t\t\tborderWidth: titlesTable.borderWidth,\n\t\t\t\tborderStyle: titlesTable.borderStyle,\n\t\t\t\tborderRadius: titlesTable.borderRadius,\n\t\t\t\tglowColor: titlesTable.glowColor,\n\t\t\t\tglowIntensity: titlesTable.glowIntensity,\n\t\t\t\tshadowColor: titlesTable.shadowColor,\n\t\t\t\tshadowBlur: titlesTable.shadowBlur,\n\t\t\t\tshadowOffsetX: titlesTable.shadowOffsetX,\n\t\t\t\tshadowOffsetY: titlesTable.shadowOffsetY,\n\t\t\t\tgradientStart: titlesTable.gradientStart,\n\t\t\t\tgradientEnd: titlesTable.gradientEnd,\n\t\t\t\tgradientDirection: titlesTable.gradientDirection,\n\t\t\t\tanimation: titlesTable.animation,\n\t\t\t\tanimationDuration: titlesTable.animationDuration,\n\t\t\t\troleId: titlesTable.roleId,\n\t\t\t\tisShopItem: titlesTable.isShopItem,\n\t\t\t\tisUnlockable: titlesTable.isUnlockable,\n\t\t\t\tunlockConditions: titlesTable.unlockConditions,\n\t\t\t\tshopPrice: titlesTable.shopPrice,\n\t\t\t\tshopCurrency: titlesTable.shopCurrency,\n\t\t\t\tcreatedAt: titlesTable.createdAt,\n\t\t\t\troleName: rolesTable.name\n\t\t\t})\n\t\t\t.from(titlesTable)\n\t\t\t.leftJoin(rolesTable, eq(titlesTable.roleId, rolesTable.id))\n\t\t\t.orderBy(asc(titlesTable.rarity), asc(titlesTable.name));\n\n\t\treturn titles;\n\t}\n\n\tasync getByRole(roleId: string) {\n\t\treturn db\n\t\t\t.select()\n\t\t\t.from(titlesTable)\n\t\t\t.where(eq(titlesTable.roleId, roleId))\n\t\t\t.orderBy(asc(titlesTable.name));\n\t}\n\n\tasync getCustomTitles() {\n\t\treturn db\n\t\t\t.select()\n\t\t\t.from(titlesTable)\n\t\t\t.where(isNull(titlesTable.roleId))\n\t\t\t.orderBy(asc(titlesTable.rarity), asc(titlesTable.name));\n\t}\n\n\tasync create(data: CreateTitleInput) {\n\t\t// Validate role exists if roleId is provided\n\t\tif (data.roleId) {\n\t\t\tconst [role] = await db\n\t\t\t\t.select({ id: rolesTable.id })\n\t\t\t\t.from(rolesTable)\n\t\t\t\t.where(eq(rolesTable.id, data.roleId));\n\t\t\tif (!role) throw new Error('Role not found');\n\t\t}\n\n\t\tconst [title] = await db.insert(titlesTable).values(data).returning();\n\t\treturn title;\n\t}\n\n\tasync update(id: Id<'id'>, data: UpdateTitleInput) {\n\t\t// Validate role exists if roleId is provided\n\t\tif (data.roleId) {\n\t\t\tconst [role] = await db\n\t\t\t\t.select({ id: rolesTable.id })\n\t\t\t\t.from(rolesTable)\n\t\t\t\t.where(eq(rolesTable.id, data.roleId));\n\t\t\tif (!role) throw new Error('Role not found');\n\t\t}\n\n\t\tconst [title] = await db\n\t\t\t.update(titlesTable)\n\t\t\t.set(data)\n\t\t\t.where(eq(titlesTable.id, id))\n\t\t\t.returning();\n\n\t\tif (!title) throw new Error('Title not found');\n\t\treturn title;\n\t}\n\n\tasync delete(id: Id<'id'>) {\n\t\tconst [title] = await db.select().from(titlesTable).where(eq(titlesTable.id, id));\n\t\tif (!title) throw new Error('Title not found');\n\n\t\tawait db.delete(titlesTable).where(eq(titlesTable.id, id));\n\t\treturn { success: true };\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/titles/titles.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/treasury/treasury.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { adminTreasuryService } from './treasury.service';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { getUserId } from '../../admin.middleware';\nimport { adminController } from '../../admin.controller';\nimport {\n\tTreasuryDepositSchema,\n\tTreasuryWithdrawalSchema,\n\tTreasurySettingsUpdateSchema,\n\tMassAirdropSchema,\n\ttype TreasuryDepositInput,\n\ttype TreasuryWithdrawalInput,\n\ttype TreasurySettingsUpdateInput,\n\ttype MassAirdropInput\n} from './treasury.validators';\nimport { validateRequestBody } from '../../admin.validation';\n\nexport class AdminTreasuryController {\n\tasync getDgtSupplyStats(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst stats = await adminTreasuryService.getDgtSupplyStats();\n\t\t\tres.json(stats);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({ error: error.message, code: error.code });\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to get DGT supply statistics' });\n\t\t}\n\t}\n\n\tasync sendFromTreasury(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, TreasuryDepositSchema);\n\t\t\tif (!data) return;\n\t\t\tconst adminId = userService.getUserFromRequest(req);\n\t\t\tconst result = await adminTreasuryService.sendFromTreasury(data, adminId);\n\n\t\t\tawait adminController.logAction(req, 'TREASURY_SEND', 'treasury', data.userId.toString(), {\n\t\t\t\tamount: data.amount,\n\t\t\t\trecipientUserId: data.userId,\n\t\t\t\tdescription: data.description\n\t\t\t});\n\t\t\tres.json({ message: 'DGT sent from treasury successfully', data: result });\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to send DGT from treasury' });\n\t\t}\n\t}\n\n\tasync recoverToTreasury(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, TreasuryWithdrawalSchema);\n\t\t\tif (!data) return;\n\t\t\tconst adminId = userService.getUserFromRequest(req);\n\t\t\tconst result = await adminTreasuryService.recoverToTreasury(data, adminId);\n\n\t\t\tawait adminController.logAction(req, 'TREASURY_RECOVER', 'treasury', data.userId.toString(), {\n\t\t\t\tamount: data.amount,\n\t\t\t\tsourceUserId: data.userId,\n\t\t\t\tdescription: data.description\n\t\t\t});\n\t\t\tres.json({ message: 'DGT recovered to treasury successfully', data: result });\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to recover DGT to treasury' });\n\t\t}\n\t}\n\n\tasync massAirdrop(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst dataAirdrop = validateRequestBody(req, res, MassAirdropSchema);\n\t\t\tif (!dataAirdrop) return;\n\t\t\tconst adminId = userService.getUserFromRequest(req);\n\t\t\tconst result = await adminTreasuryService.massAirdrop(dataAirdrop, adminId);\n\n\t\t\tawait adminController.logAction(req, 'TREASURY_MASS_AIRDROP', 'treasury', 'multiple_users', {\n\t\t\t\tamountPerUser: dataAirdrop.amountPerUser,\n\t\t\t\tuserCount: dataAirdrop.userIds.length,\n\t\t\t\treason: dataAirdrop.reason,\n\t\t\t\tmissingUserIds: result.missingUserIds\n\t\t\t});\n\t\t\tres.json({ message: 'Mass airdrop process completed.', data: result });\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to process mass airdrop' });\n\t\t}\n\t}\n\n\tasync getTreasurySettings(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst settings = await adminTreasuryService.getDgtEconomyParameters();\n\t\t\tif (!settings) {\n\t\t\t\tthrow new AdminError('Treasury settings not found.', 404, AdminErrorCodes.NOT_FOUND);\n\t\t\t}\n\t\t\tres.json(settings);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({ error: error.message, code: error.code });\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to get treasury settings' });\n\t\t}\n\t}\n\n\tasync updateTreasurySettings(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst dataSettings = validateRequestBody(req, res, TreasurySettingsUpdateSchema);\n\t\t\tif (!dataSettings) return;\n\t\t\tconst adminId = userService.getUserFromRequest(req);\n\t\t\tconst result = await adminTreasuryService.updateDgtEconomyParameters(dataSettings, adminId);\n\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t'TREASURY_SETTINGS_UPDATE',\n\t\t\t\t'treasury_settings',\n\t\t\t\t'general',\n\t\t\t\t{\n\t\t\t\t\tupdatedSettings: dataSettings\n\t\t\t\t}\n\t\t\t);\n\t\t\tres.json({ message: 'Treasury settings updated successfully', data: result });\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to update treasury settings' });\n\t\t}\n\t}\n}\n\nexport const adminTreasuryController = new AdminTreasuryController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/treasury/treasury.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/treasury/treasury.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin Treasury Service\n *\n * Handles business logic for treasury operations in the admin panel.\n */\n\nimport { db } from '@db';\nimport type { UserId } from '@shared/types/ids';\nimport {\n\tusers,\n\ttransactions,\n\tdgtEconomyParameters,\n\tsiteSettings as platformSiteSettings\n} from '@schema';\nimport type { Transaction } from '@schema';\nimport { sql, eq, desc, and, inArray } from 'drizzle-orm';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { vanitySinkAnalyzer } from '../../../shop/services/vanity-sink.analyzer';\nimport type {\n\tTreasuryDepositInput,\n\tTreasuryWithdrawalInput,\n\tTreasurySettingsUpdateInput,\n\tMassAirdropInput\n} from './treasury.validators';\nimport type { AdminUserId, ActionId } from '@shared/types/ids';\nimport { logger } from '../../../../core/logger';\n\n// Helper to format DGT amounts for display (assuming 6 decimal places for DGT)\nfunction formatDgtAmount(amount: number): number {\n\treturn amount / 1000000;\n}\n\n// Helper to parse DGT amounts for storage\nfunction parseDgtAmount(displayAmount: number): number {\n\treturn Math.floor(displayAmount * 1000000);\n}\n\nexport class AdminTreasuryService {\n\tasync getDgtSupplyStats() {\n\t\ttry {\n\t\t\tconst [totalSupplySetting] = await db\n\t\t\t\t.select({ value: platformSiteSettings.value })\n\t\t\t\t.from(platformSiteSettings)\n\t\t\t\t.where(eq(platformSiteSettings.key, 'dgt_total_supply_cap'));\n\n\t\t\tconst circulatingSupplyResult = await db\n\t\t\t\t.select({ circulating: sql<number>`sum(${users.dgtWalletBalance})` })\n\t\t\t\t.from(users)\n\t\t\t\t.where(sql`${users.id} != 999999`); // Exclude treasury user ID if you have one\n\n\t\t\tconst [treasurySpecificSettings] = await db\n\t\t\t\t.select({\n\t\t\t\t\tdgtTreasuryBalance: dgtEconomyParameters.dgtTreasuryBalance\n\t\t\t\t})\n\t\t\t\t.from(dgtEconomyParameters)\n\t\t\t\t.limit(1);\n\n\t\t\tconst holdersCountResult = await db\n\t\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t\t.from(users)\n\t\t\t\t.where(and(sql`${users.dgtWalletBalance} > 0`, sql`${users.id} != 999999`));\n\n\t\t\tconst totalSupply = parseDgtAmount(parseFloat(totalSupplySetting?.value || '1000000000'));\n\t\t\tconst circulatingAmount = Number(circulatingSupplyResult[0]?.circulating) || 0;\n\t\t\tconst treasuryAmount = Number(treasurySpecificSettings?.dgtTreasuryBalance) || 0;\n\t\t\tconst holdersCount = Number(holdersCountResult[0]?.count) || 0;\n\n\t\t\treturn {\n\t\t\t\ttotalSupply: formatDgtAmount(totalSupply),\n\t\t\t\tcirculatingSupply: formatDgtAmount(circulatingAmount),\n\t\t\t\ttreasuryBalance: formatDgtAmount(treasuryAmount),\n\t\t\t\tpercentCirculating: totalSupply > 0 ? (circulatingAmount / totalSupply) * 100 : 0,\n\t\t\t\tholders: holdersCount\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tlogger.error('Error in getDgtSupplyStats:', error);\n\t\t\tthrow new AdminError('Failed to fetch DGT supply statistics', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\tasync sendFromTreasury(input: TreasuryDepositInput, adminUserId: AdminUserId) {\n\t\tconst { amount, userId, description, metadata } = input;\n\t\tconst transferAmountDgt = parseDgtAmount(amount);\n\n\t\treturn db.transaction(async (tx) => {\n\t\t\tconst [currentDgtParams] = await tx\n\t\t\t\t.select({ balance: dgtEconomyParameters.dgtTreasuryBalance })\n\t\t\t\t.from(dgtEconomyParameters)\n\t\t\t\t.limit(1);\n\n\t\t\tconst currentTreasuryBalance = Number(currentDgtParams?.balance) || 0;\n\t\t\tif (currentTreasuryBalance < transferAmountDgt) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Insufficient treasury balance',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.OPERATION_FAILED\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst [recipient] = await tx.select().from(users).where(eq(users.id, userId));\n\t\t\tif (!recipient) {\n\t\t\t\tthrow new AdminError('Recipient user not found', 404, AdminErrorCodes.USER_NOT_FOUND);\n\t\t\t}\n\n\t\t\tawait tx.update(dgtEconomyParameters).set({\n\t\t\t\tdgtTreasuryBalance: sql`${dgtEconomyParameters.dgtTreasuryBalance} - ${transferAmountDgt}`,\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\tupdatedBy: adminUserId\n\t\t\t});\n\n\t\t\tawait tx\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\tdgtWalletBalance: sql`${users.dgtWalletBalance || 0} + ${transferAmountDgt}`,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\tconst [newTransaction] = await tx\n\t\t\t\t.insert(transactions)\n\t\t\t\t.values({\n\t\t\t\t\tuserId: userId,\n\t\t\t\t\tfromUserId: null,\n\t\t\t\t\ttoUserId: userId,\n\t\t\t\t\tamount: transferAmountDgt,\n\t\t\t\t\ttype: 'ADMIN_ADJUST',\n\t\t\t\t\tstatus: 'confirmed',\n\t\t\t\t\tdescription: description || 'Treasury allocation',\n\t\t\t\t\tmetadata: metadata || { adminUser: adminUserId },\n\t\t\t\t\tisTreasuryTransaction: true\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\treturn { ...newTransaction, amount: formatDgtAmount(newTransaction.amount || 0) };\n\t\t});\n\t}\n\n\tasync recoverToTreasury(input: TreasuryWithdrawalInput, adminUserId: AdminUserId) {\n\t\tconst { amount, userId, description, metadata } = input;\n\t\tconst transferAmountDgt = parseDgtAmount(amount);\n\n\t\treturn db.transaction(async (tx) => {\n\t\t\tconst [userToRecoverFrom] = await tx\n\t\t\t\t.select({ balance: users.dgtWalletBalance })\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\tif (!userToRecoverFrom) {\n\t\t\t\tthrow new AdminError('User not found for recovery', 404, AdminErrorCodes.USER_NOT_FOUND);\n\t\t\t}\n\n\t\t\tconst currentUserBalance = Number(userToRecoverFrom.balance) || 0;\n\t\t\tif (currentUserBalance < transferAmountDgt) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Insufficient user balance for recovery',\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.OPERATION_FAILED\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tawait tx\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\tdgtWalletBalance: sql`${users.dgtWalletBalance || 0} - ${transferAmountDgt}`,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\tawait tx.update(dgtEconomyParameters).set({\n\t\t\t\tdgtTreasuryBalance: sql`${dgtEconomyParameters.dgtTreasuryBalance || 0} + ${transferAmountDgt}`,\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\tupdatedBy: adminUserId\n\t\t\t});\n\n\t\t\tconst [newTransaction] = await tx\n\t\t\t\t.insert(transactions)\n\t\t\t\t.values({\n\t\t\t\t\tuserId: userId,\n\t\t\t\t\tfromUserId: userId,\n\t\t\t\t\ttoUserId: null,\n\t\t\t\t\tamount: transferAmountDgt,\n\t\t\t\t\ttype: 'ADMIN_ADJUST',\n\t\t\t\t\tstatus: 'confirmed',\n\t\t\t\t\tdescription: description || 'Recovery to treasury',\n\t\t\t\t\tmetadata: metadata || { adminUser: adminUserId },\n\t\t\t\t\tisTreasuryTransaction: true\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Track DGT burn for vanity sink analysis (recovery to treasury is effectively a burn)\n\t\t\tawait vanitySinkAnalyzer.trackBurn({\n\t\t\t\tuserId: userId,\n\t\t\t\torderId: newTransaction.id,\n\t\t\t\tdgtBurned: transferAmountDgt,\n\t\t\t\tburnType: 'burn',\n\t\t\t\tsource: 'treasury',\n\t\t\t\tuserLevel: 1, // TODO: Get actual user level\n\t\t\t\tuserLifetimeSpent: 0, // TODO: Get actual lifetime spending\n\t\t\t\tmetadata: {\n\t\t\t\t\tadminUserId,\n\t\t\t\t\tdescription: description || 'Recovery to treasury',\n\t\t\t\t\tburnReason: 'admin_treasury_recovery'\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn { ...newTransaction, amount: formatDgtAmount(newTransaction.amount || 0) };\n\t\t});\n\t}\n\n\tasync massAirdrop(input: MassAirdropInput, adminUserId: AdminUserId) {\n\t\tconst { userIds, amountPerUser, reason } = input;\n\t\tconst dgtAmountPerUserStorage = parseDgtAmount(amountPerUser);\n\t\tconst totalDgtAmountStorage = dgtAmountPerUserStorage * userIds.length;\n\n\t\treturn db.transaction(async (tx) => {\n\t\t\tconst [currentDgtParams] = await tx\n\t\t\t\t.select({ balance: dgtEconomyParameters.dgtTreasuryBalance })\n\t\t\t\t.from(dgtEconomyParameters)\n\t\t\t\t.limit(1);\n\t\t\tconst currentTreasuryBalance = Number(currentDgtParams?.balance) || 0;\n\n\t\t\tif (currentTreasuryBalance < totalDgtAmountStorage) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`Insufficient treasury balance. Need ${formatDgtAmount(totalDgtAmountStorage)} DGT, have ${formatDgtAmount(currentTreasuryBalance)} DGT`,\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.OPERATION_FAILED\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst foundUsers = await tx\n\t\t\t\t.select({ id: users.id, username: users.username, currentBalance: users.dgtWalletBalance })\n\t\t\t\t.from(users)\n\t\t\t\t.where(inArray(users.id, userIds));\n\n\t\t\tconst foundUserIds = foundUsers.map((u) => u.id);\n\t\t\tconst missingUserIds = userIds.filter((id) => !foundUserIds.includes(id));\n\n\t\t\tif (foundUsers.length === 0) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'No valid users found for airdrop.',\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.USER_NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tawait tx.update(dgtEconomyParameters).set({\n\t\t\t\tdgtTreasuryBalance: sql`${dgtEconomyParameters.dgtTreasuryBalance || 0} - ${totalDgtAmountStorage}`,\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\tupdatedBy: adminUserId\n\t\t\t});\n\n\t\t\tconst airdropResults: Array<{\n\t\t\t\tuserId: UserId;\n\t\t\t\tusername: string;\n\t\t\t\tamount: number;\n\t\t\t\ttransactionId?: ActionId;\n\t\t\t\tstatus: string;\n\t\t\t\terror?: string;\n\t\t\t}> = [];\n\n\t\t\tfor (const user of foundUsers) {\n\t\t\t\ttry {\n\t\t\t\t\tawait tx\n\t\t\t\t\t\t.update(users)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tdgtWalletBalance: sql`${user.currentBalance || 0} + ${dgtAmountPerUserStorage}`\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(eq(users.id, user.id));\n\n\t\t\t\t\tconst [transactionResult] = await tx\n\t\t\t\t\t\t.insert(transactions)\n\t\t\t\t\t\t.values({\n\t\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\t\tamount: dgtAmountPerUserStorage,\n\t\t\t\t\t\t\ttype: 'AIRDROP',\n\t\t\t\t\t\t\tstatus: 'confirmed',\n\t\t\t\t\t\t\tdescription: `Admin Airdrop: ${reason || 'Mass Distribution'}`,\n\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\tadminUser: adminUserId,\n\t\t\t\t\t\t\t\treason: reason || 'Mass Distribution',\n\t\t\t\t\t\t\t\tdisplayAmount: amountPerUser\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tisTreasuryTransaction: true\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.returning({ transactionId: transactions.id });\n\n\t\t\t\t\tairdropResults.push({\n\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\tusername: user.username,\n\t\t\t\t\t\tamount: amountPerUser,\n\t\t\t\t\t\ttransactionId: transactionResult.transactionId,\n\t\t\t\t\t\tstatus: 'success'\n\t\t\t\t\t});\n\t\t\t\t} catch (e: any) {\n\t\t\t\t\tairdropResults.push({\n\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\tusername: user.username,\n\t\t\t\t\t\tamount: amountPerUser,\n\t\t\t\t\t\tstatus: 'failed',\n\t\t\t\t\t\terror: e.message\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { airdropResults, missingUserIds };\n\t\t});\n\t}\n\n\tasync getDgtEconomyParameters() {\n\t\ttry {\n\t\t\tconst settings = await db.query.dgtEconomyParameters.findFirst({});\n\n\t\t\tif (!settings) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...settings,\n\t\t\t\tdgtTreasuryBalance: settings.dgtTreasuryBalance\n\t\t\t\t\t? formatDgtAmount(Number(settings.dgtTreasuryBalance))\n\t\t\t\t\t: 0,\n\t\t\t\tminWithdrawalAmount: settings.minWithdrawalAmount\n\t\t\t\t\t? formatDgtAmount(Number(settings.minWithdrawalAmount))\n\t\t\t\t\t: 0,\n\t\t\t\tminTipAmount: settings.minTipAmount ? formatDgtAmount(Number(settings.minTipAmount)) : 0,\n\t\t\t\tmaxTipAmount: settings.maxTipAmount ? formatDgtAmount(Number(settings.maxTipAmount)) : 0\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tlogger.error('Error in getDgtEconomyParameters:', error);\n\t\t\tthrow new AdminError(\n\t\t\t\t'Failed to fetch DGT economy parameters',\n\t\t\t\t500,\n\t\t\t\tAdminErrorCodes.DB_ERROR,\n\t\t\t\t{ originalError: error.message }\n\t\t\t);\n\t\t}\n\t}\n\n\tasync updateDgtEconomyParameters(input: TreasurySettingsUpdateInput, adminUserId: AdminUserId) {\n\t\ttry {\n\t\t\tconst [existingSettings] = await db.select().from(dgtEconomyParameters).limit(1);\n\n\t\t\tif (!existingSettings) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'DGT Economy Parameters record not found. Cannot update.',\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst dataToUpdate: Partial<typeof dgtEconomyParameters.$inferInsert> = {\n\t\t\t\ttreasuryWalletAddress: input.treasuryWalletAddress,\n\t\t\t\tminWithdrawalAmount:\n\t\t\t\t\tinput.minWithdrawalAmount !== undefined\n\t\t\t\t\t\t? parseDgtAmount(input.minWithdrawalAmount)\n\t\t\t\t\t\t: undefined,\n\t\t\t\twithdrawalFeePercent: input.withdrawalFeePercent,\n\t\t\t\trewardDistributionDelayHours: input.rewardDistributionDelayHours,\n\t\t\t\ttipBurnPercent: input.tipBurnPercent,\n\t\t\t\ttipRecipientPercent: input.tipRecipientPercent,\n\t\t\t\tminTipAmount:\n\t\t\t\t\tinput.minTipAmount !== undefined ? parseDgtAmount(input.minTipAmount) : undefined,\n\t\t\t\tmaxTipAmount:\n\t\t\t\t\tinput.maxTipAmount !== undefined ? parseDgtAmount(input.maxTipAmount) : undefined,\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\tupdatedBy: adminUserId\n\t\t\t};\n\n\t\t\tObject.keys(dataToUpdate).forEach(\n\t\t\t\t(key) =>\n\t\t\t\t\tdataToUpdate[key as keyof typeof dataToUpdate] === undefined &&\n\t\t\t\t\tdelete dataToUpdate[key as keyof typeof dataToUpdate]\n\t\t\t);\n\n\t\t\tconst [updatedSettings] = await db\n\t\t\t\t.update(dgtEconomyParameters)\n\t\t\t\t.set(dataToUpdate)\n\t\t\t\t.where(eq(dgtEconomyParameters.id, existingSettings.id))\n\t\t\t\t.returning();\n\n\t\t\tif (!updatedSettings) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t'Failed to update DGT Economy Parameters record.',\n\t\t\t\t\t500,\n\t\t\t\t\tAdminErrorCodes.OPERATION_FAILED\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...updatedSettings,\n\t\t\t\tdgtTreasuryBalance: updatedSettings.dgtTreasuryBalance\n\t\t\t\t\t? formatDgtAmount(Number(updatedSettings.dgtTreasuryBalance))\n\t\t\t\t\t: 0,\n\t\t\t\tminWithdrawalAmount: updatedSettings.minWithdrawalAmount\n\t\t\t\t\t? formatDgtAmount(Number(updatedSettings.minWithdrawalAmount))\n\t\t\t\t\t: 0,\n\t\t\t\tminTipAmount: updatedSettings.minTipAmount\n\t\t\t\t\t? formatDgtAmount(Number(updatedSettings.minTipAmount))\n\t\t\t\t\t: 0,\n\t\t\t\tmaxTipAmount: updatedSettings.maxTipAmount\n\t\t\t\t\t? formatDgtAmount(Number(updatedSettings.maxTipAmount))\n\t\t\t\t\t: 0\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tlogger.error('Error in updateDgtEconomyParameters:', error);\n\t\t\tthrow new AdminError(\n\t\t\t\t'Failed to update DGT economy parameters',\n\t\t\t\t500,\n\t\t\t\tAdminErrorCodes.DB_ERROR,\n\t\t\t\t{ originalError: error.message }\n\t\t\t);\n\t\t}\n\t}\n}\n\nexport const adminTreasuryService = new AdminTreasuryService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/treasury/treasury.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/ui-config/ui-config.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'success' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":176,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":176,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'success' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":368,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":368,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { uiConfigService } from './ui-config.service';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { getUserId } from '../../admin.middleware';\nimport { adminController } from '../../admin.controller';\nimport {\n\tCreateQuoteSchema,\n\tUpdateQuoteSchema,\n\tQuoteFiltersSchema,\n\tPaginationSchema,\n\tCreateCollectionSchema,\n\tUpdateCollectionSchema,\n\tReorderQuotesSchema,\n\tBulkQuoteOperationSchema,\n\tImportQuotesSchema,\n\tExportQuotesSchema,\n\tAnalyticsRequestSchema,\n\tTrackEventSchema\n} from './ui-config.validators';\nimport { validateRequestBody, validateQueryParams } from '../../admin.validation';\n\nexport class UiConfigController {\n\t// ==================== QUOTE OPERATIONS ====================\n\n\t/**\n\t * Get quotes with filtering and pagination\n\t * GET /api/admin/ui-config/quotes\n\t */\n\tasync getQuotes(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst pagination = validateQueryParams(req, res, PaginationSchema);\n\t\t\tif (!pagination) return;\n\t\t\tconst filters = validateQueryParams(req, res, QuoteFiltersSchema);\n\t\t\tif (!filters) return;\n\n\t\t\tconst result = await uiConfigService.getQuotes(filters, pagination);\n\n\t\t\tres.json(result);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to fetch quotes' });\n\t\t}\n\t}\n\n\t/**\n\t * Get a single quote by ID\n\t * GET /api/admin/ui-config/quotes/:id\n\t */\n\tasync getQuoteById(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\tif (!id) {\n\t\t\t\tthrow new AdminError('Quote ID is required', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst quote = await uiConfigService.getQuoteById(id);\n\t\t\tif (!quote) {\n\t\t\t\tthrow new AdminError('Quote not found', 404, AdminErrorCodes.RESOURCE_NOT_FOUND);\n\t\t\t}\n\n\t\t\tres.json(quote);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to fetch quote' });\n\t\t}\n\t}\n\n\t/**\n\t * Create a new quote\n\t * POST /api/admin/ui-config/quotes\n\t */\n\tasync createQuote(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, CreateQuoteSchema);\n\t\t\tif (!data) return;\n\t\t\tconst userId = userService.getUserFromRequest(req);\n\t\t\tconst quote = await uiConfigService.createQuote(data, userId);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'CREATE_UI_QUOTE', 'ui_quote', quote.id, data);\n\n\t\t\tres.status(201).json(quote);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to create quote' });\n\t\t}\n\t}\n\n\t/**\n\t * Update an existing quote\n\t * PUT /api/admin/ui-config/quotes/:id\n\t */\n\tasync updateQuote(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\t// augment body with id for validation\n\t\t\t(req as any).body = { ...req.body, id };\n\t\t\tconst dataUpdate = validateRequestBody(req, res, UpdateQuoteSchema);\n\t\t\tif (!dataUpdate) return;\n\t\t\tconst userId = userService.getUserFromRequest(req);\n\t\t\tconst quote = await uiConfigService.updateQuote(dataUpdate, userId);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'UPDATE_UI_QUOTE', 'ui_quote', id, dataUpdate);\n\n\t\t\tres.json(quote);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to update quote' });\n\t\t}\n\t}\n\n\t/**\n\t * Delete a quote\n\t * DELETE /api/admin/ui-config/quotes/:id\n\t */\n\tasync deleteQuote(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\tif (!id) {\n\t\t\t\tthrow new AdminError('Quote ID is required', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst success = await uiConfigService.deleteQuote(id);\n\t\t\tif (!success) {\n\t\t\t\tthrow new AdminError('Quote not found', 404, AdminErrorCodes.RESOURCE_NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'DELETE_UI_QUOTE', 'ui_quote', id, {});\n\n\t\t\tres.status(204).send();\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to delete quote' });\n\t\t}\n\t}\n\n\t/**\n\t * Reorder multiple quotes\n\t * POST /api/admin/ui-config/quotes/reorder\n\t */\n\tasync reorderQuotes(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, ReorderQuotesSchema);\n\t\t\tif (!data) return;\n\t\t\tconst success = await uiConfigService.reorderQuotes(data);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'REORDER_UI_QUOTES', 'ui_quote', 'multiple', {\n\t\t\t\tcount: data.quoteOrders.length\n\t\t\t});\n\n\t\t\tres.json({ success: true });\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to reorder quotes' });\n\t\t}\n\t}\n\n\t// ==================== COLLECTION OPERATIONS ====================\n\n\t/**\n\t * Get all collections\n\t * GET /api/admin/ui-config/collections\n\t */\n\tasync getCollections(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst collections = await uiConfigService.getCollections();\n\t\t\tres.json(collections);\n\t\t} catch (error) {\n\t\t\tres.status(500).json({ error: 'Failed to fetch collections' });\n\t\t}\n\t}\n\n\t/**\n\t * Create a new collection\n\t * POST /api/admin/ui-config/collections\n\t */\n\tasync createCollection(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, CreateCollectionSchema);\n\t\t\tif (!data) return;\n\t\t\tconst userId = userService.getUserFromRequest(req);\n\t\t\tconst collection = await uiConfigService.createCollection(data, userId);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t'CREATE_UI_COLLECTION',\n\t\t\t\t'ui_collection',\n\t\t\t\tcollection.id,\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tres.status(201).json(collection);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to create collection' });\n\t\t}\n\t}\n\n\t/**\n\t * Update an existing collection\n\t * PUT /api/admin/ui-config/collections/:id\n\t */\n\tasync updateCollection(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\t// augment body with id for validation\n\t\t\t(req as any).body = { ...req.body, id };\n\t\t\tconst dataUpdate = validateRequestBody(req, res, UpdateCollectionSchema);\n\t\t\tif (!dataUpdate) return;\n\t\t\tconst userId = userService.getUserFromRequest(req);\n\t\t\tconst collection = await uiConfigService.updateCollection(dataUpdate, userId);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'UPDATE_UI_COLLECTION', 'ui_collection', id, dataUpdate);\n\n\t\t\tres.json(collection);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to update collection' });\n\t\t}\n\t}\n\n\t/**\n\t * Delete a collection\n\t * DELETE /api/admin/ui-config/collections/:id\n\t */\n\tasync deleteCollection(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\tif (!id) {\n\t\t\t\tthrow new AdminError('Collection ID is required', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst success = await uiConfigService.deleteCollection(id);\n\t\t\tif (!success) {\n\t\t\t\tthrow new AdminError('Collection not found', 404, AdminErrorCodes.RESOURCE_NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'DELETE_UI_COLLECTION', 'ui_collection', id, {});\n\n\t\t\tres.status(204).send();\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to delete collection' });\n\t\t}\n\t}\n\n\t// ==================== ANALYTICS OPERATIONS ====================\n\n\t/**\n\t * Track a quote event\n\t * POST /api/admin/ui-config/analytics/track\n\t */\n\tasync trackEvent(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, TrackEventSchema);\n\t\t\tif (!data) return;\n\t\t\tconst { quoteId, eventType, context } = data;\n\n\t\t\tawait uiConfigService.trackQuoteEvent(quoteId, eventType, context);\n\n\t\t\tres.status(204).send();\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to track event' });\n\t\t}\n\t}\n\n\t/**\n\t * Get quote analytics\n\t * GET /api/admin/ui-config/analytics/quotes/:quoteId\n\t */\n\tasync getQuoteAnalytics(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst { quoteId } = req.params;\n\t\t\t// augment query with quoteId for validation\n\t\t\t(req as any).query = { ...req.query, quoteId };\n\t\t\tconst queryAnalytics = validateQueryParams(req, res, AnalyticsRequestSchema);\n\t\t\tif (!queryAnalytics) return;\n\n\t\t\tconst result = await uiConfigService.getQuoteAnalytics(queryAnalytics);\n\t\t\tres.json(result);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to fetch analytics' });\n\t\t}\n\t}\n\n\t// ==================== BULK OPERATIONS ====================\n\n\t/**\n\t * Perform bulk operations on quotes\n\t * POST /api/admin/ui-config/quotes/bulk\n\t */\n\tasync bulkUpdateQuotes(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, BulkQuoteOperationSchema);\n\t\t\tif (!data) return;\n\t\t\tconst success = await uiConfigService.bulkUpdateQuotes(data);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'BULK_UPDATE_UI_QUOTES', 'ui_quote', 'multiple', {\n\t\t\t\taction: data.action,\n\t\t\t\tcount: data.quoteIds.length\n\t\t\t});\n\n\t\t\tres.json({ success: true });\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to perform bulk operation' });\n\t\t}\n\t}\n\n\t// ==================== IMPORT/EXPORT OPERATIONS ====================\n\n\t/**\n\t * Import quotes from file\n\t * POST /api/admin/ui-config/quotes/import\n\t */\n\tasync importQuotes(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, ImportQuotesSchema);\n\t\t\tif (!data) return;\n\t\t\tconst userId = userService.getUserFromRequest(req);\n\t\t\tconst result = await uiConfigService.importQuotes(data, userId);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'IMPORT_UI_QUOTES', 'ui_quote', 'multiple', {\n\t\t\t\timported: result.imported,\n\t\t\t\tskipped: result.skipped,\n\t\t\t\ttotal: data.quotes.length\n\t\t\t});\n\n\t\t\tres.json(result);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to import quotes' });\n\t\t}\n\t}\n\n\t/**\n\t * Export quotes to file\n\t * POST /api/admin/ui-config/quotes/export\n\t */\n\tasync exportQuotes(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, ExportQuotesSchema);\n\t\t\tif (!data) return;\n\t\t\tconst result = await uiConfigService.exportQuotes(data);\n\t\t\tconst format = data.format || 'json';\n\n\t\t\t// Set appropriate headers\n\t\t\tif (format === 'csv') {\n\t\t\t\tres.setHeader('Content-Type', 'text/csv');\n\t\t\t\tres.setHeader('Content-Disposition', 'attachment; filename=\"ui-quotes.csv\"');\n\t\t\t} else {\n\t\t\t\tres.setHeader('Content-Type', 'application/json');\n\t\t\t\tres.setHeader('Content-Disposition', 'attachment; filename=\"ui-quotes.json\"');\n\t\t\t}\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'EXPORT_UI_QUOTES', 'ui_quote', 'multiple', {\n\t\t\t\tformat,\n\t\t\t\tincludeAnalytics: data.includeAnalytics\n\t\t\t});\n\n\t\t\tres.send(result);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code,\n\t\t\t\t\tdetails: error.details\n\t\t\t\t});\n\t\t\t}\n\t\t\tres.status(500).json({ error: 'Failed to export quotes' });\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const uiConfigController = new UiConfigController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/ui-config/ui-config.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/ui-config/ui-config.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":164,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":164,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":253,"column":56,"nodeType":"Identifier","messageId":"unusedVar","endLine":253,"endColumn":70}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { eq, and, or, like, inArray, gte, lte, desc, asc, sql } from 'drizzle-orm';\nimport type { NodePgDatabase } from 'drizzle-orm/node-postgres';\nimport { db } from '../../../../core/db';\nimport {\n\tuiQuotes,\n\tuiCollections,\n\tuiCollectionQuotes,\n\tuiAnalytics,\n\ttype UiQuote,\n\ttype NewUiQuote,\n\ttype UiCollection,\n\ttype NewUiCollection\n} from '@schema/admin/uiConfig';\nimport {\n\ttype CreateQuoteRequest,\n\ttype UpdateQuoteRequest,\n\ttype QuoteFilters,\n\ttype QuotesResponse,\n\ttype ReorderQuotesRequest,\n\ttype CreateCollectionRequest,\n\ttype UpdateCollectionRequest,\n\ttype QuoteAnalyticsRequest,\n\ttype QuoteAnalyticsResponse,\n\ttype BulkQuoteOperation,\n\ttype ImportQuotesRequest,\n\ttype ExportQuotesRequest,\n\ttype PaginationOptions,\n\ttype UiConfigService as IUiConfigService\n} from './ui-config.types';\nimport { logger } from '../../../../core/logger';\n\nexport class UiConfigService implements IUiConfigService {\n\t/**\n\t * Get quotes with filtering, pagination, and sorting\n\t */\n\tasync getQuotes(\n\t\tfilters?: QuoteFilters,\n\t\tpagination: PaginationOptions = {}\n\t): Promise<QuotesResponse> {\n\t\tconst { page = 1, limit = 50, sortBy = 'displayOrder', sortOrder = 'asc' } = pagination;\n\t\tconst offset = (page - 1) * limit;\n\n\t\t// Build WHERE conditions\n\t\tconst conditions = [];\n\n\t\tif (filters?.type) {\n\t\t\tconditions.push(inArray(uiQuotes.type, filters.type));\n\t\t}\n\n\t\tif (filters?.tags && filters.tags.length > 0) {\n\t\t\t// PostgreSQL array overlap operator\n\t\t\tconditions.push(sql`${uiQuotes.tags} && ${filters.tags}`);\n\t\t}\n\n\t\tif (filters?.intensity) {\n\t\t\tconditions.push(inArray(uiQuotes.intensity, filters.intensity));\n\t\t}\n\n\t\tif (filters?.theme) {\n\t\t\tconditions.push(inArray(uiQuotes.theme, filters.theme));\n\t\t}\n\n\t\tif (filters?.targetAudience) {\n\t\t\tconditions.push(inArray(uiQuotes.targetAudience, filters.targetAudience));\n\t\t}\n\n\t\tif (filters?.isActive !== undefined) {\n\t\t\tconditions.push(eq(uiQuotes.isActive, filters.isActive));\n\t\t}\n\n\t\tif (filters?.searchTerm) {\n\t\t\tconst searchTerm = `%${filters.searchTerm}%`;\n\t\t\tconditions.push(\n\t\t\t\tor(like(uiQuotes.headline, searchTerm), like(uiQuotes.subheader, searchTerm))\n\t\t\t);\n\t\t}\n\n\t\tif (filters?.startDate) {\n\t\t\tconditions.push(gte(uiQuotes.createdAt, filters.startDate));\n\t\t}\n\n\t\tif (filters?.endDate) {\n\t\t\tconditions.push(lte(uiQuotes.createdAt, filters.endDate));\n\t\t}\n\n\t\tconst whereClause = conditions.length > 0 ? and(...conditions) : undefined;\n\n\t\t// Get total count\n\t\tconst [{ count }] = await db\n\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t.from(uiQuotes)\n\t\t\t.where(whereClause);\n\n\t\t// Get quotes with proper sorting\n\t\tlet orderByClause;\n\t\tswitch (sortBy) {\n\t\t\tcase 'displayOrder':\n\t\t\t\torderByClause =\n\t\t\t\t\tsortOrder === 'desc' ? desc(uiQuotes.displayOrder) : asc(uiQuotes.displayOrder);\n\t\t\t\tbreak;\n\t\t\tcase 'createdAt':\n\t\t\t\torderByClause = sortOrder === 'desc' ? desc(uiQuotes.createdAt) : asc(uiQuotes.createdAt);\n\t\t\t\tbreak;\n\t\t\tcase 'updatedAt':\n\t\t\t\torderByClause = sortOrder === 'desc' ? desc(uiQuotes.updatedAt) : asc(uiQuotes.updatedAt);\n\t\t\t\tbreak;\n\t\t\tcase 'headline':\n\t\t\t\torderByClause = sortOrder === 'desc' ? desc(uiQuotes.headline) : asc(uiQuotes.headline);\n\t\t\t\tbreak;\n\t\t\tcase 'type':\n\t\t\t\torderByClause = sortOrder === 'desc' ? desc(uiQuotes.type) : asc(uiQuotes.type);\n\t\t\t\tbreak;\n\t\t\tcase 'intensity':\n\t\t\t\torderByClause = sortOrder === 'desc' ? desc(uiQuotes.intensity) : asc(uiQuotes.intensity);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\torderByClause = asc(uiQuotes.displayOrder);\n\t\t}\n\n\t\tconst quotes = await db\n\t\t\t.select()\n\t\t\t.from(uiQuotes)\n\t\t\t.where(whereClause)\n\t\t\t.orderBy(orderByClause)\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\n\t\treturn {\n\t\t\tquotes,\n\t\t\ttotal: count,\n\t\t\tpage,\n\t\t\tlimit,\n\t\t\tfilters: filters || {}\n\t\t};\n\t}\n\n\t/**\n\t * Get a single quote by ID\n\t */\n\tasync getQuoteById(id: string): Promise<UiQuote | null> {\n\t\tconst [quote] = await db.select().from(uiQuotes).where(eq(uiQuotes.id, id)).limit(1);\n\n\t\treturn quote || null;\n\t}\n\n\t/**\n\t * Create a new quote\n\t */\n\tasync createQuote(data: CreateQuoteRequest, userId: string): Promise<UiQuote> {\n\t\tconst newQuote: NewUiQuote = {\n\t\t\t...data,\n\t\t\tcreatedBy: userId,\n\t\t\tupdatedAt: new Date()\n\t\t};\n\n\t\tconst [quote] = await db.insert(uiQuotes).values(newQuote).returning();\n\n\t\treturn quote;\n\t}\n\n\t/**\n\t * Update an existing quote\n\t */\n\tasync updateQuote(data: UpdateQuoteRequest, userId: string): Promise<UiQuote> {\n\t\tconst { id, ...updateData } = data;\n\n\t\tconst [quote] = await db\n\t\t\t.update(uiQuotes)\n\t\t\t.set({\n\t\t\t\t...updateData,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(uiQuotes.id, id))\n\t\t\t.returning();\n\n\t\tif (!quote) {\n\t\t\tthrow new Error('Quote not found');\n\t\t}\n\n\t\treturn quote;\n\t}\n\n\t/**\n\t * Delete a quote\n\t */\n\tasync deleteQuote(id: string): Promise<boolean> {\n\t\tconst result = await db.delete(uiQuotes).where(eq(uiQuotes.id, id));\n\n\t\treturn result.rowCount > 0;\n\t}\n\n\t/**\n\t * Reorder multiple quotes\n\t */\n\tasync reorderQuotes(data: ReorderQuotesRequest): Promise<boolean> {\n\t\ttry {\n\t\t\tawait db.transaction(async (tx: any) => {\n\t\t\t\tfor (const { id, displayOrder } of data.quoteOrders) {\n\t\t\t\t\tawait tx\n\t\t\t\t\t\t.update(uiQuotes)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tdisplayOrder,\n\t\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(eq(uiQuotes.id, id));\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error reordering quotes:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Get all collections\n\t */\n\tasync getCollections(): Promise<UiCollection[]> {\n\t\treturn await db\n\t\t\t.select()\n\t\t\t.from(uiCollections)\n\t\t\t.orderBy(desc(uiCollections.priority), asc(uiCollections.name));\n\t}\n\n\t/**\n\t * Create a new collection\n\t */\n\tasync createCollection(data: CreateCollectionRequest, userId: string): Promise<UiCollection> {\n\t\tconst newCollection: NewUiCollection = {\n\t\t\t...data,\n\t\t\tcreatedBy: userId\n\t\t};\n\n\t\tconst [collection] = await db.insert(uiCollections).values(newCollection).returning();\n\n\t\t// If quoteIds provided, link them to the collection\n\t\tif (data.quoteIds && data.quoteIds.length > 0) {\n\t\t\tconst collectionQuotes = data.quoteIds.map((quoteId, index) => ({\n\t\t\t\tcollectionId: collection.id,\n\t\t\t\tquoteId,\n\t\t\t\torderInCollection: index\n\t\t\t}));\n\n\t\t\tawait db.insert(uiCollectionQuotes).values(collectionQuotes);\n\t\t}\n\n\t\treturn collection;\n\t}\n\n\t/**\n\t * Update a collection\n\t */\n\tasync updateCollection(data: UpdateCollectionRequest, userId: string): Promise<UiCollection> {\n\t\tconst { id, quoteIds, ...updateData } = data;\n\n\t\tconst [collection] = await db\n\t\t\t.update(uiCollections)\n\t\t\t.set({\n\t\t\t\t...updateData,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(uiCollections.id, id))\n\t\t\t.returning();\n\n\t\tif (!collection) {\n\t\t\tthrow new Error('Collection not found');\n\t\t}\n\n\t\t// Update quote associations if provided\n\t\tif (quoteIds) {\n\t\t\tawait db.transaction(async (tx: any) => {\n\t\t\t\t// Remove existing associations\n\t\t\t\tawait tx.delete(uiCollectionQuotes).where(eq(uiCollectionQuotes.collectionId, id));\n\n\t\t\t\t// Add new associations\n\t\t\t\tif (quoteIds.length > 0) {\n\t\t\t\t\tconst collectionQuotes = quoteIds.map((quoteId, index) => ({\n\t\t\t\t\t\tcollectionId: id,\n\t\t\t\t\t\tquoteId,\n\t\t\t\t\t\torderInCollection: index\n\t\t\t\t\t}));\n\n\t\t\t\t\tawait tx.insert(uiCollectionQuotes).values(collectionQuotes);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn collection;\n\t}\n\n\t/**\n\t * Delete a collection\n\t */\n\tasync deleteCollection(id: string): Promise<boolean> {\n\t\tconst result = await db.delete(uiCollections).where(eq(uiCollections.id, id));\n\n\t\treturn result.rowCount > 0;\n\t}\n\n\t/**\n\t * Track a quote event for analytics\n\t */\n\tasync trackQuoteEvent(\n\t\tquoteId: string,\n\t\teventType: string,\n\t\tcontext: Record<string, any>\n\t): Promise<void> {\n\t\tawait db.insert(uiAnalytics).values({\n\t\t\tquoteId,\n\t\t\teventType,\n\t\t\tuserId: context.userId || null,\n\t\t\tsessionId: context.sessionId || null,\n\t\t\tpage: context.page || null,\n\t\t\tposition: context.position || null,\n\t\t\tuserAgent: context.userAgent || null,\n\t\t\tmetadata: context.metadata || {}\n\t\t});\n\n\t\t// Update quote impression/click counters\n\t\tif (eventType === 'impression') {\n\t\t\tawait db\n\t\t\t\t.update(uiQuotes)\n\t\t\t\t.set({\n\t\t\t\t\timpressions: sql`${uiQuotes.impressions} + 1`\n\t\t\t\t})\n\t\t\t\t.where(eq(uiQuotes.id, quoteId));\n\t\t} else if (eventType === 'click') {\n\t\t\tawait db\n\t\t\t\t.update(uiQuotes)\n\t\t\t\t.set({\n\t\t\t\t\tclicks: sql`${uiQuotes.clicks} + 1`\n\t\t\t\t})\n\t\t\t\t.where(eq(uiQuotes.id, quoteId));\n\t\t}\n\t}\n\n\t/**\n\t * Get analytics for quotes\n\t */\n\tasync getQuoteAnalytics(request: QuoteAnalyticsRequest): Promise<QuoteAnalyticsResponse> {\n\t\tconst { quoteId, eventType, startDate, endDate, page, position } = request;\n\n\t\tif (!quoteId) {\n\t\t\tthrow new Error('Quote ID is required for analytics');\n\t\t}\n\n\t\t// Build conditions\n\t\tconst conditions = [eq(uiAnalytics.quoteId, quoteId)];\n\n\t\tif (eventType) {\n\t\t\tconditions.push(eq(uiAnalytics.eventType, eventType));\n\t\t}\n\n\t\tif (startDate) {\n\t\t\tconditions.push(gte(uiAnalytics.timestamp, startDate));\n\t\t}\n\n\t\tif (endDate) {\n\t\t\tconditions.push(lte(uiAnalytics.timestamp, endDate));\n\t\t}\n\n\t\tif (page) {\n\t\t\tconditions.push(eq(uiAnalytics.page, page));\n\t\t}\n\n\t\tif (position) {\n\t\t\tconditions.push(eq(uiAnalytics.position, position));\n\t\t}\n\n\t\t// Get quote data\n\t\tconst quote = await this.getQuoteById(quoteId);\n\t\tif (!quote) {\n\t\t\tthrow new Error('Quote not found');\n\t\t}\n\n\t\t// Calculate click-through rate\n\t\tconst impressions = quote.impressions || 0;\n\t\tconst clicks = quote.clicks || 0;\n\t\tconst clickThroughRate = impressions > 0 ? (clicks / impressions) * 100 : 0;\n\n\t\t// Get top pages and positions\n\t\tconst [topPages, topPositions] = await Promise.all([\n\t\t\tdb\n\t\t\t\t.select({\n\t\t\t\t\tpage: uiAnalytics.page,\n\t\t\t\t\tcount: sql<number>`count(*)`\n\t\t\t\t})\n\t\t\t\t.from(uiAnalytics)\n\t\t\t\t.where(and(...conditions))\n\t\t\t\t.groupBy(uiAnalytics.page)\n\t\t\t\t.orderBy(desc(sql`count(*)`))\n\t\t\t\t.limit(10),\n\n\t\t\tdb\n\t\t\t\t.select({\n\t\t\t\t\tposition: uiAnalytics.position,\n\t\t\t\t\tcount: sql<number>`count(*)`\n\t\t\t\t})\n\t\t\t\t.from(uiAnalytics)\n\t\t\t\t.where(and(...conditions))\n\t\t\t\t.groupBy(uiAnalytics.position)\n\t\t\t\t.orderBy(desc(sql`count(*)`))\n\t\t\t\t.limit(10)\n\t\t]);\n\n\t\treturn {\n\t\t\tquoteId,\n\t\t\ttotalImpressions: impressions,\n\t\t\ttotalClicks: clicks,\n\t\t\tclickThroughRate: Math.round(clickThroughRate * 100) / 100,\n\t\t\ttopPages: topPages.map((p: any) => ({ page: p.page || 'unknown', count: p.count })),\n\t\t\ttopPositions: topPositions.map((p: any) => ({\n\t\t\t\tposition: p.position || 'unknown',\n\t\t\t\tcount: p.count\n\t\t\t})),\n\t\t\tdateRange: {\n\t\t\t\tstart: startDate || new Date(0),\n\t\t\t\tend: endDate || new Date()\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Bulk update quotes\n\t */\n\tasync bulkUpdateQuotes(operation: BulkQuoteOperation): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { action, quoteIds, data } = operation;\n\n\t\t\tswitch (action) {\n\t\t\t\tcase 'activate':\n\t\t\t\t\tawait db\n\t\t\t\t\t\t.update(uiQuotes)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tisActive: true,\n\t\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(inArray(uiQuotes.id, quoteIds));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'deactivate':\n\t\t\t\t\tawait db\n\t\t\t\t\t\t.update(uiQuotes)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tisActive: false,\n\t\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(inArray(uiQuotes.id, quoteIds));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'delete':\n\t\t\t\t\tawait db.delete(uiQuotes).where(inArray(uiQuotes.id, quoteIds));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'update_tags':\n\t\t\t\tcase 'update_intensity':\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tawait db\n\t\t\t\t\t\t\t.update(uiQuotes)\n\t\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\t\t...data,\n\t\t\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.where(inArray(uiQuotes.id, quoteIds));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unknown bulk action: ${action}`);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error in bulk operation:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Import quotes from external source\n\t */\n\tasync importQuotes(\n\t\tdata: ImportQuotesRequest,\n\t\tuserId: string\n\t): Promise<{ imported: number; skipped: number }> {\n\t\tlet imported = 0;\n\t\tlet skipped = 0;\n\n\t\tawait db.transaction(async (tx: any) => {\n\t\t\tfor (const quoteData of data.quotes) {\n\t\t\t\ttry {\n\t\t\t\t\t// Check for duplicates if not overwriting\n\t\t\t\t\tif (!data.overwriteExisting) {\n\t\t\t\t\t\tconst [existing] = await tx\n\t\t\t\t\t\t\t.select()\n\t\t\t\t\t\t\t.from(uiQuotes)\n\t\t\t\t\t\t\t.where(\n\t\t\t\t\t\t\t\tand(eq(uiQuotes.headline, quoteData.headline), eq(uiQuotes.type, quoteData.type))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.limit(1);\n\n\t\t\t\t\t\tif (existing) {\n\t\t\t\t\t\t\tskipped++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tawait tx.insert(uiQuotes).values({\n\t\t\t\t\t\t...quoteData,\n\t\t\t\t\t\tcreatedBy: userId\n\t\t\t\t\t});\n\n\t\t\t\t\timported++;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.error('Error importing quote:', error);\n\t\t\t\t\tskipped++;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn { imported, skipped };\n\t}\n\n\t/**\n\t * Export quotes to various formats\n\t */\n\tasync exportQuotes(request: ExportQuotesRequest): Promise<Buffer | string> {\n\t\tconst { filters, format = 'json', includeAnalytics = false } = request;\n\n\t\tconst { quotes } = await this.getQuotes(filters, { limit: 10000 });\n\n\t\tif (format === 'json') {\n\t\t\tconst exportData = includeAnalytics\n\t\t\t\t? await Promise.all(\n\t\t\t\t\t\tquotes.map(async (quote) => {\n\t\t\t\t\t\t\tconst analytics = await this.getQuoteAnalytics({ quoteId: quote.id });\n\t\t\t\t\t\t\treturn { ...quote, analytics };\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t: quotes;\n\n\t\t\treturn JSON.stringify(exportData, null, 2);\n\t\t}\n\n\t\tif (format === 'csv') {\n\t\t\t// Simple CSV implementation\n\t\t\tconst headers = [\n\t\t\t\t'id',\n\t\t\t\t'type',\n\t\t\t\t'headline',\n\t\t\t\t'subheader',\n\t\t\t\t'tags',\n\t\t\t\t'intensity',\n\t\t\t\t'theme',\n\t\t\t\t'isActive',\n\t\t\t\t'impressions',\n\t\t\t\t'clicks',\n\t\t\t\t'createdAt'\n\t\t\t];\n\n\t\t\tconst rows = quotes.map((quote) => [\n\t\t\t\tquote.id,\n\t\t\t\tquote.type,\n\t\t\t\t`\"${quote.headline}\"`,\n\t\t\t\t`\"${quote.subheader || ''}\"`,\n\t\t\t\t`\"${quote.tags?.join(';') || ''}\"`,\n\t\t\t\tquote.intensity,\n\t\t\t\tquote.theme || '',\n\t\t\t\tquote.isActive,\n\t\t\t\tquote.impressions,\n\t\t\t\tquote.clicks,\n\t\t\t\tquote.createdAt?.toISOString()\n\t\t\t]);\n\n\t\t\tconst csv = [headers, ...rows].map((row) => row.join(',')).join('\\n');\n\n\t\t\treturn Buffer.from(csv, 'utf8');\n\t\t}\n\n\t\tthrow new Error(`Unsupported export format: ${format}`);\n\t}\n}\n\n// Export singleton instance\nexport const uiConfigService = new UiConfigService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/ui-config/ui-config.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/ui-config/ui-config.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/ui-config/uiThemes.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/user-groups/user-groups.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin User Groups Controller\n *\n * Handles API requests for user group management.\n */\n\nimport type { Request, Response } from 'express';\nimport type { GroupId } from '@shared/types/ids';\nimport { adminUserGroupsService } from './user-groups.service';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { getUserId } from '../../admin.middleware';\nimport { adminController } from '../../admin.controller';\nimport { UserGroupSchema, ListGroupUsersQuerySchema } from './user-groups.validators';\nimport { validateRequestBody, validateQueryParams } from '../../admin.validation';\n\nexport class AdminUserGroupsController {\n\tasync getAllGroups(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst groups = await adminUserGroupsService.getAllGroupsWithCounts();\n\t\t\tres.json(groups);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to fetch user groups' });\n\t\t}\n\t}\n\n\tasync getGroupById(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst groupId = req.params.id as GroupId;\n\t\t\tif (isNaN(groupId))\n\t\t\t\tthrow new AdminError('Invalid group ID', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\tconst group = await adminUserGroupsService.getGroupById(groupId);\n\t\t\tres.json(group);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to fetch user group' });\n\t\t}\n\t}\n\n\tasync createGroup(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst data = validateRequestBody(req, res, UserGroupSchema);\n\t\t\tif (!data) return;\n\t\t\tconst newGroup = await adminUserGroupsService.createGroup(data);\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t'CREATE_USER_GROUP',\n\t\t\t\t'user_group',\n\t\t\t\tnewGroup.id.toString(),\n\t\t\t\tdata\n\t\t\t);\n\t\t\tres.status(201).json(newGroup);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to create user group' });\n\t\t}\n\t}\n\n\tasync updateGroup(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst groupId = req.params.id as GroupId;\n\t\t\tif (isNaN(groupId))\n\t\t\t\tthrow new AdminError('Invalid group ID', 400, AdminErrorCodes.INVALID_REQUEST);\n\n\t\t\tconst data = validateRequestBody(req, res, UserGroupSchema);\n\t\t\tif (!data) return;\n\t\t\tconst updatedGroup = await adminUserGroupsService.updateGroup(groupId, data);\n\t\t\tawait adminController.logAction(\n\t\t\t\treq,\n\t\t\t\t'UPDATE_USER_GROUP',\n\t\t\t\t'user_group',\n\t\t\t\tgroupId.toString(),\n\t\t\t\tdata\n\t\t\t);\n\t\t\tres.json(updatedGroup);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to update user group' });\n\t\t}\n\t}\n\n\tasync deleteGroup(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst groupId = req.params.id as GroupId;\n\t\t\tif (isNaN(groupId))\n\t\t\t\tthrow new AdminError('Invalid group ID', 400, AdminErrorCodes.INVALID_REQUEST);\n\n\t\t\tconst result = await adminUserGroupsService.deleteGroup(groupId);\n\t\t\tawait adminController.logAction(req, 'DELETE_USER_GROUP', 'user_group', groupId.toString(), {\n\t\t\t\treassignedUsers: result.reassignedUsers\n\t\t\t});\n\t\t\tres.json(result);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to delete user group' });\n\t\t}\n\t}\n\n\tasync getUsersInGroup(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst groupId = req.params.id as GroupId;\n\t\t\tif (isNaN(groupId))\n\t\t\t\tthrow new AdminError('Invalid group ID', 400, AdminErrorCodes.INVALID_REQUEST);\n\n\t\t\tconst query = validateQueryParams(req, res, ListGroupUsersQuerySchema);\n\t\t\tif (!query) return;\n\n\t\t\tconst result = await adminUserGroupsService.getUsersInGroup(groupId, query);\n\t\t\tres.json(result);\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError)\n\t\t\t\treturn res\n\t\t\t\t\t.status(error.httpStatus)\n\t\t\t\t\t.json({ error: error.message, code: error.code, details: error.details });\n\t\t\tres.status(500).json({ error: 'Failed to fetch users in group' });\n\t\t}\n\t}\n}\n\nexport const adminUserGroupsController = new AdminUserGroupsController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/user-groups/user-groups.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/user-groups/user-groups.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/user-groups/user-groups.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/users/bulk-operations.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/users/bulk-operations.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/users/inventory.admin.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/users/inventory.admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/users/users.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { adminUsersService } from './users.service';\nimport { AdminError } from '../../admin.errors';\nimport { adminController } from '../../admin.controller';\nimport { getUserId } from '../../admin.middleware';\nimport { AdminPaginationQuery, AdminUserUpdateSchema } from '@shared/validators/admin';\nimport { validateQueryParams, validateRequestBody } from '../../admin.validation';\nimport { z } from 'zod';\nimport { db } from '@db';\nimport { users } from '@schema';\nimport { ilike } from 'drizzle-orm';\nimport type { UserId, AdminId } from '@shared/types/ids';\nimport { toId, isValidId } from '@shared/utils/id';\nimport { logger } from '../../../../core/logger';\n\nexport class AdminUsersController {\n\t/**\n\t * Get paginated users with filtering\n\t */\n\tasync getUsers(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst query = validateQueryParams(req, res, AdminPaginationQuery);\n\t\t\tif (!query) return;\n\t\t\tconst users = await adminUsersService.getUsers(query);\n\t\t\treturn res.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: users\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch users'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get a user by ID\n\t */\n\tasync getUserById(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst userIdParam = req.params.id;\n\t\t\tif (!isValidId(userIdParam)) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid user ID format'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst userId = toId<'User'>(userIdParam);\n\t\t\tconst userData = await adminUsersService.getUserById(userId);\n\t\t\treturn res.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: userData\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch user'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update a user\n\t */\n\tasync updateUser(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst userIdParam = req.params.id;\n\t\t\tif (!isValidId(userIdParam)) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid user ID format'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst userId = toId<'User'>(userIdParam);\n\t\t\tconst data = validateRequestBody(req, res, AdminUserUpdateSchema);\n\t\t\tif (!data) return;\n\t\t\tconst updatedUser = await adminUsersService.updateUser(userId, data);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'UPDATE_USER', 'user', userId, {\n\t\t\t\tchanges: data\n\t\t\t});\n\n\t\t\treturn res.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: updatedUser,\n\t\t\t\tmessage: 'User updated successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to update user'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create a new user\n\t */\n\tasync createUser(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst createSchema = AdminUserUpdateSchema.extend({\n\t\t\t\tpassword: z.string().min(6).optional(),\n\t\t\t\tusername: z.string().min(3).max(50),\n\t\t\t\temail: z.string().email()\n\t\t\t});\n\t\t\tconst dataCreate = validateRequestBody(req, res, createSchema);\n\t\t\tif (!dataCreate) return;\n\t\t\tconst newUser = await adminUsersService.createUser(dataCreate);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'CREATE_USER', 'user', newUser.id, {\n\t\t\t\tuserData: dataCreate\n\t\t\t});\n\n\t\t\treturn res.status(201).json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: newUser,\n\t\t\t\tmessage: 'User created successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to create user'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Delete a user\n\t */\n\tasync deleteUser(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst userIdParam = req.params.id;\n\t\t\tif (!isValidId(userIdParam)) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid user ID format'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst userId = toId<'User'>(userIdParam);\n\t\t\tawait adminUsersService.deleteUser(userId);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'DELETE_USER', 'user', userId, {});\n\n\t\t\treturn res.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'User deleted successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to delete user'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Ban a user\n\t */\n\tasync banUser(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst userIdParam = req.params.id;\n\t\t\tif (!isValidId(userIdParam)) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid user ID format'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst userId = toId<'User'>(userIdParam);\n\t\t\tconst { reason } = req.body;\n\t\t\tawait adminUsersService.banUser(userId, reason);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'BAN_USER', 'user', userId, {\n\t\t\t\treason\n\t\t\t});\n\n\t\t\treturn res.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'User banned successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to ban user'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Unban a user\n\t */\n\tasync unbanUser(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst userIdParam = req.params.id;\n\t\t\tif (!isValidId(userIdParam)) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid user ID format'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst userId = toId<'User'>(userIdParam);\n\t\t\tawait adminUsersService.unbanUser(userId);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'UNBAN_USER', 'user', userId, {});\n\n\t\t\treturn res.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'User unbanned successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to unban user'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Change user role\n\t */\n\tasync changeUserRole(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst userIdParam = req.params.id;\n\t\t\tif (!isValidId(userIdParam)) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid user ID format'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst userId = toId<'User'>(userIdParam);\n\t\t\tconst { role } = req.body;\n\t\t\tif (!role || !['user', 'mod', 'admin'].includes(role)) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid role. Must be one of: user, mod, admin'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst updatedUser = await adminUsersService.changeUserRole(userId, role);\n\n\t\t\t// Log admin action\n\t\t\tawait adminController.logAction(req, 'CHANGE_USER_ROLE', 'user', userId, {\n\t\t\t\tnewRole: role\n\t\t\t});\n\n\t\t\treturn res.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: updatedUser,\n\t\t\t\tmessage: 'User role updated successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\treturn res.status(error.httpStatus).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to change user role'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Search users for admin tools (XP/Clout adjustments)\n\t */\n\tasync searchUsers(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst term = req.query.term as string;\n\t\t\tif (!term || term.length < 3) {\n\t\t\t\treturn res.status(200).json({\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: { users: [] }\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Search users by username or ID and include clout data\n\t\t\tconst results = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\t\tclout: users.clout,\n\t\t\t\t\txp: users.xp,\n\t\t\t\t\tlevel: users.level\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(ilike(users.username, `%${term}%`))\n\t\t\t\t.limit(20);\n\n\t\t\t// Transform results to include tier information for frontend\n\t\t\tconst transformedResults = results.map((user) => {\n\t\t\t\t// Import clout calculator functions\n\t\t\t\tconst clout = user.clout || 0;\n\n\t\t\t\t// Basic tier calculation (we'll import the proper calculator later)\n\t\t\t\tlet tier = { tier: 0, name: 'Unknown', color: '#6b7280' };\n\t\t\t\tif (clout >= 50000) tier = { tier: 6, name: 'Mythic', color: '#ef4444' };\n\t\t\t\telse if (clout >= 15000) tier = { tier: 5, name: 'Legendary', color: '#f59e0b' };\n\t\t\t\telse if (clout >= 5000) tier = { tier: 4, name: 'Influential', color: '#8b5cf6' };\n\t\t\t\telse if (clout >= 1500) tier = { tier: 3, name: 'Respected', color: '#3b82f6' };\n\t\t\t\telse if (clout >= 500) tier = { tier: 2, name: 'Regular', color: '#22c55e' };\n\t\t\t\telse if (clout >= 100) tier = { tier: 1, name: 'Newcomer', color: '#84cc16' };\n\n\t\t\t\t// Calculate progress to next tier\n\t\t\t\tconst nextTierThresholds = [0, 100, 500, 1500, 5000, 15000, 50000, Infinity];\n\t\t\t\tconst currentTierIndex = tier.tier;\n\t\t\t\tconst nextTierClout = nextTierThresholds[currentTierIndex + 1] || Infinity;\n\t\t\t\tconst currentTierClout = nextTierThresholds[currentTierIndex];\n\n\t\t\t\tlet progressPercent = 0;\n\t\t\t\tif (nextTierClout !== Infinity) {\n\t\t\t\t\tconst progressInTier = clout - currentTierClout;\n\t\t\t\t\tconst tierRange = nextTierClout - currentTierClout;\n\t\t\t\t\tprogressPercent = tierRange > 0 ? (progressInTier / tierRange) * 100 : 0;\n\t\t\t\t} else {\n\t\t\t\t\tprogressPercent = 100; // Max tier\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tid: user.id,\n\t\t\t\t\tusername: user.username,\n\t\t\t\t\tavatarUrl: user.avatarUrl,\n\t\t\t\t\tclout: clout,\n\t\t\t\t\ttier: tier,\n\t\t\t\t\tnextTierClout: nextTierClout === Infinity ? null : nextTierClout,\n\t\t\t\t\tprogressPercent: Math.min(100, Math.max(0, progressPercent)),\n\t\t\t\t\t// Include XP/level data for XP adjustments too\n\t\t\t\t\txp: user.xp || 0,\n\t\t\t\t\tlevel: user.level || 1\n\t\t\t\t};\n\t\t\t});\n\n\t\t\treturn res.status(200).json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: { users: transformedResults }\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('Error searching users:', error);\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to search users'\n\t\t\t});\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const adminUsersController = new AdminUsersController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/users/users.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/users/users.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'like' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'or' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'roles' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin Users Service\n *\n * Handles user management operations for the admin panel\n */\n\nimport { db } from '@db';\nimport { count, desc, eq, sql, and, like, isNull, or, ne } from 'drizzle-orm';\nimport { users, roles, posts, threads, userBans, userGroups } from '@schema';\nimport { AdminError, AdminErrorCodes } from '../../admin.errors';\nimport { AdminPaginationQuery } from '@shared/validators/admin';\nimport { z } from 'zod';\nimport bcrypt from 'bcrypt';\nimport type { UserId } from '@shared/types/ids';\nimport { logger } from '../../../../core/logger';\n\nexport class AdminUsersService {\n\t/**\n\t * Get paginated users with filtering\n\t */\n\tasync getUsers(params: z.infer<typeof AdminPaginationQuery>) {\n\t\ttry {\n\t\t\tconst { page, pageSize, search } = params;\n\t\t\tconst offset = (page - 1) * pageSize;\n\n\t\t\t// Build user query with optional search\n\t\t\tlet userQuery = db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\temail: users.email,\n\t\t\t\t\trole: users.role,\n\t\t\t\t\tisActive: users.isActive,\n\t\t\t\t\tisBanned: users.isBanned,\n\t\t\t\t\tisVerified: users.isVerified,\n\t\t\t\t\tcreatedAt: users.createdAt,\n\t\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\t\tgroupId: users.groupId,\n\t\t\t\t\tgroupName: userGroups.name\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.leftJoin(userGroups, eq(users.groupId, userGroups.id));\n\n\t\t\tif (search) {\n\t\t\t\t// Use full-text search for better performance\n\t\t\t\tconst searchCondition = sql`to_tsvector('english', ${users.username} || ' ' || ${users.email}) @@ plainto_tsquery('english', ${search})`;\n\t\t\t\tuserQuery = userQuery.where(searchCondition);\n\t\t\t}\n\n\t\t\t// Get total count for pagination with same search logic\n\t\t\tconst [countResult] = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(users)\n\t\t\t\t.where(\n\t\t\t\t\tsearch\n\t\t\t\t\t\t? sql`to_tsvector('english', ${users.username} || ' ' || ${users.email}) @@ plainto_tsquery('english', ${search})`\n\t\t\t\t\t\t: undefined\n\t\t\t\t)\n\t\t\t\t.execute();\n\n\t\t\tconst total = Number(countResult?.count) || 0;\n\n\t\t\t// Fetch paginated users\n\t\t\tconst usersList = await userQuery\n\t\t\t\t.orderBy(desc(users.createdAt))\n\t\t\t\t.limit(pageSize)\n\t\t\t\t.offset(offset);\n\n\t\t\t// Get post and thread counts for users in a single optimized query\n\t\t\tconst userIds = usersList.map((user) => user.id);\n\n\t\t\tif (userIds.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tdata: [],\n\t\t\t\t\ttotal,\n\t\t\t\t\tpage,\n\t\t\t\t\tpageSize\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Optimized single query to get both post and thread counts\n\t\t\tconst userStats = await db\n\t\t\t\t.select({\n\t\t\t\t\tuserId: sql`COALESCE(${posts.userId}, ${threads.userId})`.as('userId'),\n\t\t\t\t\tpostCount: sql`COUNT(DISTINCT ${posts.id})`.as('postCount'),\n\t\t\t\t\tthreadCount: sql`COUNT(DISTINCT ${threads.id})`.as('threadCount')\n\t\t\t\t})\n\t\t\t\t.from(posts)\n\t\t\t\t.fullJoin(threads, eq(posts.userId, threads.userId))\n\t\t\t\t.where(sql`COALESCE(${posts.userId}, ${threads.userId}) = ANY(${userIds})`)\n\t\t\t\t.groupBy(sql`COALESCE(${posts.userId}, ${threads.userId})`);\n\n\t\t\t// Create stats map for quick access\n\t\t\tconst statsMap = new Map();\n\t\t\tuserStats.forEach((stat) => {\n\t\t\t\tstatsMap.set(stat.userId, {\n\t\t\t\t\tposts: Number(stat.postCount) || 0,\n\t\t\t\t\tthreads: Number(stat.threadCount) || 0\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Format users with additional data\n\t\t\tconst formattedUsers = usersList.map((user) => ({\n\t\t\t\t...user,\n\t\t\t\tstats: statsMap.get(user.id) || { posts: 0, threads: 0 },\n\t\t\t\tcreatedAtFormatted: new Date(user.createdAt).toLocaleDateString()\n\t\t\t}));\n\n\t\t\treturn {\n\t\t\t\tdata: formattedUsers,\n\t\t\t\ttotal,\n\t\t\t\tpage,\n\t\t\t\tpageSize\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching users:', error);\n\t\t\tthrow new AdminError('Failed to fetch users', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get detailed user information by ID\n\t */\n\tasync getUserById(userId: UserId) {\n\t\ttry {\n\t\t\tif (!userId) {\n\t\t\t\tthrow new AdminError('Invalid user ID', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\n\t\t\tif (!user) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`User with ID ${userId} not found`,\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.USER_NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Get user group if available\n\t\t\tlet userGroup = null;\n\t\t\tif (user.groupId) {\n\t\t\t\tconst [group] = await db.select().from(userGroups).where(eq(userGroups.id, user.groupId));\n\t\t\t\tuserGroup = group;\n\t\t\t}\n\n\t\t\t// Get all available groups for dropdown\n\t\t\tconst allGroups = await db.select().from(userGroups);\n\n\t\t\t// Get user activity stats\n\t\t\tconst [postStats] = await db\n\t\t\t\t.select({\n\t\t\t\t\tpostCount: sql`COUNT(*)`,\n\t\t\t\t\tlastPostDate: sql`MAX(${posts.createdAt})`\n\t\t\t\t})\n\t\t\t\t.from(posts)\n\t\t\t\t.where(eq(posts.userId, userId));\n\n\t\t\tconst [threadStats] = await db\n\t\t\t\t.select({\n\t\t\t\t\tthreadCount: sql`COUNT(*)`\n\t\t\t\t})\n\t\t\t\t.from(threads)\n\t\t\t\t.where(eq(threads.userId, userId));\n\n\t\t\treturn {\n\t\t\t\tuser,\n\t\t\t\tgroup: userGroup,\n\t\t\t\tallGroups,\n\t\t\t\tstats: {\n\t\t\t\t\tposts: Number(postStats?.postCount) || 0,\n\t\t\t\t\tthreads: Number(threadStats?.threadCount) || 0,\n\t\t\t\t\tlastActivity: postStats?.lastPostDate\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tlogger.error('Error fetching user details:', error);\n\t\t\tthrow new AdminError('Failed to fetch user details', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update a user\n\t */\n\tasync updateUser(userId: UserId, userData: Partial<typeof users.$inferInsert>) {\n\t\ttry {\n\t\t\t// Make sure the user exists\n\t\t\tconst [existingUser] = await db.select().from(users).where(eq(users.id, userId));\n\t\t\tif (!existingUser) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`User with ID ${userId} not found`,\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.USER_NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Validate username uniqueness if being changed\n\t\t\tif (userData.username && userData.username !== existingUser.username) {\n\t\t\t\tconst [usernameExists] = await db\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(and(eq(users.username, userData.username), ne(users.id, userId)));\n\n\t\t\t\tif (usernameExists) {\n\t\t\t\t\tthrow new AdminError('Username already taken', 400, AdminErrorCodes.DUPLICATE_ENTRY);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Validate email uniqueness if being changed\n\t\t\tif (userData.email && userData.email !== existingUser.email) {\n\t\t\t\tconst [emailExists] = await db\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(and(eq(users.email, userData.email), ne(users.id, userId)));\n\n\t\t\t\tif (emailExists) {\n\t\t\t\t\tthrow new AdminError('Email already in use', 400, AdminErrorCodes.DUPLICATE_ENTRY);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update the user\n\t\t\tconst [updatedUser] = await db\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\t...userData,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.returning();\n\n\t\t\treturn updatedUser;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tlogger.error('Error updating user:', error);\n\t\t\tthrow new AdminError('Failed to update user', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create a new user\n\t */\n\tasync createUser(userData: {\n\t\tusername: string;\n\t\temail: string;\n\t\tpassword?: string;\n\t\trole?: string;\n\t}) {\n\t\ttry {\n\t\t\t// Validate username uniqueness\n\t\t\tconst [usernameExists] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.username, userData.username));\n\n\t\t\tif (usernameExists) {\n\t\t\t\tthrow new AdminError('Username already taken', 400, AdminErrorCodes.DUPLICATE_ENTRY);\n\t\t\t}\n\n\t\t\t// Validate email uniqueness\n\t\t\tconst [emailExists] = await db.select().from(users).where(eq(users.email, userData.email));\n\n\t\t\tif (emailExists) {\n\t\t\t\tthrow new AdminError('Email already in use', 400, AdminErrorCodes.DUPLICATE_ENTRY);\n\t\t\t}\n\n\t\t\t// Hash password if provided, otherwise use a random one\n\t\t\tconst password = userData.password || Math.random().toString(36).slice(-8);\n\t\t\tconst hashedPassword = await bcrypt.hash(password, 10);\n\n\t\t\t// Create the user\n\t\t\tconst [newUser] = await db\n\t\t\t\t.insert(users)\n\t\t\t\t.values({\n\t\t\t\t\tusername: userData.username,\n\t\t\t\t\temail: userData.email,\n\t\t\t\t\tpasswordHash: hashedPassword,\n\t\t\t\t\trole: userData.role || 'user',\n\t\t\t\t\tisActive: true,\n\t\t\t\t\tisVerified: true,\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\treturn newUser;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tlogger.error('Error creating user:', error);\n\t\t\tthrow new AdminError('Failed to create user', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Delete a user\n\t */\n\tasync deleteUser(userId: UserId) {\n\t\ttry {\n\t\t\t// Check if user exists\n\t\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\t\t\tif (!user) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`User with ID ${userId} not found`,\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.USER_NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Note: In a real application, you might want to soft delete or move data\n\t\t\t// For now, we'll actually delete the user and their related data\n\n\t\t\t// Delete user's posts and threads (cascade should handle this, but being explicit)\n\t\t\tawait db.delete(posts).where(eq(posts.userId, userId));\n\t\t\tawait db.delete(threads).where(eq(threads.userId, userId));\n\n\t\t\t// Delete any ban records\n\t\t\tawait db.delete(userBans).where(eq(userBans.userId, userId));\n\n\t\t\t// Delete the user\n\t\t\tawait db.delete(users).where(eq(users.id, userId));\n\n\t\t\treturn { success: true };\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tlogger.error('Error deleting user:', error);\n\t\t\tthrow new AdminError('Failed to delete user', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Ban a user\n\t */\n\tasync banUser(userId: UserId, reason?: string) {\n\t\ttry {\n\t\t\t// Check if user exists\n\t\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\t\t\tif (!user) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`User with ID ${userId} not found`,\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.USER_NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Check if user is already banned\n\t\t\tif (user.isBanned) {\n\t\t\t\tthrow new AdminError('User is already banned', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\t// Update user ban status\n\t\t\tawait db\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\tisBanned: true,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\t// Create ban record\n\t\t\tawait db.insert(userBans).values({\n\t\t\t\tuserId,\n\t\t\t\tbannedBy: userId, // TODO: Should be admin user ID\n\t\t\t\treason: reason || 'No reason provided',\n\t\t\t\tbanType: 'manual',\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tisActive: true\n\t\t\t});\n\n\t\t\treturn { success: true };\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tlogger.error('Error banning user:', error);\n\t\t\tthrow new AdminError('Failed to ban user', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Unban a user\n\t */\n\tasync unbanUser(userId: UserId) {\n\t\ttry {\n\t\t\t// Check if user exists\n\t\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\t\t\tif (!user) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`User with ID ${userId} not found`,\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.USER_NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Check if user is actually banned\n\t\t\tif (!user.isBanned) {\n\t\t\t\tthrow new AdminError('User is not banned', 400, AdminErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\t// Update user ban status\n\t\t\tawait db\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\tisBanned: false,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\t// Deactivate ban records\n\t\t\tawait db\n\t\t\t\t.update(userBans)\n\t\t\t\t.set({\n\t\t\t\t\tisActive: false,\n\t\t\t\t\tliftedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(and(eq(userBans.userId, userId), eq(userBans.isActive, true)));\n\n\t\t\treturn { success: true };\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tlogger.error('Error unbanning user:', error);\n\t\t\tthrow new AdminError('Failed to unban user', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Change user role\n\t */\n\tasync changeUserRole(userId: UserId, newRole: string) {\n\t\ttry {\n\t\t\t// Check if user exists\n\t\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\t\t\tif (!user) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`User with ID ${userId} not found`,\n\t\t\t\t\t404,\n\t\t\t\t\tAdminErrorCodes.USER_NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Validate role\n\t\t\tconst validRoles = ['user', 'mod', 'admin'];\n\t\t\tif (!validRoles.includes(newRole)) {\n\t\t\t\tthrow new AdminError(\n\t\t\t\t\t`Invalid role: ${newRole}. Must be one of: ${validRoles.join(', ')}`,\n\t\t\t\t\t400,\n\t\t\t\t\tAdminErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Update user role\n\t\t\tconst [updatedUser] = await db\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\trole: newRole,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.returning();\n\n\t\t\treturn updatedUser;\n\t\t} catch (error) {\n\t\t\tif (error instanceof AdminError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tlogger.error('Error changing user role:', error);\n\t\t\tthrow new AdminError('Failed to change user role', 500, AdminErrorCodes.DB_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const adminUsersService = new AdminUsersService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/wallet/wallet.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/wallet/wallet.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/wallet/wallet.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/xp/xp-actions.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin XP Actions Controller\n *\n * Handles API endpoints for managing XP action settings\n */\n\nimport type { Request, Response, NextFunction } from 'express';\nimport { db } from '@db';\nimport { xpActionSettings } from '@schema';\nimport { eq } from 'drizzle-orm';\nimport { logger } from '../../../../core/logger';\nimport { xpService } from '../../../xp/xp.service';\nimport { XP_ACTION, getXpActions, loadXpActionsFromDb } from '../../../xp/xp-actions';\n// import { XpActionSettingsSchema, XpActionKeySchema } from '@shared/validators/admin'; // Commented out as schemas not found/used\n// import { validateRequest } from '@server/src/middleware/validate'; // Removed as not used and not exported\n// import { XpActionsAdminService } from './xp-actions.service'; // Removed as file not found and service not used\n\n/**\n * Get all XP action settings\n */\nexport const getAllXpActions = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// Get all XP actions from database, including disabled ones\n\t\tconst actions = await db.select().from(xpActionSettings).orderBy(xpActionSettings.action);\n\n\t\tres.status(200).json({\n\t\t\tactions,\n\t\t\tcount: actions.length\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'Error getting XP actions:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\n/**\n * Get a single XP action setting by action key\n */\nexport const getXpActionByKey = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { actionKey } = req.params;\n\n\t\tif (!actionKey) {\n\t\t\treturn res.status(400).json({ message: 'Action key is required' });\n\t\t}\n\n\t\tconst actions = await db\n\t\t\t.select()\n\t\t\t.from(xpActionSettings)\n\t\t\t.where(eq(xpActionSettings.action, actionKey))\n\t\t\t.limit(1);\n\n\t\tif (actions.length === 0) {\n\t\t\treturn res.status(404).json({ message: `XP action \"${actionKey}\" not found` });\n\t\t}\n\n\t\tres.status(200).json(actions[0]);\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'Error getting XP action:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\n/**\n * Create a new XP action setting\n */\nexport const createXpAction = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { action, baseValue, description, maxPerDay, cooldownSec, enabled } = req.body;\n\n\t\tif (!action || baseValue === undefined || !description) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'Missing required fields. action, baseValue, and description are required.'\n\t\t\t});\n\t\t}\n\n\t\t// Check if action already exists\n\t\tconst existingActions = await db\n\t\t\t.select()\n\t\t\t.from(xpActionSettings)\n\t\t\t.where(eq(xpActionSettings.action, action))\n\t\t\t.limit(1);\n\n\t\tif (existingActions.length > 0) {\n\t\t\treturn res.status(409).json({\n\t\t\t\tmessage: `XP action \"${action}\" already exists. Use the update endpoint instead.`\n\t\t\t});\n\t\t}\n\n\t\t// Insert new XP action\n\t\tawait db.insert(xpActionSettings).values({\n\t\t\taction,\n\t\t\tbaseValue,\n\t\t\tdescription,\n\t\t\tmaxPerDay: maxPerDay || null,\n\t\t\tcooldownSec: cooldownSec || null,\n\t\t\tenabled: enabled !== undefined ? enabled : true,\n\t\t\tcreatedAt: new Date(),\n\t\t\tupdatedAt: new Date()\n\t\t});\n\n\t\t// Force refresh the XP actions cache\n\t\tawait loadXpActionsFromDb(true);\n\n\t\tres.status(201).json({\n\t\t\tmessage: `XP action \"${action}\" created successfully`,\n\t\t\taction: {\n\t\t\t\taction,\n\t\t\t\tbaseValue,\n\t\t\t\tdescription,\n\t\t\t\tmaxPerDay: maxPerDay || null,\n\t\t\t\tcooldownSec: cooldownSec || null,\n\t\t\t\tenabled: enabled !== undefined ? enabled : true\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'Error creating XP action:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\n/**\n * Update an existing XP action setting\n */\nexport const updateXpAction = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { actionKey } = req.params;\n\t\tconst { baseValue, description, maxPerDay, cooldownSec, enabled } = req.body;\n\n\t\tif (!actionKey) {\n\t\t\treturn res.status(400).json({ message: 'Action key is required' });\n\t\t}\n\n\t\t// Check if action exists\n\t\tconst existingActions = await db\n\t\t\t.select()\n\t\t\t.from(xpActionSettings)\n\t\t\t.where(eq(xpActionSettings.action, actionKey))\n\t\t\t.limit(1);\n\n\t\tif (existingActions.length === 0) {\n\t\t\treturn res.status(404).json({ message: `XP action \"${actionKey}\" not found` });\n\t\t}\n\n\t\t// Prepare update data\n\t\tconst updateData: any = {\n\t\t\tupdatedAt: new Date()\n\t\t};\n\n\t\tif (baseValue !== undefined) updateData.baseValue = baseValue;\n\t\tif (description !== undefined) updateData.description = description;\n\t\tif (maxPerDay !== undefined) updateData.maxPerDay = maxPerDay;\n\t\tif (cooldownSec !== undefined) updateData.cooldownSec = cooldownSec;\n\t\tif (enabled !== undefined) updateData.enabled = enabled;\n\n\t\t// Update the XP action\n\t\tawait db.update(xpActionSettings).set(updateData).where(eq(xpActionSettings.action, actionKey));\n\n\t\t// Force refresh the XP actions cache\n\t\tawait loadXpActionsFromDb(true);\n\n\t\tres.status(200).json({\n\t\t\tmessage: `XP action \"${actionKey}\" updated successfully`,\n\t\t\taction: {\n\t\t\t\t...existingActions[0],\n\t\t\t\t...updateData\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'Error updating XP action:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\n/**\n * Toggle an XP action enabled/disabled\n */\nexport const toggleXpAction = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { actionKey } = req.params;\n\n\t\tif (!actionKey) {\n\t\t\treturn res.status(400).json({ message: 'Action key is required' });\n\t\t}\n\n\t\t// Check if action exists and get current enabled state\n\t\tconst existingActions = await db\n\t\t\t.select()\n\t\t\t.from(xpActionSettings)\n\t\t\t.where(eq(xpActionSettings.action, actionKey))\n\t\t\t.limit(1);\n\n\t\tif (existingActions.length === 0) {\n\t\t\treturn res.status(404).json({ message: `XP action \"${actionKey}\" not found` });\n\t\t}\n\n\t\tconst currentEnabled = existingActions[0].enabled;\n\n\t\t// Toggle the enabled state\n\t\tawait db\n\t\t\t.update(xpActionSettings)\n\t\t\t.set({\n\t\t\t\tenabled: !currentEnabled,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(xpActionSettings.action, actionKey));\n\n\t\t// Force refresh the XP actions cache\n\t\tawait loadXpActionsFromDb(true);\n\n\t\tres.status(200).json({\n\t\t\tmessage: `XP action \"${actionKey}\" ${!currentEnabled ? 'enabled' : 'disabled'} successfully`,\n\t\t\taction: {\n\t\t\t\t...existingActions[0],\n\t\t\t\tenabled: !currentEnabled\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'Error toggling XP action:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\n/**\n * Reset an XP action to its default values\n */\nexport const resetXpAction = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { actionKey } = req.params;\n\n\t\tif (!actionKey) {\n\t\t\treturn res.status(400).json({ message: 'Action key is required' });\n\t\t}\n\n\t\t// Check if this is a default action (in the XP_ACTION enum)\n\t\tconst isDefaultAction = Object.values(XP_ACTION).includes(actionKey as XP_ACTION);\n\n\t\tif (!isDefaultAction) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: `Cannot reset custom action \"${actionKey}\". Only default actions can be reset.`\n\t\t\t});\n\t\t}\n\n\t\t// Get all XP actions from code and extract the default for this key\n\t\tconst defaultActionsObj = await getXpActions();\n\t\tconst defaultAction = defaultActionsObj[actionKey];\n\n\t\tif (!defaultAction) {\n\t\t\treturn res\n\t\t\t\t.status(404)\n\t\t\t\t.json({ message: `Default configuration for \"${actionKey}\" not found` });\n\t\t}\n\n\t\t// Update the action with default values\n\t\tawait db\n\t\t\t.update(xpActionSettings)\n\t\t\t.set({\n\t\t\t\tbaseValue: defaultAction.baseValue,\n\t\t\t\tdescription: defaultAction.description,\n\t\t\t\tmaxPerDay: defaultAction.maxPerDay || null,\n\t\t\t\tcooldownSec: defaultAction.cooldownSeconds || null,\n\t\t\t\tenabled: true,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(xpActionSettings.action, actionKey));\n\n\t\t// Force refresh the XP actions cache\n\t\tawait loadXpActionsFromDb(true);\n\n\t\tres.status(200).json({\n\t\t\tmessage: `XP action \"${actionKey}\" reset to default values successfully`,\n\t\t\taction: {\n\t\t\t\taction: actionKey,\n\t\t\t\tbaseValue: defaultAction.baseValue,\n\t\t\t\tdescription: defaultAction.description,\n\t\t\t\tmaxPerDay: defaultAction.maxPerDay || null,\n\t\t\t\tcooldownSec: defaultAction.cooldownSeconds || null,\n\t\t\t\tenabled: true\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'Error resetting XP action:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/xp/xp.clout.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/xp/xp.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sendValidationError' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used.","line":35,"column":69,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":87},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used.","line":54,"column":62,"nodeType":"Identifier","messageId":"unusedVar","endLine":54,"endColumn":80}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { xpAdminService } from './xp.service';\nimport { logger } from '../../../../core/logger';\nimport { xpService } from '../../../xp/xp.service';\nimport { XP_ACTION } from '../../../xp/xp-actions';\nimport { db } from '@db';\nimport { xpAdjustmentLogs } from '@schema';\nimport { eq, desc } from 'drizzle-orm';\nimport { sendSuccess, sendError, sendValidationError } from '../../admin.response';\nimport { validateRequestBody, validateNumberParam } from '../../admin.validation';\nimport {\n\tXpSettingsSchema,\n\tCreateLevelSchema,\n\tUpdateLevelSchema,\n\tAdjustUserXpSchema\n} from './xp.validators';\n\n// --- XP Settings Management ---\nexport const getXpSettings = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// const settings = await xpAdminService.getXpSettings();\n\t\t// res.json(settings);\n\t\tres.status(501).json({ message: 'Get XP Settings not implemented' });\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error getting XP settings:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\nexport const updateXpSettings = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst validatedData = validateRequestBody(req, res, XpSettingsSchema);\n\t\tif (!validatedData) return;\n\n\t\t// const updatedSettings = await xpAdminService.updateXpSettings(validatedData);\n\t\t// return sendSuccess(res, updatedSettings, 'XP settings updated successfully');\n\t\treturn sendError(res, 'Update XP Settings not implemented', 501);\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error updating XP settings:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\treturn sendError(res, 'Failed to update XP settings');\n\t}\n};\n\n// --- Level Management ---\nexport const getLevels = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst levels = await xpAdminService.getLevels();\n\t\treturn sendSuccess(res, {\n\t\t\tlevels,\n\t\t\ttotalLevels: levels.length,\n\t\t\thighestLevel: levels.length > 0 ? Math.max(...levels.map((l) => l.level)) : 0,\n\t\t\tmaxXpRequired: levels.length > 0 ? Math.max(...levels.map((l) => l.xpRequired)) : 0,\n\t\t\ttotalDgtRewards: levels.reduce((sum, l) => sum + (l.rewardDgt || 0), 0)\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error getting levels:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\treturn sendError(res, 'Failed to get levels');\n\t}\n};\n\nexport const createLevel = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst data = validateRequestBody(req, res, CreateLevelSchema);\n\t\tif (!data) return; // validation handled\n\n\t\tconst level = await xpAdminService.createLevel(data);\n\t\treturn sendSuccess(res, level, 'Level created');\n\t} catch (err) {\n\t\tlogger.error('XP_ADMIN_CONTROLLER', 'Error creating level:', err);\n\t\tnext(err);\n\t}\n};\n\nexport const updateLevel = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst levelNumber = validateNumberParam(req, res, 'levelNumber');\n\t\tif (!levelNumber) return;\n\n\t\tconst data = validateRequestBody(req, res, UpdateLevelSchema);\n\t\tif (!data) return;\n\n\t\tconst level = await xpAdminService.updateLevel(levelNumber, data);\n\t\treturn sendSuccess(res, level, 'Level updated');\n\t} catch (err) {\n\t\tlogger.error('XP_ADMIN_CONTROLLER', 'Error updating level:', err);\n\t\tnext(err);\n\t}\n};\n\nexport const deleteLevel = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// const { levelNumber } = req.params;\n\t\t// await xpAdminService.deleteLevel(parseInt(levelNumber));\n\t\t// res.status(204).send();\n\t\tres.status(501).json({ message: 'Delete Level not implemented' });\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error deleting level:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\n// --- Badge Management ---\nexport const getBadges = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// const badges = await xpAdminService.getBadges();\n\t\t// res.json(badges);\n\t\tres.status(501).json({ message: 'Get Badges not implemented' });\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error getting badges:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\nexport const createBadge = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// const newBadge = await xpAdminService.createBadge(req.body);\n\t\t// res.status(201).json(newBadge);\n\t\tres.status(501).json({ message: 'Create Badge not implemented' });\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error creating badge:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\nexport const updateBadge = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// const { badgeId } = req.params;\n\t\t// const updatedBadge = await xpAdminService.updateBadge(badgeId, req.body);\n\t\t// res.json(updatedBadge);\n\t\tres.status(501).json({ message: 'Update Badge not implemented' });\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error updating badge:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\nexport const deleteBadge = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// const { badgeId } = req.params;\n\t\t// await xpAdminService.deleteBadge(badgeId);\n\t\t// res.status(204).send();\n\t\tres.status(501).json({ message: 'Delete Badge not implemented' });\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error deleting badge:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\n// --- Title Management ---\nexport const getTitles = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// const titles = await xpAdminService.getTitles();\n\t\t// res.json(titles);\n\t\tres.status(501).json({ message: 'Get Titles not implemented' });\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error getting titles:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\nexport const createTitle = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// const newTitle = await xpAdminService.createTitle(req.body);\n\t\t// res.status(201).json(newTitle);\n\t\tres.status(501).json({ message: 'Create Title not implemented' });\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error creating title:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\nexport const updateTitle = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// const { titleId } = req.params;\n\t\t// const updatedTitle = await xpAdminService.updateTitle(titleId, req.body);\n\t\t// res.json(updatedTitle);\n\t\tres.status(501).json({ message: 'Update Title not implemented' });\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error updating title:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\nexport const deleteTitle = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// const { titleId } = req.params;\n\t\t// await xpAdminService.deleteTitle(titleId);\n\t\t// res.status(204).send();\n\t\tres.status(501).json({ message: 'Delete Title not implemented' });\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error deleting title:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\n// --- User XP Adjustment ---\nexport const adjustUserXp = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { userId, amount, adjustmentType, reason } = req.body;\n\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\tif (!userId || !amount || !adjustmentType) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'Missing required parameters: userId, amount, and adjustmentType are required.'\n\t\t\t});\n\t\t}\n\n\t\tif (!['add', 'subtract', 'set'].includes(adjustmentType)) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'Invalid adjustmentType. Must be one of: add, subtract, set.'\n\t\t\t});\n\t\t}\n\n\t\tlogger.info('XP_ADMIN_CONTROLLER', 'Admin adjusting user XP', {\n\t\t\tadminId,\n\t\t\tuserId,\n\t\t\tamount,\n\t\t\tadjustmentType,\n\t\t\treason\n\t\t});\n\n\t\tconst result = await xpService.updateUserXp(\n\t\t\tuserId,\n\t\t\tNumber(amount),\n\t\t\tadjustmentType as 'add' | 'subtract' | 'set',\n\t\t\t{\n\t\t\t\treason: reason || 'Admin adjustment',\n\t\t\t\tadminId: adminId,\n\t\t\t\tlogAdjustment: true\n\t\t\t}\n\t\t);\n\n\t\tres.status(200).json({\n\t\t\tmessage: 'XP adjusted successfully',\n\t\t\tresult\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error adjusting user XP:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tif (error.message && error.message.includes('not found')) {\n\t\t\treturn res.status(404).json({ message: error.message });\n\t\t}\n\t\tnext(error);\n\t}\n};\n\nexport const getXpAdjustmentLogs = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst userId = req.query.userId ? req.query.userId : undefined;\n\t\tconst limit = req.query.limit ? Number(req.query.limit) : 50;\n\n\t\tlet query = db\n\t\t\t.select()\n\t\t\t.from(xpAdjustmentLogs)\n\t\t\t.orderBy(desc(xpAdjustmentLogs.createdAt))\n\t\t\t.limit(limit);\n\n\t\tif (userId) {\n\t\t\tquery = query.where(eq(xpAdjustmentLogs.userId, userId));\n\t\t}\n\n\t\tconst logs = await query;\n\n\t\tres.status(200).json({\n\t\t\tlogs\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error getting XP adjustment logs:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\n/**\n * Test XP Action Award (Admin Development endpoint)\n *\n * This endpoint allows administrators to test the XP action award system\n * by manually triggering a specific XP action for a user.\n */\nexport const testXpActionAward = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { userId, action, metadata } = req.body;\n\n\t\tif (!userId || !action) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'Missing required parameters. userId and action are required.'\n\t\t\t});\n\t\t}\n\n\t\t// Ensure action is valid\n\t\tif (!Object.values(XP_ACTION).includes(action as XP_ACTION)) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: `Invalid action. Must be one of: ${Object.values(XP_ACTION).join(', ')}`\n\t\t\t});\n\t\t}\n\n\t\tlogger.info('XP_ADMIN_CONTROLLER', 'Admin testing XP action award', {\n\t\t\tadminId: userService.getUserFromRequest(req)?.id,\n\t\t\tuserId,\n\t\t\taction,\n\t\t\tmetadata\n\t\t});\n\n\t\t// Call the service to award XP\n\t\tconst result = await xpService.awardXp(userId, action as XP_ACTION, metadata);\n\n\t\tif (!result) {\n\t\t\treturn res.status(429).json({\n\t\t\t\tmessage: 'Could not award XP. The user may have reached a limit for this action.'\n\t\t\t});\n\t\t}\n\n\t\tres.status(200).json({\n\t\t\tmessage: 'XP awarded successfully',\n\t\t\tresult,\n\t\t\tlimits: await xpService.getActionLimitsForUser(userId, action as XP_ACTION)\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error(\n\t\t\t'XP_ADMIN_CONTROLLER',\n\t\t\t'Error testing XP action award:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tif (error.message && error.message.includes('not found')) {\n\t\t\treturn res.status(404).json({ message: error.message });\n\t\t}\n\t\tnext(error);\n\t}\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/xp/xp.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/xp/xp.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'economySettings' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":6,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpCloutSettings' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport type { UserId } from '@shared/types/ids';\nimport {\n\tusers,\n\tlevels,\n\teconomySettings,\n\tbadges,\n\ttitles,\n\txpAdjustmentLogs,\n\txpCloutSettings\n} from '@schema';\nimport { eq, and, desc, sql } from 'drizzle-orm';\nimport { logger } from '../../../../core/logger';\nimport type { AdminId } from '@shared/types/ids';\nimport { UserId } from \"@shared/types/ids\";\n\n// Import core XP service once refactored, e.g.:\n// import { coreXpService } from '../../../xp/xp.service';\n\nexport class XpAdminService {\n\tconstructor() {\n\t\t// Ensure the xp_adjustment_logs table exists (for development/testing)\n\t\tthis.ensureTableExists().catch((err) => {\n\t\t\tlogger.error('Error ensuring xp_adjustment_logs table exists:', err);\n\t\t});\n\t}\n\n\t/**\n\t * Ensure the xp_adjustment_logs table exists - for development/testing\n\t */\n\tprivate async ensureTableExists() {\n\t\t// Only do this in development mode\n\t\tif (process.env.NODE_ENV !== 'development') return;\n\n\t\ttry {\n\t\t\t// Use more direct approach with pool.query\n\t\t\tconst { pool } = await import('../../../../core/db');\n\n\t\t\tlogger.info('XP_ADMIN_SERVICE', 'Creating xp_adjustment_logs table if not exists...');\n\n\t\t\t// Create the table\n\t\t\tawait pool.query(`\n        CREATE TABLE IF NOT EXISTS xp_adjustment_logs (\n          id SERIAL PRIMARY KEY,\n          user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n          admin_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE SET NULL,\n          adjustment_type VARCHAR(20) NOT NULL,\n          amount INTEGER NOT NULL,\n          reason TEXT NOT NULL,\n          old_xp INTEGER NOT NULL,\n          new_xp INTEGER NOT NULL,\n          created_at TIMESTAMP NOT NULL DEFAULT NOW()\n        );\n        \n        -- Create indexes if they don't exist\n        DO $$\n        BEGIN\n          IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_xp_adjustment_logs_user_id') THEN\n            CREATE INDEX idx_xp_adjustment_logs_user_id ON xp_adjustment_logs(user_id);\n          END IF;\n          \n          IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_xp_adjustment_logs_admin_id') THEN\n            CREATE INDEX idx_xp_adjustment_logs_admin_id ON xp_adjustment_logs(admin_id);\n          END IF;\n          \n          IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_xp_adjustment_logs_created_at') THEN\n            CREATE INDEX idx_xp_adjustment_logs_created_at ON xp_adjustment_logs(created_at);\n          END IF;\n        END\n        $$;\n      `);\n\n\t\t\tlogger.info('XP_ADMIN_SERVICE', 'xp_adjustment_logs table setup completed');\n\t\t} catch (error) {\n\t\t\tlogger.error(\n\t\t\t\t'XP_ADMIN_SERVICE',\n\t\t\t\t'Error setting up xp_adjustment_logs table:',\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t\t// Don't throw, just log the error and continue\n\t\t}\n\t}\n\n\t// --- XP Settings Management (Economy Settings & xpCloutSettings) ---\n\tasync getXpSettings() {\n\t\t// TODO: Fetch relevant settings from economySettings and xpCloutSettings\n\t\t// e.g., xp_per_post, daily_xp_cap, clout_per_helpful etc.\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Get XP Settings called - not implemented');\n\t\treturn { message: 'Get XP Settings not implemented' };\n\t}\n\n\tasync updateXpSettings(settings: Array<{ key: string; value: any }>) {\n\t\t// TODO: Update settings in economySettings or xpCloutSettings table\n\t\t// Ensure proper validation and typing\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Update XP Settings called - not implemented', { settings });\n\t\treturn { message: 'Update XP Settings not implemented' };\n\t}\n\n\t// --- Level Management ---\n\tasync getLevels() {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Get Levels called - not implemented');\n\t\treturn await db.select().from(levels).orderBy(levels.level);\n\t}\n\n\tasync createLevel(levelData: any) {\n\t\t// Insert a new level row; if level already exists, throw error\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Creating level', { levelData });\n\t\ttry {\n\t\t\tconst inserted = await db\n\t\t\t\t.insert(levels)\n\t\t\t\t.values({\n\t\t\t\t\tlevel: levelData.level,\n\t\t\t\t\tminXp: levelData.xpRequired,\n\t\t\t\t\tname: levelData.rewardTitle || levelData.title || null,\n\t\t\t\t\trewardDgt: levelData.rewardDgt || 0,\n\t\t\t\t\trewardTitleId: levelData.rewardTitleId,\n\t\t\t\t\tdescription: levelData.description || null,\n\t\t\t\t\ticonUrl: levelData.iconUrl,\n\t\t\t\t\tframeUrl: levelData.frameUrl,\n\t\t\t\t\tcolorTheme: levelData.colorTheme,\n\t\t\t\t\tanimationEffect: levelData.animationEffect,\n\t\t\t\t\trarity: levelData.rarity || 'common',\n\t\t\t\t\tunlocks: levelData.unlocks || {}\n\t\t\t\t})\n\t\t\t\t.onConflictDoNothing()\n\t\t\t\t.returning();\n\t\t\treturn inserted[0];\n\t\t} catch (err) {\n\t\t\tlogger.error('XP_ADMIN_SERVICE', 'Error creating level', err);\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tasync updateLevel(levelNumber: number, levelData: any) {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Updating level', { levelNumber, levelData });\n\t\ttry {\n\t\t\tconst updated = await db\n\t\t\t\t.update(levels)\n\t\t\t\t.set({\n\t\t\t\t\tminXp: levelData.xpRequired,\n\t\t\t\t\tname: levelData.rewardTitle || levelData.title || null,\n\t\t\t\t\trewardDgt: levelData.rewardDgt,\n\t\t\t\t\tdescription: levelData.description,\n\t\t\t\t\ticonUrl: levelData.iconUrl,\n\t\t\t\t\tframeUrl: levelData.frameUrl,\n\t\t\t\t\tcolorTheme: levelData.colorTheme,\n\t\t\t\t\tanimationEffect: levelData.animationEffect,\n\t\t\t\t\trarity: levelData.rarity,\n\t\t\t\t\tunlocks: levelData.unlocks\n\t\t\t\t})\n\t\t\t\t.where(eq(levels.level, levelNumber))\n\t\t\t\t.returning();\n\t\t\treturn updated[0];\n\t\t} catch (err) {\n\t\t\tlogger.error('XP_ADMIN_SERVICE', 'Error updating level', err);\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tasync deleteLevel(levelNumber: number) {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Delete Level called - not implemented', { levelNumber });\n\t\t// await db.delete(levels).where(eq(levels.level, levelNumber));\n\t\treturn { message: 'Delete Level not implemented' };\n\t}\n\n\t// --- Badge Management ---\n\tasync getBadges() {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Get Badges called - not implemented');\n\t\treturn await db.select().from(badges);\n\t}\n\n\tasync createBadge(badgeData: any) {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Create Badge called - not implemented', { badgeData });\n\t\t// const newBadge = await db.insert(badges).values(badgeData).returning();\n\t\t// return newBadge[0];\n\t\treturn { message: 'Create Badge not implemented' };\n\t}\n\n\tasync updateBadge(badgeId: string, badgeData: any) {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Update Badge called - not implemented', {\n\t\t\tbadgeId,\n\t\t\tbadgeData\n\t\t});\n\t\t// const updatedBadge = await db.update(badges).set(badgeData).where(eq(badges.id, badgeId)).returning();\n\t\t// return updatedBadge[0];\n\t\treturn { message: 'Update Badge not implemented' };\n\t}\n\n\tasync deleteBadge(badgeId: string) {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Delete Badge called - not implemented', { badgeId });\n\t\t// await db.delete(badges).where(eq(badges.id, badgeId));\n\t\treturn { message: 'Delete Badge not implemented' };\n\t}\n\n\t// --- Title Management ---\n\tasync getTitles() {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Get Titles called - not implemented');\n\t\treturn await db.select().from(titles);\n\t}\n\n\tasync createTitle(titleData: any) {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Create Title called - not implemented', { titleData });\n\t\t// const newTitle = await db.insert(titles).values(titleData).returning();\n\t\t// return newTitle[0];\n\t\treturn { message: 'Create Title not implemented' };\n\t}\n\n\tasync updateTitle(titleId: string, titleData: any) {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Update Title called - not implemented', {\n\t\t\ttitleId,\n\t\t\ttitleData\n\t\t});\n\t\t// const updatedTitle = await db.update(titles).set(titleData).where(eq(titles.id, titleId)).returning();\n\t\t// return updatedTitle[0];\n\t\treturn { message: 'Update Title not implemented' };\n\t}\n\n\tasync deleteTitle(titleId: string) {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Delete Title called - not implemented', { titleId });\n\t\t// await db.delete(titles).where(eq(titles.id, titleId));\n\t\treturn { message: 'Delete Title not implemented' };\n\t}\n\n\t// --- User XP Adjustment ---\n\tasync adjustUserXp(\n\t\tuserId: UserId,\n\t\tamount: number,\n\t\treason: string,\n\t\tadjustmentType: 'add' | 'subtract' | 'set',\n\t\tadminId: AdminId\n\t) {\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Admin adjust user XP called', {\n\t\t\tuserId,\n\t\t\tamount,\n\t\t\treason,\n\t\t\tadjustmentType,\n\t\t\tadminId\n\t\t});\n\n\t\tif (!userId || typeof amount !== 'number' || !reason || !adjustmentType || !adminId) {\n\t\t\tthrow new Error('Missing required parameters for XP adjustment.');\n\t\t}\n\n\t\t// Use the core XP service for XP adjustments\n\t\tconst { xpService } = await import('../../../../domains/xp/xp.service');\n\n\t\t// Use the core service to perform the update\n\t\tconst result = await xpService.updateUserXp(userId, amount, adjustmentType, {\n\t\t\treason,\n\t\t\tadminId,\n\t\t\tlogAdjustment: true\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tasync getXpAdjustmentLogs(params: { userId?: UserId; limit?: number; offset?: number }) {\n\t\tconst { userId, limit = 50, offset = 0 } = params; // Default limit to 50 as per your plan\n\t\tlogger.info('XP_ADMIN_SERVICE', 'Get XP Adjustment Logs called', params);\n\n\t\tconst queryConditions = userId ? [eq(xpAdjustmentLogs.userId, userId)] : [];\n\n\t\tconst logs = await db\n\t\t\t.select()\n\t\t\t.from(xpAdjustmentLogs)\n\t\t\t.where(and(...queryConditions))\n\t\t\t.orderBy(desc(xpAdjustmentLogs.createdAt))\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\n\t\treturn logs;\n\t}\n}\n\nexport const xpAdminService = new XpAdminService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/admin/sub-domains/xp/xp.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/advertising/ad-admin.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'campaignManagementService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'from' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":337,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":337,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'to' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":337,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":337,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { z } from 'zod';\nimport { adConfigurationService } from './ad-configuration.service';\nimport { campaignManagementService } from './campaign-management.service';\nimport { logger } from \"../../core/logger\";\n\n// Admin validation schemas\nconst placementConfigSchema = z.object({\n\tname: z.string().min(1).max(255),\n\tslug: z.string().min(1).max(100),\n\tdescription: z.string().optional(),\n\tposition: z.enum([\n\t\t'header_banner',\n\t\t'sidebar_top',\n\t\t'sidebar_middle',\n\t\t'sidebar_bottom',\n\t\t'thread_header',\n\t\t'thread_footer',\n\t\t'between_posts',\n\t\t'forum_header',\n\t\t'zone_header',\n\t\t'mobile_banner'\n\t]),\n\tforumZoneSlug: z.string().optional(),\n\tforumSlug: z.string().optional(),\n\tallowedFormats: z.array(z.string()),\n\tdimensions: z.string().optional(),\n\tmaxFileSize: z.number().positive().optional(),\n\tfloorPriceCpm: z.number().positive(),\n\tmaxDailyImpressions: z.number().positive().optional(),\n\tpriority: z.number().int().positive(),\n\ttargetingConstraints: z.object({}).passthrough(),\n\tdisplayRules: z.object({}).passthrough(),\n\trequiresApproval: z.boolean()\n});\n\nconst globalRuleSchema = z.object({\n\tname: z.string().min(1).max(255),\n\tdescription: z.string().optional(),\n\truleType: z.enum([\n\t\t'targeting',\n\t\t'bidding',\n\t\t'display',\n\t\t'frequency',\n\t\t'content_filter',\n\t\t'fraud_prevention'\n\t]),\n\tconditions: z.array(\n\t\tz.object({\n\t\t\tfield: z.string(),\n\t\t\toperator: z.enum(['equals', 'not_equals', 'greater_than', 'less_than', 'in', 'contains']),\n\t\t\tvalue: z.any(),\n\t\t\tlogic: z.enum(['AND', 'OR']).optional()\n\t\t})\n\t),\n\tactions: z.array(\n\t\tz.object({\n\t\t\ttype: z.enum([\n\t\t\t\t'block_ad',\n\t\t\t\t'adjust_bid',\n\t\t\t\t'set_frequency_cap',\n\t\t\t\t'require_approval',\n\t\t\t\t'flag_for_review'\n\t\t\t]),\n\t\t\tparameters: z.any()\n\t\t})\n\t),\n\tpriority: z.number().int().positive(),\n\tisActive: z.boolean(),\n\tvalidFrom: z.string().datetime().optional(),\n\tvalidUntil: z.string().datetime().optional()\n});\n\nconst systemConfigSchema = z.object({\n\tplacements: z\n\t\t.object({\n\t\t\tenabled: z.boolean(),\n\t\t\tdefaultFloorPrice: z.number().positive(),\n\t\t\tmaxDailyBudget: z.number().positive(),\n\t\t\tapprovalRequired: z.boolean()\n\t\t})\n\t\t.optional(),\n\ttargeting: z\n\t\t.object({\n\t\t\tenablePersonalization: z.boolean(),\n\t\t\tdataRetentionDays: z.number().int().positive(),\n\t\t\trequireConsent: z.boolean(),\n\t\t\tallowCrossSiteTracking: z.boolean()\n\t\t})\n\t\t.optional(),\n\trevenue: z\n\t\t.object({\n\t\t\tplatformCommission: z.number().min(0).max(100),\n\t\t\tdgtRewardPool: z.number().positive(),\n\t\t\tminimumPayout: z.number().positive(),\n\t\t\tpayoutSchedule: z.enum(['daily', 'weekly', 'monthly'])\n\t\t})\n\t\t.optional(),\n\tcontent: z\n\t\t.object({\n\t\t\tautoApproval: z.boolean(),\n\t\t\tadultContentAllowed: z.boolean(),\n\t\t\tcryptoContentOnly: z.boolean(),\n\t\t\trequireDisclaimer: z.boolean()\n\t\t})\n\t\t.optional(),\n\tgovernance: z\n\t\t.object({\n\t\t\tenableCommunityVoting: z.boolean(),\n\t\t\tminimumTokensToVote: z.number().positive(),\n\t\t\tvotingPeriodDays: z.number().int().positive(),\n\t\t\tquorumPercentage: z.number().min(1).max(100)\n\t\t})\n\t\t.optional()\n});\n\nconst governanceProposalSchema = z.object({\n\ttitle: z.string().min(1).max(255),\n\tdescription: z.string().min(10),\n\tproposalType: z.string(),\n\tproposedChanges: z.object({}).passthrough()\n});\n\n/**\n * Ad Admin Controller\n * Handles administrative functions for the ad system\n */\nexport class AdAdminController {\n\t/**\n\t * Get full system configuration\n\t * GET /api/admin/ads/config\n\t */\n\tasync getSystemConfiguration(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\t// TODO: Verify admin permissions\n\t\t\tconst config = await adConfigurationService.getSystemConfiguration();\n\t\t\tres.json(config);\n\t\t} catch (error) {\n\t\t\tlogger.error('Get system config error:', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to get system configuration',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update system configuration\n\t * PUT /api/admin/ads/config\n\t */\n\tasync updateSystemConfiguration(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst adminUserId = req.body.userId || 'admin-123'; // TODO: Extract from JWT\n\t\t\tconst configUpdates = systemConfigSchema.parse(req.body);\n\n\t\t\tconst updatedConfig = await adConfigurationService.updateSystemConfiguration(\n\t\t\t\tconfigUpdates,\n\t\t\t\tadminUserId\n\t\t\t);\n\n\t\t\tres.json(updatedConfig);\n\t\t} catch (error) {\n\t\t\tlogger.error('Update system config error:', error);\n\t\t\tres.status(400).json({\n\t\t\t\terror: 'Failed to update system configuration',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create ad placement\n\t * POST /api/admin/ads/placements\n\t */\n\tasync createPlacement(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst placementData = placementConfigSchema.parse(req.body);\n\t\t\tconst placement = await adConfigurationService.createPlacement(placementData);\n\n\t\t\tres.status(201).json(placement);\n\t\t} catch (error) {\n\t\t\tlogger.error('Create placement error:', error);\n\t\t\tres.status(400).json({\n\t\t\t\terror: 'Failed to create placement',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update ad placement\n\t * PUT /api/admin/ads/placements/:placementId\n\t */\n\tasync updatePlacement(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { placementId } = req.params;\n\t\t\tconst updates = req.body;\n\n\t\t\tconst placement = await adConfigurationService.updatePlacement(placementId, updates);\n\n\t\t\tres.json(placement);\n\t\t} catch (error) {\n\t\t\tlogger.error('Update placement error:', error);\n\t\t\tres.status(400).json({\n\t\t\t\terror: 'Failed to update placement',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Delete ad placement\n\t * DELETE /api/admin/ads/placements/:placementId\n\t */\n\tasync deletePlacement(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { placementId } = req.params;\n\t\t\tawait adConfigurationService.deletePlacement(placementId);\n\n\t\t\tres.status(204).send();\n\t\t} catch (error) {\n\t\t\tlogger.error('Delete placement error:', error);\n\t\t\tres.status(400).json({\n\t\t\t\terror: 'Failed to delete placement',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get all placements with admin data\n\t * GET /api/admin/ads/placements\n\t */\n\tasync listAllPlacements(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst filters = {\n\t\t\t\tposition: req.query.position as string,\n\t\t\t\tforumZoneSlug: req.query.forumZoneSlug as string,\n\t\t\t\tforumSlug: req.query.forumSlug as string,\n\t\t\t\tisActive: req.query.isActive ? req.query.isActive === 'true' : undefined\n\t\t\t};\n\n\t\t\tconst placements = await adConfigurationService.listPlacements(filters);\n\n\t\t\t// Include admin analytics for each placement\n\t\t\tconst placementsWithAnalytics = await Promise.all(\n\t\t\t\tplacements.map(async (placement) => {\n\t\t\t\t\tconst analytics = await adConfigurationService.getPlacementAnalytics(placement.id);\n\t\t\t\t\treturn { ...placement, analytics };\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tres.json(placementsWithAnalytics);\n\t\t} catch (error) {\n\t\t\tlogger.error('List placements error:', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to list placements',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create global rule\n\t * POST /api/admin/ads/rules\n\t */\n\tasync createGlobalRule(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst ruleData = globalRuleSchema.parse(req.body);\n\n\t\t\tconst rule = await adConfigurationService.createGlobalRule({\n\t\t\t\t...ruleData,\n\t\t\t\tvalidFrom: ruleData.validFrom ? new Date(ruleData.validFrom) : undefined,\n\t\t\t\tvalidUntil: ruleData.validUntil ? new Date(ruleData.validUntil) : undefined\n\t\t\t});\n\n\t\t\tres.status(201).json(rule);\n\t\t} catch (error) {\n\t\t\tlogger.error('Create rule error:', error);\n\t\t\tres.status(400).json({\n\t\t\t\terror: 'Failed to create rule',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update global rule\n\t * PUT /api/admin/ads/rules/:ruleId\n\t */\n\tasync updateGlobalRule(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { ruleId } = req.params;\n\t\t\tconst updates = req.body;\n\n\t\t\tconst rule = await adConfigurationService.updateGlobalRule(ruleId, updates);\n\n\t\t\tres.json(rule);\n\t\t} catch (error) {\n\t\t\tlogger.error('Update rule error:', error);\n\t\t\tres.status(400).json({\n\t\t\t\terror: 'Failed to update rule',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * List global rules\n\t * GET /api/admin/ads/rules\n\t */\n\tasync listGlobalRules(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst filters = {\n\t\t\t\truleType: req.query.ruleType as string,\n\t\t\t\tisActive: req.query.isActive ? req.query.isActive === 'true' : undefined\n\t\t\t};\n\n\t\t\tconst rules = await adConfigurationService.listGlobalRules(filters);\n\n\t\t\tres.json(rules);\n\t\t} catch (error) {\n\t\t\tlogger.error('List rules error:', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to list rules',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get platform-wide analytics\n\t * GET /api/admin/ads/analytics\n\t */\n\tasync getPlatformAnalytics(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { from, to } = req.query;\n\n\t\t\t// TODO: Implement platform-wide analytics aggregation\n\t\t\tconst analytics = {\n\t\t\t\ttotalRevenue: 125430.75,\n\t\t\t\ttotalImpressions: 2450000,\n\t\t\t\ttotalClicks: 58500,\n\t\t\t\taverageCtr: 0.0239,\n\t\t\t\taverageCpm: 1.87,\n\t\t\t\tactiveCampaigns: 156,\n\t\t\t\ttotalAdvertisers: 89,\n\t\t\t\tdgtRewardsDistributed: 15240.5,\n\t\t\t\ttopPerformingPlacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\tplacementId: 'placement-1',\n\t\t\t\t\t\tname: 'Header Banner',\n\t\t\t\t\t\trevenue: 45230.25,\n\t\t\t\t\t\tfillRate: 0.92\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\trevenueByDay: [\n\t\t\t\t\t{ date: '2025-06-20', revenue: 4250.75 },\n\t\t\t\t\t{ date: '2025-06-21', revenue: 4580.25 },\n\t\t\t\t\t{ date: '2025-06-22', revenue: 3920.5 }\n\t\t\t\t]\n\t\t\t};\n\n\t\t\tres.json(analytics);\n\t\t} catch (error) {\n\t\t\tlogger.error('Get platform analytics error:', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to get platform analytics',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get all campaigns (admin view)\n\t * GET /api/admin/ads/campaigns\n\t */\n\tasync getAllCampaigns(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst filters = {\n\t\t\t\tstatus: req.query.status as string,\n\t\t\t\ttype: req.query.type as string,\n\t\t\t\tadvertiser: req.query.advertiser as string,\n\t\t\t\tlimit: req.query.limit ? parseInt(req.query.limit as string) : 50,\n\t\t\t\toffset: req.query.offset ? parseInt(req.query.offset as string) : 0\n\t\t\t};\n\n\t\t\t// TODO: Implement admin-level campaign listing\n\t\t\t// This would show all campaigns across all advertisers\n\t\t\tconst campaigns = {\n\t\t\t\tcampaigns: [],\n\t\t\t\ttotal: 0,\n\t\t\t\tfilters: filters\n\t\t\t};\n\n\t\t\tres.json(campaigns);\n\t\t} catch (error) {\n\t\t\tlogger.error('Get all campaigns error:', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to get campaigns',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Approve/reject campaign\n\t * POST /api/admin/ads/campaigns/:campaignId/review\n\t */\n\tasync reviewCampaign(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { campaignId } = req.params;\n\t\t\tconst { action, reason } = req.body; // action: 'approve' | 'reject'\n\n\t\t\tif (!['approve', 'reject'].includes(action)) {\n\t\t\t\tres.status(400).json({ error: 'Invalid action. Must be approve or reject.' });\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// TODO: Implement campaign review logic\n\t\t\tconst newStatus = action === 'approve' ? 'active' : 'cancelled';\n\n\t\t\t// Update campaign status and add review note\n\t\t\tconst result = {\n\t\t\t\tcampaignId,\n\t\t\t\taction,\n\t\t\t\tnewStatus,\n\t\t\t\treviewedAt: new Date(),\n\t\t\t\treason\n\t\t\t};\n\n\t\t\tres.json(result);\n\t\t} catch (error) {\n\t\t\tlogger.error('Review campaign error:', error);\n\t\t\tres.status(400).json({\n\t\t\t\terror: 'Failed to review campaign',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create governance proposal\n\t * POST /api/admin/ads/governance/proposals\n\t */\n\tasync createGovernanceProposal(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst proposerUserId = req.body.userId || 'admin-123'; // TODO: Extract from JWT\n\t\t\tconst proposalData = governanceProposalSchema.parse(req.body);\n\n\t\t\tconst proposal = await adConfigurationService.createGovernanceProposal({\n\t\t\t\t...proposalData,\n\t\t\t\tproposerUserId\n\t\t\t});\n\n\t\t\tres.status(201).json(proposal);\n\t\t} catch (error) {\n\t\t\tlogger.error('Create proposal error:', error);\n\t\t\tres.status(400).json({\n\t\t\t\terror: 'Failed to create proposal',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Execute governance proposal\n\t * POST /api/admin/ads/governance/proposals/:proposalId/execute\n\t */\n\tasync executeGovernanceProposal(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { proposalId } = req.params;\n\n\t\t\tawait adConfigurationService.executeGovernanceProposal(proposalId);\n\n\t\t\tres.json({ success: true, message: 'Proposal executed successfully' });\n\t\t} catch (error) {\n\t\t\tlogger.error('Execute proposal error:', error);\n\t\t\tres.status(400).json({\n\t\t\t\terror: 'Failed to execute proposal',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get fraud detection alerts\n\t * GET /api/admin/ads/fraud/alerts\n\t */\n\tasync getFraudAlerts(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\t// TODO: Implement fraud detection system\n\t\t\tconst alerts = [\n\t\t\t\t{\n\t\t\t\t\tid: 'alert-1',\n\t\t\t\t\ttype: 'suspicious_traffic',\n\t\t\t\t\tseverity: 'high',\n\t\t\t\t\tcampaignId: 'campaign-123',\n\t\t\t\t\tdescription: 'Unusual click patterns detected',\n\t\t\t\t\tdetectedAt: new Date(),\n\t\t\t\t\tstatus: 'active'\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tres.json(alerts);\n\t\t} catch (error) {\n\t\t\tlogger.error('Get fraud alerts error:', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to get fraud alerts',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get revenue reports\n\t * GET /api/admin/ads/reports/revenue\n\t */\n\tasync getRevenueReport(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { from, to, granularity = 'daily' } = req.query;\n\n\t\t\t// TODO: Implement revenue reporting\n\t\t\tconst report = {\n\t\t\t\tperiod: { from, to },\n\t\t\t\tgranularity,\n\t\t\t\ttotalRevenue: 125430.75,\n\t\t\t\tplatformCommission: 37629.23,\n\t\t\t\tadvertiserSpend: 87801.52,\n\t\t\t\tdgtRewardsDistributed: 15240.5,\n\t\t\t\tbreakdown: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdate: '2025-06-20',\n\t\t\t\t\t\trevenue: 4250.75,\n\t\t\t\t\t\tcommission: 1275.23,\n\t\t\t\t\t\tadvertiserSpend: 2975.52\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\n\t\t\tres.json(report);\n\t\t} catch (error) {\n\t\t\tlogger.error('Get revenue report error:', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to get revenue report',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Export analytics data\n\t * GET /api/admin/ads/export\n\t */\n\tasync exportAnalytics(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { format = 'csv', type = 'campaigns', from, to } = req.query;\n\n\t\t\tif (!['csv', 'json'].includes(format as string)) {\n\t\t\t\tres.status(400).json({ error: 'Format must be csv or json' });\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// TODO: Implement data export\n\t\t\tconst exportData = {\n\t\t\t\ttype,\n\t\t\t\tformat,\n\t\t\t\tperiod: { from, to },\n\t\t\t\tgeneratedAt: new Date(),\n\t\t\t\tdownloadUrl: '/api/admin/ads/downloads/export-12345.csv'\n\t\t\t};\n\n\t\t\tres.json(exportData);\n\t\t} catch (error) {\n\t\t\tlogger.error('Export analytics error:', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to export analytics',\n\t\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport const adAdminController = new AdAdminController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/advertising/ad-configuration.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":1,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'placementId' is defined but never used.","line":511,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":511,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timeRange' is defined but never used.","line":512,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":512,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { eq, and, sql, desc, asc } from 'drizzle-orm';\nimport { db } from '@server/src/core/db';\nimport {\n\tadPlacements,\n\tcampaignRules,\n\tadGovernanceProposals,\n\tadGovernanceVotes,\n\tcampaigns,\n\ttype AdPlacement,\n\ttype CampaignRule,\n\ttype AdGovernanceProposal\n} from '@schema';\n\nexport interface PlacementConfiguration {\n\tid?: string;\n\tname: string;\n\tslug: string;\n\tdescription?: string;\n\tposition:\n\t\t| 'header_banner'\n\t\t| 'sidebar_top'\n\t\t| 'sidebar_middle'\n\t\t| 'sidebar_bottom'\n\t\t| 'thread_header'\n\t\t| 'thread_footer'\n\t\t| 'between_posts'\n\t\t| 'forum_header'\n\t\t| 'zone_header'\n\t\t| 'mobile_banner';\n\tforumZoneSlug?: string;\n\tforumSlug?: string;\n\tallowedFormats: string[];\n\tdimensions?: string;\n\tmaxFileSize?: number;\n\tfloorPriceCpm: number;\n\tmaxDailyImpressions?: number;\n\tpriority: number;\n\ttargetingConstraints: any;\n\tdisplayRules: any;\n\trequiresApproval: boolean;\n}\n\nexport interface GlobalRule {\n\tid?: string;\n\tname: string;\n\tdescription?: string;\n\truleType:\n\t\t| 'targeting'\n\t\t| 'bidding'\n\t\t| 'display'\n\t\t| 'frequency'\n\t\t| 'content_filter'\n\t\t| 'fraud_prevention';\n\tconditions: Array<{\n\t\tfield: string;\n\t\toperator: 'equals' | 'not_equals' | 'greater_than' | 'less_than' | 'in' | 'contains';\n\t\tvalue: any;\n\t\tlogic?: 'AND' | 'OR';\n\t}>;\n\tactions: Array<{\n\t\ttype: 'block_ad' | 'adjust_bid' | 'set_frequency_cap' | 'require_approval' | 'flag_for_review';\n\t\tparameters: any;\n\t}>;\n\tpriority: number;\n\tisActive: boolean;\n\tvalidFrom?: Date;\n\tvalidUntil?: Date;\n}\n\nexport interface AdSystemConfiguration {\n\tplacements: {\n\t\tenabled: boolean;\n\t\tdefaultFloorPrice: number;\n\t\tmaxDailyBudget: number;\n\t\tapprovalRequired: boolean;\n\t};\n\ttargeting: {\n\t\tenablePersonalization: boolean;\n\t\tdataRetentionDays: number;\n\t\trequireConsent: boolean;\n\t\tallowCrossSiteTracking: boolean;\n\t};\n\trevenue: {\n\t\tplatformCommission: number; // Percentage\n\t\tdgtRewardPool: number; // DGT tokens allocated for rewards\n\t\tminimumPayout: number;\n\t\tpayoutSchedule: 'daily' | 'weekly' | 'monthly';\n\t};\n\tcontent: {\n\t\tautoApproval: boolean;\n\t\tadultContentAllowed: boolean;\n\t\tcryptoContentOnly: boolean;\n\t\trequireDisclaimer: boolean;\n\t};\n\tgovernance: {\n\t\tenableCommunityVoting: boolean;\n\t\tminimumTokensToVote: number;\n\t\tvotingPeriodDays: number;\n\t\tquorumPercentage: number;\n\t};\n}\n\n/**\n * Ad Configuration Service\n * Manages system-wide ad settings, placement configuration, and governance\n */\nexport class AdConfigurationService {\n\t/**\n\t * Get current system configuration\n\t */\n\tasync getSystemConfiguration(): Promise<AdSystemConfiguration> {\n\t\t// In a real implementation, this would come from a configuration table\n\t\t// For now, returning default configuration\n\t\treturn {\n\t\t\tplacements: {\n\t\t\t\tenabled: true,\n\t\t\t\tdefaultFloorPrice: 0.5,\n\t\t\t\tmaxDailyBudget: 10000,\n\t\t\t\tapprovalRequired: true\n\t\t\t},\n\t\t\ttargeting: {\n\t\t\t\tenablePersonalization: true,\n\t\t\t\tdataRetentionDays: 90,\n\t\t\t\trequireConsent: true,\n\t\t\t\tallowCrossSiteTracking: false\n\t\t\t},\n\t\t\trevenue: {\n\t\t\t\tplatformCommission: 30, // 30% commission\n\t\t\t\tdgtRewardPool: 100000, // 100k DGT tokens\n\t\t\t\tminimumPayout: 10, // $10 minimum\n\t\t\t\tpayoutSchedule: 'weekly'\n\t\t\t},\n\t\t\tcontent: {\n\t\t\t\tautoApproval: false,\n\t\t\t\tadultContentAllowed: false,\n\t\t\t\tcryptoContentOnly: true,\n\t\t\t\trequireDisclaimer: true\n\t\t\t},\n\t\t\tgovernance: {\n\t\t\t\tenableCommunityVoting: true,\n\t\t\t\tminimumTokensToVote: 1000, // 1000 DGT tokens\n\t\t\t\tvotingPeriodDays: 7,\n\t\t\t\tquorumPercentage: 20 // 20% of token holders\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Update system configuration (admin only)\n\t */\n\tasync updateSystemConfiguration(\n\t\tconfig: Partial<AdSystemConfiguration>,\n\t\tadminUserId: string\n\t): Promise<AdSystemConfiguration> {\n\t\t// TODO: Verify admin permissions\n\n\t\t// Create governance proposal for significant changes\n\t\tif (this.isSignificantChange(config)) {\n\t\t\tawait this.createGovernanceProposal({\n\t\t\t\ttitle: 'Update Ad System Configuration',\n\t\t\t\tdescription: 'Proposed changes to advertising system configuration',\n\t\t\t\tproposerUserId: adminUserId,\n\t\t\t\tproposalType: 'ad_policy',\n\t\t\t\tproposedChanges: config,\n\t\t\t\tcurrentConfiguration: await this.getSystemConfiguration()\n\t\t\t});\n\t\t}\n\n\t\t// For now, return updated configuration\n\t\t// In production, this would be stored in database\n\t\tconst currentConfig = await this.getSystemConfiguration();\n\t\treturn { ...currentConfig, ...config };\n\t}\n\n\t/**\n\t * Create ad placement\n\t */\n\tasync createPlacement(placement: PlacementConfiguration): Promise<AdPlacement> {\n\t\t// Validate placement configuration\n\t\tawait this.validatePlacementConfig(placement);\n\n\t\tconst [newPlacement] = await db\n\t\t\t.insert(adPlacements)\n\t\t\t.values({\n\t\t\t\tname: placement.name,\n\t\t\t\tslug: placement.slug,\n\t\t\t\tdescription: placement.description,\n\t\t\t\tposition: placement.position,\n\t\t\t\tforumZoneSlug: placement.forumZoneSlug,\n\t\t\t\tforumSlug: placement.forumSlug,\n\t\t\t\tallowedFormats: placement.allowedFormats,\n\t\t\t\tdimensions: placement.dimensions,\n\t\t\t\tmaxFileSize: placement.maxFileSize,\n\t\t\t\tfloorPriceCpm: placement.floorPriceCpm.toString(),\n\t\t\t\tmaxDailyImpressions: placement.maxDailyImpressions,\n\t\t\t\tpriority: placement.priority,\n\t\t\t\ttargetingConstraints: placement.targetingConstraints,\n\t\t\t\tdisplayRules: placement.displayRules,\n\t\t\t\trequiresApproval: placement.requiresApproval\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn newPlacement;\n\t}\n\n\t/**\n\t * Update ad placement\n\t */\n\tasync updatePlacement(\n\t\tplacementId: string,\n\t\tupdates: Partial<PlacementConfiguration>\n\t): Promise<AdPlacement> {\n\t\tconst [updatedPlacement] = await db\n\t\t\t.update(adPlacements)\n\t\t\t.set({\n\t\t\t\t...updates,\n\t\t\t\tfloorPriceCpm: updates.floorPriceCpm?.toString(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(adPlacements.id, placementId))\n\t\t\t.returning();\n\n\t\tif (!updatedPlacement) {\n\t\t\tthrow new Error('Placement not found');\n\t\t}\n\n\t\treturn updatedPlacement;\n\t}\n\n\t/**\n\t * List all ad placements\n\t */\n\tasync listPlacements(\n\t\tfilters: {\n\t\t\tposition?: string;\n\t\t\tforumZoneSlug?: string;\n\t\t\tforumSlug?: string;\n\t\t\tisActive?: boolean;\n\t\t} = {}\n\t): Promise<AdPlacement[]> {\n\t\tlet query = db.select().from(adPlacements);\n\n\t\tif (filters.position) {\n\t\t\tquery = query.where(eq(adPlacements.position, filters.position as any));\n\t\t}\n\n\t\tif (filters.forumZoneSlug) {\n\t\t\tquery = query.where(eq(adPlacements.forumZoneSlug, filters.forumZoneSlug));\n\t\t}\n\n\t\tif (filters.forumSlug) {\n\t\t\tquery = query.where(eq(adPlacements.forumSlug, filters.forumSlug));\n\t\t}\n\n\t\tif (filters.isActive !== undefined) {\n\t\t\tquery = query.where(eq(adPlacements.isActive, filters.isActive));\n\t\t}\n\n\t\treturn await query.orderBy(asc(adPlacements.priority));\n\t}\n\n\t/**\n\t * Delete ad placement\n\t */\n\tasync deletePlacement(placementId: string): Promise<void> {\n\t\t// Check if placement has active campaigns\n\t\tconst activeCampaigns = await db\n\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t.from(campaigns)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\tsql`${campaigns.placementRules}::jsonb ? ${placementId}`,\n\t\t\t\t\teq(campaigns.status, 'active')\n\t\t\t\t)\n\t\t\t);\n\n\t\tif (activeCampaigns[0]?.count > 0) {\n\t\t\tthrow new Error('Cannot delete placement with active campaigns');\n\t\t}\n\n\t\tawait db.update(adPlacements).set({ isActive: false }).where(eq(adPlacements.id, placementId));\n\t}\n\n\t/**\n\t * Create global rule\n\t */\n\tasync createGlobalRule(rule: GlobalRule): Promise<CampaignRule> {\n\t\tawait this.validateRuleConfig(rule);\n\n\t\tconst [newRule] = await db\n\t\t\t.insert(campaignRules)\n\t\t\t.values({\n\t\t\t\tname: rule.name,\n\t\t\t\tdescription: rule.description,\n\t\t\t\tcampaignId: null, // Global rule\n\t\t\t\truleType: rule.ruleType,\n\t\t\t\tconditions: rule.conditions,\n\t\t\t\tactions: rule.actions,\n\t\t\t\tpriority: rule.priority,\n\t\t\t\tisActive: rule.isActive,\n\t\t\t\tvalidFrom: rule.validFrom,\n\t\t\t\tvalidUntil: rule.validUntil\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn newRule;\n\t}\n\n\t/**\n\t * Update global rule\n\t */\n\tasync updateGlobalRule(ruleId: string, updates: Partial<GlobalRule>): Promise<CampaignRule> {\n\t\tconst [updatedRule] = await db\n\t\t\t.update(campaignRules)\n\t\t\t.set({\n\t\t\t\t...updates,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(campaignRules.id, ruleId),\n\t\t\t\t\tsql`${campaignRules.campaignId} IS NULL` // Ensure it's a global rule\n\t\t\t\t)\n\t\t\t)\n\t\t\t.returning();\n\n\t\tif (!updatedRule) {\n\t\t\tthrow new Error('Global rule not found');\n\t\t}\n\n\t\treturn updatedRule;\n\t}\n\n\t/**\n\t * List global rules\n\t */\n\tasync listGlobalRules(\n\t\tfilters: {\n\t\t\truleType?: string;\n\t\t\tisActive?: boolean;\n\t\t} = {}\n\t): Promise<CampaignRule[]> {\n\t\tlet query = db\n\t\t\t.select()\n\t\t\t.from(campaignRules)\n\t\t\t.where(sql`${campaignRules.campaignId} IS NULL`);\n\n\t\tif (filters.ruleType) {\n\t\t\tquery = query.where(eq(campaignRules.ruleType, filters.ruleType));\n\t\t}\n\n\t\tif (filters.isActive !== undefined) {\n\t\t\tquery = query.where(eq(campaignRules.isActive, filters.isActive));\n\t\t}\n\n\t\treturn await query.orderBy(asc(campaignRules.priority));\n\t}\n\n\t/**\n\t * Create governance proposal\n\t */\n\tasync createGovernanceProposal(proposal: {\n\t\ttitle: string;\n\t\tdescription: string;\n\t\tproposerUserId: string;\n\t\tproposalType: string;\n\t\tproposedChanges: any;\n\t\tcurrentConfiguration?: any;\n\t}): Promise<AdGovernanceProposal> {\n\t\tconst votingStartAt = new Date();\n\t\tconst votingEndAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days\n\n\t\tconst [newProposal] = await db\n\t\t\t.insert(adGovernanceProposals)\n\t\t\t.values({\n\t\t\t\ttitle: proposal.title,\n\t\t\t\tdescription: proposal.description,\n\t\t\t\tproposerUserId: proposal.proposerUserId,\n\t\t\t\tproposalType: proposal.proposalType,\n\t\t\t\tproposedChanges: proposal.proposedChanges,\n\t\t\t\tcurrentConfiguration: proposal.currentConfiguration,\n\t\t\t\tvotingStartAt,\n\t\t\t\tvotingEndAt,\n\t\t\t\tstatus: 'active'\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn newProposal;\n\t}\n\n\t/**\n\t * Vote on governance proposal\n\t */\n\tasync voteOnProposal(\n\t\tproposalId: string,\n\t\tvoterUserId: string,\n\t\tvote: 'for' | 'against' | 'abstain',\n\t\tvotingPower: number,\n\t\treason?: string\n\t): Promise<void> {\n\t\t// Check if proposal is active\n\t\tconst [proposal] = await db\n\t\t\t.select()\n\t\t\t.from(adGovernanceProposals)\n\t\t\t.where(eq(adGovernanceProposals.id, proposalId))\n\t\t\t.limit(1);\n\n\t\tif (!proposal || proposal.status !== 'active') {\n\t\t\tthrow new Error('Proposal not found or not active');\n\t\t}\n\n\t\tif (new Date() > proposal.votingEndAt) {\n\t\t\tthrow new Error('Voting period has ended');\n\t\t}\n\n\t\t// Check if user already voted\n\t\tconst existingVote = await db\n\t\t\t.select()\n\t\t\t.from(adGovernanceVotes)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(adGovernanceVotes.proposalId, proposalId),\n\t\t\t\t\teq(adGovernanceVotes.voterUserId, voterUserId)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.limit(1);\n\n\t\tif (existingVote.length > 0) {\n\t\t\tthrow new Error('User has already voted on this proposal');\n\t\t}\n\n\t\t// Record vote\n\t\tawait db.insert(adGovernanceVotes).values({\n\t\t\tproposalId,\n\t\t\tvoterUserId,\n\t\t\tvote,\n\t\t\tvotingPower: votingPower.toString(),\n\t\t\tvoteReason: reason\n\t\t});\n\n\t\t// Update proposal vote tallies\n\t\tconst increment = vote === 'for' ? 'votes_for' : vote === 'against' ? 'votes_against' : null;\n\n\t\tif (increment) {\n\t\t\tawait db\n\t\t\t\t.update(adGovernanceProposals)\n\t\t\t\t.set({\n\t\t\t\t\t[increment]: sql`${adGovernanceProposals[increment as keyof typeof adGovernanceProposals]} + 1`,\n\t\t\t\t\ttotalVotingPower: sql`${adGovernanceProposals.totalVotingPower} + ${votingPower}`\n\t\t\t\t})\n\t\t\t\t.where(eq(adGovernanceProposals.id, proposalId));\n\t\t}\n\t}\n\n\t/**\n\t * Execute passed governance proposal\n\t */\n\tasync executeGovernanceProposal(proposalId: string): Promise<void> {\n\t\tconst [proposal] = await db\n\t\t\t.select()\n\t\t\t.from(adGovernanceProposals)\n\t\t\t.where(eq(adGovernanceProposals.id, proposalId))\n\t\t\t.limit(1);\n\n\t\tif (!proposal) {\n\t\t\tthrow new Error('Proposal not found');\n\t\t}\n\n\t\t// Check if proposal passed\n\t\tconst totalVotes = proposal.votesFor + proposal.votesAgainst;\n\t\tconst passingThreshold = totalVotes * 0.6; // 60% majority required\n\n\t\tif (proposal.votesFor < passingThreshold) {\n\t\t\tthrow new Error('Proposal did not pass');\n\t\t}\n\n\t\t// Execute the changes\n\t\ttry {\n\t\t\tawait this.applyProposalChanges(proposal.proposedChanges, proposal.proposalType);\n\n\t\t\t// Mark as executed\n\t\t\tawait db\n\t\t\t\t.update(adGovernanceProposals)\n\t\t\t\t.set({\n\t\t\t\t\tstatus: 'executed',\n\t\t\t\t\texecutedAt: new Date(),\n\t\t\t\t\texecutionResult: { success: true }\n\t\t\t\t})\n\t\t\t\t.where(eq(adGovernanceProposals.id, proposalId));\n\t\t} catch (error) {\n\t\t\t// Mark as failed\n\t\t\tawait db\n\t\t\t\t.update(adGovernanceProposals)\n\t\t\t\t.set({\n\t\t\t\t\tstatus: 'rejected',\n\t\t\t\t\texecutionResult: {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: error instanceof Error ? error.message : 'Unknown error'\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.where(eq(adGovernanceProposals.id, proposalId));\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get placement performance analytics\n\t */\n\tasync getPlacementAnalytics(\n\t\tplacementId: string,\n\t\ttimeRange?: { from: Date; to: Date }\n\t): Promise<{\n\t\timpressions: number;\n\t\tclicks: number;\n\t\trevenue: number;\n\t\tfillRate: number;\n\t\taverageCpm: number;\n\t\ttopPerformingCampaigns: Array<{\n\t\t\tcampaignId: string;\n\t\t\tcampaignName: string;\n\t\t\timpressions: number;\n\t\t\trevenue: number;\n\t\t}>;\n\t}> {\n\t\t// This would be implemented with proper analytics queries\n\t\t// For now, returning mock data\n\t\treturn {\n\t\t\timpressions: 150000,\n\t\t\tclicks: 3500,\n\t\t\trevenue: 2800.5,\n\t\t\tfillRate: 0.85,\n\t\t\taverageCpm: 1.87,\n\t\t\ttopPerformingCampaigns: [\n\t\t\t\t{\n\t\t\t\t\tcampaignId: 'campaign-1',\n\t\t\t\t\tcampaignName: 'DeFi Platform Promo',\n\t\t\t\t\timpressions: 45000,\n\t\t\t\t\trevenue: 850.0\n\t\t\t\t}\n\t\t\t]\n\t\t};\n\t}\n\n\t/**\n\t * Private helper methods\n\t */\n\tprivate async validatePlacementConfig(placement: PlacementConfiguration): Promise<void> {\n\t\tif (!placement.name?.trim()) {\n\t\t\tthrow new Error('Placement name is required');\n\t\t}\n\n\t\tif (!placement.slug?.trim()) {\n\t\t\tthrow new Error('Placement slug is required');\n\t\t}\n\n\t\t// Check slug uniqueness\n\t\tconst existing = await db\n\t\t\t.select()\n\t\t\t.from(adPlacements)\n\t\t\t.where(eq(adPlacements.slug, placement.slug))\n\t\t\t.limit(1);\n\n\t\tif (existing.length > 0 && existing[0].id !== placement.id) {\n\t\t\tthrow new Error('Placement slug must be unique');\n\t\t}\n\n\t\tif (placement.floorPriceCpm < 0) {\n\t\t\tthrow new Error('Floor price cannot be negative');\n\t\t}\n\n\t\tif (placement.priority < 1) {\n\t\t\tthrow new Error('Priority must be at least 1');\n\t\t}\n\t}\n\n\tprivate async validateRuleConfig(rule: GlobalRule): Promise<void> {\n\t\tif (!rule.name?.trim()) {\n\t\t\tthrow new Error('Rule name is required');\n\t\t}\n\n\t\tif (!rule.conditions || rule.conditions.length === 0) {\n\t\t\tthrow new Error('At least one condition is required');\n\t\t}\n\n\t\tif (!rule.actions || rule.actions.length === 0) {\n\t\t\tthrow new Error('At least one action is required');\n\t\t}\n\n\t\t// Validate condition structure\n\t\tfor (const condition of rule.conditions) {\n\t\t\tif (!condition.field || !condition.operator || condition.value === undefined) {\n\t\t\t\tthrow new Error('Each condition must have field, operator, and value');\n\t\t\t}\n\t\t}\n\n\t\t// Validate action structure\n\t\tfor (const action of rule.actions) {\n\t\t\tif (!action.type) {\n\t\t\t\tthrow new Error('Each action must have a type');\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isSignificantChange(config: Partial<AdSystemConfiguration>): boolean {\n\t\t// Define what constitutes a significant change requiring governance\n\t\treturn !!(\n\t\t\tconfig.revenue?.platformCommission ||\n\t\t\tconfig.revenue?.dgtRewardPool ||\n\t\t\tconfig.content?.cryptoContentOnly ||\n\t\t\tconfig.governance\n\t\t);\n\t}\n\n\tprivate async applyProposalChanges(changes: any, proposalType: string): Promise<void> {\n\t\t// Apply configuration changes based on proposal type\n\t\tswitch (proposalType) {\n\t\t\tcase 'ad_policy':\n\t\t\t\t// Update system configuration\n\t\t\t\tbreak;\n\t\t\tcase 'placement_rules':\n\t\t\t\t// Update placement rules\n\t\t\t\tbreak;\n\t\t\tcase 'revenue_share':\n\t\t\t\t// Update revenue sharing configuration\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown proposal type: ${proposalType}`);\n\t\t}\n\t}\n}\n\nexport const adConfigurationService = new AdConfigurationService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/advertising/ad-serving.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'campaignMetrics' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'placement' is defined but never used.","line":124,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":124,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used.","line":125,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":125,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { eq, and, sql, desc, asc } from 'drizzle-orm';\nimport { db } from '@server/src/core/db';\nimport {\n\tcampaigns,\n\tadPlacements,\n\tcampaignRules,\n\tadImpressions,\n\tcampaignMetrics,\n\ttype Campaign,\n\ttype AdPlacement\n} from '@schema';\nimport { logger } from \"../../core/logger\";\n\nexport interface AdRequest {\n\tplacementSlug: string;\n\tuserHash?: string;\n\tsessionId: string;\n\tforumSlug?: string;\n\tthreadId?: string;\n\tdeviceInfo: {\n\t\ttype: 'mobile' | 'desktop' | 'tablet';\n\t\tscreenSize: string;\n\t\tuserAgent: string;\n\t};\n\tgeoData: {\n\t\tregion: string;\n\t\ttimezone: string;\n\t};\n\tuserContext: {\n\t\tdgtBalanceTier?: string;\n\t\txpLevel?: number;\n\t\tinterestSegments?: string[];\n\t\tactivityLevel?: string;\n\t};\n}\n\nexport interface AdResponse {\n\tadId: string;\n\tcampaignId: string;\n\tcreative: {\n\t\ttype: string;\n\t\tcontent: string;\n\t\tdimensions: string;\n\t\tclickUrl: string;\n\t};\n\ttracking: {\n\t\timpressionUrl: string;\n\t\tclickUrl: string;\n\t\tconversionUrl?: string;\n\t};\n\tdgtReward?: {\n\t\tamount: number;\n\t\tcondition: string;\n\t};\n\tmetadata: {\n\t\tbidPrice: number;\n\t\tcurrency: string;\n\t\tqualityScore: number;\n\t};\n}\n\n/**\n * High-performance ad serving engine with sub-100ms response time\n * Implements privacy-preserving targeting and real-time optimization\n */\nexport class AdServingService {\n\t/**\n\t * Main ad serving endpoint - optimized for speed\n\t * Target: <50ms response time for 95% of requests\n\t */\n\tasync serveAd(request: AdRequest): Promise<AdResponse | null> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// 1. Get placement configuration (5ms)\n\t\t\tconst placement = await this.getPlacement(request.placementSlug);\n\t\t\tif (!placement) return null;\n\n\t\t\t// 2. Get eligible campaigns (15ms)\n\t\t\tconst campaigns = await this.getEligibleCampaigns(placement, request);\n\t\t\tif (campaigns.length === 0) return null;\n\n\t\t\t// 3. Apply targeting and rules (20ms)\n\t\t\tconst scoredCampaigns = await this.scoreAndRankCampaigns(campaigns, request, placement);\n\n\t\t\t// 4. Select winning campaign (5ms)\n\t\t\tconst winningCampaign = this.selectWinningCampaign(scoredCampaigns);\n\t\t\tif (!winningCampaign) return null;\n\n\t\t\t// 5. Generate ad response (5ms)\n\t\t\tconst adResponse = await this.generateAdResponse(winningCampaign, placement, request);\n\n\t\t\t// 6. Track impression asynchronously\n\t\t\tthis.trackImpressionAsync(winningCampaign, placement, request, adResponse);\n\n\t\t\tconst responseTime = Date.now() - startTime;\n\t\t\tlogger.info(`Ad served in ${responseTime}ms`);\n\n\t\t\treturn adResponse;\n\t\t} catch (error) {\n\t\t\tlogger.error('Ad serving error:', error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get placement configuration with caching\n\t */\n\tprivate async getPlacement(placementSlug: string): Promise<AdPlacement | null> {\n\t\t// TODO: Add Redis caching layer\n\t\tconst [placement] = await db\n\t\t\t.select()\n\t\t\t.from(adPlacements)\n\t\t\t.where(and(eq(adPlacements.slug, placementSlug), eq(adPlacements.isActive, true)))\n\t\t\t.limit(1);\n\n\t\treturn placement || null;\n\t}\n\n\t/**\n\t * Get campaigns eligible for the placement\n\t */\n\tprivate async getEligibleCampaigns(\n\t\tplacement: AdPlacement,\n\t\trequest: AdRequest\n\t): Promise<Campaign[]> {\n\t\tconst now = new Date();\n\n\t\treturn await db\n\t\t\t.select()\n\t\t\t.from(campaigns)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(campaigns.status, 'active'),\n\t\t\t\t\teq(campaigns.isActive, true),\n\t\t\t\t\t// Budget check\n\t\t\t\t\tsql`${campaigns.spentAmount} < ${campaigns.totalBudget}`,\n\t\t\t\t\t// Date range check\n\t\t\t\t\tsql`${campaigns.startDate} <= ${now}`,\n\t\t\t\t\tsql`(${campaigns.endDate} IS NULL OR ${campaigns.endDate} >= ${now})`\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(desc(campaigns.bidAmount))\n\t\t\t.limit(20); // Limit for performance\n\t}\n\n\t/**\n\t * Score and rank campaigns based on targeting and rules\n\t */\n\tprivate async scoreAndRankCampaigns(\n\t\tcampaigns: Campaign[],\n\t\trequest: AdRequest,\n\t\tplacement: AdPlacement\n\t): Promise<Array<{ campaign: Campaign; score: number; bidPrice: number }>> {\n\t\tconst scoredCampaigns = [];\n\n\t\tfor (const campaign of campaigns) {\n\t\t\t// Check targeting rules\n\t\t\tconst targetingScore = await this.calculateTargetingScore(campaign, request);\n\t\t\tif (targetingScore === 0) continue; // Not targeted\n\n\t\t\t// Apply campaign rules\n\t\t\tconst rulesResult = await this.applyCampaignRules(campaign, request, placement);\n\t\t\tif (rulesResult.blocked) continue;\n\n\t\t\t// Calculate final score\n\t\t\tconst qualityScore = campaign.qualityScore?.toNumber() || 1.0;\n\t\t\tconst bidPrice = rulesResult.adjustedBid || campaign.bidAmount?.toNumber() || 0;\n\t\t\tconst finalScore = targetingScore * qualityScore * bidPrice;\n\n\t\t\tscoredCampaigns.push({\n\t\t\t\tcampaign,\n\t\t\t\tscore: finalScore,\n\t\t\t\tbidPrice\n\t\t\t});\n\t\t}\n\n\t\treturn scoredCampaigns.sort((a, b) => b.score - a.score);\n\t}\n\n\t/**\n\t * Calculate targeting score (0-1) based on user profile\n\t */\n\tprivate async calculateTargetingScore(campaign: Campaign, request: AdRequest): Promise<number> {\n\t\tconst targetingRules = campaign.targetingRules as any;\n\t\tif (!targetingRules || Object.keys(targetingRules).length === 0) {\n\t\t\treturn 1.0; // No targeting = everyone\n\t\t}\n\n\t\tlet score = 1.0;\n\n\t\t// Device targeting\n\t\tif (targetingRules.deviceTypes?.length > 0) {\n\t\t\tif (!targetingRules.deviceTypes.includes(request.deviceInfo.type)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t// Geographic targeting\n\t\tif (targetingRules.geoRegions?.length > 0) {\n\t\t\tif (!targetingRules.geoRegions.includes(request.geoData.region)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t// Interest targeting\n\t\tif (targetingRules.interestSegments?.length > 0 && request.userContext.interestSegments) {\n\t\t\tconst overlap = targetingRules.interestSegments.filter((segment: string) =>\n\t\t\t\trequest.userContext.interestSegments!.includes(segment)\n\t\t\t);\n\t\t\tscore *= overlap.length / targetingRules.interestSegments.length;\n\t\t}\n\n\t\t// DGT balance targeting\n\t\tif (targetingRules.dgtBalanceTiers?.length > 0) {\n\t\t\tif (!targetingRules.dgtBalanceTiers.includes(request.userContext.dgtBalanceTier)) {\n\t\t\t\tscore *= 0.5; // Partial match\n\t\t\t}\n\t\t}\n\n\t\t// XP level targeting\n\t\tif (targetingRules.minXpLevel && request.userContext.xpLevel) {\n\t\t\tif (request.userContext.xpLevel < targetingRules.minXpLevel) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.max(0, Math.min(1, score));\n\t}\n\n\t/**\n\t * Apply campaign rules for dynamic configuration\n\t */\n\tprivate async applyCampaignRules(\n\t\tcampaign: Campaign,\n\t\trequest: AdRequest,\n\t\tplacement: AdPlacement\n\t): Promise<{ blocked: boolean; adjustedBid?: Id<'adjustedBid'>; metadata?: any }> {\n\t\t// Get applicable rules\n\t\tconst rules = await db\n\t\t\t.select()\n\t\t\t.from(campaignRules)\n\t\t\t.where(and(eq(campaignRules.campaignId, campaign.id), eq(campaignRules.isActive, true)))\n\t\t\t.orderBy(asc(campaignRules.priority));\n\n\t\tlet blocked = false;\n\t\tlet bidMultiplier = 1.0;\n\t\tconst metadata: any = {};\n\n\t\tfor (const rule of rules) {\n\t\t\tconst ruleResult = this.evaluateRule(rule, request, placement);\n\n\t\t\tif (ruleResult.block) {\n\t\t\t\tblocked = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ruleResult.bidAdjustment) {\n\t\t\t\tbidMultiplier *= ruleResult.bidAdjustment;\n\t\t\t}\n\n\t\t\tif (ruleResult.metadata) {\n\t\t\t\tObject.assign(metadata, ruleResult.metadata);\n\t\t\t}\n\t\t}\n\n\t\tconst originalBid = campaign.bidAmount?.toNumber() || 0;\n\t\tconst adjustedBid = originalBid * bidMultiplier;\n\n\t\treturn {\n\t\t\tblocked,\n\t\t\tadjustedBid: adjustedBid !== originalBid ? adjustedBid : undefined,\n\t\t\tmetadata: Object.keys(metadata).length > 0 ? metadata : undefined\n\t\t};\n\t}\n\n\t/**\n\t * Evaluate individual campaign rule\n\t */\n\tprivate evaluateRule(\n\t\trule: any,\n\t\trequest: AdRequest,\n\t\tplacement: AdPlacement\n\t): { block?: boolean; bidAdjustment?: number; metadata?: any } {\n\t\tconst conditions = rule.conditions as any[];\n\t\tconst actions = rule.actions as any[];\n\n\t\t// Check all conditions\n\t\tfor (const condition of conditions) {\n\t\t\tif (!this.evaluateCondition(condition, request, placement)) {\n\t\t\t\treturn {}; // Condition not met, skip rule\n\t\t\t}\n\t\t}\n\n\t\t// All conditions met, apply actions\n\t\tconst result: any = {};\n\n\t\tfor (const action of actions) {\n\t\t\tswitch (action.type) {\n\t\t\t\tcase 'block_ad':\n\t\t\t\t\tresult.block = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'adjust_bid':\n\t\t\t\t\tresult.bidAdjustment = action.parameters.multiplier;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'set_metadata':\n\t\t\t\t\tresult.metadata = { ...result.metadata, ...action.parameters };\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Evaluate rule condition\n\t */\n\tprivate evaluateCondition(condition: any, request: AdRequest, placement: AdPlacement): boolean {\n\t\tconst { field, operator, value } = condition;\n\n\t\tlet fieldValue: any;\n\n\t\t// Extract field value from request\n\t\tswitch (field) {\n\t\t\tcase 'device.type':\n\t\t\t\tfieldValue = request.deviceInfo.type;\n\t\t\t\tbreak;\n\t\t\tcase 'geo.region':\n\t\t\t\tfieldValue = request.geoData.region;\n\t\t\t\tbreak;\n\t\t\tcase 'user.xpLevel':\n\t\t\t\tfieldValue = request.userContext.xpLevel;\n\t\t\t\tbreak;\n\t\t\tcase 'user.dgtBalanceTier':\n\t\t\t\tfieldValue = request.userContext.dgtBalanceTier;\n\t\t\t\tbreak;\n\t\t\tcase 'placement.priority':\n\t\t\t\tfieldValue = placement.priority;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\t// Apply operator\n\t\tswitch (operator) {\n\t\t\tcase 'equals':\n\t\t\t\treturn fieldValue === value;\n\t\t\tcase 'not_equals':\n\t\t\t\treturn fieldValue !== value;\n\t\t\tcase 'greater_than':\n\t\t\t\treturn Number(fieldValue) > Number(value);\n\t\t\tcase 'less_than':\n\t\t\t\treturn Number(fieldValue) < Number(value);\n\t\t\tcase 'in':\n\t\t\t\treturn Array.isArray(value) && value.includes(fieldValue);\n\t\t\tcase 'contains':\n\t\t\t\treturn Array.isArray(fieldValue) && fieldValue.includes(value);\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Select winning campaign using auction logic\n\t */\n\tprivate selectWinningCampaign(\n\t\tscoredCampaigns: Array<{ campaign: Campaign; score: number; bidPrice: number }>\n\t): { campaign: Campaign; bidPrice: number } | null {\n\t\tif (scoredCampaigns.length === 0) return null;\n\n\t\t// Simple highest score wins (could implement second-price auction)\n\t\treturn scoredCampaigns[0];\n\t}\n\n\t/**\n\t * Generate final ad response\n\t */\n\tprivate async generateAdResponse(\n\t\twinner: { campaign: Campaign; bidPrice: number },\n\t\tplacement: AdPlacement,\n\t\trequest: AdRequest\n\t): Promise<AdResponse> {\n\t\tconst { campaign, bidPrice } = winner;\n\t\tconst creativeAssets = campaign.creativeAssets as any;\n\n\t\t// Select appropriate creative based on placement\n\t\tconst creative = this.selectCreative(creativeAssets, placement);\n\n\t\t// Generate tracking URLs\n\t\tconst trackingUrls = this.generateTrackingUrls(campaign.id, placement.id, request.sessionId);\n\n\t\t// Calculate DGT reward if applicable\n\t\tconst dgtReward = this.calculateDgtReward(campaign, request);\n\n\t\treturn {\n\t\t\tadId: `ad_${campaign.id}_${Date.now()}`,\n\t\t\tcampaignId: campaign.id,\n\t\t\tcreative: {\n\t\t\t\ttype: creative.type,\n\t\t\t\tcontent: creative.content,\n\t\t\t\tdimensions: placement.dimensions || '300x250',\n\t\t\t\tclickUrl: trackingUrls.clickUrl\n\t\t\t},\n\t\t\ttracking: trackingUrls,\n\t\t\tdgtReward,\n\t\t\tmetadata: {\n\t\t\t\tbidPrice,\n\t\t\t\tcurrency: 'DGT',\n\t\t\t\tqualityScore: campaign.qualityScore?.toNumber() || 1.0\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Select appropriate creative for placement\n\t */\n\tprivate selectCreative(creativeAssets: any[], placement: AdPlacement): any {\n\t\t// Find creative that matches placement dimensions\n\t\tconst matchingCreative = creativeAssets.find(\n\t\t\t(creative) => creative.dimensions === placement.dimensions\n\t\t);\n\n\t\treturn (\n\t\t\tmatchingCreative ||\n\t\t\tcreativeAssets[0] || {\n\t\t\t\ttype: 'banner',\n\t\t\t\tcontent: '<div>Default Ad</div>',\n\t\t\t\tdimensions: placement.dimensions\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Generate tracking URLs for analytics\n\t */\n\tprivate generateTrackingUrls(\n\t\tcampaignId: string,\n\t\tplacementId: string,\n\t\tsessionId: string\n\t): { impressionUrl: string; clickUrl: string; conversionUrl?: string } {\n\t\tconst baseUrl = process.env.DOMAIN || 'https://degentalk.com';\n\t\tconst trackingParams = `campaign=${campaignId}&placement=${placementId}&session=${sessionId}`;\n\n\t\treturn {\n\t\t\timpressionUrl: `${baseUrl}/api/ad/track/impression?${trackingParams}`,\n\t\t\tclickUrl: `${baseUrl}/api/ad/track/click?${trackingParams}`,\n\t\t\tconversionUrl: `${baseUrl}/api/ad/track/conversion?${trackingParams}`\n\t\t};\n\t}\n\n\t/**\n\t * Calculate DGT reward for user engagement\n\t */\n\tprivate calculateDgtReward(\n\t\tcampaign: Campaign,\n\t\trequest: AdRequest\n\t): { amount: number; condition: string } | undefined {\n\t\tconst campaignType = campaign.type;\n\n\t\tif (campaignType === 'user_reward') {\n\t\t\t// User gets DGT for viewing/clicking ads\n\t\t\tconst baseReward = 0.1; // 0.1 DGT base\n\t\t\tconst xpMultiplier = Math.min(2.0, 1 + (request.userContext.xpLevel || 1) / 100);\n\n\t\t\treturn {\n\t\t\t\tamount: baseReward * xpMultiplier,\n\t\t\t\tcondition: 'click'\n\t\t\t};\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Track impression asynchronously to avoid blocking response\n\t */\n\tprivate async trackImpressionAsync(\n\t\twinner: { campaign: Campaign; bidPrice: number },\n\t\tplacement: AdPlacement,\n\t\trequest: AdRequest,\n\t\tresponse: AdResponse\n\t): Promise<void> {\n\t\t// Use setTimeout to avoid blocking the response\n\t\tsetTimeout(async () => {\n\t\t\ttry {\n\t\t\t\tawait db.insert(adImpressions).values({\n\t\t\t\t\tid: BigInt(Date.now()), // Simple ID generation\n\t\t\t\t\tcampaignId: winner.campaign.id,\n\t\t\t\t\tplacementId: placement.id,\n\t\t\t\t\tuserHash: request.userHash || null,\n\t\t\t\t\tsessionId: request.sessionId,\n\t\t\t\t\tinteractionType: 'impression',\n\t\t\t\t\tbidPrice: winner.bidPrice.toString(),\n\t\t\t\t\tpaidPrice: winner.bidPrice.toString(),\n\t\t\t\t\trevenue: (winner.bidPrice * 0.7).toString(), // 70% revenue share\n\t\t\t\t\tcurrency: 'DGT',\n\t\t\t\t\tforumSlug: request.forumSlug || null,\n\t\t\t\t\tthreadId: request.threadId || null,\n\t\t\t\t\tdeviceInfo: request.deviceInfo,\n\t\t\t\t\tgeoData: request.geoData,\n\t\t\t\t\tdgtRewardAmount: response.dgtReward?.amount?.toString() || null,\n\t\t\t\t\tqualityScore: response.metadata.qualityScore.toString()\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('Failed to track impression:', error);\n\t\t\t}\n\t\t}, 0);\n\t}\n}\n\nexport const adServingService = new AdServingService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/advertising/ad.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/advertising/ad.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/advertising/campaign-management.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adPlacements' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":6,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { eq, and, sql, desc, count } from 'drizzle-orm';\nimport { db } from '@server/src/core/db';\nimport {\n\tcampaigns,\n\tcampaignRules,\n\tadPlacements,\n\tcryptoPayments,\n\tcampaignMetrics,\n\ttype Campaign,\n\ttype CampaignRule,\n\ttype CryptoPayment\n} from '@schema';\n\nexport interface CreateCampaignRequest {\n\tname: string;\n\tdescription?: string;\n\ttype:\n\t\t| 'display_banner'\n\t\t| 'sponsored_thread'\n\t\t| 'forum_spotlight'\n\t\t| 'user_reward'\n\t\t| 'native_content';\n\ttotalBudget: number;\n\tdailyBudget?: number;\n\tpaymentMethod: 'dgt_tokens' | 'usdt' | 'bitcoin' | 'ethereum' | 'stripe';\n\tpricingModel: 'CPM' | 'CPC' | 'CPA' | 'FLAT';\n\tbidAmount: number;\n\tstartDate?: Date;\n\tendDate?: Date;\n\ttargetingRules: any;\n\tplacementRules: any;\n\tfrequencyCap: any;\n\tcreativeAssets: any[];\n\toptimizationGoal?: string;\n}\n\nexport interface UpdateCampaignRequest extends Partial<CreateCampaignRequest> {\n\tstatus?: 'draft' | 'active' | 'paused' | 'completed' | 'cancelled';\n}\n\nexport interface CampaignAnalytics {\n\timpressions: number;\n\tclicks: number;\n\tconversions: number;\n\tspend: number;\n\trevenue: number;\n\tctr: number;\n\tcpm: number;\n\tcpc: number;\n\troas: number;\n\tdgtRewards: number;\n\ttimeSeriesData: {\n\t\tdate: string;\n\t\timpressions: number;\n\t\tclicks: number;\n\t\tspend: number;\n\t}[];\n}\n\n/**\n * Campaign Management Service\n * Handles CRUD operations, budget management, and performance optimization\n */\nexport class CampaignManagementService {\n\t/**\n\t * Create a new advertising campaign\n\t */\n\tasync createCampaign(\n\t\tadvertiserUserId: string,\n\t\trequest: CreateCampaignRequest\n\t): Promise<{ campaign: Campaign; paymentRequired?: CryptoPayment }> {\n\t\t// Validate campaign configuration\n\t\tawait this.validateCampaignRequest(request);\n\n\t\t// Create campaign in draft status\n\t\tconst [campaign] = await db\n\t\t\t.insert(campaigns)\n\t\t\t.values({\n\t\t\t\tname: request.name,\n\t\t\t\tdescription: request.description,\n\t\t\t\tadvertiserUserId,\n\t\t\t\ttype: request.type,\n\t\t\t\tstatus: 'draft',\n\t\t\t\ttotalBudget: request.totalBudget.toString(),\n\t\t\t\tdailyBudget: request.dailyBudget?.toString(),\n\t\t\t\tpaymentMethod: request.paymentMethod,\n\t\t\t\tpricingModel: request.pricingModel,\n\t\t\t\tbidAmount: request.bidAmount.toString(),\n\t\t\t\tstartDate: request.startDate,\n\t\t\t\tendDate: request.endDate,\n\t\t\t\ttargetingRules: request.targetingRules,\n\t\t\t\tplacementRules: request.placementRules,\n\t\t\t\tfrequencyCap: request.frequencyCap,\n\t\t\t\tcreativeAssets: request.creativeAssets,\n\t\t\t\toptimizationGoal: request.optimizationGoal\n\t\t\t})\n\t\t\t.returning();\n\n\t\t// Handle payment if required\n\t\tlet paymentRequired: CryptoPayment | undefined;\n\t\tif (request.paymentMethod !== 'stripe' && request.totalBudget > 0) {\n\t\t\tpaymentRequired = await this.createCryptoPayment(campaign, advertiserUserId);\n\t\t}\n\n\t\treturn { campaign, paymentRequired };\n\t}\n\n\t/**\n\t * Update existing campaign\n\t */\n\tasync updateCampaign(\n\t\tcampaignId: string,\n\t\tadvertiserUserId: string,\n\t\trequest: UpdateCampaignRequest\n\t): Promise<Campaign> {\n\t\t// Verify ownership\n\t\tawait this.verifyCampaignOwnership(campaignId, advertiserUserId);\n\n\t\t// Validate status transitions\n\t\tif (request.status) {\n\t\t\tawait this.validateStatusTransition(campaignId, request.status);\n\t\t}\n\n\t\tconst [updatedCampaign] = await db\n\t\t\t.update(campaigns)\n\t\t\t.set({\n\t\t\t\t...request,\n\t\t\t\ttotalBudget: request.totalBudget?.toString(),\n\t\t\t\tdailyBudget: request.dailyBudget?.toString(),\n\t\t\t\tbidAmount: request.bidAmount?.toString(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(campaigns.id, campaignId))\n\t\t\t.returning();\n\n\t\treturn updatedCampaign;\n\t}\n\n\t/**\n\t * Get campaign details with analytics\n\t */\n\tasync getCampaign(\n\t\tcampaignId: string,\n\t\tadvertiserUserId: string\n\t): Promise<Campaign & { analytics: CampaignAnalytics }> {\n\t\t// Verify ownership\n\t\tawait this.verifyCampaignOwnership(campaignId, advertiserUserId);\n\n\t\tconst [campaign] = await db\n\t\t\t.select()\n\t\t\t.from(campaigns)\n\t\t\t.where(eq(campaigns.id, campaignId))\n\t\t\t.limit(1);\n\n\t\tif (!campaign) {\n\t\t\tthrow new Error('Campaign not found');\n\t\t}\n\n\t\tconst analytics = await this.getCampaignAnalytics(campaignId);\n\n\t\treturn { ...campaign, analytics };\n\t}\n\n\t/**\n\t * List campaigns for advertiser\n\t */\n\tasync listCampaigns(\n\t\tadvertiserUserId: string,\n\t\tfilters: {\n\t\t\tstatus?: string;\n\t\t\ttype?: string;\n\t\t\tlimit?: number;\n\t\t\toffset?: number;\n\t\t} = {}\n\t): Promise<{ campaigns: Campaign[]; total: number }> {\n\t\tconst { limit = 20, offset = 0 } = filters;\n\n\t\tlet query = db.select().from(campaigns).where(eq(campaigns.advertiserUserId, advertiserUserId));\n\n\t\tif (filters.status) {\n\t\t\tquery = query.where(eq(campaigns.status, filters.status as any));\n\t\t}\n\n\t\tif (filters.type) {\n\t\t\tquery = query.where(eq(campaigns.type, filters.type as any));\n\t\t}\n\n\t\tconst campaignsList = await query\n\t\t\t.orderBy(desc(campaigns.createdAt))\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\n\t\tconst [{ total }] = await db\n\t\t\t.select({ total: count() })\n\t\t\t.from(campaigns)\n\t\t\t.where(eq(campaigns.advertiserUserId, advertiserUserId));\n\n\t\treturn { campaigns: campaignsList, total };\n\t}\n\n\t/**\n\t * Delete campaign (soft delete)\n\t */\n\tasync deleteCampaign(campaignId: string, advertiserUserId: string): Promise<void> {\n\t\tawait this.verifyCampaignOwnership(campaignId, advertiserUserId);\n\n\t\t// Check if campaign is running\n\t\tconst [campaign] = await db\n\t\t\t.select({ status: campaigns.status })\n\t\t\t.from(campaigns)\n\t\t\t.where(eq(campaigns.id, campaignId))\n\t\t\t.limit(1);\n\n\t\tif (campaign?.status === 'active') {\n\t\t\tthrow new Error('Cannot delete active campaign. Pause it first.');\n\t\t}\n\n\t\t// Soft delete by setting status to cancelled\n\t\tawait db\n\t\t\t.update(campaigns)\n\t\t\t.set({ status: 'cancelled', isActive: false, updatedAt: new Date() })\n\t\t\t.where(eq(campaigns.id, campaignId));\n\t}\n\n\t/**\n\t * Create campaign rule for dynamic configuration\n\t */\n\tasync createCampaignRule(\n\t\tcampaignId: string,\n\t\tadvertiserUserId: string,\n\t\trule: {\n\t\t\tname: string;\n\t\t\tdescription?: string;\n\t\t\truleType: string;\n\t\t\tconditions: any[];\n\t\t\tactions: any[];\n\t\t\tpriority?: number;\n\t\t\tvalidFrom?: Date;\n\t\t\tvalidUntil?: Date;\n\t\t}\n\t): Promise<CampaignRule> {\n\t\tawait this.verifyCampaignOwnership(campaignId, advertiserUserId);\n\n\t\tconst [campaignRule] = await db\n\t\t\t.insert(campaignRules)\n\t\t\t.values({\n\t\t\t\tname: rule.name,\n\t\t\t\tdescription: rule.description,\n\t\t\t\tcampaignId,\n\t\t\t\truleType: rule.ruleType,\n\t\t\t\tconditions: rule.conditions,\n\t\t\t\tactions: rule.actions,\n\t\t\t\tpriority: rule.priority || 1,\n\t\t\t\tvalidFrom: rule.validFrom,\n\t\t\t\tvalidUntil: rule.validUntil\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn campaignRule;\n\t}\n\n\t/**\n\t * Get campaign analytics\n\t */\n\tasync getCampaignAnalytics(\n\t\tcampaignId: string,\n\t\ttimeRange?: { from: Date; to: Date }\n\t): Promise<CampaignAnalytics> {\n\t\tconst from = timeRange?.from || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days ago\n\t\tconst to = timeRange?.to || new Date();\n\n\t\t// Get aggregated metrics\n\t\tconst [metricsResult] = await db\n\t\t\t.select({\n\t\t\t\timpressions: sql<number>`COALESCE(SUM(${campaignMetrics.impressions}), 0)`,\n\t\t\t\tclicks: sql<number>`COALESCE(SUM(${campaignMetrics.clicks}), 0)`,\n\t\t\t\tconversions: sql<number>`COALESCE(SUM(${campaignMetrics.conversions}), 0)`,\n\t\t\t\tspend: sql<number>`COALESCE(SUM(${campaignMetrics.spend}), 0)`,\n\t\t\t\trevenue: sql<number>`COALESCE(SUM(${campaignMetrics.revenue}), 0)`,\n\t\t\t\tdgtRewards: sql<number>`COALESCE(SUM(${campaignMetrics.dgtRewards}), 0)`\n\t\t\t})\n\t\t\t.from(campaignMetrics)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(campaignMetrics.campaignId, campaignId),\n\t\t\t\t\tsql`${campaignMetrics.dateHour} >= ${from}`,\n\t\t\t\t\tsql`${campaignMetrics.dateHour} <= ${to}`\n\t\t\t\t)\n\t\t\t);\n\n\t\t// Calculate derived metrics\n\t\tconst ctr =\n\t\t\tmetricsResult.impressions > 0 ? metricsResult.clicks / metricsResult.impressions : 0;\n\t\tconst cpm =\n\t\t\tmetricsResult.impressions > 0 ? (metricsResult.spend / metricsResult.impressions) * 1000 : 0;\n\t\tconst cpc = metricsResult.clicks > 0 ? metricsResult.spend / metricsResult.clicks : 0;\n\t\tconst roas = metricsResult.spend > 0 ? metricsResult.revenue / metricsResult.spend : 0;\n\n\t\t// Get time series data (daily aggregation)\n\t\tconst timeSeriesData = await db\n\t\t\t.select({\n\t\t\t\tdate: sql<string>`DATE(${campaignMetrics.dateHour})`,\n\t\t\t\timpressions: sql<number>`SUM(${campaignMetrics.impressions})`,\n\t\t\t\tclicks: sql<number>`SUM(${campaignMetrics.clicks})`,\n\t\t\t\tspend: sql<number>`SUM(${campaignMetrics.spend})`\n\t\t\t})\n\t\t\t.from(campaignMetrics)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(campaignMetrics.campaignId, campaignId),\n\t\t\t\t\tsql`${campaignMetrics.dateHour} >= ${from}`,\n\t\t\t\t\tsql`${campaignMetrics.dateHour} <= ${to}`\n\t\t\t\t)\n\t\t\t)\n\t\t\t.groupBy(sql`DATE(${campaignMetrics.dateHour})`)\n\t\t\t.orderBy(sql`DATE(${campaignMetrics.dateHour})`);\n\n\t\treturn {\n\t\t\t...metricsResult,\n\t\t\tctr,\n\t\t\tcpm,\n\t\t\tcpc,\n\t\t\troas,\n\t\t\ttimeSeriesData\n\t\t};\n\t}\n\n\t/**\n\t * Get bid recommendations based on performance data\n\t */\n\tasync getBidRecommendations(campaignId: string): Promise<{\n\t\tcurrentBid: Id<'currentBid'>;\n\t\trecommendedBid: Id<'recommendedBid'>;\n\t\treasoning: string;\n\t\texpectedImprovement: {\n\t\t\timpressions: number;\n\t\t\tclicks: number;\n\t\t\tconversions: number;\n\t\t};\n\t}> {\n\t\tconst [campaign] = await db\n\t\t\t.select()\n\t\t\t.from(campaigns)\n\t\t\t.where(eq(campaigns.id, campaignId))\n\t\t\t.limit(1);\n\n\t\tif (!campaign) {\n\t\t\tthrow new Error('Campaign not found');\n\t\t}\n\n\t\tconst analytics = await this.getCampaignAnalytics(campaignId);\n\t\tconst currentBid = campaign.bidAmount?.toNumber() || 0;\n\n\t\t// Simple bid optimization logic\n\t\tlet recommendedBid = currentBid;\n\t\tlet reasoning = 'Current bid is optimal';\n\n\t\tif (analytics.ctr > 0.02) {\n\t\t\t// High CTR, can afford to bid higher\n\t\t\trecommendedBid = currentBid * 1.2;\n\t\t\treasoning = 'High click-through rate suggests you can bid higher to get more volume';\n\t\t} else if (analytics.ctr < 0.005) {\n\t\t\t// Low CTR, need to improve targeting or creative\n\t\t\trecommendedBid = currentBid * 0.8;\n\t\t\treasoning = 'Low click-through rate suggests reducing bid or improving targeting';\n\t\t}\n\n\t\t// Cap bid adjustments\n\t\trecommendedBid = Math.max(0.01, Math.min(currentBid * 2, recommendedBid));\n\n\t\treturn {\n\t\t\tcurrentBid,\n\t\t\trecommendedBid: Math.round(recommendedBid * 100) / 100,\n\t\t\treasoning,\n\t\t\texpectedImprovement: {\n\t\t\t\timpressions: Math.round((recommendedBid / currentBid - 1) * analytics.impressions),\n\t\t\t\tclicks: Math.round((recommendedBid / currentBid - 1) * analytics.clicks * 0.8),\n\t\t\t\tconversions: Math.round((recommendedBid / currentBid - 1) * analytics.conversions * 0.6)\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Optimize campaign performance automatically\n\t */\n\tasync optimizeCampaign(\n\t\tcampaignId: string,\n\t\tadvertiserUserId: string\n\t): Promise<{\n\t\tchanges: string[];\n\t\texpectedImprovement: string;\n\t}> {\n\t\tawait this.verifyCampaignOwnership(campaignId, advertiserUserId);\n\n\t\tconst analytics = await this.getCampaignAnalytics(campaignId);\n\t\tconst bidRecommendation = await this.getBidRecommendations(campaignId);\n\n\t\tconst changes: string[] = [];\n\n\t\t// Apply bid optimization\n\t\tif (Math.abs(bidRecommendation.recommendedBid - bidRecommendation.currentBid) > 0.01) {\n\t\t\tawait db\n\t\t\t\t.update(campaigns)\n\t\t\t\t.set({\n\t\t\t\t\tbidAmount: bidRecommendation.recommendedBid.toString(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(campaigns.id, campaignId));\n\n\t\t\tchanges.push(\n\t\t\t\t`Adjusted bid from $${bidRecommendation.currentBid} to $${bidRecommendation.recommendedBid}`\n\t\t\t);\n\t\t}\n\n\t\t// Pause underperforming campaigns\n\t\tif (analytics.spend > 50 && analytics.roas < 0.5) {\n\t\t\tawait db\n\t\t\t\t.update(campaigns)\n\t\t\t\t.set({ status: 'paused', updatedAt: new Date() })\n\t\t\t\t.where(eq(campaigns.id, campaignId));\n\n\t\t\tchanges.push('Paused campaign due to poor performance (ROAS < 0.5)');\n\t\t}\n\n\t\treturn {\n\t\t\tchanges,\n\t\t\texpectedImprovement: bidRecommendation.reasoning\n\t\t};\n\t}\n\n\t/**\n\t * Private helper methods\n\t */\n\tprivate async validateCampaignRequest(request: CreateCampaignRequest): Promise<void> {\n\t\tif (!request.name?.trim()) {\n\t\t\tthrow new Error('Campaign name is required');\n\t\t}\n\n\t\tif (request.totalBudget <= 0) {\n\t\t\tthrow new Error('Total budget must be greater than 0');\n\t\t}\n\n\t\tif (request.bidAmount <= 0) {\n\t\t\tthrow new Error('Bid amount must be greater than 0');\n\t\t}\n\n\t\tif (request.dailyBudget && request.dailyBudget > request.totalBudget) {\n\t\t\tthrow new Error('Daily budget cannot exceed total budget');\n\t\t}\n\n\t\tif (request.endDate && request.startDate && request.endDate <= request.startDate) {\n\t\t\tthrow new Error('End date must be after start date');\n\t\t}\n\n\t\t// Validate creative assets\n\t\tif (!request.creativeAssets || request.creativeAssets.length === 0) {\n\t\t\tthrow new Error('At least one creative asset is required');\n\t\t}\n\t}\n\n\tprivate async verifyCampaignOwnership(\n\t\tcampaignId: string,\n\t\tadvertiserUserId: string\n\t): Promise<void> {\n\t\tconst [campaign] = await db\n\t\t\t.select({ advertiserUserId: campaigns.advertiserUserId })\n\t\t\t.from(campaigns)\n\t\t\t.where(eq(campaigns.id, campaignId))\n\t\t\t.limit(1);\n\n\t\tif (!campaign || campaign.advertiserUserId !== advertiserUserId) {\n\t\t\tthrow new Error('Campaign not found or access denied');\n\t\t}\n\t}\n\n\tprivate async validateStatusTransition(campaignId: string, newStatus: string): Promise<void> {\n\t\tconst [campaign] = await db\n\t\t\t.select({ status: campaigns.status })\n\t\t\t.from(campaigns)\n\t\t\t.where(eq(campaigns.id, campaignId))\n\t\t\t.limit(1);\n\n\t\tif (!campaign) {\n\t\t\tthrow new Error('Campaign not found');\n\t\t}\n\n\t\tconst currentStatus = campaign.status;\n\n\t\t// Define valid transitions\n\t\tconst validTransitions: Record<string, string[]> = {\n\t\t\tdraft: ['active', 'cancelled'],\n\t\t\tactive: ['paused', 'completed', 'cancelled'],\n\t\t\tpaused: ['active', 'cancelled'],\n\t\t\tcompleted: [],\n\t\t\tcancelled: []\n\t\t};\n\n\t\tif (!validTransitions[currentStatus]?.includes(newStatus)) {\n\t\t\tthrow new Error(`Cannot transition from ${currentStatus} to ${newStatus}`);\n\t\t}\n\t}\n\n\tprivate async createCryptoPayment(\n\t\tcampaign: Campaign,\n\t\tadvertiserUserId: string\n\t): Promise<CryptoPayment> {\n\t\tconst [payment] = await db\n\t\t\t.insert(cryptoPayments)\n\t\t\t.values({\n\t\t\t\tpaymentHash: `payment_${campaign.id}_${Date.now()}`,\n\t\t\t\tcampaignId: campaign.id,\n\t\t\t\tpayerUserId: advertiserUserId,\n\t\t\t\tcurrency: campaign.paymentMethod === 'dgt_tokens' ? 'DGT' : 'USDT',\n\t\t\t\tamount: campaign.totalBudget!.toString(),\n\t\t\t\tstatus: 'pending',\n\t\t\t\trequiredConfirmations: campaign.paymentMethod === 'dgt_tokens' ? 1 : 3,\n\t\t\t\texpiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn payment;\n\t}\n}\n\nexport const campaignManagementService = new CampaignManagementService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/advertising/user-promotion.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":139,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":139,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":172,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":172,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport { Router } from 'express';\nimport { z } from 'zod';\nimport { userPromotionService } from './user-promotion.service';\nimport { isAuthenticated, isAdmin } from '../auth/middleware/auth.middleware';\nimport { logger } from \"../../core/logger\";\n\nconst router = Router();\n\n// Validation schemas\nconst createUserPromotionSchema = z.object({\n\ttype: z.enum([\n\t\t'thread_boost',\n\t\t'announcement_bar',\n\t\t'pinned_shoutbox',\n\t\t'profile_spotlight',\n\t\t'achievement_highlight'\n\t]),\n\tcontentId: z.string().uuid().optional(),\n\ttitle: z.string().min(1).max(255),\n\tdescription: z.string().max(1000).optional(),\n\timageUrl: z.string().url().optional(),\n\tlinkUrl: z.string().url().optional(),\n\ttargetPlacement: z.string().max(100).optional(),\n\tduration: z.enum(['1h', '6h', '12h', '1d', '3d', '1w']),\n\tstartTime: z.string().datetime().optional(),\n\tautoRenew: z.boolean().optional(),\n\tmaxDailySpend: z.number().positive().optional(),\n\ttargetAudience: z.object({}).passthrough().optional()\n});\n\nconst extendPromotionSchema = z.object({\n\tadditionalHours: z.number().positive().max(168) // Max 1 week extension\n});\n\nconst moderationActionSchema = z.object({\n\taction: z.enum(['approve', 'reject']),\n\tnotes: z.string().max(500).optional(),\n\trejectionReason: z.string().max(500).optional()\n});\n\n// ============================================================================\n// USER PROMOTION MANAGEMENT ROUTES\n// ============================================================================\n\n/**\n * Create new user promotion\n * POST /api/ads/user-promotions\n */\nrouter.post('/user-promotions', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\treturn res.status(401).json({ error: 'User not authenticated' });\n\t\t}\n\n\t\tconst promotionData = createUserPromotionSchema.parse(req.body);\n\n\t\tconst result = await userPromotionService.createPromotion(userId, {\n\t\t\t...promotionData,\n\t\t\tstartTime: promotionData.startTime ? new Date(promotionData.startTime) : undefined\n\t\t});\n\n\t\tres.status(201).json(result);\n\t} catch (error) {\n\t\tlogger.error('Create user promotion error:', error);\n\t\tres.status(400).json({\n\t\t\terror: 'Failed to create promotion',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Get user's promotions\n * GET /api/ads/user-promotions\n */\nrouter.get('/user-promotions', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\treturn res.status(401).json({ error: 'User not authenticated' });\n\t\t}\n\n\t\tconst filters = {\n\t\t\tstatus: req.query.status as string,\n\t\t\ttype: req.query.type as string,\n\t\t\tlimit: req.query.limit ? parseInt(req.query.limit as string) : 20,\n\t\t\toffset: req.query.offset ? parseInt(req.query.offset as string) : 0\n\t\t};\n\n\t\tconst result = await userPromotionService.getUserPromotions(userId, filters);\n\t\tres.json(result);\n\t} catch (error) {\n\t\tlogger.error('Get user promotions error:', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to get promotions',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Get promotion cost calculation\n * POST /api/ads/user-promotions/calculate-cost\n */\nrouter.post('/user-promotions/calculate-cost', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst { type, duration, startTime } = req.body;\n\n\t\tif (!type || !duration) {\n\t\t\treturn res.status(400).json({ error: 'Type and duration are required' });\n\t\t}\n\n\t\tconst targetTime = startTime ? new Date(startTime) : new Date();\n\t\tconst costCalculation = await userPromotionService.calculatePromotionCost(\n\t\t\ttype,\n\t\t\tduration,\n\t\t\ttargetTime\n\t\t);\n\n\t\tres.json(costCalculation);\n\t} catch (error) {\n\t\tlogger.error('Calculate cost error:', error);\n\t\tres.status(400).json({\n\t\t\terror: 'Failed to calculate cost',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Extend promotion duration\n * POST /api/ads/user-promotions/:id/extend\n */\nrouter.post('/user-promotions/:id/extend', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst { id } = req.params;\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tconst { additionalHours } = extendPromotionSchema.parse(req.body);\n\n\t\t// TODO: Implement promotion extension logic\n\t\t// This would involve:\n\t\t// 1. Verify user owns the promotion\n\t\t// 2. Calculate additional cost\n\t\t// 3. Check user balance\n\t\t// 4. Extend the promotion end time\n\t\t// 5. Charge additional DGT\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: 'Promotion extension feature coming soon',\n\t\t\tpromotionId: id,\n\t\t\tadditionalHours\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Extend promotion error:', error);\n\t\tres.status(400).json({\n\t\t\terror: 'Failed to extend promotion',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Cancel promotion\n * DELETE /api/ads/user-promotions/:id\n */\nrouter.delete('/user-promotions/:id', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst { id } = req.params;\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\n\t\t// TODO: Implement promotion cancellation logic\n\t\t// This would involve:\n\t\t// 1. Verify user owns the promotion\n\t\t// 2. Check if promotion can be cancelled (not already active/completed)\n\t\t// 3. Calculate refund amount based on unused time\n\t\t// 4. Process refund to user's DGT balance\n\t\t// 5. Update promotion status to 'cancelled'\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: 'Promotion cancellation feature coming soon',\n\t\t\tpromotionId: id\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Cancel promotion error:', error);\n\t\tres.status(400).json({\n\t\t\terror: 'Failed to cancel promotion',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Get promotion analytics\n * GET /api/ads/user-promotions/:id/analytics\n */\nrouter.get('/user-promotions/:id/analytics', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst { id } = req.params;\n\t\tconst { from, to } = req.query;\n\n\t\tconst timeRange =\n\t\t\tfrom && to\n\t\t\t\t? {\n\t\t\t\t\t\tfrom: new Date(from as string),\n\t\t\t\t\t\tto: new Date(to as string)\n\t\t\t\t\t}\n\t\t\t\t: undefined;\n\n\t\tconst analytics = await userPromotionService.getPromotionAnalytics(id, timeRange);\n\t\tres.json(analytics);\n\t} catch (error) {\n\t\tlogger.error('Get promotion analytics error:', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to get analytics',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n// ============================================================================\n// ANNOUNCEMENT SLOT ROUTES\n// ============================================================================\n\n/**\n * Get available announcement slots\n * GET /api/ads/announcement-slots/available\n */\nrouter.get('/announcement-slots/available', async (req, res) => {\n\ttry {\n\t\tconst { date, duration } = req.query;\n\n\t\tif (!date || !duration) {\n\t\t\treturn res.status(400).json({ error: 'Date and duration are required' });\n\t\t}\n\n\t\tconst startTime = new Date(date as string);\n\t\tconst durationHours = parseInt(duration as string);\n\n\t\tconst availableSlots = await userPromotionService.getAvailableAnnouncementSlots(\n\t\t\tstartTime,\n\t\t\tdurationHours\n\t\t);\n\t\tres.json(availableSlots);\n\t} catch (error) {\n\t\tlogger.error('Get available slots error:', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to get available slots',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Reserve announcement slot\n * POST /api/ads/announcement-slots/reserve\n */\nrouter.post('/announcement-slots/reserve', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst { slotId, promotionId } = req.body;\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\n\t\tif (!slotId || !promotionId || !userId) {\n\t\t\treturn res\n\t\t\t\t.status(400)\n\t\t\t\t.json({ error: 'Slot ID, promotion ID, and user authentication are required' });\n\t\t}\n\n\t\tawait userPromotionService.reserveAnnouncementSlot(slotId, promotionId, userId);\n\t\tres.json({ success: true, message: 'Slot reserved successfully' });\n\t} catch (error) {\n\t\tlogger.error('Reserve slot error:', error);\n\t\tres.status(400).json({\n\t\t\terror: 'Failed to reserve slot',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Get active announcement slots (public)\n * GET /api/ads/announcement-slots/active\n */\nrouter.get('/announcement-slots/active', async (req, res) => {\n\ttry {\n\t\t// TODO: Implement getting active announcement slots for display\n\t\t// This would return currently active user promotions for the announcement bar\n\n\t\tres.json({\n\t\t\tannouncements: [],\n\t\t\tmessage: 'Active announcement slots feature coming soon'\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Get active slots error:', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to get active slots',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n// ============================================================================\n// SHOUTBOX PIN ROUTES\n// ============================================================================\n\n/**\n * Get active pinned shoutbox messages\n * GET /api/ads/shoutbox/pins/active\n */\nrouter.get('/shoutbox/pins/active', async (req, res) => {\n\ttry {\n\t\tconst activePins = await userPromotionService.getActivePinnedMessages();\n\t\tres.json(activePins);\n\t} catch (error) {\n\t\tlogger.error('Get active pins error:', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to get active pins',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n// ============================================================================\n// PROMOTION TRACKING ROUTES\n// ============================================================================\n\n/**\n * Track promotion events (impression, click, conversion)\n * POST /api/ads/user-promotions/:id/track/:eventType\n */\nrouter.post('/user-promotions/:id/track/:eventType', async (req, res) => {\n\ttry {\n\t\tconst { id, eventType } = req.params;\n\t\tconst metadata = req.body;\n\n\t\tif (!['impression', 'click', 'conversion'].includes(eventType)) {\n\t\t\treturn res.status(400).json({ error: 'Invalid event type' });\n\t\t}\n\n\t\tawait userPromotionService.trackPromotionEvent(\n\t\t\tid,\n\t\t\teventType as 'impression' | 'click' | 'conversion',\n\t\t\tmetadata\n\t\t);\n\n\t\tres.json({ success: true });\n\t} catch (error) {\n\t\tlogger.error('Track promotion event error:', error);\n\t\tres.status(400).json({\n\t\t\terror: 'Failed to track event',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n// ============================================================================\n// ADMIN MODERATION ROUTES\n// ============================================================================\n\n/**\n * Get pending promotions for moderation\n * GET /api/ads/admin/user-promotions/pending\n */\nrouter.get('/admin/user-promotions/pending', isAdmin, async (req, res) => {\n\ttry {\n\t\tconst filters = {\n\t\t\ttype: req.query.type as string,\n\t\t\tlimit: req.query.limit ? parseInt(req.query.limit as string) : 50,\n\t\t\toffset: req.query.offset ? parseInt(req.query.offset as string) : 0\n\t\t};\n\n\t\tconst pendingPromotions = await userPromotionService.getPendingPromotions(filters);\n\t\tres.json(pendingPromotions);\n\t} catch (error) {\n\t\tlogger.error('Get pending promotions error:', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to get pending promotions',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Moderate user promotion (approve/reject)\n * POST /api/ads/admin/user-promotions/:id/moderate\n */\nrouter.post('/admin/user-promotions/:id/moderate', isAdmin, async (req, res) => {\n\ttry {\n\t\tconst { id } = req.params;\n\t\tconst moderatorId = userService.getUserFromRequest(req)?.id;\n\t\tconst { action, notes, rejectionReason } = moderationActionSchema.parse(req.body);\n\n\t\tif (!moderatorId) {\n\t\t\treturn res.status(401).json({ error: 'Moderator not authenticated' });\n\t\t}\n\n\t\tif (action === 'approve') {\n\t\t\tawait userPromotionService.approvePromotion(id, moderatorId, notes);\n\t\t\tres.json({ success: true, message: 'Promotion approved successfully' });\n\t\t} else {\n\t\t\tif (!rejectionReason) {\n\t\t\t\treturn res.status(400).json({ error: 'Rejection reason is required' });\n\t\t\t}\n\t\t\tawait userPromotionService.rejectPromotion(id, moderatorId, rejectionReason);\n\t\t\tres.json({ success: true, message: 'Promotion rejected successfully' });\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('Moderate promotion error:', error);\n\t\tres.status(400).json({\n\t\t\terror: 'Failed to moderate promotion',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * Get user promotion analytics (admin)\n * GET /api/ads/admin/user-promotions/analytics\n */\nrouter.get('/admin/user-promotions/analytics', isAdmin, async (req, res) => {\n\ttry {\n\t\t// TODO: Implement admin-level analytics for all user promotions\n\t\t// This would include:\n\t\t// - Total DGT spent on promotions\n\t\t// - Most popular promotion types\n\t\t// - Revenue by time period\n\t\t// - User engagement metrics\n\t\t// - Moderation queue statistics\n\n\t\tres.json({\n\t\t\ttotalPromotions: 0,\n\t\t\ttotalDgtSpent: 0,\n\t\t\tactivePromotions: 0,\n\t\t\tpendingApproval: 0,\n\t\t\tmessage: 'Admin analytics feature coming soon'\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Get admin analytics error:', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to get admin analytics',\n\t\t\tmessage: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\nexport { router as userPromotionRoutes };\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/advertising/user-promotion.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":1,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metadata' is defined but never used.","line":426,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":426,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { eq, and, sql, desc, asc, gte, lte, isNull } from 'drizzle-orm';\nimport { db } from '@server/src/core/db';\nimport {\n\tuserPromotions,\n\tannouncementSlots,\n\tshoutboxPins,\n\tthreadBoosts,\n\tprofileSpotlights,\n\tpromotionPricingConfig,\n\tuserPromotionAnalytics,\n\twallets,\n\ttransactions,\n\ttype UserPromotion,\n\ttype AnnouncementSlot,\n\ttype ShoutboxPin,\n\ttype ThreadBoost,\n\ttype ProfileSpotlight\n} from '@schema';\nimport { vanitySinkAnalyzer } from '../shop/services/vanity-sink.analyzer';\n\nexport interface CreatePromotionRequest {\n\ttype:\n\t\t| 'thread_boost'\n\t\t| 'announcement_bar'\n\t\t| 'pinned_shoutbox'\n\t\t| 'profile_spotlight'\n\t\t| 'achievement_highlight';\n\tcontentId?: string;\n\ttitle: string;\n\tdescription?: string;\n\timageUrl?: string;\n\tlinkUrl?: string;\n\ttargetPlacement?: string;\n\tduration: string; // '1h', '6h', '1d', '3d', '1w'\n\tstartTime?: Date;\n\tautoRenew?: boolean;\n\tmaxDailySpend?: number;\n\ttargetAudience?: any;\n}\n\nexport interface PromotionCostCalculation {\n\tbaseCost: number;\n\tdemandMultiplier: number;\n\ttimeMultiplier: number;\n\ttotalCost: number;\n\tavailableSlots: number;\n\tnextAvailableTime?: Date;\n}\n\nexport interface AvailableSlot {\n\tid: string;\n\tslotNumber: number;\n\tpriority: string;\n\tdate: Date;\n\thourStart: number;\n\thourEnd: number;\n\tprice: number;\n\tisAvailable: boolean;\n}\n\n/**\n * User Promotion Service\n * Handles DGT-powered user content promotion system\n */\nexport class UserPromotionService {\n\t/**\n\t * Create a new user promotion\n\t */\n\tasync createPromotion(\n\t\tuserId: string,\n\t\trequest: CreatePromotionRequest\n\t): Promise<{\n\t\tpromotion: UserPromotion;\n\t\tcostBreakdown: PromotionCostCalculation;\n\t\tpaymentRequired: boolean;\n\t}> {\n\t\t// 1. Validate user has sufficient DGT balance\n\t\tconst userWallet = await this.getUserDgtBalance(userId);\n\t\tif (!userWallet) {\n\t\t\tthrow new Error('User wallet not found');\n\t\t}\n\n\t\t// 2. Calculate promotion cost\n\t\tconst costCalculation = await this.calculatePromotionCost(\n\t\t\trequest.type,\n\t\t\trequest.duration,\n\t\t\trequest.startTime || new Date()\n\t\t);\n\n\t\tif (parseFloat(userWallet.dgtBalance) < costCalculation.totalCost) {\n\t\t\tthrow new Error(\n\t\t\t\t`Insufficient DGT balance. Required: ${costCalculation.totalCost}, Available: ${userWallet.dgtBalance}`\n\t\t\t);\n\t\t}\n\n\t\t// 3. Check slot availability for announcement/pin requests\n\t\tif (request.type === 'announcement_bar') {\n\t\t\tconst availableSlots = await this.getAvailableAnnouncementSlots(\n\t\t\t\trequest.startTime || new Date(),\n\t\t\t\tthis.parseDurationToHours(request.duration)\n\t\t\t);\n\n\t\t\tif (availableSlots.length === 0) {\n\t\t\t\tthrow new Error('No announcement slots available for the requested time period');\n\t\t\t}\n\t\t}\n\n\t\t// 4. Calculate start and end times\n\t\tconst startTime = request.startTime || new Date();\n\t\tconst durationHours = this.parseDurationToHours(request.duration);\n\t\tconst endTime = new Date(startTime.getTime() + durationHours * 60 * 60 * 1000);\n\n\t\t// 5. Create promotion record\n\t\tconst [promotion] = await db\n\t\t\t.insert(userPromotions)\n\t\t\t.values({\n\t\t\t\tuserId,\n\t\t\t\ttype: request.type,\n\t\t\t\tcontentId: request.contentId,\n\t\t\t\ttitle: request.title,\n\t\t\t\tdescription: request.description,\n\t\t\t\timageUrl: request.imageUrl,\n\t\t\t\tlinkUrl: request.linkUrl,\n\t\t\t\ttargetPlacement: request.targetPlacement,\n\t\t\t\tstartTime,\n\t\t\t\tendTime,\n\t\t\t\tduration: durationHours,\n\t\t\t\tdgtCost: costCalculation.totalCost.toString(),\n\t\t\t\tstatus: 'pending', // Requires approval for most types\n\t\t\t\tautoRenew: request.autoRenew || false,\n\t\t\t\tmaxDailySpend: request.maxDailySpend?.toString(),\n\t\t\t\ttargetAudience: request.targetAudience ? JSON.stringify(request.targetAudience) : null\n\t\t\t})\n\t\t\t.returning();\n\n\t\t// 6. Hold DGT funds (create pending transaction)\n\t\tawait this.holdDgtFunds(userId, costCalculation.totalCost, promotion.id);\n\n\t\t// 7. Auto-approve certain low-risk promotion types\n\t\tconst autoApproveTypes = ['thread_boost'];\n\t\tif (autoApproveTypes.includes(request.type)) {\n\t\t\tawait this.approvePromotion(\n\t\t\t\tpromotion.id,\n\t\t\t\t'system',\n\t\t\t\t'Auto-approved for low-risk promotion type'\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tpromotion,\n\t\t\tcostBreakdown: costCalculation,\n\t\t\tpaymentRequired: true\n\t\t};\n\t}\n\n\t/**\n\t * Calculate promotion cost with dynamic pricing\n\t */\n\tasync calculatePromotionCost(\n\t\ttype: string,\n\t\tduration: string,\n\t\ttargetTime: Date\n\t): Promise<PromotionCostCalculation> {\n\t\t// Get base pricing configuration\n\t\tconst [pricingConfig] = await db\n\t\t\t.select()\n\t\t\t.from(promotionPricingConfig)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(promotionPricingConfig.promotionType, type),\n\t\t\t\t\teq(promotionPricingConfig.duration, duration),\n\t\t\t\t\teq(promotionPricingConfig.isActive, true)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.limit(1);\n\n\t\tif (!pricingConfig) {\n\t\t\tthrow new Error(`No pricing configuration found for ${type} with duration ${duration}`);\n\t\t}\n\n\t\tconst baseCost = parseFloat(pricingConfig.basePriceDgt);\n\n\t\t// Calculate demand multiplier based on current bookings\n\t\tconst demandMultiplier = await this.calculateDemandMultiplier(type, targetTime);\n\n\t\t// Calculate time-based multiplier (peak hours, weekends)\n\t\tconst timeMultiplier = this.calculateTimeMultiplier(targetTime, pricingConfig);\n\n\t\t// Calculate final cost\n\t\tconst totalCost = Math.max(\n\t\t\tbaseCost * demandMultiplier * timeMultiplier,\n\t\t\tparseFloat(pricingConfig.minPrice)\n\t\t);\n\n\t\t// Check available slots\n\t\tconst availableSlots = await this.getAvailableSlotsCount(type, targetTime);\n\n\t\treturn {\n\t\t\tbaseCost,\n\t\t\tdemandMultiplier,\n\t\t\ttimeMultiplier,\n\t\t\ttotalCost: Math.ceil(totalCost), // Round up to nearest DGT\n\t\t\tavailableSlots,\n\t\t\tnextAvailableTime:\n\t\t\t\tavailableSlots === 0 ? await this.getNextAvailableTime(type, targetTime) : undefined\n\t\t};\n\t}\n\n\t/**\n\t * Approve a user promotion\n\t */\n\tasync approvePromotion(promotionId: string, moderatorId: string, notes?: string): Promise<void> {\n\t\t// Update promotion status\n\t\tconst [promotion] = await db\n\t\t\t.update(userPromotions)\n\t\t\t.set({\n\t\t\t\tstatus: 'approved',\n\t\t\t\tmoderatorId,\n\t\t\t\tmoderatorNotes: notes,\n\t\t\t\tapprovedAt: new Date(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(userPromotions.id, promotionId))\n\t\t\t.returning();\n\n\t\tif (!promotion) {\n\t\t\tthrow new Error('Promotion not found');\n\t\t}\n\n\t\t// Convert held funds to actual payment\n\t\tawait this.processPromotionPayment(\n\t\t\tpromotion.userId,\n\t\t\tparseFloat(promotion.dgtCost),\n\t\t\tpromotionId\n\t\t);\n\n\t\t// Create specific promotion records based on type\n\t\tawait this.createSpecificPromotionRecord(promotion);\n\n\t\t// If start time is now or in the past, activate immediately\n\t\tif (promotion.startTime <= new Date()) {\n\t\t\tawait this.activatePromotion(promotionId);\n\t\t}\n\t}\n\n\t/**\n\t * Reject a user promotion\n\t */\n\tasync rejectPromotion(promotionId: string, moderatorId: string, reason: string): Promise<void> {\n\t\tconst [promotion] = await db\n\t\t\t.update(userPromotions)\n\t\t\t.set({\n\t\t\t\tstatus: 'rejected',\n\t\t\t\tmoderatorId,\n\t\t\t\trejectionReason: reason,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(userPromotions.id, promotionId))\n\t\t\t.returning();\n\n\t\tif (!promotion) {\n\t\t\tthrow new Error('Promotion not found');\n\t\t}\n\n\t\t// Release held DGT funds\n\t\tawait this.releaseDgtFunds(promotion.userId, parseFloat(promotion.dgtCost), promotionId);\n\t}\n\n\t/**\n\t * Activate an approved promotion\n\t */\n\tasync activatePromotion(promotionId: string): Promise<void> {\n\t\tawait db\n\t\t\t.update(userPromotions)\n\t\t\t.set({\n\t\t\t\tstatus: 'active',\n\t\t\t\tactivatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(userPromotions.id, promotionId));\n\t}\n\n\t/**\n\t * Get user's promotions\n\t */\n\tasync getUserPromotions(\n\t\tuserId: string,\n\t\tfilters: {\n\t\t\tstatus?: string;\n\t\t\ttype?: string;\n\t\t\tlimit?: number;\n\t\t\toffset?: number;\n\t\t} = {}\n\t): Promise<{\n\t\tpromotions: UserPromotion[];\n\t\ttotal: number;\n\t}> {\n\t\tlet query = db.select().from(userPromotions).where(eq(userPromotions.userId, userId));\n\n\t\tif (filters.status) {\n\t\t\tquery = query.where(eq(userPromotions.status, filters.status));\n\t\t}\n\n\t\tif (filters.type) {\n\t\t\tquery = query.where(eq(userPromotions.type, filters.type));\n\t\t}\n\n\t\tconst promotions = await query\n\t\t\t.orderBy(desc(userPromotions.createdAt))\n\t\t\t.limit(filters.limit || 20)\n\t\t\t.offset(filters.offset || 0);\n\n\t\t// Get total count\n\t\tconst [{ count }] = await db\n\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t.from(userPromotions)\n\t\t\t.where(eq(userPromotions.userId, userId));\n\n\t\treturn {\n\t\t\tpromotions,\n\t\t\ttotal: count\n\t\t};\n\t}\n\n\t/**\n\t * Get pending promotions for moderation\n\t */\n\tasync getPendingPromotions(\n\t\tfilters: {\n\t\t\ttype?: string;\n\t\t\tlimit?: number;\n\t\t\toffset?: number;\n\t\t} = {}\n\t): Promise<UserPromotion[]> {\n\t\tlet query = db.select().from(userPromotions).where(eq(userPromotions.status, 'pending'));\n\n\t\tif (filters.type) {\n\t\t\tquery = query.where(eq(userPromotions.type, filters.type));\n\t\t}\n\n\t\treturn await query\n\t\t\t.orderBy(asc(userPromotions.createdAt))\n\t\t\t.limit(filters.limit || 50)\n\t\t\t.offset(filters.offset || 0);\n\t}\n\n\t/**\n\t * Get available announcement slots\n\t */\n\tasync getAvailableAnnouncementSlots(\n\t\tstartTime: Date,\n\t\tdurationHours: number\n\t): Promise<AvailableSlot[]> {\n\t\tconst endTime = new Date(startTime.getTime() + durationHours * 60 * 60 * 1000);\n\n\t\t// Get all slots in the time range that are not booked\n\t\tconst availableSlots = await db\n\t\t\t.select()\n\t\t\t.from(announcementSlots)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\tgte(announcementSlots.date, startTime.toISOString().split('T')[0]),\n\t\t\t\t\tlte(announcementSlots.date, endTime.toISOString().split('T')[0]),\n\t\t\t\t\teq(announcementSlots.isBooked, false)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(asc(announcementSlots.slotNumber), asc(announcementSlots.hourStart));\n\n\t\treturn availableSlots.map((slot) => ({\n\t\t\tid: slot.id,\n\t\t\tslotNumber: slot.slotNumber,\n\t\t\tpriority: slot.priority,\n\t\t\tdate: slot.date,\n\t\t\thourStart: slot.hourStart,\n\t\t\thourEnd: slot.hourEnd,\n\t\t\tprice: parseFloat(slot.currentPrice),\n\t\t\tisAvailable: true\n\t\t}));\n\t}\n\n\t/**\n\t * Reserve announcement slot\n\t */\n\tasync reserveAnnouncementSlot(\n\t\tslotId: string,\n\t\tpromotionId: string,\n\t\tuserId: string\n\t): Promise<void> {\n\t\tawait db\n\t\t\t.update(announcementSlots)\n\t\t\t.set({\n\t\t\t\tuserPromotionId: promotionId,\n\t\t\t\tbookedByUserId: userId,\n\t\t\t\tisBooked: true,\n\t\t\t\tbookedAt: new Date(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(and(eq(announcementSlots.id, slotId), eq(announcementSlots.isBooked, false)));\n\t}\n\n\t/**\n\t * Get active pinned shoutbox messages\n\t */\n\tasync getActivePinnedMessages(): Promise<ShoutboxPin[]> {\n\t\tconst now = new Date();\n\n\t\treturn await db\n\t\t\t.select()\n\t\t\t.from(shoutboxPins)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(shoutboxPins.isActive, true),\n\t\t\t\t\tlte(shoutboxPins.startTime, now),\n\t\t\t\t\tgte(shoutboxPins.endTime, now)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(desc(shoutboxPins.startTime));\n\t}\n\n\t/**\n\t * Track promotion performance\n\t */\n\tasync trackPromotionEvent(\n\t\tpromotionId: string,\n\t\teventType: 'impression' | 'click' | 'conversion',\n\t\tmetadata?: any\n\t): Promise<void> {\n\t\t// Update main promotion record\n\t\tconst updateField =\n\t\t\teventType === 'impression' ? 'impressions' : eventType === 'click' ? 'clicks' : 'conversions';\n\n\t\tawait db\n\t\t\t.update(userPromotions)\n\t\t\t.set({\n\t\t\t\t[updateField]: sql`${userPromotions[updateField]} + 1`,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(userPromotions.id, promotionId));\n\n\t\t// Create analytics record for detailed tracking\n\t\tconst today = new Date().toISOString().split('T')[0];\n\t\tconst currentHour = new Date().getHours();\n\n\t\tawait db\n\t\t\t.insert(userPromotionAnalytics)\n\t\t\t.values({\n\t\t\t\tuserPromotionId: promotionId,\n\t\t\t\tdate: today,\n\t\t\t\thour: currentHour,\n\t\t\t\t[updateField]: 1\n\t\t\t})\n\t\t\t.onConflictDoUpdate({\n\t\t\t\ttarget: [\n\t\t\t\t\tuserPromotionAnalytics.userPromotionId,\n\t\t\t\t\tuserPromotionAnalytics.date,\n\t\t\t\t\tuserPromotionAnalytics.hour\n\t\t\t\t],\n\t\t\t\tset: {\n\t\t\t\t\t[updateField]: sql`${userPromotionAnalytics[updateField]} + 1`,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Get promotion analytics\n\t */\n\tasync getPromotionAnalytics(\n\t\tpromotionId: string,\n\t\ttimeRange?: { from: Date; to: Date }\n\t): Promise<{\n\t\ttotalImpressions: number;\n\t\ttotalClicks: number;\n\t\ttotalConversions: number;\n\t\tctr: number;\n\t\tconversionRate: number;\n\t\ttotalSpent: number;\n\t\taverageCPC: number;\n\t\tdailyBreakdown: Array<{\n\t\t\tdate: string;\n\t\t\timpressions: number;\n\t\t\tclicks: number;\n\t\t\tconversions: number;\n\t\t\tspent: number;\n\t\t}>;\n\t}> {\n\t\t// Get overall statistics\n\t\tconst [promotion] = await db\n\t\t\t.select()\n\t\t\t.from(userPromotions)\n\t\t\t.where(eq(userPromotions.id, promotionId))\n\t\t\t.limit(1);\n\n\t\tif (!promotion) {\n\t\t\tthrow new Error('Promotion not found');\n\t\t}\n\n\t\t// Get daily breakdown\n\t\tlet analyticsQuery = db\n\t\t\t.select()\n\t\t\t.from(userPromotionAnalytics)\n\t\t\t.where(eq(userPromotionAnalytics.userPromotionId, promotionId));\n\n\t\tif (timeRange) {\n\t\t\tanalyticsQuery = analyticsQuery.where(\n\t\t\t\tand(\n\t\t\t\t\tgte(userPromotionAnalytics.date, timeRange.from.toISOString().split('T')[0]),\n\t\t\t\t\tlte(userPromotionAnalytics.date, timeRange.to.toISOString().split('T')[0])\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst dailyAnalytics = await analyticsQuery.orderBy(asc(userPromotionAnalytics.date));\n\n\t\t// Calculate aggregated metrics\n\t\tconst totalImpressions = promotion.impressions;\n\t\tconst totalClicks = promotion.clicks;\n\t\tconst totalConversions = promotion.conversions;\n\t\tconst totalSpent = parseFloat(promotion.dgtSpent);\n\n\t\tconst ctr = totalImpressions > 0 ? (totalClicks / totalImpressions) * 100 : 0;\n\t\tconst conversionRate = totalClicks > 0 ? (totalConversions / totalClicks) * 100 : 0;\n\t\tconst averageCPC = totalClicks > 0 ? totalSpent / totalClicks : 0;\n\n\t\t// Format daily breakdown\n\t\tconst dailyBreakdown = dailyAnalytics.map((day) => ({\n\t\t\tdate: day.date,\n\t\t\timpressions: day.impressions,\n\t\t\tclicks: day.clicks,\n\t\t\tconversions: day.conversions,\n\t\t\tspent: parseFloat(day.dgtSpent)\n\t\t}));\n\n\t\treturn {\n\t\t\ttotalImpressions,\n\t\t\ttotalClicks,\n\t\t\ttotalConversions,\n\t\t\tctr: Math.round(ctr * 100) / 100,\n\t\t\tconversionRate: Math.round(conversionRate * 100) / 100,\n\t\t\ttotalSpent,\n\t\t\taverageCPC: Math.round(averageCPC * 100) / 100,\n\t\t\tdailyBreakdown\n\t\t};\n\t}\n\n\t/**\n\t * Private helper methods\n\t */\n\tprivate async getUserDgtBalance(userId: string): Promise<{ dgtBalance: string } | null> {\n\t\tconst [wallet] = await db\n\t\t\t.select({ dgtBalance: wallets.dgtBalance })\n\t\t\t.from(wallets)\n\t\t\t.where(eq(wallets.userId, userId))\n\t\t\t.limit(1);\n\n\t\treturn wallet || null;\n\t}\n\n\tprivate parseDurationToHours(duration: string): number {\n\t\tconst durationMap: { [key: string]: number } = {\n\t\t\t'1h': 1,\n\t\t\t'6h': 6,\n\t\t\t'12h': 12,\n\t\t\t'1d': 24,\n\t\t\t'3d': 72,\n\t\t\t'1w': 168\n\t\t};\n\n\t\treturn durationMap[duration] || 24; // Default to 1 day\n\t}\n\n\tprivate async calculateDemandMultiplier(type: string, targetTime: Date): Promise<number> {\n\t\t// Get current demand for the time period\n\t\tconst startOfDay = new Date(targetTime);\n\t\tstartOfDay.setHours(0, 0, 0, 0);\n\n\t\tconst endOfDay = new Date(targetTime);\n\t\tendOfDay.setHours(23, 59, 59, 999);\n\n\t\tconst [{ count }] = await db\n\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t.from(userPromotions)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(userPromotions.type, type),\n\t\t\t\t\teq(userPromotions.status, 'active'),\n\t\t\t\t\tgte(userPromotions.startTime, startOfDay),\n\t\t\t\t\tlte(userPromotions.startTime, endOfDay)\n\t\t\t\t)\n\t\t\t);\n\n\t\t// Base multiplier starts at 1.0, increases by 0.1 for each active promotion\n\t\treturn Math.max(1.0, 1.0 + count * 0.1);\n\t}\n\n\tprivate calculateTimeMultiplier(targetTime: Date, pricingConfig: any): number {\n\t\tconst hour = targetTime.getHours();\n\t\tconst dayOfWeek = targetTime.getDay();\n\t\tconst isWeekend = dayOfWeek === 0 || dayOfWeek === 6;\n\n\t\tlet multiplier = 1.0;\n\n\t\t// Apply weekend multiplier\n\t\tif (isWeekend) {\n\t\t\tmultiplier *= parseFloat(pricingConfig.weekendMultiplier);\n\t\t}\n\n\t\t// Apply peak hour multiplier\n\t\tconst peakHours = JSON.parse(pricingConfig.peakHours || '[18,19,20,21]');\n\t\tif (peakHours.includes(hour)) {\n\t\t\tmultiplier *= parseFloat(pricingConfig.peakMultiplier);\n\t\t}\n\n\t\treturn multiplier;\n\t}\n\n\tprivate async getAvailableSlotsCount(type: string, targetTime: Date): Promise<number> {\n\t\tif (type === 'announcement_bar') {\n\t\t\tconst [{ count }] = await db\n\t\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t\t.from(announcementSlots)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(announcementSlots.date, targetTime.toISOString().split('T')[0]),\n\t\t\t\t\t\teq(announcementSlots.isBooked, false)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\treturn count;\n\t\t}\n\n\t\t// For other types, return a high number as slots are virtually unlimited\n\t\treturn 100;\n\t}\n\n\tprivate async getNextAvailableTime(type: string, targetTime: Date): Promise<Date | undefined> {\n\t\tif (type === 'announcement_bar') {\n\t\t\tconst nextSlot = await db\n\t\t\t\t.select()\n\t\t\t\t.from(announcementSlots)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\tgte(announcementSlots.date, targetTime.toISOString().split('T')[0]),\n\t\t\t\t\t\teq(announcementSlots.isBooked, false)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.orderBy(asc(announcementSlots.date), asc(announcementSlots.hourStart))\n\t\t\t\t.limit(1);\n\n\t\t\tif (nextSlot.length > 0) {\n\t\t\t\tconst slot = nextSlot[0];\n\t\t\t\tconst nextTime = new Date(slot.date);\n\t\t\t\tnextTime.setHours(slot.hourStart, 0, 0, 0);\n\t\t\t\treturn nextTime;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async holdDgtFunds(userId: string, amount: number, promotionId: string): Promise<void> {\n\t\t// Create a pending transaction to hold the funds\n\t\tawait db.insert(transactions).values({\n\t\t\tuserId,\n\t\t\ttype: 'promotion_hold',\n\t\t\tamount: amount.toString(),\n\t\t\tcurrency: 'DGT',\n\t\t\tstatus: 'pending',\n\t\t\tmetadata: { promotionId, type: 'user_promotion_hold' },\n\t\t\tdescription: `DGT held for user promotion ${promotionId}`\n\t\t});\n\t}\n\n\tprivate async processPromotionPayment(\n\t\tuserId: string,\n\t\tamount: number,\n\t\tpromotionId: string\n\t): Promise<void> {\n\t\t// Deduct DGT from user wallet\n\t\tawait db\n\t\t\t.update(wallets)\n\t\t\t.set({\n\t\t\t\tdgtBalance: sql`${wallets.dgtBalance} - ${amount}`,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(wallets.userId, userId));\n\n\t\t// Create completed transaction\n\t\tconst [transaction] = await db.insert(transactions).values({\n\t\t\tuserId,\n\t\t\ttype: 'promotion_payment',\n\t\t\tamount: amount.toString(),\n\t\t\tcurrency: 'DGT',\n\t\t\tstatus: 'completed',\n\t\t\tmetadata: { promotionId, type: 'user_promotion_payment' },\n\t\t\tdescription: `DGT payment for user promotion ${promotionId}`\n\t\t}).returning();\n\n\t\t// Track DGT burn for promotion purchase\n\t\tawait vanitySinkAnalyzer.trackBurn({\n\t\t\tuserId,\n\t\t\torderId: transaction.id,\n\t\t\tdgtBurned: amount,\n\t\t\tburnType: 'promotion',\n\t\t\tsource: 'advertising',\n\t\t\tmetadata: {\n\t\t\t\tpromotionId,\n\t\t\t\tpromotionType: 'user_promotion',\n\t\t\t\tburnReason: 'thread_boost_purchase'\n\t\t\t}\n\t\t});\n\n\t\t// Update promotion spent amount\n\t\tawait db\n\t\t\t.update(userPromotions)\n\t\t\t.set({\n\t\t\t\tdgtSpent: amount.toString(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(userPromotions.id, promotionId));\n\t}\n\n\tprivate async releaseDgtFunds(\n\t\tuserId: string,\n\t\tamount: number,\n\t\tpromotionId: string\n\t): Promise<void> {\n\t\t// Mark hold transaction as cancelled\n\t\tawait db\n\t\t\t.update(transactions)\n\t\t\t.set({\n\t\t\t\tstatus: 'cancelled',\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(transactions.userId, userId),\n\t\t\t\t\teq(transactions.type, 'promotion_hold'),\n\t\t\t\t\tsql`${transactions.metadata}::jsonb ->> 'promotionId' = ${promotionId}`\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\tprivate async createSpecificPromotionRecord(promotion: UserPromotion): Promise<void> {\n\t\tswitch (promotion.type) {\n\t\t\tcase 'thread_boost':\n\t\t\t\tif (promotion.contentId) {\n\t\t\t\t\tawait db.insert(threadBoosts).values({\n\t\t\t\t\t\tuserPromotionId: promotion.id,\n\t\t\t\t\t\tthreadId: promotion.contentId,\n\t\t\t\t\t\tuserId: promotion.userId,\n\t\t\t\t\t\tstartTime: promotion.startTime,\n\t\t\t\t\t\tendTime: promotion.endTime,\n\t\t\t\t\t\tboostMultiplier: '2.0',\n\t\t\t\t\t\tpriorityLevel: 1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'pinned_shoutbox':\n\t\t\t\tawait db.insert(shoutboxPins).values({\n\t\t\t\t\tuserPromotionId: promotion.id,\n\t\t\t\t\tuserId: promotion.userId,\n\t\t\t\t\tcontent: promotion.description || promotion.title,\n\t\t\t\t\timageUrl: promotion.imageUrl,\n\t\t\t\t\tlinkUrl: promotion.linkUrl,\n\t\t\t\t\tstartTime: promotion.startTime,\n\t\t\t\t\tendTime: promotion.endTime\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'profile_spotlight':\n\t\t\t\tawait db.insert(profileSpotlights).values({\n\t\t\t\t\tuserPromotionId: promotion.id,\n\t\t\t\t\tuserId: promotion.userId,\n\t\t\t\t\tspotlightMessage: promotion.description || promotion.title,\n\t\t\t\t\tstartTime: promotion.startTime,\n\t\t\t\t\tendTime: promotion.endTime\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport const userPromotionService = new UserPromotionService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/auth/auth.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'session' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Router } from 'express';\nimport passport from 'passport';\nimport { Strategy as LocalStrategy } from 'passport-local';\nimport session from 'express-session';\nimport { storage } from '../../../storage'; // Will be refactored in a future step\nimport {\n\tcomparePasswords,\n\tgetSessionCookieSettings,\n\tcreateMockUser\n} from './services/auth.service';\nimport {\n\tregister,\n\tlogin,\n\tlogout,\n\tgetCurrentUser,\n\tverifyEmail,\n\tresendVerification\n} from './controllers/auth.controller';\nimport {\n\tisAuthenticated,\n\tisAuthenticatedOptional,\n\tisAdmin,\n\tisModerator,\n\tisAdminOrModerator,\n\tdevModeAuthHandler\n} from './middleware/auth.middleware';\nimport { isDevMode } from '../../utils/environment';\nimport { logger } from '@server/src/core/logger';\nimport { getAuthenticatedUser } from \"@server/src/core/utils/auth.helpers\";\n\nconst router = Router();\n\n/**\n * Initialize Passport.js and configure authentication\n */\nexport function setupAuthPassport(sessionStore: any) {\n\t// Configure the local strategy for Passport\n\tpassport.use(\n\t\tnew LocalStrategy(async (username, password, done) => {\n\t\t\ttry {\n\t\t\t\t// In dev mode, we can bypass the password check\n\t\t\t\tif (\n\t\t\t\t\tisDevMode() &&\n\t\t\t\t\tprocess.env.DEV_BYPASS_PASSWORD === 'true' &&\n\t\t\t\t\tprocess.env.DEV_FORCE_AUTH !== 'true'\n\t\t\t\t) {\n\t\t\t\t\tconst user = await storage.getUserByUsername(username);\n\n\t\t\t\t\tif (!user) {\n\t\t\t\t\t\treturn done(null, false, { message: 'Invalid username or password' });\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip password check in dev mode with bypass flag\n\t\t\t\t\tlogger.info('AuthRoutes', 'DEV MODE: Bypassing password check!', { username });\n\n\t\t\t\t\t// Still check other user status fields\n\t\t\t\t\tif (user.isBanned) {\n\t\t\t\t\t\treturn done(null, false, { message: 'Your account has been banned' });\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!user.isActive) {\n\t\t\t\t\t\treturn done(null, false, { message: 'Your account is inactive' });\n\t\t\t\t\t}\n\n\t\t\t\t\tif (user.isDeleted) {\n\t\t\t\t\t\treturn done(null, false, { message: 'Your account has been deleted' });\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensure role is not null and groupId is undefined if null\n\t\t\t\t\tconst userWithRole = {\n\t\t\t\t\t\t...user,\n\t\t\t\t\t\trole: user.role || 'user',\n\t\t\t\t\t\tgroupId: user.groupId === null ? undefined : user.groupId\n\t\t\t\t\t};\n\t\t\t\t\treturn done(null, userWithRole);\n\t\t\t\t}\n\n\t\t\t\t// Normal authentication flow\n\t\t\t\tconst user = await storage.getUserByUsername(username);\n\t\t\t\tif (!user || !(await comparePasswords(password, user.password))) {\n\t\t\t\t\treturn done(null, false, { message: 'Invalid username or password' });\n\t\t\t\t}\n\n\t\t\t\tif (user.isBanned) {\n\t\t\t\t\treturn done(null, false, { message: 'Your account has been banned' });\n\t\t\t\t}\n\n\t\t\t\tif (!user.isActive) {\n\t\t\t\t\treturn done(null, false, { message: 'Your account is inactive' });\n\t\t\t\t}\n\n\t\t\t\tif (user.isDeleted) {\n\t\t\t\t\treturn done(null, false, { message: 'Your account has been deleted' });\n\t\t\t\t}\n\n\t\t\t\t// Ensure role is not null and groupId is undefined if null\n\t\t\t\tconst userWithRole = {\n\t\t\t\t\t...user,\n\t\t\t\t\trole: user.role || 'user',\n\t\t\t\t\tgroupId: user.groupId === null ? undefined : user.groupId\n\t\t\t\t};\n\t\t\t\treturn done(null, userWithRole);\n\t\t\t} catch (err) {\n\t\t\t\treturn done(err);\n\t\t\t}\n\t\t})\n\t);\n\n\t// Configure user serialization (for session storage)\n\tpassport.serializeUser((user: any, done) => {\n\t\t// Support either 'id' or 'user_id' as field name\n\t\tconst userId = user.id || user.user_id;\n\t\tif (!userId) {\n\t\t\treturn done(new Error('User has no id field'), null);\n\t\t}\n\t\treturn done(null, userId);\n\t});\n\n\t// Configure user deserialization (retrieving user from session)\n\tpassport.deserializeUser(async (id: string, done) => {\n\t\tlogger.debug('Passport deserializeUser called', { id, idType: typeof id });\n\t\ttry {\n\t\t\t// Try to get user from storage\n\t\t\ttry {\n\t\t\t\tlogger.debug('Calling storage.getUser from deserializer');\n\t\t\t\tconst user = await storage.getUser(id);\n\t\t\t\tif (user) {\n\t\t\t\t\tlogger.debug('Deserializer got user from storage', {\n\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\tusername: user.username\n\t\t\t\t\t});\n\t\t\t\t\t// Ensure role is not null and groupId is undefined if null\n\t\t\t\t\tconst userWithRole = {\n\t\t\t\t\t\t...user,\n\t\t\t\t\t\trole: user.role || 'user',\n\t\t\t\t\t\tgroupId: user.groupId === null ? undefined : user.groupId\n\t\t\t\t\t};\n\t\t\t\t\treturn done(null, userWithRole);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn('Deserializer: storage.getUser returned null/undefined', { id });\n\t\t\t\t}\n\t\t\t} catch (storageErr) {\n\t\t\t\tlogger.info('❌ Deserializer: storage.getUser threw error:', storageErr);\n\t\t\t\tlogger.warn('AuthRoutes', 'Storage getUser error during deserialization, falling back.', {\n\t\t\t\t\terr: storageErr,\n\t\t\t\t\tuserId: id\n\t\t\t\t});\n\t\t\t\t// Fall through to direct SQL approach or mock user in dev mode\n\t\t\t}\n\n\t\t\t// If in development mode, create a mock user\n\t\t\tif (isDevMode()) {\n\t\t\t\tlogger.info('⚠️ Deserializer: Creating mock user in dev mode for ID:', id);\n\t\t\t\t// Check if there's a dev role stored in session\n\t\t\t\tconst role = (global as any).devRole || 'user';\n\t\t\t\tconst mockUser = createMockUser(id, role as any);\n\t\t\t\tlogger.info('🎭 Mock user created:', JSON.stringify(mockUser, null, 2));\n\t\t\t\t// Ensure role is not null and groupId is undefined if null for mock user too\n\t\t\t\tconst mockUserWithRole = {\n\t\t\t\t\t...mockUser,\n\t\t\t\t\trole: mockUser.role || 'user',\n\t\t\t\t\tgroupId: mockUser.groupId === null ? undefined : mockUser.groupId\n\t\t\t\t};\n\t\t\t\treturn done(null, mockUserWithRole);\n\t\t\t}\n\n\t\t\t// If we get here, no approach worked\n\t\t\tdone(new Error(`User with id ${id} not found`));\n\t\t} catch (err) {\n\t\t\tdone(err);\n\t\t}\n\t});\n\n\t// Return session settings for express-session middleware\n\treturn {\n\t\tsecret: process.env.SESSION_SECRET || 'sonnet-forum-secret',\n\t\tresave: false,\n\t\tsaveUninitialized: false,\n\t\tstore: sessionStore,\n\t\tcookie: getSessionCookieSettings()\n\t};\n}\n\n// Auth routes\nrouter.post('/register', register);\nrouter.post('/login', login);\nrouter.post('/logout', logout);\nrouter.get('/user', getCurrentUser);\nrouter.get('/verify-email', verifyEmail);\nrouter.post('/resend-verification', resendVerification);\n\n// Test endpoint to verify role computation\nrouter.get('/test-roles', (req, res) => {\n\tif (!req.isAuthenticated()) return res.json({ authenticated: false });\n\n\tconst user = getAuthenticatedUser(req) as any;\n\tconst computedRoles = {\n\t\toriginalRole: user.role,\n\t\tisAdmin: ['admin', 'super_admin'].includes(user.role),\n\t\tisModerator: user.role === 'moderator',\n\t\tisSuperAdmin: user.role === 'super_admin'\n\t};\n\n\tres.json({ authenticated: true, user: user.username, computedRoles });\n});\n\n// Dev mode auth switching endpoint\nrouter.get('/dev-mode/set-role', devModeAuthHandler);\n\n// Export middleware for use in other routes\nexport { isAuthenticated, isAuthenticatedOptional, isAdmin, isModerator, isAdminOrModerator };\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/auth/controllers/auth.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createHash' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'confirmPassword' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":35,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { Request, Response, NextFunction } from 'express';\nimport { z } from 'zod';\nimport { createHash, randomBytes } from 'crypto';\nimport passport from 'passport';\nimport { insertUserSchema } from '@schema';\nimport { users } from '@schema';\nimport { logger } from '@server/src/core/logger';\nimport { storage } from '@server/src/storage'; // Will be refactored in a future step\nimport { hashPassword, storeTempDevMetadata, verifyEmailToken } from '../services/auth.service';\nimport { isDevMode } from '../../../utils/environment';\nimport { walletService } from '../../wallet/wallet.service';\nimport { dgtService } from '../../wallet/dgt.service';\nimport { walletConfig } from '@shared/wallet.config';\nimport { UserTransformer } from \"@server/src/domains/users/transformers/user.transformer\";\n\ntype User = typeof users.$inferSelect;\n\n/**\n * Handle user registration\n */\nexport async function register(req: Request, res: Response, next: NextFunction) {\n\ttry {\n\t\t// Validate registration data\n\t\tconst registerSchema = insertUserSchema\n\t\t\t.extend({\n\t\t\t\tconfirmPassword: z.string()\n\t\t\t})\n\t\t\t.refine((data) => data.password === data.confirmPassword, {\n\t\t\t\tmessage: \"Passwords don't match\",\n\t\t\t\tpath: ['confirmPassword']\n\t\t\t});\n\n\t\tconst validatedData = registerSchema.parse(req.body);\n\t\tconst { confirmPassword, ...userData } = validatedData as any;\n\n\t\t// Check if username already exists\n\t\tconst existingUser = await storage.getUserByUsername(userData.username);\n\t\tif (existingUser) {\n\t\t\treturn res.status(400).json({ message: 'Username already exists' });\n\t\t}\n\n\t\t// Store temporary dev metadata if beta tools are enabled\n\t\tconst tempDevMetadata = await storeTempDevMetadata(userData.password);\n\n\t\t// Create the user with hashed password\n\t\tconst user = await storage.createUser({\n\t\t\t...userData,\n\t\t\tpassword: await hashPassword(userData.password),\n\t\t\ttempDevMeta: tempDevMetadata,\n\t\t\tisActive: isDevMode() ? true : false // Automatically active in dev mode\n\t\t});\n\n\t\t// Initialize wallet for new user\n\t\tif (walletConfig.WALLET_ENABLED) {\n\t\t\ttry {\n\t\t\t\t// Initialize DGT wallet\n\t\t\t\tawait dgtService.initializeUserWallet(user.id);\n\t\t\t\tlogger.info('AuthController', 'DGT wallet initialized for new user', { userId: user.id });\n\n\t\t\t\t// Initialize CCPayment wallet\n\t\t\t\tconst ccpaymentId = await walletService.ensureCcPaymentWallet(user.id);\n\t\t\t\tlogger.info('AuthController', 'CCPayment wallet initialized for new user', {\n\t\t\t\t\tuserId: user.id,\n\t\t\t\t\tccpaymentId\n\t\t\t\t});\n\t\t\t} catch (walletError) {\n\t\t\t\tlogger.error('AuthController', 'Error initializing wallet for new user', {\n\t\t\t\t\terr: walletError,\n\t\t\t\t\tuserId: user.id\n\t\t\t\t});\n\t\t\t\t// Continue with registration even if wallet creation fails\n\t\t\t}\n\t\t}\n\n\t\t// Create default settings for the new user\n\t\ttry {\n\t\t\t// TODO: Implement or verify createDefaultSettings functionality\n\t\t\t// Import the settings service\n\t\t\t// const { createDefaultSettings } = await import('../../admin/sub-domains/settings/settings.service');\n\t\t\t// await createDefaultSettings(user.id);\n\t\t\tlogger.info(\n\t\t\t\t'AuthController',\n\t\t\t\t'Skipping default settings creation for new user - to be implemented/verified.',\n\t\t\t\t{ userId: user.id }\n\t\t\t);\n\t\t} catch (settingsError) {\n\t\t\tlogger.error('AuthController', 'Error during (attempted) default user settings creation', {\n\t\t\t\terr: settingsError,\n\t\t\t\tuserId: user.id\n\t\t\t});\n\t\t\t// Continue with registration even if settings creation fails\n\t\t}\n\n\t\t// In dev mode, we skip verification\n\t\tif (isDevMode()) {\n\t\t\treturn res.status(201).json({\n\t\t\t\tmessage: 'Registration successful in development mode. User is automatically activated.',\n\t\t\t\tdevMode: true\n\t\t\t});\n\t\t}\n\n\t\t// Generate verification token\n\t\tconst verificationToken = randomBytes(20).toString('hex');\n\t\t// Store token in database (replace with secure token storage later)\n\t\tawait storage.storeVerificationToken(user.id, verificationToken);\n\n\t\t// Send verification email (replace with actual email sending logic)\n\t\tlogger.info('AuthController', `Verification email sent to ${userData.email}`, {\n\t\t\temail: userData.email,\n\t\t\ttoken: verificationToken\n\t\t});\n\n\t\tres.status(201).json({\n\t\t\tmessage: 'Registration successful. Please check your email to verify your account.'\n\t\t});\n\t} catch (err) {\n\t\tif (err instanceof z.ZodError) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'Validation error',\n\t\t\t\terrors: err.errors\n\t\t\t});\n\t\t}\n\t\tnext(err);\n\t}\n}\n\n/**\n * Handle user login\n */\nexport function login(req: Request, res: Response, next: NextFunction) {\n\tlogger.info('Login attempt', { username: req.body.username });\n\tpassport.authenticate('local', (err: Error, user: any, info: any) => {\n\t\tlogger.debug('Passport authenticate callback', { hasError: !!err, hasUser: !!user, info });\n\t\tif (err) {\n\t\t\tlogger.error('Authentication error', err);\n\t\t\treturn next(err);\n\t\t}\n\t\tif (!user) {\n\t\t\tlogger.warn('Authentication failed', { message: info?.message || 'No user returned' });\n\t\t\treturn res.status(401).json({ message: info?.message || 'Authentication failed' });\n\t\t}\n\n\t\tlogger.info('User authenticated', { username: user.username, userId: user.id });\n\t\treq.login(user, async (err) => {\n\t\t\tif (err) {\n\t\t\t\tlogger.error('Login session error', err);\n\t\t\t\treturn next(err);\n\t\t\t}\n\n\t\t\t// Ensure wallet is initialized for existing users\n\t\t\tif (walletConfig.WALLET_ENABLED && user.id) {\n\t\t\t\ttry {\n\t\t\t\t\t// Initialize DGT wallet if needed\n\t\t\t\t\tawait dgtService.initializeUserWallet(user.id);\n\n\t\t\t\t\t// Initialize CCPayment wallet if needed\n\t\t\t\t\tawait walletService.ensureCcPaymentWallet(user.id);\n\t\t\t\t} catch (walletError) {\n\t\t\t\t\tlogger.error('AuthController', 'Error ensuring wallet for user login', {\n\t\t\t\t\t\terr: walletError,\n\t\t\t\t\t\tuserId: user.id\n\t\t\t\t\t});\n\t\t\t\t\t// Continue with login even if wallet check fails\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove password from response\n\t\t\tconst userResponse = { ...user };\n\t\t\tdelete userResponse.password;\n\n\t\t\tres.status(200).json(userResponse);\n\t\t});\n\t})(req, res, next);\n}\n\n/**\n * Handle user logout\n */\nexport function logout(req: Request, res: Response, next: NextFunction) {\n\treq.logout((err) => {\n\t\tif (err) return next(err);\n\t\tres.sendStatus(200);\n\t});\n}\n\n/**\n * Get current user profile\n */\nexport function getCurrentUser(req: Request, res: Response) {\n\tif (!req.isAuthenticated()) return res.sendStatus(401);\n\n\t// Remove password from response\n\tconst userResponse = { ...(userService.getUserFromRequest(req) as any) };\n\tdelete userResponse.password;\n\n\t// Add computed role properties for frontend compatibility\n\tuserResponse.isAdmin = ['admin', 'super_admin'].includes(userResponse.role);\n\tuserResponse.isModerator = ['moderator', 'mod'].includes(userResponse.role);\n\tuserResponse.isSuperAdmin = userResponse.role === 'super_admin';\n\n\tres.json(UserTransformer.toAuthenticatedSelf(userResponse));\n}\n\n/**\n * Handle email verification\n */\nexport async function verifyEmail(req: Request, res: Response, next: NextFunction) {\n\ttry {\n\t\tconst { token } = req.query;\n\n\t\tif (!token || typeof token !== 'string') {\n\t\t\treturn res.status(400).json({ message: 'Invalid verification token' });\n\t\t}\n\n\t\t// Find and validate token\n\t\tconst isValid = await verifyEmailToken(token);\n\n\t\tif (!isValid) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'Invalid or expired verification token. Please request a new one.'\n\t\t\t});\n\t\t}\n\n\t\t// Activate the user account\n\t\tconst userId = isValid.userId;\n\t\tawait storage.updateUser(userId, { isActive: true });\n\n\t\treturn res.status(200).json({\n\t\t\tmessage: 'Email verified successfully. You can now log in to your account.'\n\t\t});\n\t} catch (err) {\n\t\tnext(err);\n\t}\n}\n\n/**\n * Resend verification email\n */\nexport async function resendVerification(req: Request, res: Response, next: NextFunction) {\n\ttry {\n\t\tconst { email } = req.body;\n\n\t\tif (!email) {\n\t\t\treturn res.status(400).json({ message: 'Email is required' });\n\t\t}\n\n\t\t// Find user by email\n\t\tconst user = await storage.getUserByEmail(email);\n\t\tif (!user) {\n\t\t\t// For security reasons, don't reveal if email exists or not\n\t\t\treturn res.status(200).json({\n\t\t\t\tmessage:\n\t\t\t\t\t'If your email exists in our system, you will receive a verification email shortly.'\n\t\t\t});\n\t\t}\n\n\t\t// Check if account is already active\n\t\tif (user.isActive) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'This account is already active. Please try logging in.'\n\t\t\t});\n\t\t}\n\n\t\t// Generate new verification token\n\t\tconst verificationToken = randomBytes(20).toString('hex');\n\n\t\t// Store the new token\n\t\tawait storage.storeVerificationToken(user.id, verificationToken);\n\n\t\t// Send verification email (replace with actual email sending logic)\n\t\tlogger.info('AuthController', `Verification email re-sent to ${email}`, {\n\t\t\temail,\n\t\t\ttoken: verificationToken\n\t\t});\n\n\t\tres.status(200).json({\n\t\t\tmessage: 'If your email exists in our system, you will receive a verification email shortly.'\n\t\t});\n\t} catch (err) {\n\t\tnext(err);\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/auth/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/auth/middleware/auth.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'next' is defined but never used.","line":198,"column":65,"nodeType":"Identifier","messageId":"unusedVar","endLine":198,"endColumn":83}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { Request, Response, NextFunction } from 'express';\nimport { env, isDevelopment, isProduction } from '@server/src/core/config/environment';\nimport { createMockUser } from '../services/auth.service';\nimport { logger } from '@server/src/core/logger';\nimport { shouldBypassAuth } from '@server/src/utils/environment';\n\n/**\n * Determines if a user has a specific role\n */\nexport function hasRole(req: Request, role: string): boolean {\n\tif (!userService.getUserFromRequest(req)) return false;\n\treturn (userService.getUserFromRequest(req) as any).role === role;\n}\n\n/**\n * Authentication middleware that enforces login requirement\n * Secure development bypass with strict production protection\n */\nexport function isAuthenticated(req: Request, res: Response, next: NextFunction) {\n\tif (req.isAuthenticated()) {\n\t\treturn next();\n\t}\n\n\t// SECURITY: Strict production check - no bypass allowed\n\tif (isProduction()) {\n\t\treturn res.status(401).json({\n\t\t\tmessage: 'Unauthorized',\n\t\t\terror: 'PRODUCTION_AUTH_REQUIRED'\n\t\t});\n\t}\n\n\t// Development mode bypass with strict validation\n\tif (isDevelopment() && env.DEV_BYPASS_PASSWORD && !env.DEV_FORCE_AUTH) {\n\t\tlogger.warn('AuthMiddleware', 'DEVELOPMENT: Bypassing authentication', {\n\t\t\tpath: req.path,\n\t\t\tip: req.ip,\n\t\t\tuserAgent: req.get('User-Agent')\n\t\t});\n\n\t\t// Validate development role\n\t\tconst devRole = (req.headers['x-dev-role'] as string) || 'user';\n\t\tconst validRoles = ['user', 'moderator', 'admin'];\n\n\t\tif (!validRoles.includes(devRole)) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'Invalid development role',\n\t\t\t\tvalidRoles\n\t\t\t});\n\t\t}\n\n\t\tconst roleId = req.headers['x-dev-role-id']\n\t\t\t? parseInt(req.headers['x-dev-role-id'] as string, 10)\n\t\t\t: devRole === 'admin'\n\t\t\t\t? 1\n\t\t\t\t: devRole === 'moderator'\n\t\t\t\t\t? 2\n\t\t\t\t\t: 3;\n\n\t\t// Create mock user with audit trail\n\t\t(req as any).user = createMockUser(roleId, devRole as any);\n\n\t\t// Add development flag to request for audit purposes\n\t\t(req as any).isDevelopmentBypass = true;\n\n\t\treturn next();\n\t}\n\n\tres.status(401).json({\n\t\tmessage: 'Unauthorized',\n\t\thint: isDevelopment() ? 'Set DEV_BYPASS_PASSWORD=true for development bypass' : undefined\n\t});\n}\n\n/**\n * Similar to isAuthenticated, but allows non-authenticated requests to pass through\n * In development mode, it will create a mock user if auth bypassing is enabled\n */\nexport function isAuthenticatedOptional(req: Request, res: Response, next: NextFunction) {\n\tif (req.isAuthenticated()) {\n\t\treturn next();\n\t}\n\n\t// Check if we should bypass auth in development mode\n\tif (shouldBypassAuth()) {\n\t\tlogger.info('AuthMiddleware', 'Bypassing optional authentication in development mode', {\n\t\t\tpath: req.path\n\t\t});\n\t\t// Get the dev mode role from headers or default to 'user'\n\t\tconst devRole = (req.headers['x-dev-role'] as string) || 'user';\n\t\tconst roleId = req.headers['x-dev-role-id']\n\t\t\t? parseInt(req.headers['x-dev-role-id'] as string, 10)\n\t\t\t: devRole === 'admin'\n\t\t\t\t? 1\n\t\t\t\t: devRole === 'moderator'\n\t\t\t\t\t? 2\n\t\t\t\t\t: 3;\n\n\t\t// Create a mock user with the specified role\n\t\t(req as any).user = createMockUser(roleId, devRole as any);\n\t}\n\n\t// Allow request to proceed even if not authenticated\n\treturn next();\n}\n\n/**\n * Admin role middleware - requires admin privileges\n * Secure development bypass with strict production protection\n */\nexport function isAdmin(req: Request, res: Response, next: NextFunction) {\n\t// Check if user has admin role\n\tif (hasRole(req, 'admin')) {\n\t\treturn next();\n\t}\n\n\t// SECURITY: Strict production check - no bypass allowed\n\tif (isProduction()) {\n\t\tlogger.warn('AuthMiddleware', 'PRODUCTION: Admin access denied', {\n\t\t\tpath: req.path,\n\t\t\tuserId: (userService.getUserFromRequest(req) as any)?.id,\n\t\t\tuserRole: (userService.getUserFromRequest(req) as any)?.role,\n\t\t\tip: req.ip\n\t\t});\n\t\treturn res.status(403).json({\n\t\t\tmessage: 'Forbidden - Admin access required',\n\t\t\terror: 'PRODUCTION_ADMIN_REQUIRED'\n\t\t});\n\t}\n\n\t// Development mode bypass with strict validation\n\tif (isDevelopment() && env.DEV_BYPASS_PASSWORD && req.headers['x-dev-role'] === 'admin') {\n\t\tlogger.warn('AuthMiddleware', 'DEVELOPMENT: Bypassing admin authentication', {\n\t\t\tpath: req.path,\n\t\t\tip: req.ip,\n\t\t\tuserAgent: req.get('User-Agent')\n\t\t});\n\n\t\tconst roleId = req.headers['x-dev-role-id']\n\t\t\t? parseInt(req.headers['x-dev-role-id'] as string, 10)\n\t\t\t: 1;\n\n\t\t(req as any).user = createMockUser(roleId, 'admin');\n\t\t(req as any).isDevelopmentBypass = true;\n\n\t\treturn next();\n\t}\n\n\tres.status(403).json({\n\t\tmessage: 'Forbidden - Admin access required',\n\t\thint: isDevelopment() ? 'Set x-dev-role header to \"admin\" for development bypass' : undefined\n\t});\n}\n\n/**\n * Moderator role middleware - requires moderator or admin privileges\n */\nexport function isModerator(req: Request, res: Response, next: NextFunction) {\n\tif (hasRole(req, 'moderator') || hasRole(req, 'admin')) {\n\t\treturn next();\n\t}\n\n\t// Check if we should bypass auth in development mode with moderator role\n\tif (\n\t\tshouldBypassAuth() &&\n\t\t(req.headers['x-dev-role'] === 'moderator' || req.headers['x-dev-role'] === 'admin')\n\t) {\n\t\tlogger.info('AuthMiddleware', 'Bypassing moderator authentication in development mode', {\n\t\t\tpath: req.path,\n\t\t\tdevRoleHeader: req.headers['x-dev-role']\n\t\t});\n\t\tconst devRole = req.headers['x-dev-role'] as 'moderator' | 'admin';\n\t\tconst roleId = req.headers['x-dev-role-id']\n\t\t\t? parseInt(req.headers['x-dev-role-id'] as string, 10)\n\t\t\t: devRole === 'admin'\n\t\t\t\t? 1\n\t\t\t\t: 2;\n\n\t\t(req as any).user = createMockUser(roleId, devRole);\n\t\treturn next();\n\t}\n\n\tres.status(403).json({ message: 'Forbidden' });\n}\n\n/**\n * Middleware for routes that should be accessible by either admins or moderators\n */\nexport function isAdminOrModerator(req: Request, res: Response, next: NextFunction) {\n\t// For compatibility with existing code, this is a combination function\n\treturn isModerator(req, res, next);\n}\n\n/**\n * Middleware for handling developer mode authentication switching\n * SECURITY: Only available in development with bypass enabled\n */\nexport function devModeAuthHandler(req: Request, res: Response, next: NextFunction) {\n\t// SECURITY: Strict production check\n\tif (isProduction()) {\n\t\treturn res.status(404).json({ message: 'Not found' });\n\t}\n\n\t// Only available in development mode with bypass enabled\n\tif (!isDevelopment() || !env.DEV_BYPASS_PASSWORD) {\n\t\treturn res.status(404).json({ message: 'Not found' });\n\t}\n\n\t// Log security-sensitive operation\n\tlogger.warn('AuthMiddleware', 'DEVELOPMENT: Role switching requested', {\n\t\tip: req.ip,\n\t\tuserAgent: req.get('User-Agent'),\n\t\trequestedRole: req.query.role\n\t});\n\n\t// Get the requested role from the query parameters\n\tconst role = (req.query.role as string) || 'user';\n\tconst validRoles = ['user', 'moderator', 'admin'];\n\n\tif (!validRoles.includes(role)) {\n\t\treturn res.status(400).json({\n\t\t\tmessage: 'Invalid role',\n\t\t\tvalidRoles\n\t\t});\n\t}\n\n\t// Set a session cookie with the selected role\n\t(req.session as any).devRole = role;\n\n\tres.json({\n\t\tmessage: `Development mode authentication set to: ${role}`,\n\t\trole: role,\n\t\twarning: 'DEVELOPMENT ONLY - This endpoint is disabled in production'\n\t});\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/auth/routes/xAuthRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/auth/services/auth.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/auth/services/xAuthService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/ccpayment-webhook/ccpayment-webhook.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'crypto' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CCPayment Webhook Controller\n *\n * This controller handles webhook requests from CCPayment.\n * It verifies the webhook signature and passes verified events to the service.\n */\n\nimport type { Request, Response } from 'express';\nimport { logger } from '../../core/logger';\nimport { ccpaymentService } from '../wallet/ccpayment.service';\nimport { ccpaymentWebhookService } from './ccpayment-webhook.service';\nimport { WalletError, ErrorCodes as WalletErrorCodes } from '../../core/errors';\nimport crypto from 'crypto';\n\n/**\n * CCPayment webhook controller\n */\nexport class CCPaymentWebhookController {\n\t/**\n\t * Handle webhook POST request from CCPayment\n\t * @param req Express request\n\t * @param res Express response\n\t */\n\tasync handleWebhook(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tlogger.info('Received CCPayment webhook', {\n\t\t\t\theaders: {\n\t\t\t\t\tsignature: req.header('X-Signature') ? 'present' : 'missing',\n\t\t\t\t\ttimestamp: req.header('X-Timestamp') || 'missing',\n\t\t\t\t\tappId: req.header('X-App-Id') || 'missing'\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Extract signature headers\n\t\t\tconst signature = req.header('X-Signature');\n\t\t\tconst timestamp = req.header('X-Timestamp');\n\t\t\tconst appId = req.header('X-App-Id');\n\n\t\t\t// Verify required headers are present\n\t\t\tif (!signature || !timestamp || !appId) {\n\t\t\t\tlogger.warn('Missing required webhook headers');\n\t\t\t\tres.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Missing required webhook headers'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Verify webhook signature\n\t\t\tconst isValid = ccpaymentService.verifyWebhookSignature(req.body, signature, timestamp);\n\n\t\t\tif (!isValid) {\n\t\t\t\tlogger.warn('Invalid webhook signature');\n\t\t\t\tres.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Invalid webhook signature'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Process the webhook event\n\t\t\tconst webhookEvent = req.body;\n\n\t\t\t// Log the webhook event\n\t\t\tlogger.info('Processing verified webhook event', {\n\t\t\t\teventType: webhookEvent.eventType,\n\t\t\t\torderId: webhookEvent.orderId,\n\t\t\t\tmerchantOrderId: webhookEvent.merchantOrderId,\n\t\t\t\tstatus: webhookEvent.status\n\t\t\t});\n\n\t\t\t// Process the event (asynchronously, but don't wait for completion)\n\t\t\t// This allows us to respond quickly to CCPayment while processing in the background\n\t\t\tconst processPromise = ccpaymentWebhookService.processWebhookEvent(webhookEvent);\n\n\t\t\t// Immediately respond to the webhook\n\t\t\tres.status(200).json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Webhook received and validated'\n\t\t\t});\n\n\t\t\t// Wait for processing to complete (for logging purposes)\n\t\t\tconst result = await processPromise;\n\t\t\tlogger.info('Webhook processing completed', result);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error handling webhook', error);\n\n\t\t\t// Still respond with 200 to CCPayment to prevent retries\n\t\t\t// CCPayment expects 200 OK even if processing fails\n\t\t\tres.status(200).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Webhook received but processing failed'\n\t\t\t});\n\t\t}\n\t}\n}\n\n// Export a singleton instance\nexport const ccpaymentWebhookController = new CCPaymentWebhookController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/ccpayment-webhook/ccpayment-webhook.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/ccpayment-webhook/ccpayment-webhook.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/collectibles/stickers/stickers.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":45,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":63,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":81,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":81,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":105,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":105,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":130,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":130,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":154,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":154,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":180,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":180,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":198,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":198,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":216,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":216,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":240,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":240,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":265,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":265,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":291,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":291,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":291,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":291,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":308,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":308,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":338,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":338,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":399,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":399,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'res' is defined but never used.","line":483,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":483,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Sticker Controller\n *\n * Handles HTTP requests for the sticker system\n */\n\nimport type { Request, Response } from 'express';\nimport { z } from 'zod';\nimport { stickerService } from './stickers.service';\nimport {\n\tcreateStickerSchema,\n\tupdateStickerSchema,\n\tlistStickersSchema,\n\tcreateStickerPackSchema,\n\tupdateStickerPackSchema,\n\tlistStickerPacksSchema,\n\tbulkDeleteStickersSchema,\n\ttrackStickerUsageSchema,\n\ttype CreateStickerInput,\n\ttype UpdateStickerInput,\n\ttype CreateStickerPackInput,\n\ttype UpdateStickerPackInput\n} from './stickers.validators';\nimport { formatAdminResponse, AdminOperationBoundary } from '@server/src/domains/admin/shared';\nimport { AdminError, AdminErrorCodes } from '@server/src/domains/admin/admin.errors';\nimport type { StickerId, PackId } from '@shared/types';\n\n// Additional validation schemas\nconst stickerIdSchema = z.object({\n\tid: z.string()\n});\n\nconst packIdSchema = z.object({\n\tid: z.string()\n});\n\nexport class StickerController {\n\t// ============ STICKER OPERATIONS ============\n\n\t/**\n\t * GET /api/admin/stickers\n\t * List all stickers with filtering and pagination\n\t */\n\tasync getStickers(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'LIST_STICKERS',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst filters = listStickersSchema.parse(req.query);\n\t\t\tconst result = await stickerService.getStickers(filters);\n\n\t\t\treturn formatAdminResponse(result, 'LIST_STICKERS', 'sticker');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/stickers/:id\n\t * Get sticker details by ID\n\t */\n\tasync getSticker(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_STICKER',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = stickerIdSchema.parse(req.params);\n\t\t\tconst sticker = await stickerService.getSticker(id);\n\n\t\t\treturn formatAdminResponse({ sticker }, 'GET_STICKER', 'sticker');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/stickers\n\t * Create a new sticker\n\t */\n\tasync createSticker(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'CREATE_STICKER',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst stickerData = createStickerSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await stickerService.createSticker(stickerData, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'CREATE_STICKER', 'sticker');\n\t\t});\n\t}\n\n\t/**\n\t * PUT /api/admin/stickers/:id\n\t * Update an existing sticker\n\t */\n\tasync updateSticker(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'UPDATE_STICKER',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = stickerIdSchema.parse(req.params);\n\t\t\tconst stickerData = updateStickerSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await stickerService.updateSticker(id, stickerData, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'UPDATE_STICKER', 'sticker');\n\t\t});\n\t}\n\n\t/**\n\t * DELETE /api/admin/stickers/:id\n\t * Delete a sticker (soft delete)\n\t */\n\tasync deleteSticker(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'DELETE_STICKER',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = stickerIdSchema.parse(req.params);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await stickerService.deleteSticker(id, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'DELETE_STICKER', 'sticker');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/stickers/bulk-delete\n\t * Bulk delete stickers\n\t */\n\tasync bulkDeleteStickers(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'BULK_DELETE_STICKERS',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst data = bulkDeleteStickersSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await stickerService.bulkDeleteStickers(data, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'BULK_DELETE_STICKERS', 'sticker');\n\t\t});\n\t}\n\n\t// ============ STICKER PACK OPERATIONS ============\n\n\t/**\n\t * GET /api/admin/sticker-packs\n\t * List all sticker packs with filtering\n\t */\n\tasync getStickerPacks(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'LIST_STICKER_PACKS',\n\t\t\tentityType: 'stickerPack'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst filters = listStickerPacksSchema.parse(req.query);\n\t\t\tconst result = await stickerService.getStickerPacks(filters);\n\n\t\t\treturn formatAdminResponse(result, 'LIST_STICKER_PACKS', 'stickerPack');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/sticker-packs/:id\n\t * Get sticker pack details by ID\n\t */\n\tasync getStickerPack(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_STICKER_PACK',\n\t\t\tentityType: 'stickerPack'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = packIdSchema.parse(req.params);\n\t\t\tconst pack = await stickerService.getStickerPack(id);\n\n\t\t\treturn formatAdminResponse({ pack }, 'GET_STICKER_PACK', 'stickerPack');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/sticker-packs\n\t * Create a new sticker pack\n\t */\n\tasync createStickerPack(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'CREATE_STICKER_PACK',\n\t\t\tentityType: 'stickerPack'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst packData = createStickerPackSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await stickerService.createStickerPack(packData, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'CREATE_STICKER_PACK', 'stickerPack');\n\t\t});\n\t}\n\n\t/**\n\t * PUT /api/admin/sticker-packs/:id\n\t * Update an existing sticker pack\n\t */\n\tasync updateStickerPack(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'UPDATE_STICKER_PACK',\n\t\t\tentityType: 'stickerPack'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = packIdSchema.parse(req.params);\n\t\t\tconst packData = updateStickerPackSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await stickerService.updateStickerPack(id, packData, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'UPDATE_STICKER_PACK', 'stickerPack');\n\t\t});\n\t}\n\n\t/**\n\t * DELETE /api/admin/sticker-packs/:id\n\t * Delete a sticker pack\n\t */\n\tasync deleteStickerPack(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'DELETE_STICKER_PACK',\n\t\t\tentityType: 'stickerPack'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst { id } = packIdSchema.parse(req.params);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tconst result = await stickerService.deleteStickerPack(id, adminId);\n\n\t\t\treturn formatAdminResponse(result, 'DELETE_STICKER_PACK', 'stickerPack');\n\t\t});\n\t}\n\n\t// ============ UTILITY ENDPOINTS ============\n\n\t/**\n\t * GET /api/admin/stickers/categories\n\t * Get available sticker categories/metadata\n\t */\n\tasync getStickerCategories(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'GET_STICKER_CATEGORIES',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst categories = await stickerService.getStickerCategories();\n\n\t\t\treturn formatAdminResponse(categories, 'GET_STICKER_CATEGORIES', 'sticker');\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/stickers/track-usage\n\t * Track sticker usage (for analytics)\n\t */\n\tasync trackStickerUsage(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'TRACK_STICKER_USAGE',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst usageData = trackStickerUsageSchema.parse(req.body);\n\t\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!userId) {\n\t\t\t\tthrow new AdminError('User ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\tawait stickerService.trackStickerUsage(usageData, userId);\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{ message: 'Usage tracked successfully' },\n\t\t\t\t'TRACK_STICKER_USAGE',\n\t\t\t\t'sticker'\n\t\t\t);\n\t\t});\n\t}\n\n\t// ============ FILE UPLOAD ENDPOINTS ============\n\n\t/**\n\t * POST /api/admin/stickers/upload\n\t * Upload sticker file (Supabase Storage)\n\t */\n\tasync uploadStickerFile(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'UPLOAD_STICKER_FILE',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\t// Parse upload parameters from request body\n\t\t\tconst uploadSchema = z.object({\n\t\t\t\tfileName: z.string().min(1),\n\t\t\t\tfileType: z.string().min(1),\n\t\t\t\tfileSize: z.number().positive(),\n\t\t\t\tuploadType: z.enum([\n\t\t\t\t\t'sticker_static',\n\t\t\t\t\t'sticker_animated',\n\t\t\t\t\t'sticker_thumbnail',\n\t\t\t\t\t'sticker_pack_cover',\n\t\t\t\t\t'sticker_pack_preview'\n\t\t\t\t]),\n\t\t\t\tstickerId: z.string().uuid().positive().optional(),\n\t\t\t\tpackId: z.string().uuid().positive().optional()\n\t\t\t});\n\n\t\t\tconst uploadData = uploadSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\t// Import upload service\n\t\t\tconst { uploadService } = await import('@server/src/domains/uploads/upload.service');\n\n\t\t\t// Create presigned upload URL\n\t\t\tconst result = await uploadService.createPresignedUploadUrl({\n\t\t\t\tuserId: adminId, // Admin user creating the upload\n\t\t\t\tfileName: uploadData.fileName,\n\t\t\t\tfileType: uploadData.fileType,\n\t\t\t\tfileSize: uploadData.fileSize,\n\t\t\t\tuploadType: uploadData.uploadType,\n\t\t\t\tstickerId: uploadData.stickerId,\n\t\t\t\tpackId: uploadData.packId\n\t\t\t});\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\tuploadUrl: result.uploadUrl,\n\t\t\t\t\tpublicUrl: result.publicUrl,\n\t\t\t\t\trelativePath: result.relativePath,\n\t\t\t\t\tmessage: 'Upload URL generated successfully. Use this URL to upload your file.'\n\t\t\t\t},\n\t\t\t\t'UPLOAD_STICKER_FILE',\n\t\t\t\t'sticker'\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * POST /api/admin/stickers/confirm-upload\n\t * Confirm sticker file upload completion\n\t */\n\tasync confirmStickerUpload(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'CONFIRM_STICKER_UPLOAD',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst confirmSchema = z.object({\n\t\t\t\trelativePath: z.string().min(1),\n\t\t\t\tuploadType: z.enum([\n\t\t\t\t\t'sticker_static',\n\t\t\t\t\t'sticker_animated',\n\t\t\t\t\t'sticker_thumbnail',\n\t\t\t\t\t'sticker_pack_cover',\n\t\t\t\t\t'sticker_pack_preview'\n\t\t\t\t]),\n\t\t\t\tstickerId: z.string().uuid().positive().optional(),\n\t\t\t\tpackId: z.string().uuid().positive().optional()\n\t\t\t});\n\n\t\t\tconst confirmData = confirmSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\t// Import upload service\n\t\t\tconst { uploadService } = await import('@server/src/domains/uploads/upload.service');\n\n\t\t\t// Confirm upload\n\t\t\tconst result = await uploadService.confirmUpload(adminId, {\n\t\t\t\trelativePath: confirmData.relativePath,\n\t\t\t\tuploadType: confirmData.uploadType\n\t\t\t});\n\n\t\t\t// If this is a sticker file, update the sticker record with the new URL\n\t\t\tif (confirmData.stickerId && result.newPublicUrl) {\n\t\t\t\tconst updateData: any = {};\n\n\t\t\t\tif (confirmData.uploadType === 'sticker_static') {\n\t\t\t\t\tupdateData.staticUrl = result.newPublicUrl;\n\t\t\t\t} else if (confirmData.uploadType === 'sticker_animated') {\n\t\t\t\t\tupdateData.animatedUrl = result.newPublicUrl;\n\t\t\t\t\tupdateData.isAnimated = true;\n\t\t\t\t} else if (confirmData.uploadType === 'sticker_thumbnail') {\n\t\t\t\t\tupdateData.thumbnailUrl = result.newPublicUrl;\n\t\t\t\t}\n\n\t\t\t\tif (Object.keys(updateData).length > 0) {\n\t\t\t\t\tawait stickerService.updateSticker(confirmData.stickerId, updateData, adminId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this is a pack file, update the pack record\n\t\t\tif (confirmData.packId && result.newPublicUrl) {\n\t\t\t\tconst updateData: any = {};\n\n\t\t\t\tif (confirmData.uploadType === 'sticker_pack_cover') {\n\t\t\t\t\tupdateData.coverUrl = result.newPublicUrl;\n\t\t\t\t} else if (confirmData.uploadType === 'sticker_pack_preview') {\n\t\t\t\t\tupdateData.previewUrl = result.newPublicUrl;\n\t\t\t\t}\n\n\t\t\t\tif (Object.keys(updateData).length > 0) {\n\t\t\t\t\tawait stickerService.updateStickerPack(confirmData.packId, updateData, adminId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn formatAdminResponse(\n\t\t\t\t{\n\t\t\t\t\t...result,\n\t\t\t\t\tmessage: 'Upload confirmed and sticker/pack updated successfully'\n\t\t\t\t},\n\t\t\t\t'CONFIRM_STICKER_UPLOAD',\n\t\t\t\t'sticker'\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * DELETE /api/admin/stickers/delete-file\n\t * Delete sticker file from storage (admin asset management)\n\t */\n\tasync deleteStickerFile(req: Request, res: Response) {\n\t\tconst boundary = new AdminOperationBoundary({\n\t\t\toperation: 'DELETE_STICKER_FILE',\n\t\t\tentityType: 'sticker'\n\t\t});\n\n\t\treturn boundary.execute(async () => {\n\t\t\tconst deleteSchema = z.object({\n\t\t\t\trelativePath: z.string().min(1),\n\t\t\t\tuploadType: z.enum([\n\t\t\t\t\t'sticker_static',\n\t\t\t\t\t'sticker_animated',\n\t\t\t\t\t'sticker_thumbnail',\n\t\t\t\t\t'sticker_pack_cover',\n\t\t\t\t\t'sticker_pack_preview'\n\t\t\t\t]),\n\t\t\t\tstickerId: z.string().uuid().positive().optional(),\n\t\t\t\tpackId: z.string().uuid().positive().optional()\n\t\t\t});\n\n\t\t\tconst deleteData = deleteSchema.parse(req.body);\n\t\t\tconst adminId = userService.getUserFromRequest(req)?.id;\n\n\t\t\tif (!adminId) {\n\t\t\t\tthrow new AdminError('Admin ID required', 401, AdminErrorCodes.UNAUTHORIZED);\n\t\t\t}\n\n\t\t\t// Import upload service\n\t\t\tconst { uploadService } = await import('@server/src/domains/uploads/upload.service');\n\n\t\t\t// Delete file from storage\n\t\t\tconst result = await uploadService.deleteFile(\n\t\t\t\tdeleteData.uploadType,\n\t\t\t\tdeleteData.relativePath,\n\t\t\t\tadminId\n\t\t\t);\n\n\t\t\t// If deletion was successful, update database records to remove URLs\n\t\t\tif (result.success) {\n\t\t\t\tif (deleteData.stickerId) {\n\t\t\t\t\tconst updateData: any = {};\n\n\t\t\t\t\tif (deleteData.uploadType === 'sticker_static') {\n\t\t\t\t\t\tupdateData.staticUrl = null;\n\t\t\t\t\t} else if (deleteData.uploadType === 'sticker_animated') {\n\t\t\t\t\t\tupdateData.animatedUrl = null;\n\t\t\t\t\t\tupdateData.isAnimated = false;\n\t\t\t\t\t} else if (deleteData.uploadType === 'sticker_thumbnail') {\n\t\t\t\t\t\tupdateData.thumbnailUrl = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Object.keys(updateData).length > 0) {\n\t\t\t\t\t\tawait stickerService.updateSticker(deleteData.stickerId, updateData, adminId);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (deleteData.packId) {\n\t\t\t\t\tconst updateData: any = {};\n\n\t\t\t\t\tif (deleteData.uploadType === 'sticker_pack_cover') {\n\t\t\t\t\t\tupdateData.coverUrl = null;\n\t\t\t\t\t} else if (deleteData.uploadType === 'sticker_pack_preview') {\n\t\t\t\t\t\tupdateData.previewUrl = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Object.keys(updateData).length > 0) {\n\t\t\t\t\t\tawait stickerService.updateStickerPack(deleteData.packId, updateData, adminId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn formatAdminResponse(result, 'DELETE_STICKER_FILE', 'sticker');\n\t\t});\n\t}\n\n\t/**\n\t * GET /api/admin/stickers/preview/:id\n\t * Preview sticker (supports WebP/WebM/Lottie)\n\t */\n\tasync previewSticker(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst { id } = stickerIdSchema.parse(req.params);\n\t\t\tconst sticker = await stickerService.getSticker(id);\n\n\t\t\t// Return sticker URLs for preview\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tstaticUrl: sticker.staticUrl,\n\t\t\t\t\tanimatedUrl: sticker.animatedUrl,\n\t\t\t\t\tthumbnailUrl: sticker.thumbnailUrl,\n\t\t\t\t\tformat: sticker.format,\n\t\t\t\t\tisAnimated: sticker.isAnimated,\n\t\t\t\t\twidth: sticker.width,\n\t\t\t\t\theight: sticker.height\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message || 'Failed to preview sticker'\n\t\t\t});\n\t\t}\n\t}\n}\n\n// Export controller instance\nexport const stickerController = new StickerController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/collectibles/stickers/stickers.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/collectibles/stickers/stickers.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'like' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":7,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userStickerPacks' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminId' is defined but never used.","line":279,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":279,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminId' is defined but never used.","line":344,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":344,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminId' is defined but never used.","line":369,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":369,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminId' is defined but never used.","line":537,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":537,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'adminId' is defined but never used.","line":566,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":566,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sticker Service\n *\n * Business logic for Telegram-style sticker system\n */\n\nimport { eq, and, like, desc, asc, count, sql, inArray, isNull } from 'drizzle-orm';\nimport { db } from '../../../core/db';\nimport {\n\tstickers,\n\tstickerPacks,\n\tuserStickerInventory,\n\tuserStickerPacks,\n\tstickerUsage,\n\ttype Sticker,\n\ttype StickerPack,\n\ttype NewSticker,\n\ttype NewStickerPack\n} from '@schema';\nimport {\n\ttype CreateStickerInput,\n\ttype UpdateStickerInput,\n\ttype ListStickersInput,\n\ttype CreateStickerPackInput,\n\ttype UpdateStickerPackInput,\n\ttype ListStickerPacksInput,\n\ttype BulkDeleteStickersInput,\n\ttype TrackStickerUsageInput\n} from './stickers.validators';\nimport type { PackId, StickerId } from '@shared/types';\n\nexport class StickerService {\n\t// ============ STICKER MANAGEMENT ============\n\n\t/**\n\t * Get all stickers with filtering and pagination\n\t */\n\tasync getStickers(options: ListStickersInput) {\n\t\tconst {\n\t\t\tpage,\n\t\t\tlimit,\n\t\t\tsearch,\n\t\t\trarity,\n\t\t\tpackId,\n\t\t\tunlockType,\n\t\t\tisActive,\n\t\t\tisVisible,\n\t\t\tisAnimated,\n\t\t\tsortBy,\n\t\t\tsortOrder\n\t\t} = options;\n\t\tconst offset = (page - 1) * limit;\n\n\t\t// Build where conditions\n\t\tconst conditions = [];\n\t\tconditions.push(eq(stickers.isDeleted, false));\n\n\t\tif (search) {\n\t\t\tconditions.push(\n\t\t\t\tsql`(${stickers.displayName} ILIKE ${`%${search}%`} OR ${stickers.shortcode} ILIKE ${`%${search}%`} OR ${stickers.tags} ILIKE ${`%${search}%`})`\n\t\t\t);\n\t\t}\n\t\tif (rarity) conditions.push(eq(stickers.rarity, rarity));\n\t\tif (packId) conditions.push(eq(stickers.packId, packId));\n\t\tif (unlockType) conditions.push(eq(stickers.unlockType, unlockType));\n\t\tif (isActive !== undefined) conditions.push(eq(stickers.isActive, isActive));\n\t\tif (isVisible !== undefined) conditions.push(eq(stickers.isVisible, isVisible));\n\t\tif (isAnimated !== undefined) conditions.push(eq(stickers.isAnimated, isAnimated));\n\n\t\t// Build sort order\n\t\tconst orderBy = sortOrder === 'asc' ? asc : desc;\n\t\tlet sortColumn;\n\t\tswitch (sortBy) {\n\t\t\tcase 'name':\n\t\t\t\tsortColumn = stickers.name;\n\t\t\t\tbreak;\n\t\t\tcase 'displayName':\n\t\t\t\tsortColumn = stickers.displayName;\n\t\t\t\tbreak;\n\t\t\tcase 'rarity':\n\t\t\t\tsortColumn = stickers.rarity;\n\t\t\t\tbreak;\n\t\t\tcase 'popularity':\n\t\t\t\tsortColumn = stickers.popularityScore;\n\t\t\t\tbreak;\n\t\t\tcase 'unlocks':\n\t\t\t\tsortColumn = stickers.totalUnlocks;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsortColumn = stickers.createdAt;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Execute query with pack information\n\t\tconst [stickerList, totalCountResult] = await Promise.all([\n\t\t\tdb\n\t\t\t\t.select({\n\t\t\t\t\tid: stickers.id,\n\t\t\t\t\tname: stickers.name,\n\t\t\t\t\tdisplayName: stickers.displayName,\n\t\t\t\t\tshortcode: stickers.shortcode,\n\t\t\t\t\tdescription: stickers.description,\n\t\t\t\t\tstaticUrl: stickers.staticUrl,\n\t\t\t\t\tanimatedUrl: stickers.animatedUrl,\n\t\t\t\t\tthumbnailUrl: stickers.thumbnailUrl,\n\t\t\t\t\twidth: stickers.width,\n\t\t\t\t\theight: stickers.height,\n\t\t\t\t\tstaticFileSize: stickers.staticFileSize,\n\t\t\t\t\tanimatedFileSize: stickers.animatedFileSize,\n\t\t\t\t\tformat: stickers.format,\n\t\t\t\t\trarity: stickers.rarity,\n\t\t\t\t\tpackId: stickers.packId,\n\t\t\t\t\tunlockType: stickers.unlockType,\n\t\t\t\t\tpriceDgt: stickers.priceDgt,\n\t\t\t\t\trequiredXp: stickers.requiredXp,\n\t\t\t\t\trequiredLevel: stickers.requiredLevel,\n\t\t\t\t\tisActive: stickers.isActive,\n\t\t\t\t\tisVisible: stickers.isVisible,\n\t\t\t\t\tisAnimated: stickers.isAnimated,\n\t\t\t\t\ttotalUnlocks: stickers.totalUnlocks,\n\t\t\t\t\ttotalUsage: stickers.totalUsage,\n\t\t\t\t\tpopularityScore: stickers.popularityScore,\n\t\t\t\t\tcreatedAt: stickers.createdAt,\n\t\t\t\t\tupdatedAt: stickers.updatedAt,\n\t\t\t\t\ttags: stickers.tags,\n\t\t\t\t\tadminNotes: stickers.adminNotes,\n\t\t\t\t\t// Pack information\n\t\t\t\t\tpackName: stickerPacks.displayName\n\t\t\t\t})\n\t\t\t\t.from(stickers)\n\t\t\t\t.leftJoin(stickerPacks, eq(stickers.packId, stickerPacks.id))\n\t\t\t\t.where(and(...conditions))\n\t\t\t\t.orderBy(orderBy(sortColumn))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset),\n\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(stickers)\n\t\t\t\t.leftJoin(stickerPacks, eq(stickers.packId, stickerPacks.id))\n\t\t\t\t.where(and(...conditions))\n\t\t]);\n\n\t\tconst totalCount = totalCountResult[0]?.count || 0;\n\t\tconst totalPages = Math.ceil(totalCount / limit);\n\n\t\treturn {\n\t\t\tstickers: stickerList,\n\t\t\tpagination: {\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\ttotalCount,\n\t\t\t\ttotalPages,\n\t\t\t\thasNext: page < totalPages,\n\t\t\t\thasPrev: page > 1\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Get single sticker by ID\n\t */\n\tasync getSticker(id: Id<'id'>): Promise<Sticker & { packName?: string }> {\n\t\tconst result = await db\n\t\t\t.select({\n\t\t\t\tid: stickers.id,\n\t\t\t\tname: stickers.name,\n\t\t\t\tdisplayName: stickers.displayName,\n\t\t\t\tshortcode: stickers.shortcode,\n\t\t\t\tdescription: stickers.description,\n\t\t\t\tstaticUrl: stickers.staticUrl,\n\t\t\t\tanimatedUrl: stickers.animatedUrl,\n\t\t\t\tthumbnailUrl: stickers.thumbnailUrl,\n\t\t\t\twidth: stickers.width,\n\t\t\t\theight: stickers.height,\n\t\t\t\tstaticFileSize: stickers.staticFileSize,\n\t\t\t\tanimatedFileSize: stickers.animatedFileSize,\n\t\t\t\tformat: stickers.format,\n\t\t\t\trarity: stickers.rarity,\n\t\t\t\tpackId: stickers.packId,\n\t\t\t\tunlockType: stickers.unlockType,\n\t\t\t\tpriceDgt: stickers.priceDgt,\n\t\t\t\trequiredXp: stickers.requiredXp,\n\t\t\t\trequiredLevel: stickers.requiredLevel,\n\t\t\t\tisActive: stickers.isActive,\n\t\t\t\tisVisible: stickers.isVisible,\n\t\t\t\tisAnimated: stickers.isAnimated,\n\t\t\t\tisDeleted: stickers.isDeleted,\n\t\t\t\tdeletedAt: stickers.deletedAt,\n\t\t\t\ttotalUnlocks: stickers.totalUnlocks,\n\t\t\t\ttotalUsage: stickers.totalUsage,\n\t\t\t\tpopularityScore: stickers.popularityScore,\n\t\t\t\tcreatedBy: stickers.createdBy,\n\t\t\t\tcreatedAt: stickers.createdAt,\n\t\t\t\tupdatedAt: stickers.updatedAt,\n\t\t\t\tadminNotes: stickers.adminNotes,\n\t\t\t\ttags: stickers.tags,\n\t\t\t\tpackName: stickerPacks.displayName\n\t\t\t})\n\t\t\t.from(stickers)\n\t\t\t.leftJoin(stickerPacks, eq(stickers.packId, stickerPacks.id))\n\t\t\t.where(and(eq(stickers.id, id), eq(stickers.isDeleted, false)))\n\t\t\t.limit(1);\n\n\t\tif (!result[0]) {\n\t\t\tthrow new Error('Sticker not found');\n\t\t}\n\n\t\treturn result[0];\n\t}\n\n\t/**\n\t * Create new sticker\n\t */\n\tasync createSticker(\n\t\tdata: CreateStickerInput,\n\t\tadminId: string\n\t): Promise<{ stickerId: StickerId; message: string }> {\n\t\t// Check for duplicate shortcode\n\t\tconst existingShortcode = await db\n\t\t\t.select({ id: stickers.id })\n\t\t\t.from(stickers)\n\t\t\t.where(and(eq(stickers.shortcode, data.shortcode), eq(stickers.isDeleted, false)))\n\t\t\t.limit(1);\n\n\t\tif (existingShortcode.length > 0) {\n\t\t\tthrow new Error('Sticker shortcode already exists');\n\t\t}\n\n\t\t// Check for duplicate name\n\t\tconst existingName = await db\n\t\t\t.select({ id: stickers.id })\n\t\t\t.from(stickers)\n\t\t\t.where(and(eq(stickers.name, data.name), eq(stickers.isDeleted, false)))\n\t\t\t.limit(1);\n\n\t\tif (existingName.length > 0) {\n\t\t\tthrow new Error('Sticker name already exists');\n\t\t}\n\n\t\t// Validate pack exists if specified\n\t\tif (data.packId) {\n\t\t\tconst pack = await db\n\t\t\t\t.select({ id: stickerPacks.id })\n\t\t\t\t.from(stickerPacks)\n\t\t\t\t.where(eq(stickerPacks.id, data.packId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (!pack[0]) {\n\t\t\t\tthrow new Error('Sticker pack not found');\n\t\t\t}\n\t\t}\n\n\t\tconst newSticker: NewSticker = {\n\t\t\t...data,\n\t\t\tcreatedBy: adminId\n\t\t};\n\n\t\tconst result = await db.insert(stickers).values(newSticker).returning({ id: stickers.id });\n\t\tconst stickerId = result[0].id;\n\n\t\t// Update pack sticker count if sticker belongs to a pack\n\t\tif (data.packId) {\n\t\t\tawait this.updatePackStickerCount(data.packId);\n\t\t}\n\n\t\treturn {\n\t\t\tstickerId,\n\t\t\tmessage: 'Sticker created successfully'\n\t\t};\n\t}\n\n\t/**\n\t * Update existing sticker\n\t */\n\tasync updateSticker(\n\t\tid: Id<'id'>,\n\t\tdata: UpdateStickerInput,\n\t\tadminId: string\n\t): Promise<{ message: string }> {\n\t\t// Check if sticker exists\n\t\tconst existingSticker = await this.getSticker(id);\n\n\t\t// Check for duplicate shortcode (if changing)\n\t\tif (data.shortcode && data.shortcode !== existingSticker.shortcode) {\n\t\t\tconst duplicateShortcode = await db\n\t\t\t\t.select({ id: stickers.id })\n\t\t\t\t.from(stickers)\n\t\t\t\t.where(and(eq(stickers.shortcode, data.shortcode), eq(stickers.isDeleted, false)))\n\t\t\t\t.limit(1);\n\n\t\t\tif (duplicateShortcode.length > 0) {\n\t\t\t\tthrow new Error('Sticker shortcode already exists');\n\t\t\t}\n\t\t}\n\n\t\t// Check for duplicate name (if changing)\n\t\tif (data.name && data.name !== existingSticker.name) {\n\t\t\tconst duplicateName = await db\n\t\t\t\t.select({ id: stickers.id })\n\t\t\t\t.from(stickers)\n\t\t\t\t.where(and(eq(stickers.name, data.name), eq(stickers.isDeleted, false)))\n\t\t\t\t.limit(1);\n\n\t\t\tif (duplicateName.length > 0) {\n\t\t\t\tthrow new Error('Sticker name already exists');\n\t\t\t}\n\t\t}\n\n\t\t// Validate pack exists if changing\n\t\tif (data.packId && data.packId !== existingSticker.packId) {\n\t\t\tconst pack = await db\n\t\t\t\t.select({ id: stickerPacks.id })\n\t\t\t\t.from(stickerPacks)\n\t\t\t\t.where(eq(stickerPacks.id, data.packId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (!pack[0]) {\n\t\t\t\tthrow new Error('Sticker pack not found');\n\t\t\t}\n\t\t}\n\n\t\tawait db\n\t\t\t.update(stickers)\n\t\t\t.set({ ...data, updatedAt: sql`now()` })\n\t\t\t.where(eq(stickers.id, id));\n\n\t\t// Update pack sticker counts if pack changed\n\t\tif (data.packId !== undefined) {\n\t\t\tif (existingSticker.packId) {\n\t\t\t\tawait this.updatePackStickerCount(existingSticker.packId);\n\t\t\t}\n\t\t\tif (data.packId) {\n\t\t\t\tawait this.updatePackStickerCount(data.packId);\n\t\t\t}\n\t\t}\n\n\t\treturn { message: 'Sticker updated successfully' };\n\t}\n\n\t/**\n\t * Soft delete sticker\n\t */\n\tasync deleteSticker(id: Id<'id'>, adminId: string): Promise<{ message: string }> {\n\t\tconst existingSticker = await this.getSticker(id);\n\n\t\tawait db\n\t\t\t.update(stickers)\n\t\t\t.set({\n\t\t\t\tisDeleted: true,\n\t\t\t\tdeletedAt: sql`now()`,\n\t\t\t\tupdatedAt: sql`now()`\n\t\t\t})\n\t\t\t.where(eq(stickers.id, id));\n\n\t\t// Update pack sticker count\n\t\tif (existingSticker.packId) {\n\t\t\tawait this.updatePackStickerCount(existingSticker.packId);\n\t\t}\n\n\t\treturn { message: 'Sticker deleted successfully' };\n\t}\n\n\t/**\n\t * Bulk delete stickers\n\t */\n\tasync bulkDeleteStickers(\n\t\tdata: BulkDeleteStickersInput,\n\t\tadminId: string\n\t): Promise<{ deletedCount: number; message: string }> {\n\t\t// Get pack IDs for count updates\n\t\tconst stickerPacks = await db\n\t\t\t.select({ packId: stickers.packId })\n\t\t\t.from(stickers)\n\t\t\t.where(and(inArray(stickers.id, data.ids), eq(stickers.isDeleted, false)));\n\n\t\tconst result = await db\n\t\t\t.update(stickers)\n\t\t\t.set({\n\t\t\t\tisDeleted: true,\n\t\t\t\tdeletedAt: sql`now()`,\n\t\t\t\tupdatedAt: sql`now()`\n\t\t\t})\n\t\t\t.where(and(inArray(stickers.id, data.ids), eq(stickers.isDeleted, false)))\n\t\t\t.returning({ id: stickers.id });\n\n\t\t// Update pack sticker counts\n\t\tconst uniquePackIds = [...new Set(stickerPacks.map((p) => p.packId).filter(Boolean))];\n\t\tawait Promise.all(uniquePackIds.map((packId) => this.updatePackStickerCount(packId)));\n\n\t\treturn {\n\t\t\tdeletedCount: result.length,\n\t\t\tmessage: `${result.length} stickers deleted successfully`\n\t\t};\n\t}\n\n\t// ============ STICKER PACK MANAGEMENT ============\n\n\t/**\n\t * Get all sticker packs with filtering\n\t */\n\tasync getStickerPacks(options: ListStickerPacksInput) {\n\t\tconst {\n\t\t\tpage,\n\t\t\tlimit,\n\t\t\tsearch,\n\t\t\ttheme,\n\t\t\tunlockType,\n\t\t\tisActive,\n\t\t\tisVisible,\n\t\t\tisPromoted,\n\t\t\tsortBy,\n\t\t\tsortOrder\n\t\t} = options;\n\t\tconst offset = (page - 1) * limit;\n\n\t\t// Build where conditions\n\t\tconst conditions = [];\n\n\t\tif (search) {\n\t\t\tconditions.push(\n\t\t\t\tsql`(${stickerPacks.displayName} ILIKE ${`%${search}%`} OR ${stickerPacks.description} ILIKE ${`%${search}%`})`\n\t\t\t);\n\t\t}\n\t\tif (theme) conditions.push(eq(stickerPacks.theme, theme));\n\t\tif (unlockType) conditions.push(eq(stickerPacks.unlockType, unlockType));\n\t\tif (isActive !== undefined) conditions.push(eq(stickerPacks.isActive, isActive));\n\t\tif (isVisible !== undefined) conditions.push(eq(stickerPacks.isVisible, isVisible));\n\t\tif (isPromoted !== undefined) conditions.push(eq(stickerPacks.isPromoted, isPromoted));\n\n\t\t// Build sort order\n\t\tconst orderBy = sortOrder === 'asc' ? asc : desc;\n\t\tlet sortColumn;\n\t\tswitch (sortBy) {\n\t\t\tcase 'name':\n\t\t\t\tsortColumn = stickerPacks.name;\n\t\t\t\tbreak;\n\t\t\tcase 'displayName':\n\t\t\t\tsortColumn = stickerPacks.displayName;\n\t\t\t\tbreak;\n\t\t\tcase 'popularity':\n\t\t\t\tsortColumn = stickerPacks.popularityScore;\n\t\t\t\tbreak;\n\t\t\tcase 'unlocks':\n\t\t\t\tsortColumn = stickerPacks.totalUnlocks;\n\t\t\t\tbreak;\n\t\t\tcase 'sortOrder':\n\t\t\t\tsortColumn = stickerPacks.sortOrder;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsortColumn = stickerPacks.createdAt;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Execute query\n\t\tconst [packList, totalCountResult] = await Promise.all([\n\t\t\tdb\n\t\t\t\t.select()\n\t\t\t\t.from(stickerPacks)\n\t\t\t\t.where(conditions.length > 0 ? and(...conditions) : undefined)\n\t\t\t\t.orderBy(orderBy(sortColumn))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset),\n\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(stickerPacks)\n\t\t\t\t.where(conditions.length > 0 ? and(...conditions) : undefined)\n\t\t]);\n\n\t\tconst totalCount = totalCountResult[0]?.count || 0;\n\t\tconst totalPages = Math.ceil(totalCount / limit);\n\n\t\treturn {\n\t\t\tpacks: packList,\n\t\t\tpagination: {\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\ttotalCount,\n\t\t\t\ttotalPages,\n\t\t\t\thasNext: page < totalPages,\n\t\t\t\thasPrev: page > 1\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Get single sticker pack by ID\n\t */\n\tasync getStickerPack(id: Id<'id'>): Promise<StickerPack> {\n\t\tconst result = await db.select().from(stickerPacks).where(eq(stickerPacks.id, id)).limit(1);\n\n\t\tif (!result[0]) {\n\t\t\tthrow new Error('Sticker pack not found');\n\t\t}\n\n\t\treturn result[0];\n\t}\n\n\t/**\n\t * Create new sticker pack\n\t */\n\tasync createStickerPack(\n\t\tdata: CreateStickerPackInput,\n\t\tadminId: string\n\t): Promise<{ packId: PackId; message: string }> {\n\t\t// Check for duplicate name\n\t\tconst existingName = await db\n\t\t\t.select({ id: stickerPacks.id })\n\t\t\t.from(stickerPacks)\n\t\t\t.where(eq(stickerPacks.name, data.name))\n\t\t\t.limit(1);\n\n\t\tif (existingName.length > 0) {\n\t\t\tthrow new Error('Sticker pack name already exists');\n\t\t}\n\n\t\tconst newPack: NewStickerPack = {\n\t\t\t...data,\n\t\t\tcreatedBy: adminId\n\t\t};\n\n\t\tconst result = await db.insert(stickerPacks).values(newPack).returning({ id: stickerPacks.id });\n\n\t\treturn {\n\t\t\tpackId: result[0].id,\n\t\t\tmessage: 'Sticker pack created successfully'\n\t\t};\n\t}\n\n\t/**\n\t * Update existing sticker pack\n\t */\n\tasync updateStickerPack(\n\t\tid: Id<'id'>,\n\t\tdata: UpdateStickerPackInput,\n\t\tadminId: string\n\t): Promise<{ message: string }> {\n\t\t// Check if pack exists\n\t\tawait this.getStickerPack(id);\n\n\t\t// Check for duplicate name (if changing)\n\t\tif (data.name) {\n\t\t\tconst duplicateName = await db\n\t\t\t\t.select({ id: stickerPacks.id })\n\t\t\t\t.from(stickerPacks)\n\t\t\t\t.where(and(eq(stickerPacks.name, data.name), sql`${stickerPacks.id} != ${id}`))\n\t\t\t\t.limit(1);\n\n\t\t\tif (duplicateName.length > 0) {\n\t\t\t\tthrow new Error('Sticker pack name already exists');\n\t\t\t}\n\t\t}\n\n\t\tawait db\n\t\t\t.update(stickerPacks)\n\t\t\t.set({ ...data, updatedAt: sql`now()` })\n\t\t\t.where(eq(stickerPacks.id, id));\n\n\t\treturn { message: 'Sticker pack updated successfully' };\n\t}\n\n\t/**\n\t * Delete sticker pack (and unlink stickers)\n\t */\n\tasync deleteStickerPack(id: Id<'id'>, adminId: string): Promise<{ message: string }> {\n\t\t// Check if pack exists\n\t\tawait this.getStickerPack(id);\n\n\t\t// Unlink all stickers from this pack\n\t\tawait db\n\t\t\t.update(stickers)\n\t\t\t.set({ packId: null, updatedAt: sql`now()` })\n\t\t\t.where(eq(stickers.packId, id));\n\n\t\t// Delete the pack\n\t\tawait db.delete(stickerPacks).where(eq(stickerPacks.id, id));\n\n\t\treturn { message: 'Sticker pack deleted successfully' };\n\t}\n\n\t// ============ UTILITY METHODS ============\n\n\t/**\n\t * Update sticker count for a pack\n\t */\n\tprivate async updatePackStickerCount(packId: PackId): Promise<void> {\n\t\tconst countResult = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(stickers)\n\t\t\t.where(and(eq(stickers.packId, packId), eq(stickers.isDeleted, false)));\n\n\t\tconst stickerCount = countResult[0]?.count || 0;\n\n\t\tawait db\n\t\t\t.update(stickerPacks)\n\t\t\t.set({ totalStickers: stickerCount, updatedAt: sql`now()` })\n\t\t\t.where(eq(stickerPacks.id, packId));\n\t}\n\n\t/**\n\t * Get sticker categories/themes for dropdowns\n\t */\n\tasync getStickerCategories(): Promise<{\n\t\tthemes: string[];\n\t\trarities: string[];\n\t\tformats: string[];\n\t}> {\n\t\tconst [themesResult, raritiesResult, formatsResult] = await Promise.all([\n\t\t\tdb\n\t\t\t\t.selectDistinct({ theme: stickerPacks.theme })\n\t\t\t\t.from(stickerPacks)\n\t\t\t\t.where(isNull(stickerPacks.theme).not()),\n\n\t\t\tdb\n\t\t\t\t.selectDistinct({ rarity: stickers.rarity })\n\t\t\t\t.from(stickers)\n\t\t\t\t.where(eq(stickers.isDeleted, false)),\n\n\t\t\tdb\n\t\t\t\t.selectDistinct({ format: stickers.format })\n\t\t\t\t.from(stickers)\n\t\t\t\t.where(eq(stickers.isDeleted, false))\n\t\t]);\n\n\t\treturn {\n\t\t\tthemes: themesResult.map((r) => r.theme).filter(Boolean),\n\t\t\trarities: raritiesResult.map((r) => r.rarity),\n\t\t\tformats: formatsResult.map((r) => r.format)\n\t\t};\n\t}\n\n\t/**\n\t * Track sticker usage\n\t */\n\tasync trackStickerUsage(data: TrackStickerUsageInput, userId: string): Promise<void> {\n\t\t// Record usage\n\t\tawait db.insert(stickerUsage).values({\n\t\t\tuserId,\n\t\t\tstickerId: data.stickerId,\n\t\t\tcontextType: data.contextType,\n\t\t\tcontextId: data.contextId\n\t\t});\n\n\t\t// Update sticker total usage and user inventory usage\n\t\tawait Promise.all([\n\t\t\t// Update global sticker usage\n\t\t\tdb\n\t\t\t\t.update(stickers)\n\t\t\t\t.set({\n\t\t\t\t\ttotalUsage: sql`${stickers.totalUsage} + 1`,\n\t\t\t\t\tpopularityScore: sql`${stickers.popularityScore} + 1`,\n\t\t\t\t\tupdatedAt: sql`now()`\n\t\t\t\t})\n\t\t\t\t.where(eq(stickers.id, data.stickerId)),\n\n\t\t\t// Update user inventory usage\n\t\t\tdb\n\t\t\t\t.update(userStickerInventory)\n\t\t\t\t.set({\n\t\t\t\t\tusageCount: sql`${userStickerInventory.usageCount} + 1`,\n\t\t\t\t\tlastUsed: sql`now()`\n\t\t\t\t})\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userStickerInventory.userId, userId),\n\t\t\t\t\t\teq(userStickerInventory.stickerId, data.stickerId)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t]);\n\t}\n}\n\n// Export service instance\nexport const stickerService = new StickerService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/collectibles/stickers/stickers.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/cosmetics/avatarFrameStore.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/cosmetics/frameEquip.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'avatarFrames' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { avatarFrames, userOwnedFrames, users } from '@schema';\nimport { eq } from 'drizzle-orm';\nimport { xpService } from '../../xp/xp.service';\nimport { XP_ACTION } from '../../xp/xp-actions';\nimport { FrameId } from \"@shared/types\";\nimport { logger } from \"../../core/logger\";\n\nclass FrameEquipService {\n\tasync userOwnsFrame(userId: string, frameId: FrameId): Promise<boolean> {\n\t\tconst res = await db\n\t\t\t.select({ id: userOwnedFrames.id })\n\t\t\t.from(userOwnedFrames)\n\t\t\t.where(eq(userOwnedFrames.userId, userId))\n\t\t\t.where(eq(userOwnedFrames.frameId, frameId))\n\t\t\t.limit(1);\n\t\treturn res.length > 0;\n\t}\n\n\tasync equipFrame(userId: string, frameId: FrameId) {\n\t\tconst owns = await this.userOwnsFrame(userId, frameId);\n\t\tif (!owns) {\n\t\t\tthrow new Error('Frame not owned');\n\t\t}\n\t\tawait db.update(users).set({ activeFrameId: frameId }).where(eq(users.id, userId));\n\n\t\t// Award XP for equipping frame\n\t\ttry {\n\t\t\tawait xpService.awardXp(userId as unknown as number, XP_ACTION.FRAME_EQUIPPED, { frameId });\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to award XP for frame equip', err);\n\t\t}\n\t}\n\n\tasync grantOwnership(userId: string, frameId: FrameId, source: string = 'purchase') {\n\t\t// Idempotent insert\n\t\tconst exists = await this.userOwnsFrame(userId, frameId);\n\t\tif (exists) return;\n\t\tawait db.insert(userOwnedFrames).values({ userId, frameId, source });\n\t}\n}\n\nexport const frameEquipService = new FrameEquipService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/dictionary/dictionary.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/dictionary/dictionary.service.ts","messages":[{"ruleId":"no-constant-condition","severity":1,"message":"Unexpected constant condition.","line":96,"column":10,"nodeType":"Literal","messageId":"unexpected","endLine":96,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { and, count, desc, eq, ilike, or, sql } from 'drizzle-orm';\nimport { dictionaryEntries, dictionaryUpvotes, insertDictionaryEntrySchema } from '@schema';\nimport { XP_ACTIONS, xpLevelService } from '../../../services/xp-level-service';\nimport slugify from 'slugify';\nimport type { EntryId } from '@shared/types';\n\nexport const DictionaryStatus = {\n\tPENDING: 'pending',\n\tAPPROVED: 'approved',\n\tREJECTED: 'rejected'\n} as const;\n\nexport class DictionaryService {\n\t/** Fetch paginated entries with optional filters */\n\tstatic async list(params: {\n\t\tpage?: number;\n\t\tlimit?: number;\n\t\tsearch?: string;\n\t\tstatus?: string;\n\t\ttag?: string;\n\t\tauthorId?: string;\n\t\tsort?: 'newest' | 'oldest' | 'popular' | 'alphabetical';\n\t}) {\n\t\tconst page = params.page ?? 1;\n\t\tconst limit = params.limit ?? 20;\n\t\tconst offset = (page - 1) * limit;\n\n\t\tconst whereClauses: any[] = [];\n\n\t\tif (params.status && params.status !== 'all') {\n\t\t\twhereClauses.push(eq(dictionaryEntries.status, params.status));\n\t\t}\n\t\tif (params.search) {\n\t\t\tconst q = `%${params.search}%`;\n\t\t\twhereClauses.push(\n\t\t\t\tor(ilike(dictionaryEntries.word, q), ilike(dictionaryEntries.definition, q))\n\t\t\t);\n\t\t}\n\t\tif (params.tag) {\n\t\t\t// Simple includes using @> for Postgres array contains\n\t\t\twhereClauses.push(sql`${dictionaryEntries.tags} @> ARRAY[${params.tag}]`);\n\t\t}\n\t\tif (params.authorId) {\n\t\t\twhereClauses.push(eq(dictionaryEntries.authorId, params.authorId));\n\t\t}\n\n\t\tconst orderBy = (() => {\n\t\t\tswitch (params.sort) {\n\t\t\t\tcase 'oldest':\n\t\t\t\t\treturn [dictionaryEntries.createdAt];\n\t\t\t\tcase 'popular':\n\t\t\t\t\treturn [desc(dictionaryEntries.upvoteCount)];\n\t\t\t\tcase 'alphabetical':\n\t\t\t\t\treturn [dictionaryEntries.word];\n\t\t\t\tcase 'newest':\n\t\t\t\tdefault:\n\t\t\t\t\treturn [desc(dictionaryEntries.createdAt)];\n\t\t\t}\n\t\t})();\n\n\t\tconst entries = await db\n\t\t\t.select()\n\t\t\t.from(dictionaryEntries)\n\t\t\t.where(whereClauses.length ? and(...whereClauses) : undefined)\n\t\t\t.orderBy(...orderBy)\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\n\t\tconst total = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(dictionaryEntries)\n\t\t\t.where(whereClauses.length ? and(...whereClauses) : undefined);\n\n\t\treturn { entries, total: total[0]?.count ?? 0 };\n\t}\n\n\t/** Fetch single entry by slug */\n\tstatic async getBySlug(slug: string) {\n\t\tconst [entry] = await db\n\t\t\t.select()\n\t\t\t.from(dictionaryEntries)\n\t\t\t.where(eq(dictionaryEntries.slug, slug))\n\t\t\t.limit(1);\n\t\treturn entry;\n\t}\n\n\t/** Create a new dictionary entry */\n\tstatic async create(data: unknown & { authorId: string }) {\n\t\tconst parsed = insertDictionaryEntrySchema.parse(data);\n\t\tconst slugBase = slugify(parsed.word);\n\n\t\t// Ensure slug uniqueness by appending a numeric suffix if needed\n\t\tlet slug = slugBase;\n\t\tlet counter = 1;\n\t\twhile (true) {\n\t\t\tconst existing = await db\n\t\t\t\t.select({ id: dictionaryEntries.id })\n\t\t\t\t.from(dictionaryEntries)\n\t\t\t\t.where(eq(dictionaryEntries.slug, slug))\n\t\t\t\t.limit(1);\n\t\t\tif (existing.length === 0) break;\n\t\t\tslug = `${slugBase}-${counter++}`;\n\t\t}\n\n\t\tconst [inserted] = await db\n\t\t\t.insert(dictionaryEntries)\n\t\t\t.values({\n\t\t\t\t...parsed,\n\t\t\t\tslug,\n\t\t\t\tauthorId: data.authorId\n\t\t\t})\n\t\t\t.returning();\n\n\t\t// Award XP to author\n\t\tawait xpLevelService.awardXp(\n\t\t\tdata.authorId as unknown as number,\n\t\t\tXP_ACTIONS.DICTIONARY_ENTRY_SUBMITTED\n\t\t);\n\n\t\treturn inserted;\n\t}\n\n\t/** Approve or reject entry (moderation) */\n\tstatic async moderate(entryId: EntryId, status: 'approved' | 'rejected', approverId: string) {\n\t\tconst [updated] = await db\n\t\t\t.update(dictionaryEntries)\n\t\t\t.set({ status, approverId, updatedAt: new Date() })\n\t\t\t.where(eq(dictionaryEntries.id, entryId))\n\t\t\t.returning();\n\n\t\tif (status === 'approved') {\n\t\t\t// Award XP to author & moderator\n\t\t\tif (updated) {\n\t\t\t\tawait Promise.all([\n\t\t\t\t\txpLevelService.awardXp(\n\t\t\t\t\t\tupdated.authorId as unknown as number,\n\t\t\t\t\t\tXP_ACTIONS.DICTIONARY_ENTRY_APPROVED\n\t\t\t\t\t),\n\t\t\t\t\txpLevelService.awardXp(\n\t\t\t\t\t\tapproverId as unknown as number,\n\t\t\t\t\t\tXP_ACTIONS.DICTIONARY_ENTRY_APPROVAL\n\t\t\t\t\t)\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\t\treturn updated;\n\t}\n\n\t/** Upvote toggle */\n\tstatic async toggleUpvote(entryId: EntryId, userId: string) {\n\t\t// Check existing\n\t\tconst existing = await db\n\t\t\t.select()\n\t\t\t.from(dictionaryUpvotes)\n\t\t\t.where(and(eq(dictionaryUpvotes.entryId, entryId), eq(dictionaryUpvotes.userId, userId)))\n\t\t\t.limit(1);\n\n\t\tlet upvoted = false;\n\n\t\tawait db.transaction(async (tx) => {\n\t\t\tif (existing.length) {\n\t\t\t\t// Remove upvote\n\t\t\t\tawait tx.delete(dictionaryUpvotes).where(eq(dictionaryUpvotes.id, existing[0].id));\n\t\t\t\tawait tx\n\t\t\t\t\t.update(dictionaryEntries)\n\t\t\t\t\t.set({ upvoteCount: sql`${dictionaryEntries.upvoteCount} - 1` })\n\t\t\t\t\t.where(eq(dictionaryEntries.id, entryId));\n\t\t\t} else {\n\t\t\t\t// Add upvote\n\t\t\t\tawait tx.insert(dictionaryUpvotes).values({ entryId, userId });\n\t\t\t\tawait tx\n\t\t\t\t\t.update(dictionaryEntries)\n\t\t\t\t\t.set({ upvoteCount: sql`${dictionaryEntries.upvoteCount} + 1` })\n\t\t\t\t\t.where(eq(dictionaryEntries.id, entryId));\n\t\t\t\tupvoted = true;\n\t\t\t}\n\t\t});\n\n\t\tif (upvoted) {\n\t\t\tconst [entry] = await db\n\t\t\t\t.select({ authorId: dictionaryEntries.authorId })\n\t\t\t\t.from(dictionaryEntries)\n\t\t\t\t.where(eq(dictionaryEntries.id, entryId))\n\t\t\t\t.limit(1);\n\t\t\tif (entry) {\n\t\t\t\tawait xpLevelService.awardXp(\n\t\t\t\t\tentry.authorId as unknown as number,\n\t\t\t\t\tXP_ACTIONS.DICTIONARY_ENTRY_UPVOTED\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn { upvoted };\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/economy/services/cloutService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/economy/services/rewardService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/economy/transformers/economy.transformer.ts","messages":[{"ruleId":"prefer-const","severity":1,"message":"'tokenInfo' is never reassigned. Use 'const' instead.","line":373,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":373,"endColumn":23,"fix":{"range":[13355,13386],"text":"const tokenInfo: any = undefined;"}},{"ruleId":"prefer-const","severity":1,"message":"'currentPrice' is never reassigned. Use 'const' instead.","line":374,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":374,"endColumn":26,"fix":{"range":[13391,13425],"text":"const currentPrice: any = undefined;"}},{"ruleId":"prefer-const","severity":1,"message":"'withdrawFee' is never reassigned. Use 'const' instead.","line":375,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":375,"endColumn":25,"fix":{"range":[13430,13463],"text":"const withdrawFee: any = undefined;"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ipAddress' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":702,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":702,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'internalNotes' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":702,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":702,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'systemFlags' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":702,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":702,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":1104,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":1104,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":3,"source":"/**\n * Economy Data Transformer - Security-First Implementation\n * \n * Transforms raw database economy records into role-appropriate\n * response objects with GDPR compliance, financial security, and audit trail.\n */\n\nimport type { \n  PublicWallet,\n  AuthenticatedWallet,\n  AdminWallet,\n  PublicTransaction,\n  AuthenticatedTransaction,\n  AdminTransaction,\n  PublicCryptoWallet,\n  AuthenticatedCryptoWallet,\n  AdminCryptoWallet,\n  TransactionHistoryItem\n} from '../types';\nimport type { \n  WalletId, \n  TransactionId, \n  CryptoWalletId, \n  UserId,\n  DgtAmount,\n  UsdAmount,\n  XpAmount\n} from '@shared/types/ids';\nimport { createHash } from 'crypto';\nimport { logger } from \"../../../core/logger\";\n\nexport class EconomyTransformer {\n  /**\n   * Transform wallet data for public consumption\n   * Only shows basic balance and public user info\n   */\n  static toPublicWallet(dbWallet: any): PublicWallet {\n    if (!dbWallet) {\n      throw new Error('Invalid wallet data provided to transformer');\n    }\n\n    return {\n      id: dbWallet.id as WalletId,\n      balance: this.sanitizeDgtAmount(dbWallet.balance),\n      \n      // User data (via UserTransformer)\n      user: {\n        id: dbWallet.user?.id as UserId,\n        username: dbWallet.user?.username || '[deleted]',\n        avatarUrl: dbWallet.user?.avatarUrl || undefined,\n        level: this.calculateLevel(dbWallet.user?.xp || 0)\n      },\n      \n      // Public stats only (if enabled by user preferences)\n      publicStats: this.shouldShowPublicStats(dbWallet.user) ? {\n        totalEarned: this.calculateTotalEarned(dbWallet.transactions),\n        totalSpent: this.calculateTotalSpent(dbWallet.transactions),\n        level: this.calculateLevel(dbWallet.user?.xp || 0)\n      } : undefined\n    };\n  }\n\n  /**\n   * Transform wallet data for authenticated user viewing their own wallet\n   * Includes personal financial data and permissions\n   */\n  static toAuthenticatedWallet(dbWallet: any, requestingUser: any): AuthenticatedWallet {\n    const publicData = this.toPublicWallet(dbWallet);\n    \n    return {\n      ...publicData,\n      estimatedUsdValue: this.calculateUsdValue(dbWallet.balance),\n      \n      // Transaction permissions\n      permissions: this.calculateWalletPermissions(dbWallet, requestingUser),\n      \n      // Enhanced stats\n      detailedStats: {\n        totalTips: this.calculateTotalTips(dbWallet.transactions),\n        totalRainReceived: this.calculateTotalRain(dbWallet.transactions),\n        totalWithdrawn: this.calculateTotalWithdrawals(dbWallet.transactions),\n        totalDeposited: this.calculateTotalDeposits(dbWallet.transactions),\n        weeklyEarnings: this.calculateWeeklyEarnings(dbWallet.transactions),\n        monthlyEarnings: this.calculateMonthlyEarnings(dbWallet.transactions)\n      },\n      \n      // Limits and restrictions\n      limits: {\n        dailyTipLimit: this.getDailyTipLimit(requestingUser),\n        dailyWithdrawalLimit: this.getDailyWithdrawalLimit(requestingUser),\n        remainingDaily: {\n          tips: this.getRemainingDailyTips(dbWallet, requestingUser),\n          withdrawals: this.getRemainingDailyWithdrawals(dbWallet, requestingUser)\n        }\n      }\n    };\n  }\n\n  /**\n   * Transform wallet data for admin view\n   * Includes all data with proper anonymization and audit trail\n   */\n  static toAdminWallet(dbWallet: any): AdminWallet {\n    const authenticatedData = this.toAuthenticatedWallet(dbWallet, { role: 'admin' });\n    \n    return {\n      ...authenticatedData,\n      // Admin-only financial data\n      adminData: {\n        totalVolumeUsd: this.calculateTotalVolume(dbWallet.transactions),\n        flaggedTransactions: this.countFlaggedTransactions(dbWallet.transactions),\n        riskScore: this.calculateRiskScore(dbWallet),\n        lastLargeTransaction: this.getLastLargeTransaction(dbWallet.transactions),\n        suspiciousActivity: this.detectSuspiciousActivity(dbWallet)\n      },\n      \n      // System fields\n      internalNotes: dbWallet.internalNotes || undefined,\n      complianceFlags: dbWallet.complianceFlags || undefined,\n      kycStatus: dbWallet.kycStatus || undefined,\n      \n      // Enhanced audit trail\n      auditLog: {\n        createdAt: dbWallet.createdAt,\n        createdBy: dbWallet.createdBy as UserId || undefined,\n        lastModifiedAt: dbWallet.updatedAt,\n        lastModifiedBy: dbWallet.updatedBy as UserId || undefined,\n        accessLog: this.getRecentAccessLog(dbWallet),\n        complianceHistory: this.getComplianceHistory(dbWallet)\n      }\n    };\n  }\n\n  /**\n   * Transform transaction data for public consumption\n   * Strips all sensitive financial and system data\n   */\n  static toPublicTransaction(dbTransaction: any): PublicTransaction {\n    if (!dbTransaction) {\n      throw new Error('Invalid transaction data provided to transformer');\n    }\n\n    return {\n      id: dbTransaction.id as TransactionId,\n      type: dbTransaction.type,\n      amount: this.sanitizeDgtAmount(dbTransaction.amount),\n      status: dbTransaction.status,\n      createdAt: dbTransaction.createdAt,\n      \n      // Public transaction context (sanitized)\n      displayType: this.getDisplayType(dbTransaction.type),\n      direction: this.getTransactionDirection(dbTransaction),\n      \n      // Related user (if applicable and public)\n      relatedUser: this.getPublicRelatedUser(dbTransaction)\n    };\n  }\n\n  /**\n   * Transform transaction data for authenticated users\n   * Includes personal context and USD values\n   */\n  static toAuthenticatedTransaction(dbTransaction: any, requestingUser: any): AuthenticatedTransaction {\n    const publicData = this.toPublicTransaction(dbTransaction);\n    \n    return {\n      ...publicData,\n      description: dbTransaction.description || undefined,\n      metadata: this.filterMetadataForUser(dbTransaction.metadata, requestingUser),\n      \n      // Enhanced context with source normalization\n      context: {\n        source: this.normalizeTransactionSource(dbTransaction.metadata?.source || dbTransaction.type),\n        threadId: dbTransaction.metadata?.threadId || undefined,\n        postId: dbTransaction.metadata?.postId || undefined,\n        targetUserId: dbTransaction.toUserId as UserId || undefined,\n        originatingIP: this.getAnonymizedIP(dbTransaction.metadata?.ipAddress),\n        platform: dbTransaction.metadata?.platform || 'web'\n      },\n      \n      // Audit trail for user\n      auditTrail: {\n        processedAt: new Date().toISOString(),\n        verificationStatus: this.getVerificationStatus(dbTransaction),\n        riskLevel: this.calculateTransactionRiskLevel(dbTransaction)\n      },\n      \n      // USD values\n      usdAmount: this.calculateTransactionUsdValue(dbTransaction),\n      exchangeRate: dbTransaction.exchangeRate || undefined,\n      \n      // Fees\n      fee: this.calculateTransactionFee(dbTransaction),\n      netAmount: this.calculateNetAmount(dbTransaction)\n    };\n  }\n\n  /**\n   * Transform transaction data for admin view\n   * Includes all system data with proper IP anonymization\n   */\n  static toAdminTransaction(dbTransaction: any): AdminTransaction {\n    const authenticatedData = this.toAuthenticatedTransaction(dbTransaction, { role: 'admin' });\n    \n    return {\n      ...authenticatedData,\n      // Full system data\n      systemData: {\n        fromWalletId: dbTransaction.fromWalletId as WalletId || undefined,\n        toWalletId: dbTransaction.toWalletId as WalletId || undefined,\n        blockchainTxId: dbTransaction.blockchainTxId || undefined,\n        fromWalletAddress: dbTransaction.fromWalletAddress || undefined,\n        toWalletAddress: dbTransaction.toWalletAddress || undefined,\n        isTreasuryTransaction: dbTransaction.isTreasuryTransaction || false,\n        ipHash: dbTransaction.ipAddress ? this.hashIP(dbTransaction.ipAddress) : undefined\n      },\n      \n      // Admin fields\n      adminNotes: dbTransaction.adminNotes || undefined,\n      flagged: dbTransaction.flagged || false,\n      flagReason: dbTransaction.flagReason || undefined,\n      reviewedBy: dbTransaction.reviewedBy as UserId || undefined,\n      reviewedAt: dbTransaction.reviewedAt || undefined,\n      \n      // Full metadata\n      rawMetadata: dbTransaction.metadata || {}\n    };\n  }\n\n  /**\n   * Transform single transaction for transaction history display\n   * Optimized for wallet history and audit trail views\n   */\n  static toTransactionHistoryItem(dbTransaction: any, requestingUser?: any): TransactionHistoryItem {\n    return {\n      id: dbTransaction.id as TransactionId,\n      type: this.normalizeTransactionTypeForHistory(dbTransaction.type),\n      amount: this.sanitizeDgtAmount(dbTransaction.amount),\n      usdValue: this.calculateTransactionUsdValue(dbTransaction),\n      \n      // Direction and counterparty\n      direction: this.getTransactionDirection(dbTransaction, requestingUser?.id),\n      counterparty: this.getTransactionCounterparty(dbTransaction, requestingUser?.id),\n      \n      // Essential metadata\n      description: this.sanitizeDescription(dbTransaction.description),\n      timestamp: dbTransaction.createdAt.toISOString(),\n      status: this.getTransactionStatus(dbTransaction),\n      \n      // Enhanced context with source normalization\n      context: {\n        source: this.normalizeTransactionSource(dbTransaction.metadata?.source || dbTransaction.type),\n        category: this.getTransactionCategory(dbTransaction),\n        reference: dbTransaction.metadata?.reference || dbTransaction.id,\n        \n        // Related entities (anonymized for privacy)\n        threadId: dbTransaction.metadata?.threadId || undefined,\n        postId: dbTransaction.metadata?.postId || undefined,\n        itemId: dbTransaction.metadata?.itemId || undefined\n      },\n      \n      // Transaction properties\n      properties: {\n        isReversible: this.isTransactionReversible(dbTransaction),\n        hasReceipt: !!dbTransaction.receiptUrl,\n        isInternal: this.isInternalTransaction(dbTransaction),\n        requiresConfirmation: this.requiresConfirmation(dbTransaction)\n      },\n      \n      // Audit and verification\n      verification: {\n        isVerified: dbTransaction.status === 'confirmed',\n        verifiedAt: dbTransaction.confirmedAt?.toISOString(),\n        blockchainTxId: dbTransaction.blockchainTxId || undefined,\n        confirmations: dbTransaction.confirmations || 0\n      }\n    };\n  }\n\n  /**\n   * Transform transaction list specifically for history views\n   * Optimized for wallet history display with enhanced filtering\n   */\n  static toTransactionHistory(\n    dbTransactions: any[],\n    requestingUser: any,\n    filters?: {\n      dateRange?: { start: Date; end: Date };\n      categories?: string[];\n      minAmount?: DgtAmount;\n      maxAmount?: DgtAmount;\n    }\n  ): {\n    transactions: TransactionHistoryItem[];\n    summary: {\n      totalIn: DgtAmount;\n      totalOut: DgtAmount;\n      netChange: DgtAmount;\n      transactionCount: number;\n      categoryBreakdown: Record<string, { count: number; amount: DgtAmount }>;\n    };\n  } {\n    // Filter transactions if filters provided\n    let filteredTransactions = dbTransactions;\n    \n    if (filters?.dateRange) {\n      filteredTransactions = filteredTransactions.filter(tx => {\n        const txDate = new Date(tx.createdAt);\n        return txDate >= filters.dateRange!.start && txDate <= filters.dateRange!.end;\n      });\n    }\n    \n    if (filters?.categories?.length) {\n      filteredTransactions = filteredTransactions.filter(tx => {\n        const category = this.getTransactionCategory(tx);\n        return filters.categories!.includes(category);\n      });\n    }\n    \n    if (filters?.minAmount !== undefined) {\n      filteredTransactions = filteredTransactions.filter(tx => \n        Math.abs(tx.amount) >= filters.minAmount!\n      );\n    }\n    \n    if (filters?.maxAmount !== undefined) {\n      filteredTransactions = filteredTransactions.filter(tx => \n        Math.abs(tx.amount) <= filters.maxAmount!\n      );\n    }\n\n    // Transform transactions\n    const transactions = filteredTransactions.map(tx => \n      this.toTransactionHistoryItem(tx, requestingUser)\n    );\n\n    // Calculate summary statistics\n    const summary = this.calculateTransactionSummary(transactions, requestingUser?.id);\n\n    return { transactions, summary };\n  }\n\n  /**\n   * Transform crypto wallet data for public consumption\n   * Never exposes wallet addresses publicly\n   */\n  static toPublicCryptoWallet(dbCryptoWallet: any): PublicCryptoWallet {\n    if (!dbCryptoWallet) {\n      throw new Error('Invalid crypto wallet data provided to transformer');\n    }\n\n    return {\n      id: dbCryptoWallet.id as CryptoWalletId,\n      coinSymbol: dbCryptoWallet.coinSymbol,\n      chain: dbCryptoWallet.chain\n      // Address is NEVER exposed in public view for security\n    };\n  }\n\n  /**\n   * Transform crypto wallet data for authenticated user (owner only)\n   * Shows CCPayment wallet address only to the owner for security\n   */\n  static async toAuthenticatedCryptoWallet(dbCryptoWallet: any, requestingUser: any): Promise<AuthenticatedCryptoWallet> {\n    const publicData = this.toPublicCryptoWallet(dbCryptoWallet);\n    \n    // Security check: only show CCPayment address to wallet owner\n    if (dbCryptoWallet.userId !== requestingUser?.id) {\n      throw new Error('Unauthorized access to CCPayment wallet address');\n    }\n\n    // Get enhanced token information from CCPayment\n    let tokenInfo: any = undefined;\n    let currentPrice: any = undefined;\n    let withdrawFee: any = undefined;\n    \n    try {\n      // CCPayment integration temporarily disabled\n      logger.warn('CCPayment token service integration disabled');\n    } catch (error) {\n      // Fallback to basic data if CCPayment API fails\n      logger.warn('Failed to fetch enhanced token data:', error);\n    }\n    \n    return {\n      ...publicData,\n      address: dbCryptoWallet.address, // CCPayment-generated deposit address (owner only)\n      memo: dbCryptoWallet.memo || undefined, // Required for some chains (TRX, XRP)\n      qrCodeUrl: this.generateQRCodeUrl(dbCryptoWallet.address, dbCryptoWallet.memo), // Generate QR for deposits\n      \n      // CCPayment integration data\n      balance: this.formatCryptoBalance(dbCryptoWallet.balance || '0'),\n      frozenBalance: this.formatCryptoBalance(dbCryptoWallet.frozenBalance || '0'),\n      \n      // Enhanced token information\n      tokenInfo: tokenInfo ? {\n        logoUrl: tokenInfo.logoUrl,\n        coinFullName: tokenInfo.coinFullName,\n        status: tokenInfo.status,\n        precision: tokenInfo.networks?.[dbCryptoWallet.chain]?.precision || 18\n      } : undefined,\n      \n      // Current market price\n      marketPrice: currentPrice ? currentPrice[dbCryptoWallet.coinId] : undefined,\n      \n      // USD value of balance\n      balanceUsdValue: this.calculateCryptoUsdValue(\n        dbCryptoWallet.balance || '0',\n        currentPrice ? currentPrice[dbCryptoWallet.coinId] : undefined\n      ),\n      \n      // CCPayment permissions\n      permissions: {\n        canReceive: this.canReceiveToCCPaymentWallet(dbCryptoWallet, requestingUser),\n        canGenerateNew: this.canGenerateNewCCPaymentWallet(requestingUser),\n        canWithdraw: this.canWithdrawFromCCPayment(dbCryptoWallet, requestingUser),\n        canSwap: this.canSwapCCPayment(requestingUser)\n      },\n      \n      // Enhanced limits from CCPayment\n      limits: {\n        minDeposit: tokenInfo?.networks?.[dbCryptoWallet.chain]?.minimumDepositAmount || dbCryptoWallet.minDepositAmount || '0',\n        minWithdraw: tokenInfo?.networks?.[dbCryptoWallet.chain]?.minimumWithdrawAmount || dbCryptoWallet.minWithdrawAmount || '0',\n        maxWithdraw: tokenInfo?.networks?.[dbCryptoWallet.chain]?.maximumWithdrawAmount || '0',\n        withdrawFee: withdrawFee?.amount || dbCryptoWallet.withdrawFee || '0'\n      }\n    };\n  }\n\n  /**\n   * Transform crypto wallet data for admin view\n   * Includes all CCPayment system data and tracking information\n   */\n  static async toAdminCryptoWallet(dbCryptoWallet: any): Promise<AdminCryptoWallet> {\n    const authenticatedData = await this.toAuthenticatedCryptoWallet(dbCryptoWallet, { role: 'admin', id: dbCryptoWallet.userId });\n    \n    return {\n      ...authenticatedData,\n      // CCPayment-specific admin data\n      ccpaymentUserId: dbCryptoWallet.ccpaymentUserId || undefined,\n      coinId: dbCryptoWallet.coinId,\n      \n      // Blockchain/CCPayment tracking\n      createdAt: dbCryptoWallet.createdAt,\n      totalReceived: this.calculateTotalReceived(dbCryptoWallet),\n      totalWithdrawn: this.calculateTotalWithdrawn(dbCryptoWallet),\n      transactionCount: this.getTransactionCount(dbCryptoWallet),\n      lastUsed: this.getLastUsedDate(dbCryptoWallet),\n      \n      // CCPayment webhook data\n      lastDepositAt: dbCryptoWallet.lastDepositAt || undefined,\n      lastWithdrawalAt: dbCryptoWallet.lastWithdrawalAt || undefined,\n      \n      // Admin monitoring\n      riskScore: this.calculateCryptoRiskScore(dbCryptoWallet),\n      flaggedTransactions: this.countFlaggedCryptoTransactions(dbCryptoWallet),\n      \n      // Enhanced admin data\n      networkStatus: authenticatedData.tokenInfo?.status || 'Unknown',\n      ccpaymentStatus: this.getCCPaymentWalletStatus(dbCryptoWallet),\n      \n      // System status\n      isActive: dbCryptoWallet.isActive !== false,\n      isFrozen: dbCryptoWallet.isFrozen === true\n    };\n  }\n\n  /**\n   * Batch transform wallets based on user permissions\n   */\n  static toWalletList(\n    dbWallets: any[], \n    requestingUser: any, \n    view: 'public' | 'authenticated' | 'admin' = 'public'\n  ): (PublicWallet | AuthenticatedWallet | AdminWallet)[] {\n    return dbWallets.map(wallet => {\n      switch (view) {\n        case 'authenticated':\n          return this.toAuthenticatedWallet(wallet, requestingUser);\n        case 'admin':\n          return this.toAdminWallet(wallet);\n        default:\n          return this.toPublicWallet(wallet);\n      }\n    });\n  }\n\n  /**\n   * Batch transform transactions based on user permissions\n   */\n  static toTransactionList(\n    dbTransactions: any[], \n    requestingUser: any, \n    view: 'public' | 'authenticated' | 'admin' = 'public'\n  ): (PublicTransaction | AuthenticatedTransaction | AdminTransaction)[] {\n    return dbTransactions.map(transaction => {\n      switch (view) {\n        case 'authenticated':\n          return this.toAuthenticatedTransaction(transaction, requestingUser);\n        case 'admin':\n          return this.toAdminTransaction(transaction);\n        default:\n          return this.toPublicTransaction(transaction);\n      }\n    });\n  }\n\n  // Private utility methods for calculations and security\n  \n  private static sanitizeDgtAmount(amount: number): DgtAmount {\n    // Round to 6 decimal places for DGT\n    return Math.round(amount * 1000000) / 1000000 as DgtAmount;\n  }\n\n  private static calculateLevel(xp: number): number {\n    if (xp < 0) return 1;\n    return Math.floor(xp / 100) + 1;\n  }\n\n  private static shouldShowPublicStats(user: any): boolean {\n    return user?.privacySettings?.showWalletStats !== false;\n  }\n\n  private static calculateUsdValue(dgtAmount: number): UsdAmount {\n    // Get current DGT->USD rate from multiple sources with fallback\n    const envRate = process.env.DGT_USD_RATE ? parseFloat(process.env.DGT_USD_RATE) : null;\n    const configRate = 0.01; // Default fallback rate\n    \n    // Use environment rate if valid, otherwise fallback\n    const currentRate = (envRate && envRate > 0 && envRate < 100) ? envRate : configRate;\n    \n    // Round to 4 decimal places for USD\n    return Math.round(dgtAmount * currentRate * 10000) / 10000 as UsdAmount;\n  }\n\n  private static calculateTotalEarned(transactions: any[]): DgtAmount {\n    if (!transactions) return 0 as DgtAmount;\n    return transactions\n      .filter(tx => tx.direction === 'in' && tx.status === 'confirmed')\n      .reduce((total, tx) => total + tx.amount, 0) as DgtAmount;\n  }\n\n  private static calculateTotalSpent(transactions: any[]): DgtAmount {\n    if (!transactions) return 0 as DgtAmount;\n    return transactions\n      .filter(tx => tx.direction === 'out' && tx.status === 'confirmed')\n      .reduce((total, tx) => total + tx.amount, 0) as DgtAmount;\n  }\n\n  private static calculateTotalTips(transactions: any[]): DgtAmount {\n    if (!transactions) return 0 as DgtAmount;\n    return transactions\n      .filter(tx => tx.type === 'TIP' && tx.status === 'confirmed')\n      .reduce((total, tx) => total + tx.amount, 0) as DgtAmount;\n  }\n\n  private static calculateTotalRain(transactions: any[]): DgtAmount {\n    if (!transactions) return 0 as DgtAmount;\n    return transactions\n      .filter(tx => tx.type === 'RAIN' && tx.status === 'confirmed')\n      .reduce((total, tx) => total + tx.amount, 0) as DgtAmount;\n  }\n\n  private static calculateTotalWithdrawals(transactions: any[]): DgtAmount {\n    if (!transactions) return 0 as DgtAmount;\n    return transactions\n      .filter(tx => tx.type === 'WITHDRAWAL' && tx.status === 'confirmed')\n      .reduce((total, tx) => total + tx.amount, 0) as DgtAmount;\n  }\n\n  private static calculateTotalDeposits(transactions: any[]): DgtAmount {\n    if (!transactions) return 0 as DgtAmount;\n    return transactions\n      .filter(tx => tx.type === 'DEPOSIT' && tx.status === 'confirmed')\n      .reduce((total, tx) => total + tx.amount, 0) as DgtAmount;\n  }\n\n  private static calculateWeeklyEarnings(transactions: any[]): DgtAmount {\n    if (!transactions) return 0 as DgtAmount;\n    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n    return transactions\n      .filter(tx => \n        tx.direction === 'in' && \n        tx.status === 'confirmed' && \n        new Date(tx.createdAt) > weekAgo\n      )\n      .reduce((total, tx) => total + tx.amount, 0) as DgtAmount;\n  }\n\n  private static calculateMonthlyEarnings(transactions: any[]): DgtAmount {\n    if (!transactions) return 0 as DgtAmount;\n    const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n    return transactions\n      .filter(tx => \n        tx.direction === 'in' && \n        tx.status === 'confirmed' && \n        new Date(tx.createdAt) > monthAgo\n      )\n      .reduce((total, tx) => total + tx.amount, 0) as DgtAmount;\n  }\n\n  private static calculateWalletPermissions(dbWallet: any, user: any) {\n    const isOwner = dbWallet.userId === user?.id;\n    const isAdmin = this.isAdmin(user);\n    const userLevel = this.calculateLevel(user?.xp || 0);\n    \n    return {\n      canTip: isOwner && userLevel >= 2,\n      canWithdraw: isOwner && user?.kycVerified === true,\n      canDeposit: isOwner,\n      canTransfer: (isOwner && userLevel >= 5) || isAdmin\n    };\n  }\n\n  private static getDailyTipLimit(user: any): DgtAmount {\n    const level = this.calculateLevel(user?.xp || 0);\n    // Tip limit increases with level\n    return Math.min(1000, level * 100) as DgtAmount;\n  }\n\n  private static getDailyWithdrawalLimit(user: any): UsdAmount {\n    if (!user?.kycVerified) return 0 as UsdAmount;\n    return user?.withdrawalLimit || 1000 as UsdAmount;\n  }\n\n  private static getRemainingDailyTips(dbWallet: any, user: any): DgtAmount {\n    const dailyLimit = this.getDailyTipLimit(user);\n    const todaysTips = this.getTodaysTips(dbWallet.transactions);\n    return Math.max(0, dailyLimit - todaysTips) as DgtAmount;\n  }\n\n  private static getRemainingDailyWithdrawals(dbWallet: any, user: any): UsdAmount {\n    const dailyLimit = this.getDailyWithdrawalLimit(user);\n    const todaysWithdrawals = this.getTodaysWithdrawals(dbWallet.transactions);\n    return Math.max(0, dailyLimit - todaysWithdrawals) as UsdAmount;\n  }\n\n  private static getTodaysTips(transactions: any[]): DgtAmount {\n    if (!transactions) return 0 as DgtAmount;\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    return transactions\n      .filter(tx => \n        tx.type === 'TIP' && \n        tx.direction === 'out' &&\n        new Date(tx.createdAt) >= today\n      )\n      .reduce((total, tx) => total + tx.amount, 0) as DgtAmount;\n  }\n\n  private static getTodaysWithdrawals(transactions: any[]): UsdAmount {\n    if (!transactions) return 0 as UsdAmount;\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    return transactions\n      .filter(tx => \n        tx.type === 'WITHDRAWAL' && \n        new Date(tx.createdAt) >= today\n      )\n      .reduce((total, tx) => total + (tx.usdAmount || 0), 0) as UsdAmount;\n  }\n\n  private static getDisplayType(type: string): string {\n    const displayMap: Record<string, string> = {\n      'TIP': 'Tip',\n      'RAIN': 'Rain',\n      'DEPOSIT': 'Deposit',\n      'WITHDRAWAL': 'Withdrawal',\n      'SHOP_PURCHASE': 'Purchase',\n      'ADMIN_ADJUST': 'Adjustment',\n      'AIRDROP': 'Airdrop',\n      'REWARD': 'Reward',\n      'REFERRAL_BONUS': 'Referral',\n      'FEE': 'Fee'\n    };\n    return displayMap[type] || type;\n  }\n\n  private static getTransactionDirection(dbTransaction: any): 'in' | 'out' {\n    // This logic depends on how transactions are structured\n    // Typically, positive amounts are 'in', negative are 'out'\n    return dbTransaction.amount > 0 ? 'in' : 'out';\n  }\n\n  private static getPublicRelatedUser(dbTransaction: any): any {\n    if (!dbTransaction.relatedUser) return undefined;\n    \n    return {\n      id: dbTransaction.relatedUser.id,\n      username: dbTransaction.relatedUser.username,\n      avatarUrl: dbTransaction.relatedUser.avatarUrl\n    };\n  }\n\n  private static filterMetadataForUser(metadata: any, user: any): Record<string, any> {\n    if (!metadata) return {};\n    \n    // Filter sensitive metadata fields for non-admin users\n    if (!this.isAdmin(user)) {\n      const { ipAddress, internalNotes, systemFlags, ...safeMetadata } = metadata;\n      return safeMetadata;\n    }\n    \n    return metadata;\n  }\n\n  private static calculateTransactionUsdValue(dbTransaction: any): UsdAmount | undefined {\n    if (!dbTransaction.amount) return undefined;\n    \n    // Use transaction-specific rate if available, otherwise current rate\n    const transactionRate = dbTransaction.exchangeRate;\n    const currentRate = this.getCurrentDgtUsdRate();\n    \n    const rate = transactionRate || currentRate;\n    return Math.round(dbTransaction.amount * rate * 10000) / 10000 as UsdAmount;\n  }\n\n  private static getCurrentDgtUsdRate(): number {\n    const envRate = process.env.DGT_USD_RATE ? parseFloat(process.env.DGT_USD_RATE) : null;\n    return (envRate && envRate > 0 && envRate < 100) ? envRate : 0.01;\n  }\n\n  private static calculateTransactionFee(dbTransaction: any): DgtAmount {\n    return dbTransaction.fee || 0 as DgtAmount;\n  }\n\n  private static calculateNetAmount(dbTransaction: any): DgtAmount {\n    const fee = this.calculateTransactionFee(dbTransaction);\n    return (dbTransaction.amount - fee) as DgtAmount;\n  }\n\n  private static hashIP(ip: string): string {\n    if (!ip) return '';\n    return createHash('sha256').update(ip + process.env.IP_SALT || 'default-salt').digest('hex');\n  }\n\n  private static isAdmin(user: any): boolean {\n    return user && (user.role === 'admin' || user.role === 'owner');\n  }\n\n  // Admin calculation methods\n  private static calculateTotalVolume(transactions: any[]): UsdAmount {\n    if (!transactions) return 0 as UsdAmount;\n    return transactions\n      .filter(tx => tx.status === 'confirmed')\n      .reduce((total, tx) => total + (tx.usdAmount || 0), 0) as UsdAmount;\n  }\n\n  private static countFlaggedTransactions(transactions: any[]): number {\n    if (!transactions) return 0;\n    return transactions.filter(tx => tx.flagged === true).length;\n  }\n\n  private static calculateRiskScore(dbWallet: any): number {\n    // Simple risk scoring based on transaction patterns\n    let score = 0;\n    \n    const balance = dbWallet.balance || 0;\n    const transactionCount = dbWallet.transactions?.length || 0;\n    \n    if (balance > 100000) score += 2; // Large balance\n    if (transactionCount > 1000) score += 2; // High activity\n    // Add more risk factors as needed\n    \n    return Math.min(10, score);\n  }\n\n  private static getLastLargeTransaction(transactions: any[]): Date | undefined {\n    if (!transactions) return undefined;\n    \n    const largeTransactions = transactions\n      .filter(tx => tx.amount > 10000 && tx.status === 'confirmed')\n      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n    \n    return largeTransactions[0]?.createdAt;\n  }\n\n  private static detectSuspiciousActivity(dbWallet: any): boolean {\n    // Simple suspicious activity detection\n    const riskScore = this.calculateRiskScore(dbWallet);\n    const flaggedCount = this.countFlaggedTransactions(dbWallet.transactions);\n    \n    return riskScore > 7 || flaggedCount > 5;\n  }\n\n  // CCPayment crypto wallet specific methods\n  private static canReceiveToCCPaymentWallet(dbCryptoWallet: any, user: any): boolean {\n    // Check if user owns the wallet and has CCPayment account initialized\n    return dbCryptoWallet.userId === user?.id && !!user?.ccpaymentUserId;\n  }\n\n  private static canGenerateNewCCPaymentWallet(user: any): boolean {\n    // Users can generate wallets if they have CCPayment account and meet level requirements\n    return user?.level >= 2 && !!user?.ccpaymentUserId;\n  }\n\n  // CCPayment crypto wallet utility methods\n  private static formatCryptoBalance(balance: string): string {\n    // Format crypto balance with proper decimal places\n    const num = parseFloat(balance);\n    return isNaN(num) ? '0' : num.toString();\n  }\n\n  private static generateQRCodeUrl(address: string, memo?: string): string | undefined {\n    if (!address) return undefined;\n    \n    // Generate QR code URL for crypto deposits\n    const qrData = memo ? `${address}?memo=${memo}` : address;\n    return `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(qrData)}`;\n  }\n\n  private static canWithdrawFromCCPayment(dbCryptoWallet: any, user: any): boolean {\n    return dbCryptoWallet.userId === user?.id && \n           !!user?.ccpaymentUserId && \n           user?.kycVerified === true &&\n           !dbCryptoWallet.isFrozen;\n  }\n\n  private static canSwapCCPayment(user: any): boolean {\n    return !!user?.ccpaymentUserId && user?.level >= 3;\n  }\n\n  private static calculateTotalReceived(dbCryptoWallet: any): string {\n    // Total received from CCPayment deposit records\n    return dbCryptoWallet.totalReceived || '0';\n  }\n\n  private static calculateTotalWithdrawn(dbCryptoWallet: any): string {\n    // Total withdrawn from CCPayment withdrawal records\n    return dbCryptoWallet.totalWithdrawn || '0';\n  }\n\n  private static getTransactionCount(dbCryptoWallet: any): number {\n    return (dbCryptoWallet.depositCount || 0) + (dbCryptoWallet.withdrawalCount || 0);\n  }\n\n  private static getLastUsedDate(dbCryptoWallet: any): Date | undefined {\n    const lastDeposit = dbCryptoWallet.lastDepositAt;\n    const lastWithdrawal = dbCryptoWallet.lastWithdrawalAt;\n    \n    if (!lastDeposit && !lastWithdrawal) return undefined;\n    if (!lastDeposit) return new Date(lastWithdrawal);\n    if (!lastWithdrawal) return new Date(lastDeposit);\n    \n    return new Date(Math.max(new Date(lastDeposit).getTime(), new Date(lastWithdrawal).getTime()));\n  }\n\n  private static calculateCryptoRiskScore(dbCryptoWallet: any): number {\n    let score = 0;\n    \n    const totalReceived = parseFloat(dbCryptoWallet.totalReceived || '0');\n    const totalWithdrawn = parseFloat(dbCryptoWallet.totalWithdrawn || '0');\n    const transactionCount = this.getTransactionCount(dbCryptoWallet);\n    \n    // High volume activity\n    if (totalReceived > 10000) score += 2;\n    if (totalWithdrawn > 10000) score += 2;\n    \n    // High frequency activity\n    if (transactionCount > 100) score += 1;\n    \n    // Suspicious patterns\n    if (dbCryptoWallet.flaggedTransactions > 0) score += 3;\n    \n    return Math.min(10, score);\n  }\n\n  private static countFlaggedCryptoTransactions(dbCryptoWallet: any): number {\n    return dbCryptoWallet.flaggedTransactions || 0;\n  }\n\n  private static calculateCryptoUsdValue(balance: string, usdtPrice?: string): string {\n    if (!usdtPrice || !balance) return '0';\n    \n    try {\n      const balanceNum = parseFloat(balance);\n      const priceNum = parseFloat(usdtPrice);\n      \n      if (isNaN(balanceNum) || isNaN(priceNum)) return '0';\n      \n      const usdValue = balanceNum * priceNum;\n      return usdValue.toFixed(4);\n    } catch (error) {\n      return '0';\n    }\n  }\n\n  private static getCCPaymentWalletStatus(dbCryptoWallet: any): 'active' | 'inactive' | 'frozen' | 'maintenance' {\n    if (dbCryptoWallet.isFrozen) return 'frozen';\n    if (!dbCryptoWallet.isActive) return 'inactive';\n    if (dbCryptoWallet.underMaintenance) return 'maintenance';\n    return 'active';\n  }\n\n  // Transaction source normalization and audit trail methods\n  private static normalizeTransactionSource(rawSource: string): string {\n    const sourceMap: Record<string, string> = {\n      'TIP': 'user_tip',\n      'RAIN': 'community_rain',\n      'DEPOSIT': 'crypto_deposit',\n      'WITHDRAWAL': 'crypto_withdrawal',\n      'SHOP_PURCHASE': 'shop_purchase',\n      'ADMIN_ADJUST': 'admin_adjustment',\n      'AIRDROP': 'promotional_airdrop',\n      'REWARD': 'system_reward',\n      'REFERRAL_BONUS': 'referral_program',\n      'FEE': 'service_fee',\n      'INTERNAL_TRANSFER': 'internal_transfer',\n      'CCPAYMENT_DEPOSIT': 'external_deposit',\n      'CCPAYMENT_WITHDRAWAL': 'external_withdrawal'\n    };\n    \n    return sourceMap[rawSource?.toUpperCase()] || 'unknown_source';\n  }\n\n  private static getAnonymizedIP(ipAddress?: string): string | undefined {\n    if (!ipAddress) return undefined;\n    \n    // Anonymize IP for GDPR compliance - keep first 3 octets for IPv4, first 4 groups for IPv6\n    if (ipAddress.includes(':')) {\n      // IPv6\n      const parts = ipAddress.split(':');\n      return parts.slice(0, 4).join(':') + '::****';\n    } else {\n      // IPv4\n      const parts = ipAddress.split('.');\n      return parts.slice(0, 3).join('.') + '.***';\n    }\n  }\n\n  private static getVerificationStatus(dbTransaction: any): 'verified' | 'pending' | 'flagged' {\n    if (dbTransaction.flagged) return 'flagged';\n    if (dbTransaction.status === 'confirmed') return 'verified';\n    return 'pending';\n  }\n\n  private static calculateTransactionRiskLevel(dbTransaction: any): 'low' | 'medium' | 'high' {\n    let riskScore = 0;\n    \n    // Large amounts increase risk\n    if (dbTransaction.amount > 10000) riskScore += 2;\n    else if (dbTransaction.amount > 1000) riskScore += 1;\n    \n    // Certain transaction types are higher risk\n    const highRiskTypes = ['WITHDRAWAL', 'ADMIN_ADJUST'];\n    if (highRiskTypes.includes(dbTransaction.type)) riskScore += 1;\n    \n    // Flagged transactions are high risk\n    if (dbTransaction.flagged) riskScore += 3;\n    \n    // Time-based risk (very recent transactions)\n    const transactionAge = Date.now() - new Date(dbTransaction.createdAt).getTime();\n    if (transactionAge < 60000) riskScore += 1; // Less than 1 minute old\n    \n    if (riskScore >= 4) return 'high';\n    if (riskScore >= 2) return 'medium';\n    return 'low';\n  }\n\n  private static getRecentAccessLog(dbWallet: any): Array<{ timestamp: string; action: string; ip?: string }> {\n    // Return recent access events (would come from audit log table)\n    return dbWallet.recentAccess || [];\n  }\n\n  private static getComplianceHistory(dbWallet: any): Array<{ timestamp: string; event: string; details?: string }> {\n    // Return compliance-related events (would come from compliance log table)\n    return dbWallet.complianceEvents || [];\n  }\n\n  // Transaction History utility methods\n  private static normalizeTransactionTypeForHistory(type: string): string {\n    const typeMap: Record<string, string> = {\n      'TIP': 'tip',\n      'RAIN': 'rain',\n      'DEPOSIT': 'deposit',\n      'WITHDRAWAL': 'withdrawal',\n      'SHOP_PURCHASE': 'purchase',\n      'ADMIN_ADJUST': 'adjustment',\n      'AIRDROP': 'airdrop',\n      'REWARD': 'reward',\n      'REFERRAL_BONUS': 'referral',\n      'FEE': 'fee',\n      'REFUND': 'refund',\n      'INTERNAL_TRANSFER': 'transfer'\n    };\n    \n    return typeMap[type?.toUpperCase()] || type?.toLowerCase() || 'unknown';\n  }\n\n  private static getTransactionDirection(dbTransaction: any, userId?: any): 'incoming' | 'outgoing' | 'internal' {\n    if (!userId) return 'internal';\n    \n    if (dbTransaction.fromUserId === userId) {\n      return dbTransaction.toUserId === userId ? 'internal' : 'outgoing';\n    } else if (dbTransaction.toUserId === userId) {\n      return 'incoming';\n    }\n    \n    return 'internal';\n  }\n\n  private static getTransactionCounterparty(dbTransaction: any, userId?: any): { type: string; name: string; id?: string } | undefined {\n    const direction = this.getTransactionDirection(dbTransaction, userId);\n    \n    if (direction === 'internal') {\n      return { type: 'system', name: 'System' };\n    }\n    \n    if (direction === 'outgoing' && dbTransaction.toUserId) {\n      return {\n        type: 'user',\n        name: dbTransaction.toUsername || 'Unknown User',\n        id: dbTransaction.toUserId\n      };\n    }\n    \n    if (direction === 'incoming' && dbTransaction.fromUserId) {\n      return {\n        type: 'user',\n        name: dbTransaction.fromUsername || 'Unknown User',\n        id: dbTransaction.fromUserId\n      };\n    }\n    \n    // Check for system/shop transactions\n    if (dbTransaction.type?.includes('SHOP')) {\n      return { type: 'shop', name: 'DegenTalk Shop' };\n    }\n    \n    if (dbTransaction.type?.includes('ADMIN')) {\n      return { type: 'admin', name: 'Administration' };\n    }\n    \n    return { type: 'system', name: 'System' };\n  }\n\n  private static sanitizeDescription(description?: string): string {\n    if (!description) return 'Transaction';\n    \n    // Truncate long descriptions\n    if (description.length > 100) {\n      return description.substring(0, 97) + '...';\n    }\n    \n    return description;\n  }\n\n  private static getTransactionStatus(dbTransaction: any): 'pending' | 'confirmed' | 'failed' | 'cancelled' {\n    if (dbTransaction.status === 'confirmed') return 'confirmed';\n    if (dbTransaction.status === 'failed') return 'failed';\n    if (dbTransaction.status === 'cancelled') return 'cancelled';\n    return 'pending';\n  }\n\n  private static getTransactionCategory(dbTransaction: any): string {\n    const type = this.normalizeTransactionTypeForHistory(dbTransaction.type);\n    \n    const categoryMap: Record<string, string> = {\n      'tip': 'social',\n      'rain': 'social',\n      'purchase': 'shopping',\n      'deposit': 'wallet',\n      'withdrawal': 'wallet',\n      'transfer': 'wallet',\n      'reward': 'earning',\n      'airdrop': 'earning',\n      'referral': 'earning',\n      'fee': 'system',\n      'adjustment': 'system',\n      'refund': 'system'\n    };\n    \n    return categoryMap[type] || 'other';\n  }\n\n  private static isTransactionReversible(dbTransaction: any): boolean {\n    // Most transactions are not reversible after confirmation\n    if (dbTransaction.status === 'confirmed') {\n      // Only certain types can be reversed by admin\n      const reversibleTypes = ['ADMIN_ADJUST', 'REFUND'];\n      return reversibleTypes.includes(dbTransaction.type);\n    }\n    \n    // Pending transactions can usually be cancelled\n    return dbTransaction.status === 'pending';\n  }\n\n  private static isInternalTransaction(dbTransaction: any): boolean {\n    // Internal transactions don't touch external blockchain\n    const internalTypes = ['TIP', 'RAIN', 'SHOP_PURCHASE', 'INTERNAL_TRANSFER', 'ADMIN_ADJUST'];\n    return internalTypes.includes(dbTransaction.type);\n  }\n\n  private static requiresConfirmation(dbTransaction: any): boolean {\n    // External transactions require blockchain confirmations\n    const externalTypes = ['DEPOSIT', 'WITHDRAWAL'];\n    return externalTypes.includes(dbTransaction.type);\n  }\n\n  private static calculateTransactionSummary(\n    transactions: any[],\n    userId?: any\n  ): {\n    totalIn: DgtAmount;\n    totalOut: DgtAmount;\n    netChange: DgtAmount;\n    transactionCount: number;\n    categoryBreakdown: Record<string, { count: number; amount: DgtAmount }>;\n  } {\n    let totalIn = 0 as DgtAmount;\n    let totalOut = 0 as DgtAmount;\n    const categoryBreakdown: Record<string, { count: number; amount: DgtAmount }> = {};\n\n    for (const tx of transactions) {\n      // Add to category breakdown\n      if (!categoryBreakdown[tx.context.category]) {\n        categoryBreakdown[tx.context.category] = { count: 0, amount: 0 as DgtAmount };\n      }\n      categoryBreakdown[tx.context.category].count++;\n      categoryBreakdown[tx.context.category].amount = (categoryBreakdown[tx.context.category].amount + Math.abs(tx.amount)) as DgtAmount;\n\n      // Calculate in/out totals based on direction\n      if (tx.direction === 'incoming') {\n        totalIn = (totalIn + tx.amount) as DgtAmount;\n      } else if (tx.direction === 'outgoing') {\n        totalOut = (totalOut + Math.abs(tx.amount)) as DgtAmount;\n      }\n    }\n\n    const netChange = (totalIn - totalOut) as DgtAmount;\n\n    return {\n      totalIn,\n      totalOut,\n      netChange,\n      transactionCount: transactions.length,\n      categoryBreakdown\n    };\n  }\n}\n\n// Export convenience methods\nexport const { \n  toPublicWallet, \n  toAuthenticatedWallet, \n  toAdminWallet,\n  toPublicTransaction,\n  toAuthenticatedTransaction,\n  toAdminTransaction\n} = EconomyTransformer;","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/economy/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/editor/editor.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'z' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAuthenticated' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Editor Routes\n *\n * Defines API routes for editor functionality including Giphy integration.\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport axios from 'axios';\nimport { z } from 'zod';\nimport { isAuthenticated } from '../../domains/auth/middleware/auth.middleware.ts';\nimport type { IStorage } from '../../../storage';\nimport { logger } from \"../../core/logger\";\n\n/**\n * Initialize editor routes\n */\nconst router = Router();\n\n// Check if Giphy is enabled\nrouter.get('/giphy-status', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst storage = req.app.get('storage') as IStorage;\n\t\tconst settings = await storage.getSiteSettings();\n\n\t\t// Find giphy settings\n\t\tconst giphyApiKey = process.env.GIPHY_API_KEY;\n\t\tconst giphyEnabled = settings.find((s) => s.key === 'giphy_enabled')?.value === 'true';\n\n\t\t// If no API key, Giphy is not available regardless of settings\n\t\tif (!giphyApiKey) {\n\t\t\treturn res.json({ enabled: false });\n\t\t}\n\n\t\treturn res.json({\n\t\t\tenabled: giphyEnabled\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Error checking Giphy status:', error);\n\t\tres.status(500).json({ error: 'Failed to check Giphy status' });\n\t}\n});\n\n// Get trending GIFs\nrouter.get('/giphy-trending', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst storage = req.app.get('storage') as IStorage;\n\t\tconst settings = await storage.getSiteSettings();\n\n\t\t// Find giphy settings\n\t\tconst giphyApiKey = process.env.GIPHY_API_KEY;\n\t\tconst giphyEnabled = settings.find((s) => s.key === 'giphy_enabled')?.value === 'true';\n\n\t\t// If not enabled or no API key, return error\n\t\tif (!giphyEnabled || !giphyApiKey) {\n\t\t\treturn res.status(403).json({ error: 'Giphy integration is not enabled' });\n\t\t}\n\n\t\t// Get limit and rating from settings\n\t\tconst limit = parseInt(settings.find((s) => s.key === 'giphy_result_limit')?.value || '10');\n\t\tconst rating = settings.find((s) => s.key === 'giphy_rating')?.value || 'g';\n\n\t\t// Call Giphy API\n\t\tconst response = await axios.get(`https://api.giphy.com/v1/gifs/trending`, {\n\t\t\tparams: {\n\t\t\t\tapi_key: giphyApiKey,\n\t\t\t\tlimit,\n\t\t\t\trating\n\t\t\t}\n\t\t});\n\n\t\tres.json(response.data);\n\t} catch (error) {\n\t\tlogger.error('Error fetching trending GIFs:', error);\n\t\tres.status(500).json({ error: 'Failed to fetch trending GIFs' });\n\t}\n});\n\n// Search GIFs\nrouter.post('/giphy-search', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst { query } = req.body;\n\n\t\tif (!query) {\n\t\t\treturn res.status(400).json({ error: 'Search query is required' });\n\t\t}\n\n\t\tconst storage = req.app.get('storage') as IStorage;\n\t\tconst settings = await storage.getSiteSettings();\n\n\t\t// Find giphy settings\n\t\tconst giphyApiKey = process.env.GIPHY_API_KEY;\n\t\tconst giphyEnabled = settings.find((s) => s.key === 'giphy_enabled')?.value === 'true';\n\n\t\t// If not enabled or no API key, return error\n\t\tif (!giphyEnabled || !giphyApiKey) {\n\t\t\treturn res.status(403).json({ error: 'Giphy integration is not enabled' });\n\t\t}\n\n\t\t// Get limit and rating from settings\n\t\tconst limit = parseInt(settings.find((s) => s.key === 'giphy_result_limit')?.value || '10');\n\t\tconst rating = settings.find((s) => s.key === 'giphy_rating')?.value || 'g';\n\n\t\t// Call Giphy API\n\t\tconst response = await axios.get(`https://api.giphy.com/v1/gifs/search`, {\n\t\t\tparams: {\n\t\t\t\tapi_key: giphyApiKey,\n\t\t\t\tq: query,\n\t\t\t\tlimit,\n\t\t\t\trating\n\t\t\t}\n\t\t});\n\n\t\tres.json(response.data);\n\t} catch (error) {\n\t\tlogger.error('Error searching GIFs:', error);\n\t\tres.status(500).json({ error: 'Failed to search GIFs' });\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/airdrop/airdrop.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/airdrop/airdrop.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/airdrop/airdrop.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'airdropSettings' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gt' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'between' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'threshold' is defined but never used.","line":321,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":321,"endColumn":20},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":326,"column":5,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":331,"endColumn":50},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":337,"column":5,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":337,"endColumn":37},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":340,"column":5,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":350,"endColumn":8},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":356,"column":5,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":361,"endColumn":87}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Airdrop Service\n *\n * This service handles admin-initiated airdrops to distribute tokens to all active users.\n *\n * // [REFAC-AIRDROP]\n */\n\nimport { db } from '@db';\nimport { transactions, users, airdropSettings, airdropRecords } from '@schema';\nimport { eq, and, gt, sql, desc, between } from 'drizzle-orm';\nimport { logger } from '../../../core/logger';\nimport { WalletError, ErrorCodes as WalletErrorCodes } from '../../../core/errors';\nimport { dgtService } from '../../wallet/dgt.service';\nimport { v4 as uuidv4 } from 'uuid';\nimport type { AdminUserId, AirdropId, ActionId, UserId } from '@shared/types/ids';\n\n/**\n * Airdrop options structure\n */\nexport interface AirdropOptions {\n\tadminUserId: AdminUserId;\n\tamount: number;\n\tcurrency: string;\n\ttitle?: string;\n\tdescription?: string;\n\ttarget?: 'all' | 'active' | 'premium';\n\tactivityDays?: number; // For active target, how many days back to look\n\tthreshold?: number; // Minimum amount of activity to qualify\n}\n\n/**\n * Airdrop result structure\n */\nexport interface AirdropResult {\n\tid: AirdropId;\n\ttitle: string;\n\tadminUserId: AdminUserId;\n\tamount: number;\n\tperUserAmount: number;\n\tcurrency: string;\n\trecipientCount: number;\n\ttransactionId: ActionId;\n\tstatus: string;\n\tcreatedAt: Date;\n}\n\n/**\n * Service for handling airdrops to users\n */\nexport class AirdropService {\n\t/**\n\t * Process an airdrop to distribute tokens to users\n\t * @param options - Airdrop options\n\t * @returns Airdrop result\n\t */\n\tasync processAirdrop(options: AirdropOptions): Promise<AirdropResult> {\n\t\tconst {\n\t\t\tadminUserId,\n\t\t\tamount,\n\t\t\tcurrency,\n\t\t\ttitle = 'Platform Airdrop',\n\t\t\tdescription = 'Token distribution to active users',\n\t\t\ttarget = 'active',\n\t\t\tactivityDays = 30,\n\t\t\tthreshold = 1\n\t\t} = options;\n\n\t\ttry {\n\t\t\tlogger.info('AirdropService', `Processing airdrop from admin ${adminUserId}`, {\n\t\t\t\tamount,\n\t\t\t\tcurrency,\n\t\t\t\ttarget\n\t\t\t});\n\n\t\t\t// Only DGT is supported for now\n\t\t\tif (currency !== 'DGT') {\n\t\t\t\tthrow new WalletError(\n\t\t\t\t\t'Only DGT airdrops are supported at this time',\n\t\t\t\t\t400,\n\t\t\t\t\tWalletErrorCodes.INVALID_PARAMETERS\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Verify admin has sufficient balance if they're the source\n\t\t\tif (adminUserId) {\n\t\t\t\tconst [admin] = await db\n\t\t\t\t\t.select({\n\t\t\t\t\t\tid: users.id,\n\t\t\t\t\t\tdgtWalletBalance: users.dgtWalletBalance,\n\t\t\t\t\t\tgroupId: users.groupId\n\t\t\t\t\t})\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(eq(users.id, adminUserId))\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tif (!admin) {\n\t\t\t\t\tthrow new WalletError('Admin user not found', 404, WalletErrorCodes.USER_NOT_FOUND);\n\t\t\t\t}\n\n\t\t\t\t// Check if user is actually an admin\n\t\t\t\tconst { canUser } = await import('@lib/auth/canUser.ts');\n\t\t\t\tif (!(await canUser(admin as any, 'canViewAdminPanel'))) {\n\t\t\t\t\tthrow new WalletError(\n\t\t\t\t\t\t'Only administrators can initiate airdrops',\n\t\t\t\t\t\t403,\n\t\t\t\t\t\tWalletErrorCodes.PERMISSION_DENIED\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Check admin balance\n\t\t\t\tif (admin.dgtWalletBalance < amount) {\n\t\t\t\t\tthrow new WalletError(\n\t\t\t\t\t\t'Insufficient DGT balance',\n\t\t\t\t\t\t400,\n\t\t\t\t\t\tWalletErrorCodes.INSUFFICIENT_FUNDS,\n\t\t\t\t\t\t{ required: amount, available: admin.dgtWalletBalance }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get recipients based on target\n\t\t\tconst recipientIds = await this.getRecipients(target, activityDays, threshold);\n\n\t\t\tif (recipientIds.length === 0) {\n\t\t\t\tthrow new WalletError(\n\t\t\t\t\t'No eligible recipients found for airdrop',\n\t\t\t\t\t400,\n\t\t\t\t\tWalletErrorCodes.INVALID_PARAMETERS\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Calculate per-user amount\n\t\t\tconst recipientCount = recipientIds.length;\n\t\t\tconst perUserAmount = Math.floor(amount / recipientCount);\n\n\t\t\tif (perUserAmount <= 0) {\n\t\t\t\tthrow new WalletError(\n\t\t\t\t\t'Airdrop amount too small for the number of recipients',\n\t\t\t\t\t400,\n\t\t\t\t\tWalletErrorCodes.INVALID_AMOUNT,\n\t\t\t\t\t{ recipients: recipientCount, minAmount: recipientCount }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Create a unique reference for the airdrop\n\t\t\tconst airdropRef = uuidv4();\n\n\t\t\t// Record the airdrop in db\n\t\t\tconst [airdropRecord] = await db\n\t\t\t\t.insert(airdropRecords)\n\t\t\t\t.values({\n\t\t\t\t\tadminUserId,\n\t\t\t\t\ttitle,\n\t\t\t\t\tdescription,\n\t\t\t\t\tamount,\n\t\t\t\t\tperUserAmount,\n\t\t\t\t\tcurrency,\n\t\t\t\t\trecipientCount,\n\t\t\t\t\ttarget,\n\t\t\t\t\tactivityDays,\n\t\t\t\t\tthreshold,\n\t\t\t\t\treference: airdropRef,\n\t\t\t\t\tstatus: 'processing',\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\trecipientIds,\n\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t},\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Record the transaction\n\t\t\tconst [airdropTransaction] = await db\n\t\t\t\t.insert(transactions)\n\t\t\t\t.values({\n\t\t\t\t\tuserId: adminUserId,\n\t\t\t\t\tfromUserId: adminUserId,\n\t\t\t\t\tamount,\n\t\t\t\t\ttype: 'AIRDROP',\n\t\t\t\t\tstatus: 'confirmed',\n\t\t\t\t\tcurrency,\n\t\t\t\t\tdescription: `Airdrop: ${title}`,\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\trecipientCount,\n\t\t\t\t\t\tperUserAmount,\n\t\t\t\t\t\tairdropId: airdropRecord.id,\n\t\t\t\t\t\treference: airdropRef,\n\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t},\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Process the airdrop distribution\n\t\t\t// Note: For large airdrops, this would ideally be handled by a background job\n\t\t\t// or a queue system to avoid timeout issues\n\t\t\tif (currency === 'DGT') {\n\t\t\t\tawait this.processDGTAirdrop(\n\t\t\t\t\tadminUserId,\n\t\t\t\t\tperUserAmount,\n\t\t\t\t\trecipientIds,\n\t\t\t\t\tairdropTransaction.id,\n\t\t\t\t\tairdropRecord.id,\n\t\t\t\t\ttitle\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Update the airdrop record to completed\n\t\t\tawait db\n\t\t\t\t.update(airdropRecords)\n\t\t\t\t.set({\n\t\t\t\t\tstatus: 'completed',\n\t\t\t\t\ttransactionId: airdropTransaction.id,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(airdropRecords.id, airdropRecord.id));\n\n\t\t\tlogger.info(\n\t\t\t\t'AirdropService',\n\t\t\t\t`Airdrop completed: Admin ${adminUserId} -> ${recipientCount} users`,\n\t\t\t\t{\n\t\t\t\t\tamount,\n\t\t\t\t\tcurrency,\n\t\t\t\t\tairdropId: airdropRecord.id,\n\t\t\t\t\ttransactionId: airdropTransaction.id\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tid: airdropRecord.id,\n\t\t\t\ttitle,\n\t\t\t\tadminUserId,\n\t\t\t\tamount,\n\t\t\t\tperUserAmount,\n\t\t\t\tcurrency,\n\t\t\t\trecipientCount,\n\t\t\t\ttransactionId: airdropTransaction.id,\n\t\t\t\tstatus: 'completed',\n\t\t\t\tcreatedAt: airdropRecord.createdAt\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tlogger.error('AirdropService', `Error processing airdrop: ${error.message}`);\n\n\t\t\tthrow new WalletError(\n\t\t\t\t`Failed to process airdrop: ${error.message}`,\n\t\t\t\t500,\n\t\t\t\tWalletErrorCodes.TRANSACTION_FAILED,\n\t\t\t\t{ originalError: error.message }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Process DGT airdrop by distributing to recipient users\n\t */\n\tprivate async processDGTAirdrop(\n\t\tadminUserId: AdminUserId,\n\t\tperUserAmount: number,\n\t\trecipientIds: UserId[],\n\t\ttransactionId: ActionId,\n\t\tairdropId: AirdropId,\n\t\ttitle: string\n\t): Promise<void> {\n\t\t// Process airdrop for each recipient individually\n\t\tfor (const recipientId of recipientIds) {\n\t\t\t// Skip sending to the admin themselves\n\t\t\tif (recipientId === adminUserId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Use dgtService to grant DGT to the recipient\n\t\t\t\tawait dgtService.grantDGT(recipientId, perUserAmount, 'airdrop', {\n\t\t\t\t\tairdropId,\n\t\t\t\t\tparentTransactionId: transactionId,\n\t\t\t\t\ttitle,\n\t\t\t\t\tadminUserId\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\t// Log error but continue with other recipients\n\t\t\t\tlogger.error(\n\t\t\t\t\t'AirdropService',\n\t\t\t\t\t`Error sending airdrop to recipient ${recipientId}: ${error.message}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// If the admin is in the recipients list, deduct the full amount from them\n\t\tif (adminUserId && recipientIds.includes(adminUserId)) {\n\t\t\ttry {\n\t\t\t\t// Deduct the entire airdrop amount from admin\n\t\t\t\tconst totalAmount = perUserAmount * (recipientIds.length - 1); // Exclude admin from recipients\n\t\t\t\tawait dgtService.deductDGT(adminUserId, totalAmount, 'airdrop_source', {\n\t\t\t\t\tairdropId,\n\t\t\t\t\tparentTransactionId: transactionId,\n\t\t\t\t\ttitle\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\t// This should not happen since we checked balance earlier\n\t\t\t\tlogger.error(\n\t\t\t\t\t'AirdropService',\n\t\t\t\t\t`Error deducting airdrop amount from admin ${adminUserId}: ${error.message}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get list of recipient user IDs based on target criteria\n\t */\n\tprivate async getRecipients(\n\t\ttarget: 'all' | 'active' | 'premium',\n\t\tactivityDays: number,\n\t\tthreshold: number\n\t): Promise<UserId[]> {\n\t\tswitch (target) {\n\t\t\tcase 'all':\n\t\t\t\t// Get all users excluding suspended\n\t\t\t\tconst allUsers = await db\n\t\t\t\t\t.select({\n\t\t\t\t\t\tid: users.id\n\t\t\t\t\t})\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(sql`${users.status} != 'suspended'`);\n\n\t\t\t\treturn allUsers.map((u) => u.id);\n\n\t\t\tcase 'active':\n\t\t\t\t// Get users active in the last X days\n\t\t\t\tconst activityDate = new Date();\n\t\t\t\tactivityDate.setDate(activityDate.getDate() - activityDays);\n\n\t\t\t\tconst activeUsers = await db\n\t\t\t\t\t.select({\n\t\t\t\t\t\tid: users.id\n\t\t\t\t\t})\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\tsql`${users.status} != 'suspended'`,\n\t\t\t\t\t\t\tsql`${users.lastActive} >= ${activityDate.toISOString()}`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\treturn activeUsers.map((u) => u.id);\n\n\t\t\tcase 'premium':\n\t\t\t\t// Get users with premium status\n\t\t\t\tconst premiumUsers = await db\n\t\t\t\t\t.select({\n\t\t\t\t\t\tid: users.id\n\t\t\t\t\t})\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(and(sql`${users.status} != 'suspended'`, sql`${users.isPremium} = true`));\n\n\t\t\t\treturn premiumUsers.map((u) => u.id);\n\n\t\t\tdefault:\n\t\t\t\tthrow new WalletError(\n\t\t\t\t\t`Invalid target type: ${target}`,\n\t\t\t\t\t400,\n\t\t\t\t\tWalletErrorCodes.INVALID_PARAMETERS\n\t\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get airdrop history for admin\n\t */\n\tasync getAirdropHistory(\n\t\tlimit: number = 20,\n\t\toffset: number = 0\n\t): Promise<{\n\t\tairdrops: any[];\n\t\ttotal: number;\n\t}> {\n\t\ttry {\n\t\t\tconst airdrops = await db\n\t\t\t\t.select()\n\t\t\t\t.from(airdropRecords)\n\t\t\t\t.orderBy(sql`${airdropRecords.createdAt} DESC`)\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\tconst [{ count }] = await db\n\t\t\t\t.select({\n\t\t\t\t\tcount: sql`COUNT(*)`\n\t\t\t\t})\n\t\t\t\t.from(airdropRecords);\n\n\t\t\treturn {\n\t\t\t\tairdrops,\n\t\t\t\ttotal: Number(count)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('AirdropService', `Error getting airdrop history: ${error.message}`);\n\t\t\tthrow new WalletError(\n\t\t\t\t`Failed to get airdrop history: ${error.message}`,\n\t\t\t\t500,\n\t\t\t\tWalletErrorCodes.SYSTEM_ERROR\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get airdrop details with recipients\n\t */\n\tasync getAirdropDetails(airdropId: AirdropId): Promise<any> {\n\t\ttry {\n\t\t\tconst [airdrop] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(airdropRecords)\n\t\t\t\t.where(eq(airdropRecords.id, airdropId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (!airdrop) {\n\t\t\t\tthrow new WalletError('Airdrop not found', 404, WalletErrorCodes.TRANSACTION_NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Get transaction details\n\t\t\tconst [transaction] = airdrop.transactionId\n\t\t\t\t? await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(transactions)\n\t\t\t\t\t\t.where(eq(transactions.id, airdrop.transactionId))\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t: [null];\n\n\t\t\treturn {\n\t\t\t\t...airdrop,\n\t\t\t\ttransaction\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tlogger.error('AirdropService', `Error getting airdrop details: ${error.message}`);\n\t\t\tthrow new WalletError(\n\t\t\t\t`Failed to get airdrop details: ${error.message}`,\n\t\t\t\t500,\n\t\t\t\tWalletErrorCodes.SYSTEM_ERROR\n\t\t\t);\n\t\t}\n\t}\n}\n\n// Export a singleton instance\nexport const airdropService = new AirdropService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/engagement.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'db' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dgtService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'vaultService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":21,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Engagement Service\n *\n * [REFAC-ENGAGEMENT]\n *\n * This service orchestrates interactions between different engagement subdomains:\n * - tip: User-to-user tipping functionality\n * - rain: Distribution of DGT to multiple users\n * - airdrop: Admin-distributed DGT rewards\n * - vault: Time-locked DGT storage\n */\n\nimport { logger } from '../../../core/logger';\nimport type { UserId } from '@shared/types/ids';\nimport { db } from '@db';\nimport { dgtService } from '../wallet/dgt.service';\nimport { tipService } from './tip/tip.service';\nimport { rainService } from './rain/rain.service';\nimport { airdropService } from './airdrop/airdrop.service';\nimport { WalletError, WalletErrorCodes } from '../../../core/errors';\nimport { vaultService } from './vault/vault.service';\nimport type { AdminUserId, EntityId } from '@shared/types/ids';\n\n/**\n * Engagement service for orchestrating social engagement features\n */\nexport class EngagementService {\n\t/**\n\t * Process a user tip\n\t *\n\t * @param fromUserId The user sending the tip\n\t * @param toUserId The user receiving the tip\n\t * @param amount Amount of DGT to tip\n\t * @param reason Optional reason for the tip\n\t * @param contentReference Optional content reference (post/thread ID)\n\t */\n\tasync processTip(\n\t\tfromUserId: UserId,\n\t\ttoUserId: UserId,\n\t\tamount: bigint,\n\t\treason?: string,\n\t\tcontentReference?: {\n\t\t\ttype: 'post' | 'thread' | 'reply';\n\t\t\tid: EntityId;\n\t\t}\n\t) {\n\t\ttry {\n\t\t\treturn await tipService.processTip(fromUserId, toUserId, amount, reason, contentReference);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error processing tip:', error);\n\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthrow new WalletError('Failed to process tip', 500, WalletErrorCodes.UNKNOWN_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Process a rain distribution\n\t *\n\t * @param fromUserId The user initiating the rain\n\t * @param amount Total amount of DGT to distribute\n\t * @param recipientCount Number of users to receive the rain\n\t * @param channelId Optional channel ID for targeting\n\t */\n\tasync processRain(\n\t\tfromUserId: UserId,\n\t\tamount: bigint,\n\t\trecipientCount: number,\n\t\tchannelId?: Id<'channel'>\n\t) {\n\t\ttry {\n\t\t\treturn await rainService.processRain(fromUserId, amount, recipientCount, channelId);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error processing rain:', error);\n\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthrow new WalletError('Failed to process rain', 500, WalletErrorCodes.UNKNOWN_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Process an airdrop\n\t *\n\t * @param adminUserId The admin initiating the airdrop\n\t * @param targetUserIds Array of user IDs to receive the airdrop\n\t * @param amount Amount of DGT per user\n\t * @param reason Reason for the airdrop\n\t */\n\tasync processAirdrop(\n\t\tadminUserId: AdminUserId,\n\t\ttargetUserIds: UserId[],\n\t\tamount: bigint,\n\t\treason: string\n\t) {\n\t\ttry {\n\t\t\treturn await airdropService.processAirdrop(adminUserId, targetUserIds, amount, reason);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error processing airdrop:', error);\n\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthrow new WalletError('Failed to process airdrop', 500, WalletErrorCodes.UNKNOWN_ERROR, {\n\t\t\t\toriginalError: error.message\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get user's engagement statistics\n\t *\n\t * @param userId User ID\n\t */\n\tasync getUserEngagementStats(userId: UserId) {\n\t\ttry {\n\t\t\t// Get tip stats\n\t\t\tconst tipStats = await tipService.getUserTipStats(userId);\n\n\t\t\t// Get rain stats\n\t\t\tconst rainStats = await rainService.getUserRainStats(userId);\n\n\t\t\t// Get airdrop stats\n\t\t\tconst airdropStats = await airdropService.getUserAirdropStats(userId);\n\n\t\t\t// Combine stats\n\t\t\treturn {\n\t\t\t\ttip: tipStats,\n\t\t\t\train: rainStats,\n\t\t\t\tairdrop: airdropStats,\n\t\t\t\t// Summary data\n\t\t\t\ttotalSent: tipStats.totalSent + rainStats.totalSent + airdropStats.totalSent,\n\t\t\t\ttotalReceived:\n\t\t\t\t\ttipStats.totalReceived + rainStats.totalReceived + airdropStats.totalReceived,\n\t\t\t\ttransactionCount:\n\t\t\t\t\ttipStats.transactionCount + rainStats.transactionCount + airdropStats.transactionCount\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting user engagement stats:', error);\n\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthrow new WalletError(\n\t\t\t\t'Failed to get user engagement stats',\n\t\t\t\t500,\n\t\t\t\tWalletErrorCodes.UNKNOWN_ERROR,\n\t\t\t\t{ originalError: error.message }\n\t\t\t);\n\t\t}\n\t}\n}\n\n// Export a singleton instance\nexport const engagementService = new EngagementService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/rain/rain.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Rain Controller\n *\n * Handles HTTP requests related to rain functionality\n *\n * // [REFAC-RAIN]\n */\n\nimport type { Request, Response } from 'express';\nimport { RainService } from './rain.service';\nimport { asyncHandler } from '../../../core/errors';\nimport { z } from 'zod';\nimport { logger } from '../../../core/logger';\n\n/**\n * Controller for rain functionality\n */\nexport class RainController {\n\tprivate rainService: RainService;\n\n\tconstructor() {\n\t\tthis.rainService = new RainService();\n\t}\n\n\t/**\n\t * Process a rain distribution\n\t */\n\tprocessRain = asyncHandler(async (req: Request, res: Response) => {\n\t\tconst fromUserId = userService.getUserFromRequest(req).id;\n\t\tconst { amount, eligibleUserCount, channel, message } = req.body;\n\n\t\t// Validate input using zod\n\t\tconst rainSchema = z.object({\n\t\t\tamount: z.number().positive(),\n\t\t\teligibleUserCount: z.number().positive().default(10),\n\t\t\tchannel: z.string().default('general'),\n\t\t\tmessage: z.string().optional()\n\t\t});\n\n\t\tconst validatedData = rainSchema.parse({\n\t\t\tamount,\n\t\t\teligibleUserCount,\n\t\t\tchannel,\n\t\t\tmessage\n\t\t});\n\n\t\tconst result = await this.rainService.processRain(\n\t\t\tfromUserId,\n\t\t\tvalidatedData.amount,\n\t\t\tvalidatedData.eligibleUserCount,\n\t\t\tvalidatedData.channel,\n\t\t\tvalidatedData.message\n\t\t);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: result\n\t\t});\n\t});\n\n\t/**\n\t * Get recent rain events\n\t */\n\tgetRecentRainEvents = asyncHandler(async (req: Request, res: Response) => {\n\t\tconst limit = parseInt(req.query.limit as string) || 10;\n\t\tconst offset = parseInt(req.query.offset as string) || 0;\n\n\t\tconst events = await this.rainService.getRecentRainEvents(limit, offset);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: events\n\t\t});\n\t});\n\n\t/**\n\t * Get rain settings\n\t */\n\tgetRainSettings = asyncHandler(async (req: Request, res: Response) => {\n\t\tconst settings = await this.rainService.getRainSettings();\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: settings\n\t\t});\n\t});\n\n\t/**\n\t * Update rain settings (admin only)\n\t */\n\tupdateRainSettings = asyncHandler(async (req: Request, res: Response) => {\n\t\tconst userId = userService.getUserFromRequest(req).id;\n\t\tconst {\n\t\t\tminAmount,\n\t\t\tmaxAmount,\n\t\t\tminEligibleUsers,\n\t\t\tmaxEligibleUsers,\n\t\t\tactivityWindowMinutes,\n\t\t\tcooldownMinutes\n\t\t} = req.body;\n\n\t\t// Validate input using zod\n\t\tconst settingsSchema = z.object({\n\t\t\tminAmount: z.number().min(1).optional(),\n\t\t\tmaxAmount: z.number().positive().optional(),\n\t\t\tminEligibleUsers: z.number().min(1).optional(),\n\t\t\tmaxEligibleUsers: z.number().min(1).optional(),\n\t\t\tactivityWindowMinutes: z.number().min(1).optional(),\n\t\t\tcooldownMinutes: z.number().min(0).optional()\n\t\t});\n\n\t\tconst validatedData = settingsSchema.parse({\n\t\t\tminAmount,\n\t\t\tmaxAmount,\n\t\t\tminEligibleUsers,\n\t\t\tmaxEligibleUsers,\n\t\t\tactivityWindowMinutes,\n\t\t\tcooldownMinutes\n\t\t});\n\n\t\tconst updatedSettings = await this.rainService.updateRainSettings(userId, validatedData);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: updatedSettings\n\t\t});\n\t});\n}\n\n// Export a singleton instance\nexport const rainController = new RainController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/rain/rain.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/rain/rain.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/tip/tip.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Tip Controller\n *\n * Handles HTTP requests related to tipping functionality\n *\n * // [REFAC-TIP]\n */\n\nimport type { Request, Response } from 'express';\nimport { TipService } from './tip.service';\nimport { asyncHandler } from '../../../core/errors';\nimport { z } from 'zod';\nimport { logger } from '../../../core/logger';\n\n/**\n * Controller for tipping functionality\n */\nexport class TipController {\n\tprivate tipService: TipService;\n\n\tconstructor() {\n\t\tthis.tipService = new TipService();\n\t}\n\n\t/**\n\t * Send a tip to another user\n\t */\n\tsendTip = asyncHandler(async (req: Request, res: Response) => {\n\t\tconst fromUserId = userService.getUserFromRequest(req).id;\n\t\tconst { toUserId, amount, reason } = req.body;\n\n\t\t// Validate input using zod\n\t\tconst tipSchema = z.object({\n\t\t\ttoUserId: z.string().uuid(),\n\t\t\tamount: z.number().positive(),\n\t\t\treason: z.string().optional()\n\t\t});\n\n\t\tconst validatedData = tipSchema.parse({ toUserId, amount, reason });\n\n\t\tconst result = await this.tipService.sendTip(\n\t\t\tfromUserId,\n\t\t\tvalidatedData.toUserId,\n\t\t\tvalidatedData.amount,\n\t\t\tvalidatedData.reason || 'Tip'\n\t\t);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: result\n\t\t});\n\t});\n\n\t/**\n\t * Get tip history for the authenticated user\n\t */\n\tgetTipHistory = asyncHandler(async (req: Request, res: Response) => {\n\t\tconst userId = userService.getUserFromRequest(req).id;\n\t\tconst limit = parseInt(req.query.limit as string) || 20;\n\t\tconst offset = parseInt(req.query.offset as string) || 0;\n\t\tconst type = (req.query.type as string) || 'all'; // 'sent', 'received', 'all'\n\n\t\tconst tipHistory = await this.tipService.getTipHistory(userId, limit, offset, type);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: tipHistory\n\t\t});\n\t});\n\n\t/**\n\t * Get tip leaderboard\n\t * Shows users who've sent the most tips or received the most tips\n\t */\n\tgetTipLeaderboard = asyncHandler(async (req: Request, res: Response) => {\n\t\tconst period = (req.query.period as string) || 'all'; // 'day', 'week', 'month', 'all'\n\t\tconst type = (req.query.type as string) || 'received'; // 'sent', 'received'\n\t\tconst limit = parseInt(req.query.limit as string) || 10;\n\n\t\tconst leaderboard = await this.tipService.getTipLeaderboard(period, type, limit);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: leaderboard\n\t\t});\n\t});\n\n\t/**\n\t * Get tip settings (min/max amounts, etc.)\n\t */\n\tgetTipSettings = asyncHandler(async (req: Request, res: Response) => {\n\t\tconst settings = await this.tipService.getTipSettings();\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: settings\n\t\t});\n\t});\n\n\t/**\n\t * Update tip settings (admin only)\n\t */\n\tupdateTipSettings = asyncHandler(async (req: Request, res: Response) => {\n\t\tconst userId = userService.getUserFromRequest(req).id;\n\t\tconst { minAmount, maxAmount, cooldownMinutes, burnPercentage } = req.body;\n\n\t\t// Validate input using zod\n\t\tconst settingsSchema = z.object({\n\t\t\tminAmount: z.number().min(1).optional(),\n\t\t\tmaxAmount: z.number().positive().optional(),\n\t\t\tcooldownMinutes: z.number().min(0).optional(),\n\t\t\tburnPercentage: z.number().min(0).max(100).optional()\n\t\t});\n\n\t\tconst validatedData = settingsSchema.parse({\n\t\t\tminAmount,\n\t\t\tmaxAmount,\n\t\t\tcooldownMinutes,\n\t\t\tburnPercentage\n\t\t});\n\n\t\tconst updatedSettings = await this.tipService.updateTipSettings(userId, validatedData);\n\n\t\treturn res.json({\n\t\t\tsuccess: true,\n\t\t\tdata: updatedSettings\n\t\t});\n\t});\n}\n\n// Export a singleton instance\nexport const tipController = new TipController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/tip/tip.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/tip/tip.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ccpaymentService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'walletService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uuidv4' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'XP_ACTION' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":20,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":21,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'source' is defined but never used.","line":203,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":203,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tip Service\n *\n * This service handles tipping between users, supporting both DGT and crypto.\n *\n * // [REFAC-TIP]\n */\n\nimport { db } from '@db';\nimport type { UserId, TipId, TransactionId } from '@shared/types/ids';\nimport { users, transactions } from '@schema';\nimport { eq, and, sql } from 'drizzle-orm';\nimport { logger } from '../../../core/logger';\nimport { dgtService } from '../../wallet/dgt.service';\nimport { ccpaymentService } from '../../wallet/ccpayment.service';\nimport { walletService } from '../../wallet/wallet.service';\nimport { WalletError, ErrorCodes as WalletErrorCodes } from '../../../core/errors';\nimport { v4 as uuidv4 } from 'uuid';\nimport { WalletService } from '../../wallet/wallet.service';\nimport { XP_ACTION } from '../../xp/xp-actions';\nimport { xpService } from '../../xp/xp.service';\n\n// Create local table definitions until we update the schema\nimport {\n\tpgTable,\n\tserial,\n\tinteger,\n\ttext,\n\ttimestamp,\n\tjsonb,\n\tvarchar,\n\tdecimal\n} from 'drizzle-orm/pg-core';\n\n// Temporary tip records table definition until it's added to the schema\nconst tipRecords = pgTable('tip_records', {\n\tid: serial('id').primaryKey(),\n\tfromUserId: integer('from_user_id').notNull(),\n\ttoUserId: integer('to_user_id').notNull(),\n\tamount: decimal('amount', { precision: 18, scale: 6 }).notNull(),\n\tcurrency: varchar('currency', { length: 10 }).notNull().default('DGT'),\n\tsource: varchar('source', { length: 100 }),\n\tcontextId: varchar('context_id', { length: 100 }),\n\tmessage: text('message'),\n\tstatus: varchar('status', { length: 20 }).notNull().default('completed'),\n\tmetadata: jsonb('metadata'),\n\tcreatedAt: timestamp('created_at').notNull().defaultNow(),\n\tupdatedAt: timestamp('updated_at').notNull().defaultNow()\n});\n\n// Temporary tip settings table definition until it's added to the schema\nconst tipSettings = pgTable('tip_settings', {\n\tid: serial('id').primaryKey(),\n\tminTipAmountDGT: decimal('min_tip_amount_dgt', { precision: 18, scale: 6 }),\n\tmaxTipAmountDGT: decimal('max_tip_amount_dgt', { precision: 18, scale: 6 }),\n\tdailyTipLimitDGT: decimal('daily_tip_limit_dgt', { precision: 18, scale: 6 }),\n\ttipCooldownSeconds: integer('tip_cooldown_seconds').default(0),\n\tcreatedAt: timestamp('created_at').notNull().defaultNow(),\n\tupdatedAt: timestamp('updated_at').notNull().defaultNow()\n});\n\n/**\n * Tip request structure\n */\nexport interface TipRequest {\n\tfromUserId: UserId;\n\ttoUserId: UserId;\n\tamount: number;\n\tcurrency: string; // DGT or crypto currency code\n\tsource: string; // forum, shoutbox, etc.\n\tcontextId?: string; // post ID, thread ID, etc.\n\tmessage?: string;\n}\n\n/**\n * Tip response structure\n */\nexport interface TipResponse {\n\tid: TipId;\n\tfromUserId: UserId;\n\ttoUserId: UserId;\n\tamount: number;\n\tcurrency: string;\n\tsource: string;\n\tstatus: string;\n\tcreatedAt: Date;\n\ttransactionIds?: TransactionId[];\n}\n\n/**\n * Service for handling tips between users\n */\nexport class TipService {\n\tprivate walletService: WalletService;\n\n\tconstructor() {\n\t\tthis.walletService = new WalletService();\n\t}\n\n\t/**\n\t * Send a tip from one user to another\n\t * @param request Tip request details\n\t * @returns Tip response\n\t */\n\tasync sendTip(request: TipRequest): Promise<TipResponse> {\n\t\tconst { fromUserId, toUserId, amount, currency, source, contextId, message } = request;\n\n\t\ttry {\n\t\t\t// Validate request\n\t\t\tif (fromUserId === toUserId) {\n\t\t\t\tthrow new WalletError('Cannot tip yourself', 400, WalletErrorCodes.INVALID_PARAMETERS);\n\t\t\t}\n\n\t\t\tif (amount <= 0) {\n\t\t\t\tthrow new WalletError('Tip amount must be positive', 400, WalletErrorCodes.INVALID_AMOUNT);\n\t\t\t}\n\n\t\t\t// Check tip settings (min/max amounts, cooldowns, etc.)\n\t\t\tawait this.validateTipSettings(fromUserId, toUserId, amount, currency, source);\n\n\t\t\t// Process tip based on currency type\n\t\t\tlet transactionIds: TransactionId[] = [];\n\n\t\t\tif (currency === 'DGT') {\n\t\t\t\t// Handle DGT tip using internal transfer\n\t\t\t\tconst result = await dgtService.transferDgt(fromUserId, toUserId, BigInt(amount), 'TIP', {\n\t\t\t\t\tsource,\n\t\t\t\t\tcontextId,\n\t\t\t\t\tmessage\n\t\t\t\t});\n\n\t\t\t\ttransactionIds = [result.transactionId];\n\t\t\t} else {\n\t\t\t\t// For crypto: Not directly supported - we'd need to simulate it\n\t\t\t\t// since CCPayment likely doesn't support direct wallet-to-wallet transfers\n\t\t\t\t// without going through their system\n\n\t\t\t\t// TODO: Implement crypto tipping if CCPayment supports it\n\t\t\t\tthrow new WalletError(\n\t\t\t\t\t'Cryptocurrency tipping not supported yet',\n\t\t\t\t\t400,\n\t\t\t\t\tWalletErrorCodes.INVALID_PARAMETERS\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Record the tip in the tipRecords table\n\t\t\tconst [tipRecord] = await db\n\t\t\t\t.insert(tipRecords)\n\t\t\t\t.values({\n\t\t\t\t\tfromUserId,\n\t\t\t\t\ttoUserId,\n\t\t\t\t\tamount,\n\t\t\t\t\tcurrency,\n\t\t\t\t\tsource,\n\t\t\t\t\tcontextId,\n\t\t\t\t\tmessage,\n\t\t\t\t\tstatus: 'completed',\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\ttransactionIds,\n\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t},\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Update user tip statistics (if needed)\n\t\t\t// This could track tips given/received for achievements, etc.\n\n\t\t\treturn {\n\t\t\t\tid: tipRecord.id,\n\t\t\t\tfromUserId,\n\t\t\t\ttoUserId,\n\t\t\t\tamount,\n\t\t\t\tcurrency,\n\t\t\t\tsource,\n\t\t\t\tstatus: 'completed',\n\t\t\t\tcreatedAt: tipRecord.createdAt,\n\t\t\t\ttransactionIds\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tlogger.error('TipService', `Error sending tip: ${error.message}`);\n\t\t\tthrow new WalletError(\n\t\t\t\t`Failed to send tip: ${error.message}`,\n\t\t\t\t500,\n\t\t\t\tWalletErrorCodes.TRANSACTION_FAILED\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Validate tip settings, including limits and cooldowns\n\t */\n\tprivate async validateTipSettings(\n\t\tfromUserId: UserId,\n\t\ttoUserId: UserId,\n\t\tamount: number,\n\t\tcurrency: string,\n\t\tsource: string\n\t): Promise<void> {\n\t\t// Get global tip settings\n\t\tconst [settings] = await db.select().from(tipSettings).limit(1);\n\n\t\tif (!settings) {\n\t\t\treturn; // No restrictions if settings don't exist\n\t\t}\n\n\t\t// Check minimum tip amount\n\t\tif (currency === 'DGT' && settings.minTipAmountDGT && amount < Number(settings.minTipAmountDGT)) {\n\t\t\tthrow new WalletError(\n\t\t\t\t`Minimum DGT tip amount is ${settings.minTipAmountDGT}`,\n\t\t\t\t400,\n\t\t\t\tWalletErrorCodes.INVALID_AMOUNT\n\t\t\t);\n\t\t}\n\n\t\t// Check maximum tip amount\n\t\tif (currency === 'DGT' && settings.maxTipAmountDGT && amount > Number(settings.maxTipAmountDGT)) {\n\t\t\tthrow new WalletError(\n\t\t\t\t`Maximum DGT tip amount is ${settings.maxTipAmountDGT}`,\n\t\t\t\t400,\n\t\t\t\tWalletErrorCodes.INVALID_AMOUNT\n\t\t\t);\n\t\t}\n\n\t\t// Check daily limit\n\t\tif (settings.dailyTipLimitDGT && currency === 'DGT') {\n\t\t\tconst todayStart = new Date();\n\t\t\ttodayStart.setHours(0, 0, 0, 0);\n\n\t\t\t// Get sum of tips sent today\n\t\t\tconst [dailyTotal] = await db\n\t\t\t\t.select({\n\t\t\t\t\ttotal: sql`SUM(amount)`\n\t\t\t\t})\n\t\t\t\t.from(tipRecords).where(sql`\n        from_user_id = ${fromUserId} \n        AND currency = 'DGT'\n        AND created_at >= ${todayStart.toISOString()}\n      `);\n\n\t\t\tconst totalSentToday = Number(dailyTotal.total) || 0;\n\n\t\t\tif (totalSentToday + amount > Number(settings.dailyTipLimitDGT)) {\n\t\t\t\tthrow new WalletError(\n\t\t\t\t\t`Daily DGT tip limit of ${settings.dailyTipLimitDGT} would be exceeded`,\n\t\t\t\t\t400,\n\t\t\t\t\tWalletErrorCodes.RATE_LIMITED\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Check cooldown period\n\t\tif (settings.tipCooldownSeconds > 0) {\n\t\t\tconst cooldownTime = new Date();\n\t\t\tcooldownTime.setSeconds(cooldownTime.getSeconds() - settings.tipCooldownSeconds);\n\n\t\t\t// Check if user has sent a tip recently\n\t\t\tconst [recentTip] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(tipRecords)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(tipRecords.fromUserId, fromUserId),\n\t\t\t\t\t\teq(tipRecords.toUserId, toUserId),\n\t\t\t\t\t\tsql`${tipRecords.createdAt} >= ${cooldownTime.toISOString()}`\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.limit(1);\n\n\t\t\tif (recentTip) {\n\t\t\t\tconst nextAllowedTime = new Date(recentTip.createdAt);\n\t\t\t\tnextAllowedTime.setSeconds(nextAllowedTime.getSeconds() + settings.tipCooldownSeconds);\n\n\t\t\t\tthrow new WalletError(\n\t\t\t\t\t`Tip cooldown in effect. You can tip this user again at ${nextAllowedTime.toISOString()}`,\n\t\t\t\t\t400,\n\t\t\t\t\tWalletErrorCodes.RATE_LIMITED,\n\t\t\t\t\t{ nextAllowedTime }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get tip history for a user (sent or received)\n\t */\n\tasync getTipHistory(\n\t\tuserId: UserId,\n\t\ttype: 'sent' | 'received' = 'both',\n\t\tlimit: number = 20,\n\t\toffset: number = 0\n\t): Promise<{\n\t\ttips: any[];\n\t\ttotal: number;\n\t}> {\n\t\ttry {\n\t\t\tlet whereClause;\n\n\t\t\tif (type === 'sent') {\n\t\t\t\twhereClause = eq(tipRecords.fromUserId, userId);\n\t\t\t} else if (type === 'received') {\n\t\t\t\twhereClause = eq(tipRecords.toUserId, userId);\n\t\t\t} else {\n\t\t\t\t// 'both' - either sent or received\n\t\t\t\twhereClause = sql`\n          ${tipRecords.fromUserId} = ${userId} OR ${tipRecords.toUserId} = ${userId}\n        `;\n\t\t\t}\n\n\t\t\tconst tips = await db\n\t\t\t\t.select()\n\t\t\t\t.from(tipRecords)\n\t\t\t\t.where(whereClause)\n\t\t\t\t.orderBy(sql`${tipRecords.createdAt} DESC`)\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\tconst [{ count }] = await db\n\t\t\t\t.select({\n\t\t\t\t\tcount: sql`COUNT(*)`\n\t\t\t\t})\n\t\t\t\t.from(tipRecords)\n\t\t\t\t.where(whereClause);\n\n\t\t\treturn {\n\t\t\t\ttips,\n\t\t\t\ttotal: Number(count)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('TipService', `Error getting tip history: ${error.message}`);\n\t\t\tthrow new WalletError(\n\t\t\t\t`Failed to get tip history: ${error.message}`,\n\t\t\t\t500,\n\t\t\t\tWalletErrorCodes.SYSTEM_ERROR\n\t\t\t);\n\t\t}\n\t}\n}\n\n// Export a singleton instance\nexport const tipService = new TipService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/vault/vault.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/vault/vault.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAuthenticated' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":17,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdminOrModerator' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Vault Routes\n *\n * Defines API routes for vault functionality (locking and unlocking funds).\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { z } from 'zod';\nimport { db } from '@db';\nimport { sql, eq } from 'drizzle-orm';\nimport { vaults, transactions } from '@schema';\nimport { VaultService } from './vault.service';\nimport { logger } from '../../../core/logger';\n\nimport {\n\tisAuthenticated,\n\tisAdminOrModerator,\n\tisAdmin\n} from '../../auth/middleware/auth.middleware';\nimport { getUserIdFromRequest } from '@server/src/utils/auth';\nimport { isValidId } from '@shared/utils/id';\n\n// Initialize the service\nconst vaultService = new VaultService();\n\n// Create validation schemas\nconst lockFundsSchema = z.object({\n\tuserId: z.string().uuid(),\n\twalletAddress: z.string(), // No length validation - we handle test addresses\n\tamount: z.number().positive(),\n\tunlockTime: z.string().transform((str) => new Date(str)), // Convert string to Date\n\tnotes: z.string().optional()\n});\n\nconst unlockFundsSchema = z.object({\n\tuserId: z.string().uuid(),\n\tvaultId: z.string().uuid()\n});\n\nconst router = Router();\n\n// Admin endpoints for vault management\n// Admin endpoint to get all vaults\nrouter.get('/admin/vaults', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\t// Get all vaults with user info\n\t\tconst allVaults = await db.execute(sql`\n      SELECT \n        v.*,\n        u.username,\n        u.email\n      FROM vaults v\n      JOIN users u ON v.user_id = u.user_id\n      ORDER BY v.created_at DESC\n    `);\n\n\t\tres.json(allVaults.rows);\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'VAULT',\n\t\t\t`Admin vault list error: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t{ error: error instanceof Error ? error.message : String(error) }\n\t\t);\n\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to fetch vault list',\n\t\t\tdetails: error instanceof Error ? error.message : String(error)\n\t\t});\n\t}\n});\n\n// Admin endpoint to manually unlock a vault (override time constraints)\nrouter.post('/admin/vaults/unlock/:vaultId', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst vaultId = req.params.vaultId;\n\t\tif (!isValidId(vaultId)) {\n\t\t\treturn res.status(400).json({ error: 'Invalid vault ID' });\n\t\t}\n\n\t\t// Get the vault\n\t\tconst vault = await vaultService.getVault(vaultId);\n\t\tif (!vault) {\n\t\t\treturn res.status(404).json({ error: 'Vault not found' });\n\t\t}\n\n\t\t// Check if already unlocked\n\t\tif (vault.status === 'unlocked') {\n\t\t\treturn res.status(400).json({ error: 'Vault is already unlocked' });\n\t\t}\n\n\t\t// Force unlock through database directly to bypass time checks\n\t\tconst [updatedVault] = await db\n\t\t\t.update(vaults)\n\t\t\t.set({\n\t\t\t\tstatus: 'unlocked',\n\t\t\t\tunlockedAt: new Date(),\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\tnotes: vault.notes ? `${vault.notes}\\n[Admin override unlock]` : '[Admin override unlock]'\n\t\t\t})\n\t\t\t.where(eq(vaults.id, vaultId))\n\t\t\t.returning();\n\n\t\t// Record the transaction\n\t\tconst [transaction] = await db\n\t\t\t.insert(transactions)\n\t\t\t.values({\n\t\t\t\tuserId: vault.userId,\n\t\t\t\ttype: 'VAULT_UNLOCK',\n\t\t\t\tamount: vault.amount,\n\t\t\t\tstatus: 'confirmed',\n\t\t\t\tdescription: `Admin override: Unlocked ${vault.amount} USDT from vault #${vaultId}`,\n\t\t\t\tmetadata: JSON.stringify({\n\t\t\t\t\tvaultId,\n\t\t\t\t\tadminUnlock: true,\n\t\t\t\t\tlockedAt: vault.lockedAt.toISOString(),\n\t\t\t\t\tunlockTime: vault.unlockTime.toISOString(),\n\t\t\t\t\tinitialAmount: vault.initialAmount\n\t\t\t\t})\n\t\t\t})\n\t\t\t.returning();\n\n\t\t// Update the vault with the transaction ID\n\t\tawait db\n\t\t\t.update(vaults)\n\t\t\t.set({\n\t\t\t\tunlockTransactionId: transaction.id\n\t\t\t})\n\t\t\t.where(eq(vaults.id, vaultId));\n\n\t\t// Log the admin unlock\n\t\tconst adminUserId = getUserIdFromRequest(req);\n\t\tlogger.info(\n\t\t\t'VAULT',\n\t\t\t`Admin user #${adminUserId ?? 'UNKNOWN_ADMIN'} manually unlocked vault #${vaultId} with ${vault.amount} USDT`,\n\t\t\t{\n\t\t\t\tadminUserId: adminUserId ?? null, // Log null if undefined\n\t\t\t\tvaultId,\n\t\t\t\tuserId: vault.userId,\n\t\t\t\tamount: vault.amount,\n\t\t\t\ttransactionId: transaction.id\n\t\t\t}\n\t\t);\n\n\t\tres.json({\n\t\t\tstatus: 'unlocked',\n\t\t\tvault: updatedVault,\n\t\t\ttransaction\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'VAULT',\n\t\t\t`Admin vault unlock error: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t{\n\t\t\t\tvaultId: req.params.vaultId,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t}\n\t\t);\n\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to unlock vault',\n\t\t\tdetails: error instanceof Error ? error.message : String(error)\n\t\t});\n\t}\n});\n\n// Test endpoint for vault system (development only, no blockchain interaction)\nif (process.env.NODE_ENV !== 'production') {\n\trouter.get('/test-status', async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\t// Get a test user (any user)\n\t\t\tconst testUser = await db.execute(sql`\n        SELECT user_id, username, wallet_address \n        FROM users \n        LIMIT 1\n      `);\n\n\t\t\tif (!testUser.rows || testUser.rows.length === 0) {\n\t\t\t\treturn res.status(404).json({ error: 'No users found in database' });\n\t\t\t}\n\n\t\t\tconst user = testUser.rows[0];\n\t\t\tconst userId = user.user_id;\n\n\t\t\t// For testing, we'll handle both cases - with or without wallet\n\t\t\tconst walletAddress = user.wallet_address || 'TRzJRNqjgmzCR4zwm6wLMnECDj35zZZnVt'; // Use test address if none exists\n\n\t\t\t// Check current vaults\n\t\t\tconst existingVaults = await vaultService.getUserVaults(userId);\n\n\t\t\t// For test purposes, we'll mock the wallet balances\n\t\t\tconst mockedBalances = {\n\t\t\t\tusdt: {\n\t\t\t\t\traw: '100000000', // 100 USDT in raw units\n\t\t\t\t\ttrx: 0,\n\t\t\t\t\tformatted: 100\n\t\t\t\t},\n\t\t\t\ttrx: {\n\t\t\t\t\ttrx: 100,\n\t\t\t\t\tsun: 100000000 // 100 TRX in sun units\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Vault system is functioning correctly',\n\t\t\t\tvaultSystemStatus: {\n\t\t\t\t\tvaultTableExists: true,\n\t\t\t\t\tcanQueryVaults: true,\n\t\t\t\t\ttransactionTypesConfigured: true\n\t\t\t\t},\n\t\t\t\ttestUser: {\n\t\t\t\t\tuserId: user.user_id,\n\t\t\t\t\tusername: user.username,\n\t\t\t\t\thasWallet: !!user.wallet_address,\n\t\t\t\t\ttestWalletAddress: walletAddress\n\t\t\t\t},\n\t\t\t\texistingVaults,\n\t\t\t\tmockedBalances,\n\t\t\t\ttestActions: {\n\t\t\t\t\tcreateVault: {\n\t\t\t\t\t\turl: '/api/vault/lock',\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\tuserId,\n\t\t\t\t\t\t\twalletAddress,\n\t\t\t\t\t\t\tamount: 10, // Default small test amount\n\t\t\t\t\t\t\tunlockTime: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours from now\n\t\t\t\t\t\t\tnotes: 'Test vault created via test endpoint'\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tgetVaults: {\n\t\t\t\t\t\turl: `/api/vaults/${userId}`,\n\t\t\t\t\t\tmethod: 'GET'\n\t\t\t\t\t},\n\t\t\t\t\tgetStats: {\n\t\t\t\t\t\turl: `/api/vault/stats/${userId}`,\n\t\t\t\t\t\tmethod: 'GET'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error(\n\t\t\t\t'VAULT',\n\t\t\t\t`Vault test endpoint error: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t\t{ error: error instanceof Error ? error.message : String(error) }\n\t\t\t);\n\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to run vault test',\n\t\t\t\tdetails: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t}\n\t});\n}\n\n// Lock funds in a vault\nrouter.post('/lock', async (req: Request, res: Response) => {\n\ttry {\n\t\t// Validate request body\n\t\tconst { userId, walletAddress, amount, unlockTime, notes } = lockFundsSchema.parse(req.body);\n\n\t\t// Validate that unlock time is in the future\n\t\tconst now = new Date();\n\t\tif (unlockTime <= now) {\n\t\t\treturn res.status(400).json({\n\t\t\t\terror: 'Unlock time must be in the future.'\n\t\t\t});\n\t\t}\n\n\t\t// Validate minimum lock duration (24 hours)\n\t\tconst minLockDuration = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n\t\tif (unlockTime.getTime() - now.getTime() < minLockDuration) {\n\t\t\treturn res.status(400).json({\n\t\t\t\terror: 'Minimum lock duration is 24 hours.'\n\t\t\t});\n\t\t}\n\n\t\t// Create the vault\n\t\tconst vault = await vaultService.createVault(userId, walletAddress, amount, unlockTime, notes);\n\n\t\tres.json({\n\t\t\tstatus: 'locked',\n\t\t\tvault\n\t\t});\n\t} catch (error) {\n\t\t// Log the error\n\t\tlogger.error(\n\t\t\t'VAULT',\n\t\t\t`Failed to lock funds: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t{\n\t\t\t\trequestBody: req.body,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t}\n\t\t);\n\n\t\t// Return error response\n\t\tres.status(400).json({\n\t\t\terror: error instanceof Error ? error.message : 'Failed to lock funds'\n\t\t});\n\t}\n});\n\n// Unlock funds from a vault\nrouter.post('/unlock', async (req: Request, res: Response) => {\n\ttry {\n\t\t// Validate request body\n\t\tconst { userId, vaultId } = unlockFundsSchema.parse(req.body);\n\n\t\t// Unlock the vault\n\t\tconst vault = await vaultService.unlockVault(vaultId, userId);\n\n\t\tres.json({\n\t\t\tstatus: 'unlocked',\n\t\t\tvault\n\t\t});\n\t} catch (error) {\n\t\t// Log the error\n\t\tlogger.error(\n\t\t\t'VAULT',\n\t\t\t`Failed to unlock funds: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t{\n\t\t\t\trequestBody: req.body,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t}\n\t\t);\n\n\t\t// Return error response\n\t\tres.status(400).json({\n\t\t\terror: error instanceof Error ? error.message : 'Failed to unlock funds'\n\t\t});\n\t}\n});\n\n// Get vaults for a user\nrouter.get('/:userId', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = req.params.userId;\n\n\t\tif (isNaN(userId)) {\n\t\t\treturn res.status(400).json({ error: 'Invalid user ID' });\n\t\t}\n\n\t\tconst vaults = await vaultService.getUserVaults(userId);\n\t\tres.json(vaults);\n\t} catch (error) {\n\t\t// Log the error\n\t\tlogger.error(\n\t\t\t'VAULT',\n\t\t\t`Failed to fetch vaults: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t{\n\t\t\t\tuserId: req.params.userId,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t}\n\t\t);\n\n\t\t// Return error response\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to fetch vaults'\n\t\t});\n\t}\n});\n\n// Get vault statistics\nrouter.get('/stats/:userId?', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = req.params.userId ? req.params.userId : undefined;\n\n\t\tif (req.params.userId && isNaN(userId!)) {\n\t\t\treturn res.status(400).json({ error: 'Invalid user ID' });\n\t\t}\n\n\t\tconst stats = await vaultService.getVaultStatistics(userId);\n\t\tres.json(stats);\n\t} catch (error) {\n\t\t// Log the error\n\t\tlogger.error(\n\t\t\t'VAULT',\n\t\t\t`Failed to fetch vault statistics: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t{\n\t\t\t\tuserId: req.params.userId,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t}\n\t\t);\n\n\t\t// Return error response\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to fetch vault statistics'\n\t\t});\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/engagement/vault/vault.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'deductResult' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":73,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":73,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'grantResult' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":175,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":175,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Vault Service\n *\n * This service handles the token vaulting functionality, allowing users to lock tokens for a period of time.\n *\n * // [REFAC-VAULT]\n */\n\nimport { db } from '@db';\nimport type { UserId } from '@shared/types/ids';\nimport {\n\ttransactions,\n\tusers, // vaultSettings is not in schema\n\t/* vaultSettings, */ vaults as vaultLocks\n} from '@schema';\nimport { eq, and, lt, sql, gte } from 'drizzle-orm';\nimport { logger } from '../../../core/logger';\nimport { WalletError, ErrorCodes } from '../../../core/errors';\nimport { dgtService } from '../../wallet/dgt.service';\nimport type { UnlockTransactionId, VaultLockId, ActionId } from '@shared/types/ids';\n\n/**\n * Vault lock options structure\n */\nexport interface VaultLockOptions {\n\tuserId: UserId;\n\tamount: number;\n\tcurrency: string;\n\tlockDurationDays: number;\n\treason?: string;\n}\n\n/**\n * Service for handling token vaulting functionality\n */\nexport class VaultService {\n\t/**\n\t * Lock tokens in the vault for a period of time\n\t * @param options Vault lock options\n\t * @returns The created vault lock record\n\t */\n\tasync lockTokens(options: VaultLockOptions): Promise<any> {\n\t\tconst { userId, amount, currency, lockDurationDays, reason } = options;\n\n\t\ttry {\n\t\t\tlogger.info('VaultService', `Processing token lock for user ${userId}`, {\n\t\t\t\tamount,\n\t\t\t\tcurrency,\n\t\t\t\tlockDurationDays\n\t\t\t});\n\n\t\t\tconst { userWalletAddress } = await this.validateLockOptions(\n\t\t\t\tuserId,\n\t\t\t\tamount,\n\t\t\t\tcurrency,\n\t\t\t\tlockDurationDays\n\t\t\t);\n\n\t\t\tif (!userWalletAddress) {\n\t\t\t\tthrow new WalletError(\n\t\t\t\t\t'User wallet address not found, cannot create vault lock.',\n\t\t\t\t\t400,\n\t\t\t\t\tErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst unlockDate = new Date();\n\t\t\tunlockDate.setDate(unlockDate.getDate() + lockDurationDays);\n\n\t\t\tconst transactionId: ActionId | null = null; // This will be lockTransactionId in vaults table\n\n\t\t\tif (currency === 'DGT') {\n\t\t\t\tconst deductResult = await dgtService.deductDgt(\n\t\t\t\t\tuserId,\n\t\t\t\t\tBigInt(Math.floor(amount)),\n\t\t\t\t\t'ADMIN_ADJUST', // Using ADMIN_ADJUST as VAULT_LOCK is not in DgtTransactionType\n\t\t\t\t\t{\n\t\t\t\t\t\tlockDurationDays,\n\t\t\t\t\t\tunlockDate: unlockDate.toISOString(),\n\t\t\t\t\t\treason: reason || 'Vault Lock'\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\t// transactionId = deductResult.transactionId; // Assuming dgtService.deductDgt returns an object with transactionId\n\t\t\t\t// This needs to be confirmed from dgt.service.ts structure.\n\t\t\t\t// For now, keeping it null if not directly returned.\n\t\t\t} else {\n\t\t\t\tthrow new WalletError(\n\t\t\t\t\t`Vaulting of ${currency} is not supported yet`,\n\t\t\t\t\t400,\n\t\t\t\t\tErrorCodes.INVALID_REQUEST\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst [vaultLock] = await db\n\t\t\t\t.insert(vaultLocks)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\twalletAddress: userWalletAddress, // Added required walletAddress\n\t\t\t\t\tamount: amount,\n\t\t\t\t\tinitialAmount: amount,\n\t\t\t\t\tlockedAt: new Date(),\n\t\t\t\t\tunlockTime: unlockDate,\n\t\t\t\t\tstatus: 'locked',\n\t\t\t\t\tlockTransactionId: transactionId,\n\t\t\t\t\tnotes: reason || 'User initiated',\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tcreatedAt: new Date().toISOString(),\n\t\t\t\t\t\tcurrency: currency\n\t\t\t\t\t},\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\tlogger.info('VaultService', `Token lock created for user ${userId}`, {\n\t\t\t\tamount,\n\t\t\t\tcurrency,\n\t\t\t\tvaultLockId: vaultLock.id,\n\t\t\t\tunlockDate\n\t\t\t});\n\n\t\t\treturn vaultLock;\n\t\t} catch (error) {\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error('VaultService', `Error locking tokens: ${errorMessage}`);\n\n\t\t\tthrow new WalletError(\n\t\t\t\t`Failed to lock tokens: ${errorMessage}`,\n\t\t\t\t500,\n\t\t\t\tErrorCodes.OPERATION_FAILED,\n\t\t\t\t{ originalError: errorMessage }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Unlock tokens from the vault when they reach their unlock date\n\t * @param vaultLockId The ID of the vault lock to unlock\n\t * @returns The updated vault lock record\n\t */\n\tasync unlockTokens(vaultLockId: VaultLockId): Promise<any> {\n\t\ttry {\n\t\t\tconst [vaultLock] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(vaultLocks)\n\t\t\t\t.where(eq(vaultLocks.id, vaultLockId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (!vaultLock) {\n\t\t\t\tthrow new WalletError('Vault lock not found', 404, ErrorCodes.NOT_FOUND);\n\t\t\t}\n\n\t\t\tif (vaultLock.status === 'unlocked') {\n\t\t\t\tthrow new WalletError('Vault lock already unlocked', 400, ErrorCodes.INVALID_REQUEST);\n\t\t\t}\n\n\t\t\tconst now = new Date();\n\t\t\tif (vaultLock.unlockTime && now < vaultLock.unlockTime) {\n\t\t\t\tthrow new WalletError('Vault lock is still locked', 400, ErrorCodes.OPERATION_FAILED, {\n\t\t\t\t\tunlockDate: vaultLock.unlockTime,\n\t\t\t\t\ttimeRemaining: vaultLock.unlockTime\n\t\t\t\t\t\t? Math.floor((vaultLock.unlockTime.getTime() - now.getTime()) / 1000)\n\t\t\t\t\t\t: undefined\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst unlockTransactionId: UnlockTransactionId | null = null;\n\t\t\tconst vaultCurrency = (vaultLock.metadata as any)?.currency || 'DGT';\n\n\t\t\tif (vaultCurrency === 'DGT') {\n\t\t\t\tconst grantResult = await dgtService.addDgt(\n\t\t\t\t\tvaultLock.userId,\n\t\t\t\t\tBigInt(Math.floor(vaultLock.amount)),\n\t\t\t\t\t'ADMIN_ADJUST', // Using ADMIN_ADJUST as VAULT_UNLOCK is not in DgtTransactionType\n\t\t\t\t\t{\n\t\t\t\t\t\tvaultLockId: vaultLock.id,\n\t\t\t\t\t\tlockDuration: vaultLock.lockedAt\n\t\t\t\t\t\t\t? Math.floor((now.getTime() - vaultLock.lockedAt.getTime()) / (1000 * 60 * 60 * 24))\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\toriginalLockTransaction: vaultLock.lockTransactionId\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\t// unlockTransactionId = grantResult.transactionId; // Assuming addDgt returns transactionId\n\t\t\t}\n\n\t\t\tconst [updatedVaultLock] = await db\n\t\t\t\t.update(vaultLocks)\n\t\t\t\t.set({\n\t\t\t\t\tstatus: 'unlocked',\n\t\t\t\t\tunlockedAt: now,\n\t\t\t\t\tunlockTransactionId,\n\t\t\t\t\tupdatedAt: now\n\t\t\t\t})\n\t\t\t\t.where(eq(vaultLocks.id, vaultLockId))\n\t\t\t\t.returning();\n\n\t\t\tlogger.info('VaultService', `Tokens unlocked for user ${vaultLock.userId}`, {\n\t\t\t\tamount: vaultLock.amount,\n\t\t\t\tcurrency: vaultCurrency,\n\t\t\t\tvaultLockId,\n\t\t\t\tlockedDuration: vaultLock.lockedAt\n\t\t\t\t\t? Math.floor((now.getTime() - vaultLock.lockedAt.getTime()) / (1000 * 60 * 60 * 24))\n\t\t\t\t\t: undefined\n\t\t\t});\n\n\t\t\treturn updatedVaultLock;\n\t\t} catch (error) {\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error('VaultService', `Error unlocking tokens: ${errorMessage}`);\n\n\t\t\tthrow new WalletError(\n\t\t\t\t`Failed to unlock tokens: ${errorMessage}`,\n\t\t\t\t500,\n\t\t\t\tErrorCodes.OPERATION_FAILED,\n\t\t\t\t{ originalError: errorMessage }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Process automatic unlocks for any vault locks that have reached their unlock date\n\t * @returns Array of processed vault locks\n\t */\n\tasync processAutomaticUnlocks(): Promise<any[]> {\n\t\ttry {\n\t\t\tconst now = new Date();\n\n\t\t\tconst eligibleLocks = await db\n\t\t\t\t.select()\n\t\t\t\t.from(vaultLocks)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(vaultLocks.status, 'locked'),\n\t\t\t\t\t\tvaultLocks.unlockTime ? lt(vaultLocks.unlockTime, now) : sql`FALSE`\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.limit(50);\n\n\t\t\tconst results = [];\n\t\t\tfor (const lock of eligibleLocks) {\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await this.unlockTokens(lock.id);\n\t\t\t\t\tresults.push(result);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'VaultService',\n\t\t\t\t\t\t`Error processing automatic unlock for lock ${lock.id}: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error('VaultService', `Error processing automatic unlocks: ${errorMessage}`);\n\t\t\tthrow new WalletError(\n\t\t\t\t`Failed to process automatic unlocks: ${errorMessage}`,\n\t\t\t\t500,\n\t\t\t\tErrorCodes.OPERATION_FAILED\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get active vault locks for a user\n\t * @param userId User ID\n\t * @returns Array of active vault locks\n\t */\n\tasync getUserVaultLocks(userId: UserId): Promise<any[]> {\n\t\ttry {\n\t\t\tconst vaultLocksList = await db\n\t\t\t\t.select()\n\t\t\t\t.from(vaultLocks)\n\t\t\t\t.where(eq(vaultLocks.userId, userId))\n\t\t\t\t.orderBy(sql`${vaultLocks.createdAt} DESC`);\n\n\t\t\treturn vaultLocksList;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error('VaultService', `Error getting user vault locks: ${errorMessage}`);\n\t\t\tthrow new WalletError(\n\t\t\t\t`Failed to get user vault locks: ${errorMessage}`,\n\t\t\t\t500,\n\t\t\t\tErrorCodes.OPERATION_FAILED\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Validate lock options\n\t */\n\tprivate async validateLockOptions(\n\t\tuserId: UserId,\n\t\tamount: number,\n\t\tcurrency: string,\n\t\tlockDurationDays: number\n\t): Promise<{ userWalletAddress: string | null }> {\n\t\tconst [user] = await db\n\t\t\t.select({\n\t\t\t\tid: users.id,\n\t\t\t\tdgtWalletBalance: users.dgtWalletBalance,\n\t\t\t\twalletAddress: users.walletAddress\n\t\t\t})\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, userId))\n\t\t\t.limit(1);\n\n\t\tif (!user) {\n\t\t\tthrow new WalletError('User not found', 404, ErrorCodes.USER_NOT_FOUND);\n\t\t}\n\n\t\tif (currency !== 'DGT') {\n\t\t\tthrow new WalletError(\n\t\t\t\t'Only DGT vaulting is supported at this time',\n\t\t\t\t400,\n\t\t\t\tErrorCodes.INVALID_REQUEST\n\t\t\t);\n\t\t}\n\n\t\tif (amount <= 0) {\n\t\t\tthrow new WalletError('Amount must be positive', 400, ErrorCodes.INVALID_REQUEST);\n\t\t}\n\n\t\tif (currency === 'DGT' && BigInt(user.dgtWalletBalance) < BigInt(Math.floor(amount))) {\n\t\t\tthrow new WalletError('Insufficient DGT balance', 400, ErrorCodes.WALLET_INSUFFICIENT_FUNDS, {\n\t\t\t\trequired: amount,\n\t\t\t\tavailable: user.dgtWalletBalance\n\t\t\t});\n\t\t}\n\n\t\t// Since vaultSettings is commented out, using default validations\n\t\tif (lockDurationDays < 1) {\n\t\t\tthrow new WalletError(\n\t\t\t\t'Lock duration must be at least 1 day',\n\t\t\t\t400,\n\t\t\t\tErrorCodes.INVALID_REQUEST\n\t\t\t);\n\t\t}\n\n\t\tif (lockDurationDays > 365) {\n\t\t\tthrow new WalletError(\n\t\t\t\t'Lock duration cannot exceed 365 days',\n\t\t\t\t400,\n\t\t\t\tErrorCodes.INVALID_REQUEST\n\t\t\t);\n\t\t}\n\t\treturn { userWalletAddress: user.walletAddress };\n\t}\n}\n\n// Export a singleton instance\nexport const vaultService = new VaultService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/feature-gates/feature-gates.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/feature-gates/feature-gates.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/feature-gates/feature-gates.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'featureFlags' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport type { UserId } from '@shared/types';\nimport { featureFlags, users } from '@schema'; // Corrected import\nimport { logger, LogLevel } from '../../core/logger';\nimport { eq, and } from 'drizzle-orm';\n\n// Feature gate configuration type\nexport interface FeatureGate {\n\tid: string;\n\tname: string;\n\tdescription: string;\n\tminLevel: number;\n\tbadgeRequired?: string;\n\tenabled: boolean;\n}\n\n// User feature access type\nexport interface UserFeatureAccess {\n\tfeatureId: string;\n\thasAccess: boolean;\n\treason?: string;\n\tunlocksAtLevel?: number;\n\tmissingBadge?: string;\n}\n\n// Default feature gates - ideally this would be in database\n// Moving to database would be a future enhancement\nconst DEFAULT_FEATURE_GATES: FeatureGate[] = [\n\t{\n\t\tid: 'shoutbox',\n\t\tname: 'Shoutbox',\n\t\tdescription: 'Access to the global shoutbox chat',\n\t\tminLevel: 3,\n\t\tenabled: true\n\t},\n\t{\n\t\tid: 'signature',\n\t\tname: 'Forum Signature',\n\t\tdescription: 'Add a custom signature to your forum posts',\n\t\tminLevel: 5,\n\t\tenabled: true\n\t},\n\t{\n\t\tid: 'custom_emoji',\n\t\tname: 'Custom Emoji',\n\t\tdescription: 'Use custom emoji in posts and messages',\n\t\tminLevel: 7,\n\t\tenabled: true\n\t},\n\t{\n\t\tid: 'clout_voting',\n\t\tname: 'Clout Voting',\n\t\tdescription: \"Vote on other users' clout\",\n\t\tminLevel: 10,\n\t\tenabled: true\n\t},\n\t{\n\t\tid: 'avatar_frames',\n\t\tname: 'Avatar Frames',\n\t\tdescription: 'Use decorative frames around your avatar',\n\t\tminLevel: 8,\n\t\tbadgeRequired: 'Style Master',\n\t\tenabled: true\n\t},\n\t{\n\t\tid: 'username_colors',\n\t\tname: 'Username Colors',\n\t\tdescription: 'Use custom colors for your username',\n\t\tminLevel: 15,\n\t\tenabled: true\n\t},\n\t{\n\t\tid: 'thread_pinning',\n\t\tname: 'Thread Pinning',\n\t\tdescription: 'Pin threads at the top of forums',\n\t\tminLevel: 20,\n\t\tenabled: true\n\t},\n\t{\n\t\tid: 'badge_showcase',\n\t\tname: 'Badge Showcase',\n\t\tdescription: 'Display your favorite badges on your profile',\n\t\tminLevel: 3,\n\t\tenabled: true\n\t},\n\t{\n\t\tid: 'advanced_search',\n\t\tname: 'Advanced Search',\n\t\tdescription: 'Access to advanced search features',\n\t\tminLevel: 2,\n\t\tenabled: true\n\t}\n];\n\n/**\n * Service for managing feature gates and checking user access\n */\nexport class FeatureGatesService {\n\t/**\n\t * Get all feature gates\n\t */\n\tasync getAllFeatureGates(): Promise<FeatureGate[]> {\n\t\t// In a real implementation, this would fetch from database\n\t\t// For now, using DEFAULT_FEATURE_GATES. If featureFlags table is to be used, this needs change.\n\t\t// const dbGates = await db.select().from(featureFlags);\n\t\t// return dbGates.map(gate => ({...})); // Map to FeatureGate interface\n\t\treturn DEFAULT_FEATURE_GATES;\n\t}\n\n\t/**\n\t * Get a specific feature gate by ID\n\t */\n\tasync getFeatureGate(featureId: string): Promise<FeatureGate | null> {\n\t\t// const gate = DEFAULT_FEATURE_GATES.find(g => g.id === featureId);\n\t\t// If using DB:\n\t\t// const [dbGate] = await db.select().from(featureFlags).where(eq(featureFlags.key, featureId)).limit(1);\n\t\t// if (!dbGate) return null;\n\t\t// return { id: dbGate.key, name: dbGate.name, description: dbGate.description || '', minLevel: (dbGate.config as any)?.minLevel || 0, enabled: dbGate.isEnabled, badgeRequired: (dbGate.config as any)?.badgeRequired };\n\t\tconst gate = DEFAULT_FEATURE_GATES.find((g) => g.id === featureId); // Sticking to current logic\n\t\treturn gate || null;\n\t}\n\n\t/**\n\t * Check if a user has access to a specific feature\n\t */\n\tasync checkFeatureAccess(userId: UserId, featureId: string): Promise<UserFeatureAccess> {\n\t\ttry {\n\t\t\tconst gate = await this.getFeatureGate(featureId);\n\n\t\t\tif (!gate || !gate.enabled) {\n\t\t\t\treturn {\n\t\t\t\t\tfeatureId,\n\t\t\t\t\thasAccess: false,\n\t\t\t\t\treason: 'feature_not_available'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst userResults = await db\n\t\t\t\t.select({ level: users.level })\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userResults.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tfeatureId,\n\t\t\t\t\thasAccess: false,\n\t\t\t\t\treason: 'user_not_found'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst userLevel = userResults[0].level;\n\t\t\tconst levelMet = userLevel >= gate.minLevel;\n\n\t\t\tif (gate.badgeRequired) {\n\t\t\t\t// Placeholder for badge check logic\n\t\t\t\tconst hasBadge = false;\n\n\t\t\t\tif (!hasBadge) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfeatureId,\n\t\t\t\t\t\thasAccess: levelMet && hasBadge, // Access denied if badge required and not present\n\t\t\t\t\t\treason: 'badge_required',\n\t\t\t\t\t\tunlocksAtLevel: gate.minLevel,\n\t\t\t\t\t\tmissingBadge: gate.badgeRequired\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tfeatureId,\n\t\t\t\thasAccess: levelMet,\n\t\t\t\treason: levelMet ? undefined : 'level_too_low',\n\t\t\t\tunlocksAtLevel: gate.minLevel\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst errStr = error instanceof Error ? error.message : String(error);\n\t\t\t// Corrected logger call with namespace, message, and data object\n\t\t\tlogger.error(\n\t\t\t\t'FeatureGatesService',\n\t\t\t\t'Error checking feature access for userId: ' + userId + ', featureId: ' + featureId,\n\t\t\t\t{ error: errStr }\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tfeatureId,\n\t\t\t\thasAccess: false,\n\t\t\t\treason: 'error'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Check access for multiple features for a user\n\t */\n\tasync checkAllFeatureAccess(userId: UserId): Promise<UserFeatureAccess[]> {\n\t\tconst gates = await this.getAllFeatureGates();\n\n\t\tconst accessPromises = gates.map((gate) => this.checkFeatureAccess(userId, gate.id));\n\n\t\treturn Promise.all(accessPromises);\n\t}\n}\n\nexport const featureGatesService = new FeatureGatesService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/forum.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/forum.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lt' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":21,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'requireAuth' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":22,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Forum Routes - Main Router\n *\n * QUALITY IMPROVEMENT: Decomposed god object into focused route modules\n * This file now orchestrates between specialized route handlers\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { db } from '@db';\nimport { z } from 'zod';\nimport {\n\tusers,\n\tthreadPrefixes,\n\ttags,\n\tforumStructure,\n\tposts,\n\tthreads,\n\tusers as usersTable\n} from '@schema';\nimport { eq, ilike, asc, gt, inArray, lt, desc, and, sql } from 'drizzle-orm';\nimport { isAuthenticated as requireAuth } from '../auth/middleware/auth.middleware';\nimport { logger } from '@server/src/core/logger';\nimport { forumStructureService } from './services/structure.service';\nimport { threadService } from './services/thread.service';\nimport { asyncHandler } from '@server/src/core/errors';\nimport type { StructureId } from '@shared/types/ids';\n\n// Import specialized route modules\nimport threadRoutes from './routes/thread.routes';\nimport postRoutes from './routes/post.routes';\nimport bookmarkRoutes from './routes/bookmark.routes';\nimport categoryRoutes from './routes/category.routes';\nimport contentRoutes from './routes/content.routes';\nimport rulesRoutes from './rules/rules.routes';\nimport reportsRoutes from './sub-domains/reports/reports.routes';\n\nconst router = Router();\n\n// Mount specialized route modules\nrouter.use('/threads', threadRoutes);\nrouter.use('/posts', postRoutes);\nrouter.use('/bookmarks', bookmarkRoutes);\nrouter.use('/categories', categoryRoutes);\nrouter.use('/content', contentRoutes);\nrouter.use('/rules', rulesRoutes);\nrouter.use('/reports', reportsRoutes);\n\n// ------------------------------------------------------------------\n// FLAT FORUM STRUCTURE ENDPOINT  ✨\n//\n// Returns `{ zones, forums }` without any deprecated \"categories\" path so\n// the client can call `/api/forum/structure` directly.\n// ------------------------------------------------------------------\n\nrouter.get(\n\t'/structure',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst structures = await forumStructureService.getStructuresWithStats();\n\t\t\tconst zones = structures.filter((s) => s.type === 'zone');\n\t\t\tconst forums = structures.filter((s) => s.type === 'forum');\n\t\t\treturn res.json({ zones, forums });\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumRoutes', 'Error in GET /structure', { error });\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch forum structure'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Validation schemas for remaining endpoints\nconst userSearchSchema = z.object({\n\tq: z.string().min(1).max(50)\n});\n\n// User search endpoint (used by mention system)\nrouter.get(\n\t'/users/search',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst validatedQuery = userSearchSchema.parse(req.query);\n\t\t\tconst searchTerm = validatedQuery.q;\n\n\t\t\tconst users_results = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tavatar: users.avatarUrl\n\t\t\t\t\t// Note: Removed role field since it's in roles table via primaryRoleId\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(ilike(users.username, `%${searchTerm}%`))\n\t\t\t\t.limit(10)\n\t\t\t\t.orderBy(asc(users.username));\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: users_results\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumRoutes', 'Error in GET /users/search', { error });\n\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid search query',\n\t\t\t\t\tdetails: error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to search users'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get thread prefixes\nrouter.get(\n\t'/prefixes',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst forumId = req.query.forumId ? (req.query.forumId as string) : undefined;\n\n\t\t\tlet prefixes;\n\t\t\tif (forumId) {\n\t\t\t\tprefixes = await db\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(threadPrefixes)\n\t\t\t\t\t.where(eq(threadPrefixes.isActive, true))\n\t\t\t\t\t.orderBy(asc(threadPrefixes.position));\n\t\t\t} else {\n\t\t\t\tprefixes = await db\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(threadPrefixes)\n\t\t\t\t\t.where(eq(threadPrefixes.isActive, true))\n\t\t\t\t\t.orderBy(asc(threadPrefixes.position));\n\t\t\t}\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: prefixes\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumRoutes', 'Error in GET /prefixes', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch prefixes'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get tags\nrouter.get(\n\t'/tags',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst allTags = await db.select().from(tags).orderBy(asc(tags.name));\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: allTags\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumRoutes', 'Error in GET /tags', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch tags'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Health check endpoint\nrouter.get(\n\t'/health',\n\tasyncHandler((req: Request, res: Response) => {\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: 'Forum API is healthy',\n\t\t\ttimestamp: new Date().toISOString()\n\t\t});\n\t})\n);\n\n// ------------------------------------------------------------------\n// LIST THREADS BY FORUM ID (flat model)\n// ------------------------------------------------------------------\n\nrouter.get(\n\t'/forums/:id/threads',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst forumId = req.params.id as StructureId;\n\t\t\tconst page = parseInt(req.query.page as string) || 1;\n\t\t\tconst limit = Math.min(parseInt(req.query.limit as string) || 20, 100);\n\t\t\tconst sortBy = (req.query.sort as string) || 'newest';\n\t\t\tconst search = req.query.search as string;\n\n\t\t\tconst result = await threadService.searchThreads({\n\t\t\t\tstructureId: forumId,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\tsortBy: sortBy as any,\n\t\t\t\tsearch\n\t\t\t});\n\n\t\t\treturn res.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: result,\n\t\t\t\tpagination: {\n\t\t\t\t\tpage,\n\t\t\t\t\tlimit,\n\t\t\t\t\ttotal: result.total,\n\t\t\t\t\ttotalPages: result.totalPages\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumRoutes', 'Error in GET /forums/:id/threads', { error });\n\t\t\treturn res.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch threads'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// -------------------------------------------------------------\n//  Zone Stats Endpoint – returns today\\'s post count, trending threads,\n//  last active user and creation date for momentum math.\n//  GET /api/forum/zone-stats?slug=<zoneSlug>\n// -------------------------------------------------------------\n\nrouter.get(\n\t'/zone-stats',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst slug = (req.query.slug as string) ?? '';\n\t\t\tif (!slug) {\n\t\t\t\treturn res.status(400).json({ success: false, error: 'Missing slug query param' });\n\t\t\t}\n\n\t\t\t// Fetch the zone node\n\t\t\tconst [zone] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(eq(forumStructure.slug, slug))\n\t\t\t\t.limit(1);\n\t\t\tif (!zone || zone.type !== 'zone') {\n\t\t\t\treturn res.status(404).json({ success: false, error: 'Zone not found' });\n\t\t\t}\n\n\t\t\t// Find forums under this zone\n\t\t\tconst forumRows = await db\n\t\t\t\t.select({ id: forumStructure.id })\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(eq(forumStructure.parentId, zone.id));\n\n\t\t\tconst forumIds = forumRows.map((f) => f.id);\n\t\t\tif (forumIds.length === 0) {\n\t\t\t\treturn res.json({\n\t\t\t\t\ttodaysPosts: 0,\n\t\t\t\t\ttrendingThreads: 0,\n\t\t\t\t\tlastActiveUser: null,\n\t\t\t\t\tcreatedAt: zone.createdAt\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst todayStart = new Date();\n\t\t\ttodayStart.setUTCHours(0, 0, 0, 0);\n\n\t\t\t// Count today\\'s posts\n\t\t\tconst [{ count: todaysPosts }] = await db\n\t\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t\t.from(posts)\n\t\t\t\t.innerJoin(threads, eq(posts.threadId, threads.id))\n\t\t\t\t.where(and(inArray(threads.structureId, forumIds), gt(posts.createdAt, todayStart)));\n\n\t\t\t// Trending threads = threads with most posts in last 24h (top 3)\n\t\t\tconst trending = await db\n\t\t\t\t.select({ id: threads.id })\n\t\t\t\t.from(threads)\n\t\t\t\t.where(and(inArray(threads.structureId, forumIds), gt(threads.createdAt, todayStart)))\n\t\t\t\t.orderBy(desc(threads.postCount))\n\t\t\t\t.limit(3);\n\n\t\t\tconst trendingThreads = trending.length;\n\n\t\t\t// Last active user = author of most recent post today\n\t\t\tconst [lastPost] = await db\n\t\t\t\t.select({ userId: posts.userId })\n\t\t\t\t.from(posts)\n\t\t\t\t.innerJoin(threads, eq(posts.threadId, threads.id))\n\t\t\t\t.where(inArray(threads.structureId, forumIds))\n\t\t\t\t.orderBy(desc(posts.createdAt))\n\t\t\t\t.limit(1);\n\n\t\t\tlet lastActiveUser = null;\n\t\t\tif (lastPost) {\n\t\t\t\tconst [u] = await db\n\t\t\t\t\t.select({ username: usersTable.username, avatarUrl: usersTable.avatarUrl })\n\t\t\t\t\t.from(usersTable)\n\t\t\t\t\t.where(eq(usersTable.id, lastPost.userId))\n\t\t\t\t\t.limit(1);\n\t\t\t\tif (u) lastActiveUser = { username: u.username, avatarUrl: u.avatarUrl };\n\t\t\t}\n\n\t\t\treturn res.json({ todaysPosts, trendingThreads, lastActiveUser, createdAt: zone.createdAt });\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumRoutes', 'Error in GET /zone-stats', { error });\n\t\t\treturn res.status(500).json({ success: false, error: 'Failed to fetch zone stats' });\n\t\t}\n\t})\n);\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/forum.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getAllDescendantLeafForumIds' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":43,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":43,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'includeCounts' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":130,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":130,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Forum Service - Orchestration Layer\n *\n * QUALITY IMPROVEMENT: Decomposed god object into focused services\n * This file now orchestrates between specialized services rather than handling everything\n */\n\nimport { db } from '@db';\nimport { logger } from '@server/src/core/logger';\nimport { forumStructure, threads, threadPrefixes, tags } from '@schema';\nimport { sql, desc, asc, and, eq, inArray } from 'drizzle-orm';\nimport type {\n\tForumStructureWithStats,\n\tThreadWithPostsAndUser\n} from '../../../db/types/forum.types';\n// Import specialized services\nimport { forumStructureService } from './services/structure.service';\nimport { threadService } from './services/thread.service';\nimport { postService } from './services/post.service';\nimport { configService } from './services/config.service';\nimport { cacheService } from './services/cache.service';\nimport type { ForumId, StructureId, ThreadId, PostId } from '@shared/types/ids';\n\nexport interface ThreadSearchParams {\n\tcategoryId?: StructureId;\n\tstructureId?: StructureId;\n\tprefix?: string;\n\ttag?: string;\n\tpage?: number;\n\tlimit?: number;\n\tsortBy?: 'latest' | 'hot' | 'staked' | 'popular' | 'recent';\n\tsearch?: string;\n}\n\ninterface StructureTreeOptions {\n\tincludeEmptyStats?: boolean;\n\tincludeHidden?: boolean;\n}\n\n/**\n * Helper function to get all descendant leaf forum IDs for a given structure ID\n */\nasync function getAllDescendantLeafForumIds(startStructureId: StructureId): Promise<StructureId[]> {\n\tconst allStructures = await db\n\t\t.select({\n\t\t\tid: forumStructure.id,\n\t\t\tparentId: forumStructure.parentId,\n\t\t\ttype: forumStructure.type\n\t\t})\n\t\t.from(forumStructure);\n\n\tconst structureMap = new Map<\n\t\tStructureId,\n\t\t{ id: StructureId; parentId: StructureId | null; type: string; children: StructureId[] }\n\t>();\n\n\tallStructures.forEach((s) => {\n\t\tstructureMap.set(s.id, { ...s, children: [] });\n\t});\n\n\tallStructures.forEach((s) => {\n\t\tif (s.parentId && structureMap.has(s.parentId)) {\n\t\t\tstructureMap.get(s.parentId)?.children.push(s.id);\n\t\t}\n\t});\n\n\tconst leafForumIds: StructureId[] = [];\n\tconst queue: StructureId[] = [startStructureId];\n\tconst visited = new Set<StructureId>();\n\n\twhile (queue.length > 0) {\n\t\tconst currentId = queue.shift()!;\n\t\tif (visited.has(currentId)) continue;\n\t\tvisited.add(currentId);\n\n\t\tconst structureNode = structureMap.get(currentId);\n\t\tif (!structureNode) continue;\n\n\t\tconst isLeafForum =\n\t\t\tstructureNode.type === 'forum' &&\n\t\t\t!structureNode.children.some((childId) => structureMap.get(childId)?.type === 'forum');\n\n\t\tif (isLeafForum) {\n\t\t\tleafForumIds.push(currentId);\n\t\t} else {\n\t\t\tstructureNode.children.forEach((childId) => {\n\t\t\t\tif (!visited.has(childId)) {\n\t\t\t\t\tqueue.push(childId);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tconst startStructureNode = structureMap.get(startStructureId);\n\tif (\n\t\tstartStructureNode &&\n\t\tstartStructureNode.type === 'forum' &&\n\t\tstartStructureNode.children.length === 0 &&\n\t\t!leafForumIds.includes(startStructureId)\n\t) {\n\t\tleafForumIds.push(startStructureId);\n\t}\n\n\treturn [...new Set(leafForumIds)]; // Ensure unique IDs\n}\n\nexport const forumService = {\n\t/**\n\t * Get complete forum structure with zones and forums\n\t */\n\tasync getForumStructure(): Promise<{\n\t\tzones: ForumStructureWithStats[];\n\t\tforums: ForumStructureWithStats[];\n\t}> {\n\t\ttry {\n\t\t\t// Delegate to the new structure service\n\t\t\treturn {\n\t\t\t\tzones: await forumStructureService.getForumHierarchy(),\n\t\t\t\tforums: await forumStructureService.getStructuresWithStats()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumService', 'Error in getForumStructure', { err: error });\n\t\t\tthrow error;\n\t\t}\n\t},\n\n\t/**\n\t * Get structures with statistics - delegates to StructureService\n\t */\n\tasync getStructuresWithStats(includeCounts: boolean = true): Promise<ForumStructureWithStats[]> {\n\t\treturn forumStructureService.getStructuresWithStats();\n\t},\n\n\t/**\n\t * Get structure tree - delegates to StructureService\n\t */\n\tasync getStructureTree(options: StructureTreeOptions = {}) {\n\t\treturn forumStructureService.getStructureTree(options);\n\t},\n\n\t/**\n\t * Get forum by slug - delegates to StructureService\n\t */\n\tasync getForumBySlug(slug: string): Promise<ForumStructureWithStats | null> {\n\t\treturn forumStructureService.getStructureBySlug(slug);\n\t},\n\n\t/**\n\t * Get categories tree - delegates to StructureService\n\t */\n\tasync getCategoriesTree(options: StructureTreeOptions = {}) {\n\t\treturn forumStructureService.getStructureTree(options);\n\t},\n\n\t/**\n\t * Get categories with stats - delegates to StructureService\n\t */\n\tasync getCategoriesWithStats(): Promise<ForumStructureWithStats[]> {\n\t\treturn forumStructureService.getStructuresWithStats();\n\t},\n\n\t/**\n\t * Get forum with topics by slug\n\t */\n\tasync getForumBySlugWithTopics(slug: string): Promise<{ forum: ForumStructureWithStats | null }> {\n\t\tconst forum = await this.getCategoryBySlug(slug);\n\t\treturn { forum };\n\t},\n\n\t/**\n\t * Get forum and sub-forums by slug\n\t */\n\tasync getForumAndItsSubForumsBySlug(slug: string): Promise<{\n\t\tforum: ForumStructureWithStats | null;\n\t}> {\n\t\tconst forum = await this.getForumBySlug(slug);\n\t\treturn { forum };\n\t},\n\n\t/**\n\t * Get category by ID from structure\n\t */\n\tasync getCategoryById(id: StructureId): Promise<ForumStructureWithStats | null> {\n\t\tconst { zones } = await this.getForumStructure();\n\t\tfor (const zone of zones) {\n\t\t\tfor (const parentForum of zone.childForums || []) {\n\t\t\t\tif (parentForum.id === id) {\n\t\t\t\t\treturn parentForum;\n\t\t\t\t}\n\t\t\t\tif (parentForum.childForums) {\n\t\t\t\t\tconst subForum = parentForum.childForums.find((sf) => sf.id === id);\n\t\t\t\t\tif (subForum) {\n\t\t\t\t\t\treturn subForum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t},\n\n\t/**\n\t * Get structures by parent ID\n\t */\n\tasync getForumsByParentId(parentId: StructureId): Promise<ForumStructureWithStats[]> {\n\t\tconst parentStructure = await this.getCategoryById(parentId);\n\t\treturn parentStructure?.childForums || [];\n\t},\n\n\t/**\n\t * Debug forum relationships\n\t */\n\tasync debugForumRelationships() {\n\t\ttry {\n\t\t\tconst { zones: structuredZones } = await this.getForumStructure();\n\t\t\tconst result = structuredZones.map((zone) => ({\n\t\t\t\tid: zone.id,\n\t\t\t\tname: zone.name,\n\t\t\t\tslug: zone.slug,\n\t\t\t\tisPrimary: zone.isPrimary || false,\n\t\t\t\tforums: (zone.childForums || []).map((parentForum) => ({\n\t\t\t\t\tid: parentForum.id,\n\t\t\t\t\tname: parentForum.name,\n\t\t\t\t\tslug: parentForum.slug,\n\t\t\t\t\tparentId: parentForum.parentId,\n\t\t\t\t\tsubForums: (parentForum.childForums || []).map((subForum) => ({\n\t\t\t\t\t\tid: subForum.id,\n\t\t\t\t\t\tname: subForum.name,\n\t\t\t\t\t\tslug: subForum.slug,\n\t\t\t\t\t\tparentId: subForum.parentId\n\t\t\t\t\t}))\n\t\t\t\t}))\n\t\t\t}));\n\t\t\treturn { zones: result };\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumService', 'Error in debugForumRelationships', { err: error });\n\t\t\tthrow error;\n\t\t}\n\t},\n\n\t/**\n\t * Get thread prefixes - simple delegation\n\t */\n\tasync getPrefixes(forumId?: StructureId) {\n\t\tif (forumId) {\n\t\t\treturn db\n\t\t\t\t.select()\n\t\t\t\t.from(threadPrefixes)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(threadPrefixes.isActive, true),\n\t\t\t\t\t\tsql`${threadPrefixes.structureId} IS NULL OR ${threadPrefixes.structureId} = ${forumId}`\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.orderBy(asc(threadPrefixes.position));\n\t\t} else {\n\t\t\treturn db\n\t\t\t\t.select()\n\t\t\t\t.from(threadPrefixes)\n\t\t\t\t.where(eq(threadPrefixes.isActive, true))\n\t\t\t\t.orderBy(asc(threadPrefixes.position));\n\t\t}\n\t},\n\n\t/**\n\t * Get tags - simple delegation\n\t */\n\tasync getTags() {\n\t\treturn db.select().from(tags).orderBy(asc(tags.name));\n\t},\n\n\t/**\n\t * Search threads - delegates to ThreadService\n\t */\n\tasync searchThreads(params: ThreadSearchParams) {\n\t\treturn threadService.searchThreads(params);\n\t},\n\n\t/**\n\t * Get thread details - delegates to ThreadService and PostService\n\t */\n\tasync getThreadDetails(\n\t\tslugOrId: string | number,\n\t\tpage: number = 1,\n\t\trequestedLimit: number = 20,\n\t\tcurrentUserId?: string\n\t): Promise<ThreadWithPostsAndUser | null> {\n\t\t// This method is complex and involves multiple services,\n\t\t// keeping it here for now as it orchestrates between thread and post services\n\t\ttry {\n\t\t\tconst thread = await threadService.getThreadBySlug(String(slugOrId));\n\t\t\tif (!thread) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst postsResponse = await postService.getPostsByThread({\n\t\t\t\tthreadId: thread.id,\n\t\t\t\tpage,\n\t\t\t\tlimit: requestedLimit,\n\t\t\t\tsortBy: 'oldest'\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tthread,\n\t\t\t\tposts: postsResponse.posts,\n\t\t\t\tpagination: {\n\t\t\t\t\tpage: postsResponse.page,\n\t\t\t\t\tpageSize: requestedLimit,\n\t\t\t\t\ttotalItems: postsResponse.total,\n\t\t\t\t\ttotalPages: postsResponse.totalPages\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumService', 'Error in getThreadDetails', {\n\t\t\t\terr: error,\n\t\t\t\tslugOrId,\n\t\t\t\tpage,\n\t\t\t\trequestedLimit,\n\t\t\t\tcurrentUserId\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t},\n\n\t/**\n\t * Update thread solved status - delegates to ThreadService\n\t */\n\tasync updateThreadSolvedStatus(params: { threadId: ThreadId; solvingPostId?: PostId | null }) {\n\t\t// For now, keeping this implementation here as it's thread-specific\n\t\t// TODO: Move to ThreadService in next iteration\n\t\ttry {\n\t\t\tconst { threadId, solvingPostId } = params;\n\n\t\t\tconst [updatedThread] = await db\n\t\t\t\t.update(threads)\n\t\t\t\t.set({\n\t\t\t\t\tisSolved: solvingPostId !== null && solvingPostId !== undefined,\n\t\t\t\t\tsolvingPostId: solvingPostId === undefined ? null : solvingPostId,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(threads.id, threadId))\n\t\t\t\t.returning({\n\t\t\t\t\tid: threads.id,\n\t\t\t\t\ttitle: threads.title,\n\t\t\t\t\tisSolved: threads.isSolved,\n\t\t\t\t\tsolvingPostId: threads.solvingPostId,\n\t\t\t\t\tupdatedAt: threads.updatedAt\n\t\t\t\t});\n\t\t\treturn updatedThread || null;\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumService', 'Error in updateThreadSolvedStatus', {\n\t\t\t\terr: error,\n\t\t\t\t...params\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t},\n\n\t/**\n\t * Ensure valid leaf forum - delegates to ConfigService\n\t */\n\tensureValidLeafForum(slug: string) {\n\t\treturn configService.ensureValidLeafForum(slug);\n\t},\n\n\t/**\n\t * Get threads in forum by slug\n\t */\n\tasync getThreadsInForum(slug: string) {\n\t\t// Validate against config\n\t\tconfigService.ensureValidLeafForum(slug);\n\n\t\t// Resolve the corresponding structure ID in the database\n\t\tconst [structureRow] = await db\n\t\t\t.select({ id: forumStructure.id })\n\t\t\t.from(forumStructure)\n\t\t\t.where(eq(forumStructure.slug, slug))\n\t\t\t.limit(1);\n\n\t\tif (!structureRow) {\n\t\t\tthrow new Error(\n\t\t\t\t`Forum with slug '${slug}' not found in database after validation. Did you run sync:forums?`\n\t\t\t);\n\t\t}\n\n\t\treturn db\n\t\t\t.select()\n\t\t\t.from(threads)\n\t\t\t.where(eq(threads.structureId, structureRow.id))\n\t\t\t.orderBy(desc(threads.createdAt));\n\t},\n\n\t/**\n\t * Clear all caches - delegates to CacheService\n\t */\n\tclearCache() {\n\t\tcacheService.clearAllCaches();\n\t}\n};\n\nexport default forumService;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/routes/bookmark.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":107,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":107,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Bookmark Routes\n *\n * QUALITY IMPROVEMENT: Extracted from forum.routes.ts god object\n * Handles bookmark-specific API endpoints with proper separation of concerns\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { z } from 'zod';\nimport { db } from '@db';\nimport { userThreadBookmarks } from '@schema';\nimport { eq, and } from 'drizzle-orm';\nimport { isAuthenticated as requireAuth } from '../../auth/middleware/auth.middleware';\nimport { logger } from '@server/src/core/logger';\nimport { asyncHandler } from '@server/src/core/errors';\n\nconst router = Router();\n\n// Validation schemas\nconst createBookmarkSchema = z.object({\n\tthreadId: z.string().uuid('Invalid threadId format')\n});\n\n// Create bookmark\nrouter.post(\n\t'/',\n\trequireAuth,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst validatedData = createBookmarkSchema.parse(req.body);\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\n\t\t\tif (!userId) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'User not authenticated'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Check if bookmark already exists\n\t\t\tconst existingBookmark = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userThreadBookmarks)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userThreadBookmarks.userId, userId),\n\t\t\t\t\t\teq(userThreadBookmarks.threadId, validatedData.threadId)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.limit(1);\n\n\t\t\tif (existingBookmark.length > 0) {\n\t\t\t\treturn res.status(409).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Thread already bookmarked'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Create bookmark\n\t\t\tawait db.insert(userThreadBookmarks).values({\n\t\t\t\tuserId,\n\t\t\t\tthreadId: validatedData.threadId,\n\t\t\t\tcreatedAt: new Date()\n\t\t\t});\n\n\t\t\tres.status(201).json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Thread bookmarked successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('BookmarkRoutes', 'Error in POST /bookmarks', { error });\n\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid input data',\n\t\t\t\t\tdetails: error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to create bookmark'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Delete bookmark\nrouter.delete(\n\t'/:threadId',\n\trequireAuth,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst threadId = req.params.threadId; // Note: Consider adding ThreadId type if needed\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\n\t\t\tif (!userId) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'User not authenticated'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst result = await db\n\t\t\t\t.delete(userThreadBookmarks)\n\t\t\t\t.where(\n\t\t\t\t\tand(eq(userThreadBookmarks.userId, userId), eq(userThreadBookmarks.threadId, threadId))\n\t\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Bookmark removed successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('BookmarkRoutes', 'Error in DELETE /bookmarks/:threadId', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to remove bookmark'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get user bookmarks\nrouter.get(\n\t'/',\n\trequireAuth,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\t\t\tconst page = parseInt(req.query.page as string) || 1;\n\t\t\tconst limit = Math.min(parseInt(req.query.limit as string) || 20, 100);\n\t\t\tconst offset = (page - 1) * limit;\n\n\t\t\tif (!userId) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'User not authenticated'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst bookmarks = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userThreadBookmarks)\n\t\t\t\t.where(eq(userThreadBookmarks.userId, userId))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset)\n\t\t\t\t.orderBy(userThreadBookmarks.createdAt);\n\n\t\t\t// TODO: Join with threads table to get thread details\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: bookmarks,\n\t\t\t\tpagination: {\n\t\t\t\t\tpage,\n\t\t\t\t\tlimit,\n\t\t\t\t\toffset\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('BookmarkRoutes', 'Error in GET /bookmarks', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch bookmarks'\n\t\t\t});\n\t\t}\n\t})\n);\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/routes/category.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'forumService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'includeStats' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":71,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":71,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Forum Structure Routes\n *\n * Modern API endpoints for forum structure operations.\n * Replaces the old category routes with clearer terminology.\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { forumStructureService } from '../services/structure.service';\nimport { forumService } from '../forum.service';\nimport { logger } from '@server/src/core/logger';\nimport { asyncHandler } from '@server/src/core/errors';\n\nconst router = Router();\n\n// -------------------------------------------------------------\n// FLAT STRUCTURE ENDPOINT  ✨\n//\n// `categories` layer has been deprecated.  The frontend now expects a\n// flat payload of the form `{ zones: ZoneEntity[], forums: ForumEntity[] }`.\n// We derive this directly from `getStructuresWithStats()` and split on the\n// `type` field.  The previous nested hierarchy response is still available\n// via `/hierarchy` for legacy consumers.\n// -------------------------------------------------------------\n\nrouter.get(\n\t'/structure',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\t// Fetch all structures with statistics in a single query\n\t\t\tconst allStructures = await forumStructureService.getStructuresWithStats();\n\n\t\t\t// Separate into zones and forums for the flat client payload\n\t\t\tconst zones = allStructures.filter((s) => s.type === 'zone');\n\t\t\tconst forums = allStructures.filter((s) => s.type === 'forum');\n\n\t\t\tres.json({ zones, forums });\n\t\t} catch (error) {\n\t\t\tlogger.error('StructureRoutes', 'Error in GET /structure', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch forum structure'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Alternative endpoint name for clarity\nrouter.get(\n\t'/hierarchy',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst hierarchy = await forumStructureService.getForumHierarchy();\n\t\t\tres.json(hierarchy);\n\t\t} catch (error) {\n\t\t\tlogger.error('StructureRoutes', 'Error in GET /hierarchy', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch forum hierarchy'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get structures list\nrouter.get(\n\t'/',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst includeStats = req.query.includeStats !== 'false';\n\t\t\tconst structures = await forumStructureService.getStructuresWithStats();\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: structures\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('StructureRoutes', 'Error in GET /structures', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch forum structures'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get structure tree\nrouter.get(\n\t'/tree',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst includeHidden = req.query.includeHidden === 'true';\n\t\t\tconst includeEmptyStats = req.query.includeEmptyStats === 'true';\n\n\t\t\tconst tree = await forumStructureService.getStructureTree({\n\t\t\t\tincludeHidden,\n\t\t\t\tincludeEmptyStats\n\t\t\t});\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: tree\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('StructureRoutes', 'Error in GET /structure/tree', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch structure tree'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get structure by slug\nrouter.get(\n\t'/slug/:slug',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst slug = req.params.slug;\n\t\t\tconst structure = await forumStructureService.getStructureBySlug(slug);\n\n\t\t\tif (!structure) {\n\t\t\t\treturn res.status(404).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Forum structure not found'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: structure\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('StructureRoutes', 'Error in GET /structure/slug/:slug', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch forum structure'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get structure statistics\nrouter.get(\n\t'/:id/stats',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst structureId = req.params.id; // Note: Consider adding StructureId type if needed\n\t\t\tconst stats = await forumStructureService.getStructureStats(structureId);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: stats\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('StructureRoutes', 'Error in GET /structure/:id/stats', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch structure statistics'\n\t\t\t});\n\t\t}\n\t})\n);\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/routes/content.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/routes/post.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":106,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":106,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":147,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":147,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'postId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":217,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":217,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'validatedData' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":218,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":218,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Post Routes\n *\n * QUALITY IMPROVEMENT: Extracted from forum.routes.ts god object\n * Handles post-specific API endpoints with proper separation of concerns\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { z } from 'zod';\nimport { isAuthenticated as requireAuth } from '../../auth/middleware/auth.middleware';\nimport { postService } from '../services/post.service';\nimport { logger } from '@server/src/core/logger';\nimport {\n\trequirePostEditPermission,\n\trequirePostDeletePermission\n} from '../services/permissions.service';\nimport { asyncHandler } from '@server/src/core/errors';\nimport type { ThreadId, PostId, UserId } from '@shared/types/ids';\nimport { ForumTransformer } from '../transformers/forum.transformer';\n\nconst router = Router();\n\n// Validation schemas\nconst createPostSchema = z.object({\n\tthreadId: z.string().uuid('Invalid threadId format'),\n\tcontent: z.string().min(1),\n\treplyToPostId: z.string().uuid('Invalid postId format').optional().nullable(),\n\teditorState: z.any().optional()\n});\n\nconst updatePostSchema = z.object({\n\tcontent: z.string().min(1),\n\teditorState: z.any().optional(),\n\teditReason: z.string().optional()\n});\n\nconst postReactionSchema = z.object({\n\treactionType: z.enum(['like', 'dislike'])\n});\n\nconst tipPostSchema = z.object({\n\tamount: z.number().positive().min(0.000001)\n});\n\n// Create new post (reply)\nrouter.post(\n\t'/',\n\trequireAuth,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst validatedData = createPostSchema.parse(req.body);\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\n\t\t\tif (!userId) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'User not authenticated'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst newPost = await postService.createPost({\n\t\t\t\tcontent: validatedData.content,\n\t\t\t\tthreadId: validatedData.threadId,\n\t\t\t\tuserId: userId,\n\t\t\t\treplyToPostId: validatedData.replyToPostId\n\t\t\t});\n\n\t\t\t// Transform post response using ForumTransformer for authenticated user\n\t\t\tconst requestingUser = userService.getUserFromRequest(req);\n\t\t\tconst transformedPost = ForumTransformer.toAuthenticatedPost(newPost, requestingUser);\n\n\t\t\tres.status(201).json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: transformedPost\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('PostRoutes', 'Error in POST /posts', { error });\n\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid input data',\n\t\t\t\t\tdetails: error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to create post'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Update post\nrouter.put(\n\t'/:id',\n\trequireAuth,\n\trequirePostEditPermission,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst postId = req.params.id as PostId;\n\t\t\tconst validatedData = updatePostSchema.parse(req.body);\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\n\t\t\tconst updatedPost = await postService.updatePost(postId, {\n\t\t\t\tcontent: validatedData.content\n\t\t\t});\n\n\t\t\t// Transform post response using ForumTransformer for authenticated user\n\t\t\tconst requestingUser = userService.getUserFromRequest(req);\n\t\t\tconst transformedPost = ForumTransformer.toAuthenticatedPost(updatedPost, requestingUser);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: transformedPost\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('PostRoutes', 'Error in PUT /posts/:id', { error });\n\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid input data',\n\t\t\t\t\tdetails: error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to update post'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Delete post\nrouter.delete(\n\t'/:id',\n\trequireAuth,\n\trequirePostDeletePermission,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst postId = req.params.id as PostId;\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\n\t\t\tawait postService.deletePost(postId);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Post deleted successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('PostRoutes', 'Error in DELETE /posts/:id', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to delete post'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// React to post (like/dislike)\nrouter.post(\n\t'/:postId/react',\n\trequireAuth,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst postId = req.params.postId as PostId;\n\t\t\tconst validatedData = postReactionSchema.parse(req.body);\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\n\t\t\tif (!userId) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'User not authenticated'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (validatedData.reactionType === 'like') {\n\t\t\t\tawait postService.likePost(postId, userId);\n\t\t\t} else {\n\t\t\t\tawait postService.unlikePost(postId, userId);\n\t\t\t}\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Reaction updated successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('PostRoutes', 'Error in POST /posts/:postId/react', { error });\n\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid input data',\n\t\t\t\t\tdetails: error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to update reaction'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Tip post\nrouter.post(\n\t'/:postId/tip',\n\trequireAuth,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst postId = req.params.postId as PostId;\n\t\t\tconst validatedData = tipPostSchema.parse(req.body);\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\n\t\t\tif (!userId) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'User not authenticated'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// TODO: Implement tipping logic with DGT service integration\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Post tipped successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('PostRoutes', 'Error in POST /posts/:postId/tip', { error });\n\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid input data',\n\t\t\t\t\tdetails: error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to tip post'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get post replies\nrouter.get(\n\t'/:postId/replies',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst postId = req.params.postId as PostId;\n\n\t\t\tconst replies = await postService.getPostReplies(postId);\n\n\t\t\t// Transform post replies using ForumTransformer based on user context\n\t\t\tconst requestingUser = userService.getUserFromRequest(req);\n\t\t\tconst transformedReplies = replies.map(reply => {\n\t\t\t\treturn requestingUser ? \n\t\t\t\t\tForumTransformer.toAuthenticatedPost(reply, requestingUser) :\n\t\t\t\t\tForumTransformer.toPublicPost(reply);\n\t\t\t});\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: transformedReplies\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('PostRoutes', 'Error in GET /posts/:postId/replies', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch post replies'\n\t\t\t});\n\t\t}\n\t})\n);\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/routes/thread.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdminOrModerator' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":257,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":257,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'threadId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":301,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":301,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'validatedData' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":302,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":302,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":303,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":303,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'threadId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":338,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":338,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tagId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":339,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":339,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'threadId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":422,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":422,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Thread Routes\n *\n * QUALITY IMPROVEMENT: Extracted from forum.routes.ts god object\n * Handles thread-specific API endpoints with proper separation of concerns\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { z } from 'zod';\nimport {\n\tisAuthenticated as requireAuth,\n\tisAdminOrModerator\n} from '../../auth/middleware/auth.middleware';\nimport {\n\trequireThreadSolvePermission,\n\trequireThreadTagPermission\n} from '../services/permissions.service';\nimport { forumController } from '../forum.controller';\nimport { threadService } from '../services/thread.service';\nimport { postService } from '../services/post.service';\nimport { logger } from '@server/src/core/logger';\nimport { asyncHandler } from '@server/src/core/errors';\nimport type { ThreadId, PostId, StructureId } from '@shared/types/ids';\nimport { ForumTransformer } from '../transformers/forum.transformer';\n\nconst router = Router();\n\n// Validation schemas\nconst createThreadSchema = z.object({\n\ttitle: z.string().min(1).max(200),\n\tcontent: z.string().min(1),\n\tstructureId: z.string().uuid('Invalid structureId format'),\n\ttags: z.array(z.string()).optional(),\n\tisLocked: z.boolean().optional(),\n\tisPinned: z.boolean().optional(),\n\tprefix: z.string().optional()\n});\n\nconst updateThreadSolvedSchema = z.object({\n\tsolvingPostId: z.string().uuid('Invalid postId format').optional().nullable()\n});\n\nconst addTagsSchema = z.object({\n\ttags: z.array(z.string().min(1)).min(1).max(10)\n});\n\n// Thread search and listing\nrouter.get('/search', forumController.searchThreads);\n\nrouter.get(\n\t'/',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst page = parseInt(req.query.page as string) || 1;\n\t\t\tconst limit = Math.min(parseInt(req.query.limit as string) || 20, 100);\n\t\t\tconst structureId = req.query.structureId\n\t\t\t\t? (req.query.structureId as StructureId)\n\t\t\t\t: undefined;\n\t\t\tconst sortBy = (req.query.sortBy as string) || 'newest';\n\t\t\tconst search = req.query.search as string;\n\n\t\t\t// Log search parameters for debugging\n\t\t\tlogger.debug('ThreadRoutes', 'Searching threads with parameters', {\n\t\t\t\tstructureId,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\tsortBy,\n\t\t\t\tsearch\n\t\t\t});\n\n\t\t\tconst result = await threadService.searchThreads({\n\t\t\t\tstructureId,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\tsortBy: sortBy as any,\n\t\t\t\tsearch\n\t\t\t});\n\n\t\t\t// Get user context for permissions and personalization\n\t\t\tconst requestingUser = userService.getUserFromRequest(req);\n\t\t\t\n\t\t\t// Transform threads using ForumTransformer based on user context\n\t\t\tconst transformedThreads = result.threads.map(thread => {\n\t\t\t\tif (requestingUser) {\n\t\t\t\t\treturn ForumTransformer.toSlimThread(thread);\n\t\t\t\t} else {\n\t\t\t\t\treturn ForumTransformer.toPublicThread(thread);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlogger.debug('ThreadRoutes', 'Thread search results', {\n\t\t\t\tthreadCount: transformedThreads.length,\n\t\t\t\ttotal: result.total,\n\t\t\t\tpage: result.page,\n\t\t\t\ttotalPages: result.totalPages\n\t\t\t});\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tthreads: transformedThreads,\n\t\t\t\t\tpagination: {\n\t\t\t\t\t\tpage,\n\t\t\t\t\t\tlimit: limit,\n\t\t\t\t\t\ttotalThreads: result.total,\n\t\t\t\t\t\ttotalPages: result.totalPages\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadRoutes', 'Error in GET /threads', {\n\t\t\t\terror: error.message,\n\t\t\t\tstack: error.stack,\n\t\t\t\tquery: req.query\n\t\t\t});\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch threads',\n\t\t\t\tdetails: error.message\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get thread by ID\nrouter.get(\n\t'/:id',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst threadId = req.params.id as ThreadId;\n\t\t\tconst thread = await threadService.getThreadById(threadId);\n\n\t\t\tif (!thread) {\n\t\t\t\treturn res.status(404).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Thread not found'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Get user context for permissions and personalization\n\t\t\tconst requestingUser = userService.getUserFromRequest(req);\n\t\t\t\n\t\t\t// Transform thread using ForumTransformer based on user context\n\t\t\tconst transformedThread = requestingUser ? \n\t\t\t\tForumTransformer.toAuthenticatedThread(thread, requestingUser) :\n\t\t\t\tForumTransformer.toPublicThread(thread);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: transformedThread\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadRoutes', 'Error in GET /threads/:id', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch thread'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get thread by slug\nrouter.get(\n\t'/slug/:slug',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst slug = req.params.slug;\n\t\t\tconst thread = await threadService.getThreadBySlug(slug);\n\n\t\t\tif (!thread) {\n\t\t\t\treturn res.status(404).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Thread not found'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Increment view count\n\t\t\tawait threadService.incrementViewCount(thread.id);\n\n\t\t\t// Get user context for permissions and personalization\n\t\t\tconst requestingUser = userService.getUserFromRequest(req);\n\t\t\t\n\t\t\t// Transform thread using ForumTransformer based on user context\n\t\t\tconst transformedThread = requestingUser ? \n\t\t\t\tForumTransformer.toAuthenticatedThread(thread, requestingUser) :\n\t\t\t\tForumTransformer.toPublicThread(thread);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: transformedThread\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadRoutes', 'Error in GET /threads/slug/:slug', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch thread'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Create new thread\nrouter.post(\n\t'/',\n\trequireAuth,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst validatedData = createThreadSchema.parse(req.body);\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\n\t\t\tif (!userId) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'User not authenticated'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst newThread = await threadService.createThread({\n\t\t\t\t...validatedData,\n\t\t\t\tuserId: userId\n\t\t\t});\n\n\t\t\tres.status(201).json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: newThread\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadRoutes', 'Error in POST /threads', { error });\n\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid input data',\n\t\t\t\t\tdetails: error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to create thread'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Update thread solved status\nrouter.put(\n\t'/:threadId/solve',\n\trequireAuth,\n\trequireThreadSolvePermission,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst threadId = req.params.threadId as ThreadId;\n\t\t\tconst validatedData = updateThreadSolvedSchema.parse(req.body);\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\n\t\t\tconst updatedThread = await threadService.updateThreadSolvedStatus({\n\t\t\t\tthreadId,\n\t\t\t\tsolvingPostId: validatedData.solvingPostId\n\t\t\t});\n\n\t\t\tif (!updatedThread) {\n\t\t\t\treturn res.status(404).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Thread not found'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: updatedThread\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadRoutes', 'Error in PUT /threads/:threadId/solve', { error });\n\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid input data',\n\t\t\t\t\tdetails: error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to update thread'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Add tags to thread\nrouter.post(\n\t'/:threadId/tags',\n\trequireAuth,\n\trequireThreadTagPermission,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst threadId = req.params.threadId as ThreadId;\n\t\t\tconst validatedData = addTagsSchema.parse(req.body);\n\t\t\tconst userId = (userService.getUserFromRequest(req) as any)?.id;\n\n\t\t\t// Permission check is handled by middleware\n\t\t\t// TODO: Implement tag addition logic\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Tags added successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadRoutes', 'Error in POST /threads/:threadId/tags', { error });\n\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid input data',\n\t\t\t\t\tdetails: error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to add tags'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Remove tag from thread\nrouter.delete(\n\t'/:threadId/tags/:tagId',\n\trequireAuth,\n\trequireThreadTagPermission,\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst threadId = req.params.threadId as ThreadId;\n\t\t\tconst tagId = req.params.tagId; // TagId conversion TODO if needed\n\n\t\t\t// TODO: Implement tag removal logic\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Tag removed successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadRoutes', 'Error in DELETE /threads/:threadId/tags/:tagId', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to remove tag'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get posts for a thread\nrouter.get(\n\t'/:threadId/posts',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst threadId = req.params.threadId as ThreadId;\n\t\t\tconst page = parseInt(req.query.page as string) || 1;\n\t\t\tconst limit = Math.min(parseInt(req.query.limit as string) || 20, 100);\n\t\t\tconst sortBy = (req.query.sortBy as string) || 'oldest';\n\n\t\t\tif (!threadId) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid thread ID'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst result = await postService.getPostsByThread({\n\t\t\t\tthreadId,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\tsortBy: sortBy as any\n\t\t\t});\n\n\t\t\t// Get user context for permissions and personalization\n\t\t\tconst requestingUser = userService.getUserFromRequest(req);\n\t\t\t\n\t\t\t// Transform posts using ForumTransformer based on user context\n\t\t\tconst transformedPosts = result.posts.map(post => {\n\t\t\t\treturn requestingUser ? \n\t\t\t\t\tForumTransformer.toAuthenticatedPost(post, requestingUser) :\n\t\t\t\t\tForumTransformer.toPublicPost(post);\n\t\t\t});\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tposts: transformedPosts,\n\t\t\t\t\tpagination: {\n\t\t\t\t\t\tpage: result.page,\n\t\t\t\t\t\tlimit,\n\t\t\t\t\t\ttotalPosts: result.total,\n\t\t\t\t\t\ttotalPages: result.totalPages\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadRoutes', 'Error in GET /threads/:threadId/posts', {\n\t\t\t\terror: error.message,\n\t\t\t\tstack: error.stack,\n\t\t\t\tthreadId: req.params.threadId\n\t\t\t});\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch thread posts'\n\t\t\t});\n\t\t}\n\t})\n);\n\n// Get thread tags\nrouter.get(\n\t'/:threadId/tags',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst threadId = req.params.threadId as ThreadId;\n\n\t\t\t// TODO: Implement get thread tags logic\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: []\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadRoutes', 'Error in GET /threads/:threadId/tags', { error });\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to fetch thread tags'\n\t\t\t});\n\t\t}\n\t})\n);\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/rules/rules.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'like' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'crypto' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":20,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAuthenticated' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":22,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Forum Rules Routes\n *\n * Defines API routes for forum rules and user agreements to those rules.\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { db } from '@db';\nimport { count, desc, eq, and, like, sql, inArray } from 'drizzle-orm';\nimport {\n\tforumRules,\n\tuserRulesAgreements,\n\tcontentEditStatusEnum,\n\ttype ForumRule,\n\ttype UserRulesAgreement,\n\ttype User\n} from '@schema';\nimport crypto from 'crypto';\nimport { z } from 'zod';\nimport { isAuthenticated } from '../../auth/middleware/auth.middleware';\nimport { storage } from '../../../../storage';\nimport { asyncHandler } from '@server/src/core/errors'; // Assuming asyncHandler is in core errors\nimport { getUserIdFromRequest } from '@server/src/utils/auth';\nimport { logger } from \"../../../core/logger\";\n\nconst router = Router();\n\n// Get all published forum rules\nrouter.get(\n\t'/',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst { section, status } = req.query;\n\n\t\t\t// Build query conditionally based on request\n\t\t\tlet query = db.select().from(forumRules);\n\n\t\t\t// Filter by status (default to 'published' if not specified)\n\t\t\tconst ruleStatus = (status as string) || 'published';\n\t\t\tif (ruleStatus && ruleStatus in contentEditStatusEnum.enumValues) {\n\t\t\t\tquery = query.where(eq(forumRules.status, ruleStatus as any));\n\t\t\t}\n\n\t\t\t// Filter by section if provided\n\t\t\tif (section) {\n\t\t\t\tquery = query.where(eq(forumRules.section, section as string));\n\t\t\t}\n\n\t\t\t// Execute query and sort by position\n\t\t\tconst rules = await query.orderBy(forumRules.position);\n\n\t\t\treturn res.status(200).json({\n\t\t\t\tdata: rules,\n\t\t\t\tcount: rules.length\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching forum rules:', error);\n\t\t\treturn res.status(500).json({ error: 'Failed to fetch forum rules' });\n\t\t}\n\t})\n);\n\n// Get a specific rule\nrouter.get(\n\t'/:id',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst ruleId = req.params.id;\n\t\t\tif (!ruleId || typeof ruleId !== 'string') {\n\t\t\t\treturn res.status(400).json({ error: 'Invalid rule ID' });\n\t\t\t}\n\n\t\t\tconst rule = await storage.getForumRule(ruleId);\n\n\t\t\tif (!rule) {\n\t\t\t\treturn res.status(404).json({ error: 'Rule not found' });\n\t\t\t}\n\n\t\t\t// Only allow published rules to be viewed, unless the user is an admin\n\t\t\tif (\n\t\t\t\trule.status !== 'published' &&\n\t\t\t\t(!userService.getUserFromRequest(req) ||\n\t\t\t\t\t(userService.getUserFromRequest(req) as any).role !== 'admin')\n\t\t\t) {\n\t\t\t\t// Fixed isAdmin check\n\t\t\t\treturn res.status(403).json({ error: 'This rule is not published' });\n\t\t\t}\n\n\t\t\treturn res.status(200).json({ rule });\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching forum rule:', error);\n\t\t\treturn res.status(500).json({ error: 'Failed to fetch forum rule' });\n\t\t}\n\t})\n);\n\n// Get user agreements (requires authentication)\nrouter.get(\n\t'/user-agreements',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\tif (!req.isAuthenticated() || !userService.getUserFromRequest(req)) {\n\t\t\treturn res.status(401).json({ error: 'Authentication required' });\n\t\t}\n\n\t\ttry {\n\t\t\tconst userId = getUserIdFromRequest(req);\n\t\t\tif (userId === undefined) {\n\t\t\t\t// This case should ideally be caught by !req.isAuthenticated() already,\n\t\t\t\t// but as a safeguard if req.user exists but ID doesn't.\n\t\t\t\treturn res.status(401).json({ error: 'User ID not found after authentication' });\n\t\t\t}\n\n\t\t\t// Get all user rule agreements\n\t\t\tconst agreements = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userRulesAgreements)\n\t\t\t\t.where(eq(userRulesAgreements.userId, userId))\n\t\t\t\t.orderBy(desc(userRulesAgreements.agreedAt));\n\n\t\t\t// Get all published rules\n\t\t\tconst rules = await db.select().from(forumRules).where(eq(forumRules.status, 'published'));\n\n\t\t\t// Find which rules require agreement\n\t\t\tconst requiredRules = rules.filter((rule: ForumRule) => rule.isRequired);\n\n\t\t\t// Check which required rules have been agreed to\n\t\t\tconst agreedRequiredRuleIds = agreements\n\t\t\t\t.filter((agreement: UserRulesAgreement) => {\n\t\t\t\t\tconst rule = rules.find((r: ForumRule) => r.id === agreement.ruleId);\n\t\t\t\t\treturn rule && rule.isRequired;\n\t\t\t\t})\n\t\t\t\t.map((agreement: UserRulesAgreement) => agreement.ruleId);\n\n\t\t\tconst allRequiredRulesAgreed = requiredRules.every((rule: ForumRule) =>\n\t\t\t\tagreedRequiredRuleIds.includes(rule.id)\n\t\t\t);\n\n\t\t\treturn res.status(200).json({\n\t\t\t\tagreements,\n\t\t\t\trequiredRules,\n\t\t\t\tallRequiredRulesAgreed,\n\t\t\t\trequiresAction: !allRequiredRulesAgreed\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching user rule agreements:', error);\n\t\t\treturn res.status(500).json({ error: 'Failed to fetch user rule agreements' });\n\t\t}\n\t})\n);\n\n// Agree to rules (requires authentication)\nrouter.post(\n\t'/agree',\n\tasyncHandler(async (req: Request, res: Response) => {\n\t\tif (!req.isAuthenticated() || !userService.getUserFromRequest(req)) {\n\t\t\treturn res.status(401).json({ error: 'Authentication required' });\n\t\t}\n\n\t\t// Validate request body using Zod\n\t\tconst agreeSchema = z.object({\n\t\t\truleIds: z.array(z.string().uuid('Invalid ruleId format'))\n\t\t});\n\n\t\tconst parsed = agreeSchema.safeParse(req.body);\n\t\tif (!parsed.success) {\n\t\t\treturn res.status(400).json({\n\t\t\t\terror: 'Invalid request body',\n\t\t\t\tdetails: parsed.error.issues\n\t\t\t});\n\t\t}\n\n\t\tconst { ruleIds } = parsed.data;\n\n\t\ttry {\n\t\t\tconst userId = getUserIdFromRequest(req);\n\t\t\tif (userId === undefined) {\n\t\t\t\t// This case should ideally be caught by !req.isAuthenticated() already.\n\t\t\t\treturn res.status(401).json({ error: 'User ID not found after authentication' });\n\t\t\t}\n\n\t\t\t// Get rules\n\t\t\tconst rules = await db\n\t\t\t\t.select()\n\t\t\t\t.from(forumRules)\n\t\t\t\t.where(and(inArray(forumRules.id, ruleIds), eq(forumRules.status, 'published')));\n\n\t\t\tif (rules.length !== ruleIds.length) {\n\t\t\t\treturn res.status(404).json({\n\t\t\t\t\terror: 'One or more rules not found or not published'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Get existing agreements\n\t\t\tconst existingAgreements = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userRulesAgreements)\n\t\t\t\t.where(\n\t\t\t\t\tand(eq(userRulesAgreements.userId, userId), inArray(userRulesAgreements.ruleId, ruleIds))\n\t\t\t\t);\n\n\t\t\t// Create map of existing agreements for faster lookup\n\t\t\tconst existingAgreementMap = new Map<number, UserRulesAgreement>();\n\t\t\texistingAgreements.forEach((agreement: UserRulesAgreement) => {\n\t\t\t\texistingAgreementMap.set(agreement.ruleId, agreement);\n\t\t\t});\n\n\t\t\t// Process each rule agreement\n\t\t\tfor (const rule of rules) {\n\t\t\t\tconst existingAgreement = existingAgreementMap.get(rule.id);\n\n\t\t\t\t// If agreement already exists and hash is the same, skip\n\t\t\t\tif (existingAgreement && existingAgreement.versionHash === rule.versionHash) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If agreement exists but hash is different (rule was updated), update the agreement\n\t\t\t\tif (existingAgreement) {\n\t\t\t\t\tawait db\n\t\t\t\t\t\t.update(userRulesAgreements)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tversionHash: rule.versionHash,\n\t\t\t\t\t\t\tagreedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(\n\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\teq(userRulesAgreements.userId, existingAgreement.userId),\n\t\t\t\t\t\t\t\teq(userRulesAgreements.ruleId, existingAgreement.ruleId)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t// Also update the rule's lastAgreedVersionHash if not already set\n\t\t\t\t\tif (!rule.lastAgreedVersionHash) {\n\t\t\t\t\t\tawait db\n\t\t\t\t\t\t\t.update(forumRules)\n\t\t\t\t\t\t\t.set({ lastAgreedVersionHash: rule.versionHash })\n\t\t\t\t\t\t\t.where(eq(forumRules.id, rule.id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If no agreement exists, create a new one\n\t\t\t\telse {\n\t\t\t\t\tawait db.insert(userRulesAgreements).values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\truleId: rule.id,\n\t\t\t\t\t\tversionHash: rule.versionHash,\n\t\t\t\t\t\tagreedAt: new Date()\n\t\t\t\t\t});\n\n\t\t\t\t\t// Also update the rule's lastAgreedVersionHash if not already set\n\t\t\t\t\tif (!rule.lastAgreedVersionHash) {\n\t\t\t\t\t\tawait db\n\t\t\t\t\t\t\t.update(forumRules)\n\t\t\t\t\t\t\t.set({ lastAgreedVersionHash: rule.versionHash })\n\t\t\t\t\t\t\t.where(eq(forumRules.id, rule.id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res.status(200).json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Successfully agreed to rules',\n\t\t\t\truleIds\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('Error agreeing to rules:', error);\n\t\t\treturn res.status(500).json({ error: 'Failed to process rule agreements' });\n\t\t}\n\t})\n);\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/services/cache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/services/category.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'usersTable' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Forum Category Service\n *\n * QUALITY IMPROVEMENT: Extracted from forum.service.ts god object\n * Handles category-specific operations with proper separation of concerns\n */\n\nimport { db } from '@db';\nimport { logger } from '@server/src/core/logger';\nimport { forumStructure, threads, posts, users as usersTable } from '@schema';\nimport { sql, desc, eq, count, isNull } from 'drizzle-orm';\nimport type { ForumCategoryWithStats } from '../../../../db/types/forum.types';\nimport type { CategoryId } from '@shared/types/ids';\n\n// Simple in-memory cache for categories\nconst CACHE_DURATION_MS = 30 * 1000; // 30 seconds\nlet categoriesCache: {\n\ttimestamp: number;\n\tdata: ForumCategoryWithStats[];\n} | null = null;\n\nexport class CategoryService {\n\t/**\n\t * Get all categories with forum statistics\n\t */\n\tasync getCategoriesWithStats(): Promise<ForumCategoryWithStats[]> {\n\t\ttry {\n\t\t\t// Check cache first\n\t\t\tif (categoriesCache && Date.now() - categoriesCache.timestamp < CACHE_DURATION_MS) {\n\t\t\t\tlogger.info('CategoryService', 'Returning cached categories');\n\t\t\t\treturn categoriesCache.data;\n\t\t\t}\n\n\t\t\tlogger.info('CategoryService', 'Fetching categories with stats from database');\n\n\t\t\t// Simplified query without complex joins that might be causing issues\n\t\t\tconst categoriesWithStats = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: forumStructure.id,\n\t\t\t\t\tname: forumStructure.name,\n\t\t\t\t\tslug: forumStructure.slug,\n\t\t\t\t\tdescription: forumStructure.description,\n\t\t\t\t\ttype: forumStructure.type,\n\t\t\t\t\tposition: forumStructure.position,\n\t\t\t\t\tisVisible: sql<boolean>`NOT ${forumStructure.isHidden}`,\n\t\t\t\t\tparentId: forumStructure.parentId,\n\t\t\t\t\tthreadCount: sql<number>`0`, // Simplified for now\n\t\t\t\t\tpostCount: sql<number>`0`, // Simplified for now\n\t\t\t\t\tlastPostAt: sql<Date | null>`NULL`,\n\t\t\t\t\tcreatedAt: forumStructure.createdAt,\n\t\t\t\t\tupdatedAt: forumStructure.updatedAt,\n\t\t\t\t\tpluginData: forumStructure.pluginData\n\t\t\t\t})\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.orderBy(forumStructure.position, forumStructure.name);\n\n\t\t\t// Update cache\n\t\t\tcategoriesCache = {\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tdata: categoriesWithStats\n\t\t\t};\n\n\t\t\tlogger.info(\n\t\t\t\t'CategoryService',\n\t\t\t\t`Successfully fetched ${categoriesWithStats.length} categories`\n\t\t\t);\n\t\t\treturn categoriesWithStats;\n\t\t} catch (error) {\n\t\t\tlogger.error('CategoryService', 'Error fetching categories with stats', { error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get hierarchical category tree\n\t */\n\tasync getCategoriesTree(\n\t\toptions: {\n\t\t\tincludeHidden?: boolean;\n\t\t\tincludeEmptyStats?: boolean;\n\t\t} = {}\n\t): Promise<ForumCategoryWithStats[]> {\n\t\ttry {\n\t\t\tconst { includeHidden = false } = options;\n\n\t\t\tconst baseQuery = db\n\t\t\t\t.select({\n\t\t\t\t\tid: forumStructure.id,\n\t\t\t\t\tname: forumStructure.name,\n\t\t\t\t\tslug: forumStructure.slug,\n\t\t\t\t\tdescription: forumStructure.description,\n\t\t\t\t\ttype: forumStructure.type,\n\t\t\t\t\tposition: forumStructure.position,\n\t\t\t\t\tisHidden: forumStructure.isHidden,\n\t\t\t\t\tparentId: forumStructure.parentId,\n\t\t\t\t\tthreadCount: sql<number>`COALESCE(${count(threads.id)}, 0)`,\n\t\t\t\t\tpostCount: sql<number>`COALESCE(SUM(${threads.postCount}), 0)`,\n\t\t\t\t\tlastPostAt: sql<Date | null>`MAX(${posts.createdAt})`,\n\t\t\t\t\tcreatedAt: forumStructure.createdAt,\n\t\t\t\t\tupdatedAt: forumStructure.updatedAt,\n\t\t\t\t\tpluginData: forumStructure.pluginData\n\t\t\t\t})\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.leftJoin(threads, eq(forumStructure.id, threads.structureId))\n\t\t\t\t.leftJoin(posts, eq(threads.id, posts.threadId))\n\t\t\t\t.groupBy(forumStructure.id);\n\n\t\t\tif (!includeHidden) {\n\t\t\t\tbaseQuery.where(eq(forumStructure.isVisible, true));\n\t\t\t}\n\n\t\t\tconst categories = await baseQuery.orderBy(forumStructure.position, forumStructure.name);\n\n\t\t\t// Build tree structure\n\t\t\tconst rootCategories = categories.filter((cat) => cat.parentId === null);\n\t\t\tconst childCategories = categories.filter((cat) => cat.parentId !== null);\n\n\t\t\t// Attach children to parents\n\t\t\tconst buildTree = (parentCategories: ForumCategoryWithStats[]): ForumCategoryWithStats[] => {\n\t\t\t\treturn parentCategories.map((parent) => ({\n\t\t\t\t\t...parent,\n\t\t\t\t\tchildren: childCategories.filter((child) => child.parentId === parent.id)\n\t\t\t\t}));\n\t\t\t};\n\n\t\t\treturn buildTree(rootCategories);\n\t\t} catch (error) {\n\t\t\tlogger.error('CategoryService', 'Error fetching category tree', { error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get category by slug\n\t */\n\tasync getCategoryBySlug(slug: string): Promise<ForumCategoryWithStats | null> {\n\t\ttry {\n\t\t\tconst [category] = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: forumStructure.id,\n\t\t\t\t\tname: forumStructure.name,\n\t\t\t\t\tslug: forumStructure.slug,\n\t\t\t\t\tdescription: forumStructure.description,\n\t\t\t\t\ttype: forumStructure.type,\n\t\t\t\t\tposition: forumStructure.position,\n\t\t\t\t\tisHidden: forumStructure.isHidden,\n\t\t\t\t\tparentId: forumStructure.parentId,\n\t\t\t\t\tthreadCount: sql<number>`COALESCE(${count(threads.id)}, 0)`,\n\t\t\t\t\tpostCount: sql<number>`COALESCE(SUM(${threads.postCount}), 0)`,\n\t\t\t\t\tlastPostAt: sql<Date | null>`MAX(${posts.createdAt})`,\n\t\t\t\t\tcreatedAt: forumStructure.createdAt,\n\t\t\t\t\tupdatedAt: forumStructure.updatedAt,\n\t\t\t\t\tpluginData: forumStructure.pluginData\n\t\t\t\t})\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.leftJoin(threads, eq(forumStructure.id, threads.structureId))\n\t\t\t\t.leftJoin(posts, eq(threads.id, posts.threadId))\n\t\t\t\t.where(eq(forumStructure.slug, slug))\n\t\t\t\t.groupBy(forumStructure.id);\n\n\t\t\treturn category || null;\n\t\t} catch (error) {\n\t\t\tlogger.error('CategoryService', 'Error fetching category by slug', { slug, error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Clear categories cache\n\t */\n\tclearCache(): void {\n\t\tcategoriesCache = null;\n\t\tlogger.info('CategoryService', 'Categories cache cleared');\n\t}\n\n\t/**\n\t * Get category statistics\n\t */\n\tasync getCategoryStats(categoryId: CategoryId): Promise<{\n\t\tthreadCount: number;\n\t\tpostCount: number;\n\t\tlastPostAt: Date | null;\n\t}> {\n\t\ttry {\n\t\t\tconst [stats] = await db\n\t\t\t\t.select({\n\t\t\t\t\tthreadCount: sql<number>`COALESCE(${count(threads.id)}, 0)`,\n\t\t\t\t\tpostCount: sql<number>`COALESCE(SUM(${threads.postCount}), 0)`,\n\t\t\t\t\tlastPostAt: sql<Date | null>`MAX(${posts.createdAt})`\n\t\t\t\t})\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.leftJoin(threads, eq(forumStructure.id, threads.structureId))\n\t\t\t\t.leftJoin(posts, eq(threads.id, posts.threadId))\n\t\t\t\t.where(eq(forumStructure.id, categoryId))\n\t\t\t\t.groupBy(forumStructure.id);\n\n\t\t\treturn stats || { threadCount: 0, postCount: 0, lastPostAt: null };\n\t\t} catch (error) {\n\t\t\tlogger.error('CategoryService', 'Error fetching category stats', { categoryId, error });\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const categoryService = new CategoryService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/services/config.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/services/permissions.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/services/post.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/services/structure.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'usersTable' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Forum Structure Service\n *\n * Modern service handling forum structure operations with clear terminology.\n * Replaces the confusing CategoryService with better domain modeling.\n */\n\nimport { db } from '@db';\nimport { logger } from '@server/src/core/logger';\nimport { forumStructure, threads, posts, users as usersTable } from '@schema';\nimport { sql, desc, eq, count, isNull } from 'drizzle-orm';\nimport type { ForumStructureWithStats } from '../../../../db/types/forum.types';\nimport type { StructureId } from '@shared/types/ids';\n\n// Simple in-memory cache for forum structure\nconst CACHE_DURATION_MS = 30 * 1000; // 30 seconds\nlet structureCache: {\n\ttimestamp: number;\n\tdata: ForumStructureWithStats[];\n} | null = null;\n\nexport class ForumStructureService {\n\t/**\n\t * Get all forum structures with statistics\n\t */\n\tasync getStructuresWithStats(): Promise<ForumStructureWithStats[]> {\n\t\ttry {\n\t\t\t// Check cache first\n\t\t\tif (structureCache && Date.now() - structureCache.timestamp < CACHE_DURATION_MS) {\n\t\t\t\tlogger.info('ForumStructureService', 'Returning cached structures');\n\t\t\t\treturn structureCache.data;\n\t\t\t}\n\n\t\t\tlogger.info('ForumStructureService', 'Fetching forum structures with stats from database');\n\n\t\t\t// Query with stats calculation - FILTER OUT HIDDEN FORUMS BY DEFAULT\n\t\t\tconst structuresWithStats = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: forumStructure.id,\n\t\t\t\t\tname: forumStructure.name,\n\t\t\t\t\tslug: forumStructure.slug,\n\t\t\t\t\tdescription: forumStructure.description,\n\t\t\t\t\ttype: forumStructure.type,\n\t\t\t\t\tposition: forumStructure.position,\n\t\t\t\t\tparentId: forumStructure.parentId,\n\t\t\t\t\tparentForumSlug: forumStructure.parentForumSlug,\n\t\t\t\t\tisVip: forumStructure.isVip,\n\t\t\t\t\tisLocked: forumStructure.isLocked,\n\t\t\t\t\tisHidden: forumStructure.isHidden,\n\t\t\t\t\tminXp: forumStructure.minXp,\n\t\t\t\t\tminGroupIdRequired: forumStructure.minGroupIdRequired,\n\t\t\t\t\tcolor: forumStructure.color,\n\t\t\t\t\ticon: forumStructure.icon,\n\t\t\t\t\tcolorTheme: forumStructure.colorTheme,\n\t\t\t\t\ttippingEnabled: forumStructure.tippingEnabled,\n\t\t\t\t\txpMultiplier: forumStructure.xpMultiplier,\n\t\t\t\t\tpluginData: forumStructure.pluginData,\n\t\t\t\t\tcreatedAt: forumStructure.createdAt,\n\t\t\t\t\tupdatedAt: forumStructure.updatedAt,\n\t\t\t\t\tthreadCount: sql<number>`COALESCE(${count(threads.id)}, 0)`,\n\t\t\t\t\tpostCount: sql<number>`COALESCE(SUM(${threads.postCount}), 0)`,\n\t\t\t\t\tlastPostAt: sql<Date | null>`MAX(${posts.createdAt})`\n\t\t\t\t})\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.leftJoin(threads, eq(forumStructure.id, threads.structureId))\n\t\t\t\t.leftJoin(posts, eq(threads.id, posts.threadId))\n\t\t\t\t.where(eq(forumStructure.isHidden, false))\n\t\t\t\t.groupBy(forumStructure.id)\n\t\t\t\t.orderBy(forumStructure.position, forumStructure.name);\n\n\t\t\t// Transform to domain model\n\t\t\tconst structures: ForumStructureWithStats[] = structuresWithStats.map((item) => ({\n\t\t\t\t...item,\n\t\t\t\tcanHaveThreads: item.type === 'forum', // Only forums can have threads, not zones\n\t\t\t\tisZone: item.type === 'zone',\n\t\t\t\tcanonical: item.type === 'zone', // Zones are canonical in the hierarchy\n\t\t\t\tchildStructures: [], // Will be populated in tree methods\n\t\t\t\t// Plugin data parsing for additional properties\n\t\t\t\tisPrimary: item.type === 'zone' && (item.pluginData as any)?.configZoneType === 'primary',\n\t\t\t\tfeatures: (item.pluginData as any)?.features || [],\n\t\t\t\tcustomComponents: (item.pluginData as any)?.customComponents || [],\n\t\t\t\tstaffOnly: (item.pluginData as any)?.staffOnly || false\n\t\t\t}));\n\n\t\t\t// Update cache\n\t\t\tstructureCache = {\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tdata: structures\n\t\t\t};\n\n\t\t\tlogger.info(\n\t\t\t\t'ForumStructureService',\n\t\t\t\t`Successfully fetched ${structures.length} forum structures`\n\t\t\t);\n\t\t\treturn structures;\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumStructureService', 'Error fetching structures with stats', { error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get hierarchical forum structure tree\n\t */\n\tasync getStructureTree(\n\t\toptions: {\n\t\t\tincludeHidden?: boolean;\n\t\t\tincludeEmptyStats?: boolean;\n\t\t} = {}\n\t): Promise<ForumStructureWithStats[]> {\n\t\ttry {\n\t\t\tconst { includeHidden = false } = options;\n\n\t\t\t// Get all structures\n\t\t\tconst allStructures = await this.getStructuresWithStats();\n\n\t\t\t// Filter out hidden structures if requested\n\t\t\tconst filteredStructures = includeHidden\n\t\t\t\t? allStructures\n\t\t\t\t: allStructures.filter((structure) => !structure.isHidden);\n\n\t\t\t// Build tree structure\n\t\t\tconst rootStructures = filteredStructures.filter((structure) => structure.parentId === null);\n\t\t\tconst childStructures = filteredStructures.filter((structure) => structure.parentId !== null);\n\n\t\t\t// Recursive tree building\n\t\t\tconst buildTree = (\n\t\t\t\tparentStructures: ForumStructureWithStats[]\n\t\t\t): ForumStructureWithStats[] => {\n\t\t\t\treturn parentStructures.map((parent) => ({\n\t\t\t\t\t...parent,\n\t\t\t\t\tchildStructures: buildTree(\n\t\t\t\t\t\tchildStructures.filter((child) => child.parentId === parent.id)\n\t\t\t\t\t)\n\t\t\t\t}));\n\t\t\t};\n\n\t\t\treturn buildTree(rootStructures);\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumStructureService', 'Error fetching structure tree', { error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get forum structure by slug\n\t */\n\tasync getStructureBySlug(slug: string): Promise<ForumStructureWithStats | null> {\n\t\ttry {\n\t\t\tconst [structure] = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: forumStructure.id,\n\t\t\t\t\tname: forumStructure.name,\n\t\t\t\t\tslug: forumStructure.slug,\n\t\t\t\t\tdescription: forumStructure.description,\n\t\t\t\t\ttype: forumStructure.type,\n\t\t\t\t\tposition: forumStructure.position,\n\t\t\t\t\tparentId: forumStructure.parentId,\n\t\t\t\t\tparentForumSlug: forumStructure.parentForumSlug,\n\t\t\t\t\tisVip: forumStructure.isVip,\n\t\t\t\t\tisLocked: forumStructure.isLocked,\n\t\t\t\t\tisHidden: forumStructure.isHidden,\n\t\t\t\t\tminXp: forumStructure.minXp,\n\t\t\t\t\tminGroupIdRequired: forumStructure.minGroupIdRequired,\n\t\t\t\t\tcolor: forumStructure.color,\n\t\t\t\t\ticon: forumStructure.icon,\n\t\t\t\t\tcolorTheme: forumStructure.colorTheme,\n\t\t\t\t\ttippingEnabled: forumStructure.tippingEnabled,\n\t\t\t\t\txpMultiplier: forumStructure.xpMultiplier,\n\t\t\t\t\tpluginData: forumStructure.pluginData,\n\t\t\t\t\tcreatedAt: forumStructure.createdAt,\n\t\t\t\t\tupdatedAt: forumStructure.updatedAt,\n\t\t\t\t\tthreadCount: sql<number>`COALESCE(${count(threads.id)}, 0)`,\n\t\t\t\t\tpostCount: sql<number>`COALESCE(SUM(${threads.postCount}), 0)`,\n\t\t\t\t\tlastPostAt: sql<Date | null>`MAX(${posts.createdAt})`\n\t\t\t\t})\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.leftJoin(threads, eq(forumStructure.id, threads.structureId))\n\t\t\t\t.leftJoin(posts, eq(threads.id, posts.threadId))\n\t\t\t\t.where(eq(forumStructure.slug, slug))\n\t\t\t\t.groupBy(forumStructure.id);\n\n\t\t\tif (!structure) return null;\n\n\t\t\treturn {\n\t\t\t\t...structure,\n\t\t\t\tcanHaveThreads: structure.type === 'forum',\n\t\t\t\tisZone: structure.type === 'zone',\n\t\t\t\tcanonical: structure.type === 'zone',\n\t\t\t\tchildStructures: [],\n\t\t\t\tisPrimary:\n\t\t\t\t\tstructure.type === 'zone' && (structure.pluginData as any)?.configZoneType === 'primary',\n\t\t\t\tfeatures: (structure.pluginData as any)?.features || [],\n\t\t\t\tcustomComponents: (structure.pluginData as any)?.customComponents || [],\n\t\t\t\tstaffOnly: (structure.pluginData as any)?.staffOnly || false\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumStructureService', 'Error fetching structure by slug', { slug, error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get structure statistics\n\t */\n\tasync getStructureStats(structureId: StructureId): Promise<{\n\t\tthreadCount: number;\n\t\tpostCount: number;\n\t\tlastPostAt: Date | null;\n\t}> {\n\t\ttry {\n\t\t\tconst [stats] = await db\n\t\t\t\t.select({\n\t\t\t\t\tthreadCount: sql<number>`COALESCE(${count(threads.id)}, 0)`,\n\t\t\t\t\tpostCount: sql<number>`COALESCE(SUM(${threads.postCount}), 0)`,\n\t\t\t\t\tlastPostAt: sql<Date | null>`MAX(${posts.createdAt})`\n\t\t\t\t})\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.leftJoin(threads, eq(forumStructure.id, threads.structureId))\n\t\t\t\t.leftJoin(posts, eq(threads.id, posts.threadId))\n\t\t\t\t.where(eq(forumStructure.id, structureId))\n\t\t\t\t.groupBy(forumStructure.id);\n\n\t\t\treturn stats || { threadCount: 0, postCount: 0, lastPostAt: null };\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumStructureService', 'Error fetching structure stats', {\n\t\t\t\tstructureId,\n\t\t\t\terror\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get forum hierarchy for API responses (optimized)\n\t */\n\tasync getForumHierarchy(): Promise<any> {\n\t\ttry {\n\t\t\tconst tree = await this.getStructureTree({ includeHidden: false });\n\n\t\t\t// Transform to the expected API format\n\t\t\treturn tree.map((zone) => ({\n\t\t\t\tid: zone.id,\n\t\t\t\tname: zone.name,\n\t\t\t\tslug: zone.slug,\n\t\t\t\tdescription: zone.description,\n\t\t\t\ttype: zone.type,\n\t\t\t\tposition: zone.position,\n\t\t\t\tcolor: zone.color,\n\t\t\t\ticon: zone.icon,\n\t\t\t\tisZone: zone.isZone,\n\t\t\t\tcanonical: zone.canonical,\n\t\t\t\tisPrimary: zone.isPrimary,\n\t\t\t\tfeatures: zone.features,\n\t\t\t\tcustomComponents: zone.customComponents,\n\t\t\t\tstaffOnly: zone.staffOnly,\n\t\t\t\tforums:\n\t\t\t\t\tzone.childStructures?.map((forum) => ({\n\t\t\t\t\t\tid: forum.id,\n\t\t\t\t\t\tname: forum.name,\n\t\t\t\t\t\tslug: forum.slug,\n\t\t\t\t\t\tdescription: forum.description,\n\t\t\t\t\t\ttype: forum.type,\n\t\t\t\t\t\tposition: forum.position,\n\t\t\t\t\t\tcolor: forum.color,\n\t\t\t\t\t\ticon: forum.icon,\n\t\t\t\t\t\tthreadCount: forum.threadCount,\n\t\t\t\t\t\tpostCount: forum.postCount,\n\t\t\t\t\t\tlastPostAt: forum.lastPostAt,\n\t\t\t\t\t\tcanHaveThreads: forum.canHaveThreads,\n\t\t\t\t\t\ttippingEnabled: forum.tippingEnabled,\n\t\t\t\t\t\txpMultiplier: forum.xpMultiplier,\n\t\t\t\t\t\tisLocked: forum.isLocked,\n\t\t\t\t\t\tisVip: forum.isVip,\n\t\t\t\t\t\tminXp: forum.minXp,\n\t\t\t\t\t\t// Recursive for subforums\n\t\t\t\t\t\tforums:\n\t\t\t\t\t\t\tforum.childStructures?.map((subforum) => ({\n\t\t\t\t\t\t\t\tid: subforum.id,\n\t\t\t\t\t\t\t\tname: subforum.name,\n\t\t\t\t\t\t\t\tslug: subforum.slug,\n\t\t\t\t\t\t\t\tdescription: subforum.description,\n\t\t\t\t\t\t\t\ttype: subforum.type,\n\t\t\t\t\t\t\t\tposition: subforum.position,\n\t\t\t\t\t\t\t\tcolor: subforum.color,\n\t\t\t\t\t\t\t\ticon: subforum.icon,\n\t\t\t\t\t\t\t\tthreadCount: subforum.threadCount,\n\t\t\t\t\t\t\t\tpostCount: subforum.postCount,\n\t\t\t\t\t\t\t\tlastPostAt: subforum.lastPostAt,\n\t\t\t\t\t\t\t\tcanHaveThreads: subforum.canHaveThreads,\n\t\t\t\t\t\t\t\ttippingEnabled: subforum.tippingEnabled,\n\t\t\t\t\t\t\t\txpMultiplier: subforum.xpMultiplier,\n\t\t\t\t\t\t\t\tisLocked: subforum.isLocked,\n\t\t\t\t\t\t\t\tisVip: subforum.isVip,\n\t\t\t\t\t\t\t\tminXp: subforum.minXp\n\t\t\t\t\t\t\t})) || []\n\t\t\t\t\t})) || []\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tlogger.error('ForumStructureService', 'Error getting forum hierarchy', { error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Clear structure cache\n\t */\n\tclearCache(): void {\n\t\tstructureCache = null;\n\t\tlogger.info('ForumStructureService', 'Forum structure cache cleared');\n\t}\n\n\t/**\n\t * Force refresh structures from database (bypass cache)\n\t */\n\tasync forceRefresh(): Promise<ForumStructureWithStats[]> {\n\t\tthis.clearCache();\n\t\treturn await this.getStructuresWithStats();\n\t}\n\n\t/**\n\t * Sync forum configuration to database (from forumMap.config.ts)\n\t */\n\tasync syncFromConfig(): Promise<void> {\n\t\t// This method will be implemented to replace the old sync script\n\t\t// For now, we reference the existing sync functionality\n\t\tlogger.info('ForumStructureService', 'Forum config sync not yet implemented in service layer');\n\t\tthrow new Error('Use npm run sync:forums script for now');\n\t}\n}\n\n// Export singleton instance\nexport const forumStructureService = new ForumStructureService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/services/thread.service.batch-optimization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/services/thread.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userFollows' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":21,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'or' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":62,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tagFilters' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":190,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":190,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'status' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":194,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":194,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'followingUserId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":195,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":195,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Forum Thread Service\n *\n * QUALITY IMPROVEMENT: Extracted from forum.service.ts god object\n * Handles thread-specific operations with proper separation of concerns\n */\n\nimport { db } from '@db';\nimport { logger } from '@server/src/core/logger';\nimport { postService } from './post.service';\nimport { cacheService } from '@server/src/core/cache.service';\nimport { AchievementEventEmitter } from '../../../core/events/achievement-events.service';\nimport { getZoneInfoBatch } from './thread.service.batch-optimization';\nimport {\n\tthreads,\n\tposts,\n\tforumStructure,\n\tusers as usersTable,\n\tthreadTags,\n\ttags,\n\tuserFollows\n} from '@schema';\nimport { sql, desc, asc, eq, and, or, ilike, inArray, count, gte } from 'drizzle-orm';\nimport type {\n\tThreadWithUser,\n\tThreadWithPostsAndUser,\n\tThreadWithUserAndCategory\n} from '../../../../db/types/forum.types';\nimport { eventLogger } from '../../activity/services/event-logger.service';\nimport type { ForumId, StructureId, ThreadId, UserId, PostId, TagId } from '@shared/types/ids';\n\n// Using centralized cache service (Redis with in-memory fallback)\n\nexport interface ThreadSearchParams {\n\tstructureId?: StructureId;\n\tuserId?: UserId;\n\tsearch?: string;\n\ttags?: string[];\n\tpage?: number;\n\tlimit?: number;\n\tsortBy?: 'newest' | 'oldest' | 'mostReplies' | 'mostViews' | 'trending';\n\tstatus?: 'active' | 'locked' | 'pinned';\n\tfollowingUserId?: UserId; // For \"following\" tab - get threads by users that this user follows\n}\n\nexport type ContentTab = 'trending' | 'recent' | 'following';\n\nexport interface TabContentParams {\n\ttab: ContentTab;\n\tpage?: number;\n\tlimit?: number;\n\tforumId?: ForumId;\n\tuserId?: UserId; // For following tab\n}\n\nexport interface ThreadCreateInput {\n\ttitle: string;\n\tcontent: string;\n\tstructureId: StructureId;\n\tuserId: UserId;\n\ttags?: string[];\n\tisLocked?: boolean;\n\tisPinned?: boolean;\n\tprefix?: string;\n}\n\nexport class ThreadService {\n\tconstructor() {\n\t\t// Cache is now handled by the centralized cache service\n\t}\n\n\t/**\n\t * Fetch threads by tab with caching\n\t * Main entry point for the new content system\n\t */\n\tasync fetchThreadsByTab(params: TabContentParams): Promise<{\n\t\titems: ThreadWithUserAndCategory[];\n\t\tmeta: {\n\t\t\thasMore: boolean;\n\t\t\ttotal: number;\n\t\t\tpage: number;\n\t\t};\n\t}> {\n\t\tconst { tab, page = 1, limit = 20, forumId, userId } = params;\n\n\t\t// Build cache key\n\t\tconst cacheKey = `${tab}:${forumId ?? 'all'}:${page}:${limit}:${userId ?? 'anon'}`;\n\n\t\t// Try cache first\n\t\tconst cached = await cacheService.get(cacheKey);\n\t\tif (cached) {\n\t\t\tlogger.debug('ThreadService', 'Cache hit for tab content', { tab, cacheKey });\n\t\t\treturn cached;\n\t\t}\n\n\t\t// Build search params based on tab type\n\t\tconst searchParams = this.buildSearchParamsForTab(tab, {\n\t\t\tpage,\n\t\t\tlimit,\n\t\t\tstructureId: forumId,\n\t\t\tfollowingUserId: tab === 'following' ? userId : undefined\n\t\t});\n\n\t\t// Fetch data\n\t\tconst result = await this.searchThreads(searchParams);\n\n\t\t// Transform to expected format\n\t\tconst response = {\n\t\t\titems: result.threads,\n\t\t\tmeta: {\n\t\t\t\thasMore: result.page < result.totalPages,\n\t\t\t\ttotal: result.total,\n\t\t\t\tpage: result.page\n\t\t\t}\n\t\t};\n\n\t\t// Cache the result (different TTL for different tabs)\n\t\tconst cacheTTL = this.getCacheTTLForTab(tab);\n\t\tawait cacheService.set(cacheKey, response, cacheTTL);\n\n\t\tlogger.info('ThreadService', 'Fetched tab content', {\n\t\t\ttab,\n\t\t\tcount: result.threads.length,\n\t\t\tpage,\n\t\t\tcached: false\n\t\t});\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Build search parameters for specific tabs\n\t */\n\tprivate buildSearchParamsForTab(\n\t\ttab: ContentTab,\n\t\tbaseParams: Partial<ThreadSearchParams>\n\t): ThreadSearchParams {\n\t\tconst params: ThreadSearchParams = {\n\t\t\t...baseParams,\n\t\t\tstatus: 'active' // Only show active threads by default\n\t\t};\n\n\t\tswitch (tab) {\n\t\t\tcase 'trending':\n\t\t\t\tparams.sortBy = 'trending';\n\t\t\t\t// Only consider threads from last 7 days for trending\n\t\t\t\tbreak;\n\t\t\tcase 'recent':\n\t\t\t\tparams.sortBy = 'newest';\n\t\t\t\tbreak;\n\t\t\tcase 'following':\n\t\t\t\tparams.sortBy = 'newest';\n\t\t\t\t// followingUserId will be used to filter by followed users\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn params;\n\t}\n\n\t/**\n\t * Get cache TTL based on tab type\n\t */\n\tprivate getCacheTTLForTab(tab: ContentTab): number {\n\t\tswitch (tab) {\n\t\t\tcase 'trending':\n\t\t\t\treturn 60 * 1000; // 1 minute for trending\n\t\t\tcase 'recent':\n\t\t\t\treturn 30 * 1000; // 30 seconds for recent\n\t\t\tcase 'following':\n\t\t\t\treturn 45 * 1000; // 45 seconds for following\n\t\t\tdefault:\n\t\t\t\treturn 60 * 1000;\n\t\t}\n\t}\n\n\t/**\n\t * Search and filter threads with pagination\n\t */\n\tasync searchThreads(params: ThreadSearchParams): Promise<{\n\t\tthreads: ThreadWithUserAndCategory[];\n\t\ttotal: number;\n\t\tpage: number;\n\t\ttotalPages: number;\n\t}> {\n\t\ttry {\n\t\t\tconst {\n\t\t\t\tstructureId,\n\t\t\t\tuserId,\n\t\t\t\tsearch,\n\t\t\t\ttags: tagFilters,\n\t\t\t\tpage = 1,\n\t\t\t\tlimit = 20,\n\t\t\t\tsortBy = 'newest',\n\t\t\t\tstatus,\n\t\t\t\tfollowingUserId\n\t\t\t} = params;\n\n\t\t\tconst offset = (page - 1) * limit;\n\n\t\t\t// Build WHERE conditions\n\t\t\tconst whereConditions = [];\n\n\t\t\t// Filter by structureId if provided\n\t\t\tif (structureId) {\n\t\t\t\twhereConditions.push(eq(threads.structureId, structureId));\n\t\t\t}\n\n\t\t\t// Filter by userId if provided\n\t\t\tif (userId) {\n\t\t\t\twhereConditions.push(eq(threads.userId, userId));\n\t\t\t}\n\n\t\t\t// Filter by search term if provided\n\t\t\tif (search) {\n\t\t\t\twhereConditions.push(ilike(threads.title, `%${search}%`));\n\t\t\t}\n\n\t\t\t// Combine WHERE conditions\n\t\t\tconst whereClause = whereConditions.length > 0 ? and(...whereConditions) : undefined;\n\n\t\t\t// Count query with proper filtering\n\t\t\tconst totalCountResult = await db\n\t\t\t\t.select({ count: count(threads.id) })\n\t\t\t\t.from(threads)\n\t\t\t\t.where(whereClause)\n\t\t\t\t.execute();\n\n\t\t\tconst total = totalCountResult[0]?.count || 0;\n\t\t\tconst totalPages = Math.max(1, Math.ceil(total / limit));\n\n\t\t\t// Main query with proper filtering and sorting - using simple select\n\t\t\tlet query = db.select().from(threads).where(whereClause).limit(limit).offset(offset);\n\n\t\t\t// Apply sorting\n\t\t\tswitch (sortBy) {\n\t\t\t\tcase 'newest':\n\t\t\t\t\tquery = query.orderBy(desc(threads.createdAt));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'oldest':\n\t\t\t\t\tquery = query.orderBy(asc(threads.createdAt));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mostReplies':\n\t\t\t\t\tquery = query.orderBy(desc(threads.postCount));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mostViews':\n\t\t\t\t\tquery = query.orderBy(desc(threads.viewCount));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'trending':\n\t\t\t\t\t// For trending, prioritize recent threads with high engagement\n\t\t\t\t\tquery = query.orderBy(desc(threads.hotScore), desc(threads.createdAt));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tquery = query.orderBy(desc(threads.createdAt));\n\t\t\t}\n\n\t\t\tconst threadsData = await query.execute();\n\n\t\t\t// Format threads with separate queries for relations\n\t\t\t// Batch fetch all users and structures instead of N+1 queries\n\t\t\tconst userIds = [...new Set(threadsData.map((t) => t.userId))];\n\t\t\tconst structureIds = [...new Set(threadsData.map((t) => t.structureId))];\n\t\t\tconst threadIds = threadsData.map((t) => t.id);\n\n\t\t\t// First get the initial structures to find parent IDs\n\t\t\tconst initialStructuresData = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: forumStructure.id,\n\t\t\t\t\tname: forumStructure.name,\n\t\t\t\t\tslug: forumStructure.slug,\n\t\t\t\t\ttype: forumStructure.type,\n\t\t\t\t\tparentId: forumStructure.parentId,\n\t\t\t\t\tpluginData: forumStructure.pluginData,\n\t\t\t\t\tcolorTheme: forumStructure.colorTheme\n\t\t\t\t})\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(inArray(forumStructure.id, structureIds));\n\n\t\t\t// Get unique parent IDs for additional zone lookup\n\t\t\tconst parentIds = [\n\t\t\t\t...new Set(initialStructuresData.map((s) => s.parentId).filter(Boolean))\n\t\t\t] as number[];\n\n\t\t\tconst [usersData, parentStructuresData, excerptData] = await Promise.all([\n\t\t\t\t// Batch fetch users\n\t\t\t\tdb\n\t\t\t\t\t.select({\n\t\t\t\t\t\tid: usersTable.id,\n\t\t\t\t\t\tusername: usersTable.username,\n\t\t\t\t\t\tavatarUrl: usersTable.avatarUrl,\n\t\t\t\t\t\tactiveAvatarUrl: usersTable.activeAvatarUrl,\n\t\t\t\t\t\trole: usersTable.role\n\t\t\t\t\t})\n\t\t\t\t\t.from(usersTable)\n\t\t\t\t\t.where(inArray(usersTable.id, userIds)),\n\n\t\t\t\t// Batch fetch parent structures (potential zones)\n\t\t\t\tparentIds.length > 0\n\t\t\t\t\t? db\n\t\t\t\t\t\t\t.select({\n\t\t\t\t\t\t\t\tid: forumStructure.id,\n\t\t\t\t\t\t\t\tname: forumStructure.name,\n\t\t\t\t\t\t\t\tslug: forumStructure.slug,\n\t\t\t\t\t\t\t\ttype: forumStructure.type,\n\t\t\t\t\t\t\t\tparentId: forumStructure.parentId,\n\t\t\t\t\t\t\t\tpluginData: forumStructure.pluginData,\n\t\t\t\t\t\t\t\tcolorTheme: forumStructure.colorTheme\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.from(forumStructure)\n\t\t\t\t\t\t\t.where(inArray(forumStructure.id, parentIds))\n\t\t\t\t\t: [],\n\n\t\t\t\t// Batch fetch excerpts\n\t\t\t\tthis.getFirstPostExcerptsBatch(threadIds)\n\t\t\t]);\n\n\t\t\t// Combine all structures\n\t\t\tconst structuresData = [...initialStructuresData, ...parentStructuresData];\n\n\t\t\t// Create lookup maps for O(1) access\n\t\t\tconst usersMap = new Map(usersData.map((u) => [u.id, u]));\n\t\t\tconst structuresMap = new Map(structuresData.map((s) => [s.id, s]));\n\t\t\tconst excerptsMap = new Map(excerptData.map((e) => [e.threadId, e.excerpt]));\n\n\t\t\t// Batch fetch zone info for all unique structure IDs to eliminate N+1\n\t\t\tlet zoneInfoMap: Map<number, any>;\n\t\t\ttry {\n\t\t\t\tzoneInfoMap = await getZoneInfoBatch(structureIds);\n\t\t\t} catch (batchError) {\n\t\t\t\tlogger.warn('ThreadService', 'Batch zone fetch failed, using individual lookups', {\n\t\t\t\t\terror: batchError.message,\n\t\t\t\t\tstructureCount: structureIds.length\n\t\t\t\t});\n\t\t\t\t// Fallback to individual lookups\n\t\t\t\tzoneInfoMap = new Map();\n\t\t\t\tfor (const structureId of structureIds) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst zoneInfo = await this.getZoneInfo(structureId);\n\t\t\t\t\t\tzoneInfoMap.set(structureId, zoneInfo);\n\t\t\t\t\t} catch (individualError) {\n\t\t\t\t\t\tlogger.warn('ThreadService', `Individual zone lookup failed for ${structureId}`, {\n\t\t\t\t\t\t\terror: individualError.message\n\t\t\t\t\t\t});\n\t\t\t\t\t\tzoneInfoMap.set(structureId, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Debug: Log what zone info we got\n\t\t\tlogger.info('ThreadService', 'Zone info batch results', {\n\t\t\t\trequestedIds: structureIds,\n\t\t\t\tmapSize: zoneInfoMap.size,\n\t\t\t\tresults: Object.fromEntries(\n\t\t\t\t\tArray.from(zoneInfoMap.entries()).map(([id, info]) => [\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tinfo ? `${info.name} (${info.slug})` : 'null'\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t});\n\n\t\t\tconst formattedThreads = threadsData.map((thread) => {\n\t\t\t\tconst userResult = usersMap.get(thread.userId);\n\t\t\t\tconst structureResult = structuresMap.get(thread.structureId);\n\t\t\t\tconst excerpt = excerptsMap.get(thread.id);\n\t\t\t\tlet zoneInfo = zoneInfoMap.get(thread.structureId);\n\n\t\t\t\t// Fallback: If batch optimization didn't find zone, try direct lookup\n\t\t\t\tif (!zoneInfo && structureResult?.parentId) {\n\t\t\t\t\tconst parentStructure = structuresMap.get(structureResult.parentId);\n\t\t\t\t\tif (parentStructure) {\n\t\t\t\t\t\tconst parentPluginData = (parentStructure.pluginData || {}) as any;\n\t\t\t\t\t\tconst parentConfigZoneType = parentPluginData?.configZoneType;\n\t\t\t\t\t\tif (parentConfigZoneType && parentConfigZoneType !== 'none') {\n\t\t\t\t\t\t\tzoneInfo = {\n\t\t\t\t\t\t\t\tid: parentStructure.id,\n\t\t\t\t\t\t\t\tname: parentStructure.name,\n\t\t\t\t\t\t\t\tslug: parentStructure.slug,\n\t\t\t\t\t\t\t\tcolorTheme: parentStructure.colorTheme || 'default',\n\t\t\t\t\t\t\t\tisPrimary: parentConfigZoneType === 'primary'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tlogger.info('ThreadService', `Fallback zone found for thread ${thread.id}`, {\n\t\t\t\t\t\t\t\tthreadStructureId: thread.structureId,\n\t\t\t\t\t\t\t\tthreadStructureName: structureResult?.name,\n\t\t\t\t\t\t\t\tparentId: structureResult.parentId,\n\t\t\t\t\t\t\t\tparentName: parentStructure.name,\n\t\t\t\t\t\t\t\tparentConfigZoneType\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tid: thread.id,\n\t\t\t\t\ttitle: thread.title,\n\t\t\t\t\tslug: thread.slug ?? this.generateSlug(thread.title),\n\t\t\t\t\tuserId: thread.userId,\n\t\t\t\t\tprefixId: null,\n\t\t\t\t\tisSticky: thread.isSticky || false,\n\t\t\t\t\tisLocked: thread.isLocked || false,\n\t\t\t\t\tisHidden: false,\n\t\t\t\t\tviewCount: thread.viewCount || 0,\n\t\t\t\t\tpostCount: thread.postCount || 0,\n\t\t\t\t\tfirstPostLikeCount: 0,\n\t\t\t\t\tlastPostAt: thread.lastPostAt ? new Date(thread.lastPostAt).toISOString() : null,\n\t\t\t\t\tcreatedAt: thread.createdAt\n\t\t\t\t\t\t? new Date(thread.createdAt).toISOString()\n\t\t\t\t\t\t: new Date().toISOString(),\n\t\t\t\t\tupdatedAt: thread.updatedAt ? new Date(thread.updatedAt).toISOString() : null,\n\t\t\t\t\tisSolved: thread.isSolved || false,\n\t\t\t\t\tsolvingPostId: null,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: thread.userId,\n\t\t\t\t\t\tusername: userResult?.username || 'Unknown',\n\t\t\t\t\t\tavatarUrl: userResult?.avatarUrl || null,\n\t\t\t\t\t\tactiveAvatarUrl: userResult?.activeAvatarUrl || null,\n\t\t\t\t\t\trole: userResult?.role || 'user',\n\t\t\t\t\t\tforumStats: {\n\t\t\t\t\t\t\tlevel: 1, // TODO: Calculate actual level from XP\n\t\t\t\t\t\t\txp: 0, // TODO: Fetch actual XP\n\t\t\t\t\t\t\treputation: 0, // TODO: Fetch actual reputation\n\t\t\t\t\t\t\ttotalPosts: 0, // TODO: Calculate post count\n\t\t\t\t\t\t\ttotalThreads: 0, // TODO: Calculate thread count\n\t\t\t\t\t\t\ttotalLikes: 0, // TODO: Calculate like count\n\t\t\t\t\t\t\ttotalTips: 0 // TODO: Calculate tip count\n\t\t\t\t\t\t},\n\t\t\t\t\t\tisOnline: false, // TODO: Implement online status\n\t\t\t\t\t\tlastSeenAt: null // TODO: Implement last seen tracking\n\t\t\t\t\t},\n\t\t\t\t\tcategory: {\n\t\t\t\t\t\tid: thread.structureId,\n\t\t\t\t\t\tname: structureResult?.name || 'Unknown',\n\t\t\t\t\t\tslug: structureResult?.slug || 'unknown'\n\t\t\t\t\t},\n\t\t\t\t\tzone: zoneInfo\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tid: zoneInfo.id,\n\t\t\t\t\t\t\t\tname: zoneInfo.name,\n\t\t\t\t\t\t\t\tslug: zoneInfo.slug,\n\t\t\t\t\t\t\t\tcolorTheme: zoneInfo.colorTheme || 'default',\n\t\t\t\t\t\t\t\tisPrimary: zoneInfo.isPrimary || false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tid: thread.structureId,\n\t\t\t\t\t\t\t\tname: structureResult?.name || 'Unknown',\n\t\t\t\t\t\t\t\tslug: structureResult?.slug || 'unknown',\n\t\t\t\t\t\t\t\tcolorTheme: 'default',\n\t\t\t\t\t\t\t\tisPrimary: false\n\t\t\t\t\t\t\t},\n\t\t\t\t\ttags: [],\n\t\t\t\t\tpermissions: {\n\t\t\t\t\t\tcanEdit: false, // TODO: Implement proper permission checking\n\t\t\t\t\t\tcanDelete: false, // TODO: Implement proper permission checking\n\t\t\t\t\t\tcanReply: true, // TODO: Check forum rules and user permissions\n\t\t\t\t\t\tcanMarkSolved: false, // TODO: Check if user can mark as solved\n\t\t\t\t\t\tcanModerate: userResult?.role === 'admin' || userResult?.role === 'mod'\n\t\t\t\t\t},\n\t\t\t\t\t// Legacy compatibility fields (deprecated but keeping for now)\n\t\t\t\t\tcanEdit: false,\n\t\t\t\t\tcanDelete: false,\n\t\t\t\t\texcerpt: excerpt || undefined\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tlogger.info(\n\t\t\t\t'ThreadService',\n\t\t\t\t`Found ${threadsData.length} threads (page ${page}/${totalPages})`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tthreads: formattedThreads,\n\t\t\t\ttotal,\n\t\t\t\tpage,\n\t\t\t\ttotalPages\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadService', 'Error searching threads', {\n\t\t\t\tparams,\n\t\t\t\tmessage: (error as any)?.message,\n\t\t\t\tstack: (error as any)?.stack\n\t\t\t});\n\n\t\t\t// EMERGENCY: Throw the error so we can see what's happening\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get thread by ID with author and category details\n\t * Returns ThreadDisplay compatible format with proper zone data\n\t */\n\tasync getThreadById(threadId: ThreadId): Promise<ThreadWithUserAndCategory | null> {\n\t\ttry {\n\t\t\tconst [threadResult] = await db.select().from(threads).where(eq(threads.id, threadId));\n\n\t\t\tif (!threadResult) return null;\n\n\t\t\t// Get user information separately\n\t\t\tconst [userResult] = await db\n\t\t\t\t.select({\n\t\t\t\t\tusername: usersTable.username,\n\t\t\t\t\tavatarUrl: usersTable.avatarUrl,\n\t\t\t\t\tactiveAvatarUrl: usersTable.activeAvatarUrl,\n\t\t\t\t\trole: usersTable.role\n\t\t\t\t})\n\t\t\t\t.from(usersTable)\n\t\t\t\t.where(eq(usersTable.id, threadResult.userId));\n\n\t\t\t// Get structure information separately\n\t\t\tconst [structureResult] = await db\n\t\t\t\t.select({\n\t\t\t\t\tname: forumStructure.name,\n\t\t\t\t\tslug: forumStructure.slug,\n\t\t\t\t\ttype: forumStructure.type\n\t\t\t\t})\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(eq(forumStructure.id, threadResult.structureId));\n\n\t\t\t// Get zone information for theming\n\t\t\tconst zoneInfo = await this.getZoneInfo(threadResult.structureId);\n\n\t\t\t// Get excerpt\n\t\t\tconst excerpt = await this.getFirstPostExcerpt(threadId);\n\n\t\t\t// Format as ThreadDisplay-compatible object\n\t\t\tconst formattedThread = {\n\t\t\t\tid: threadResult.id,\n\t\t\t\ttitle: threadResult.title,\n\t\t\t\tslug: threadResult.slug ?? this.generateSlug(threadResult.title),\n\t\t\t\tuserId: threadResult.userId,\n\t\t\t\tstructureId: threadResult.structureId,\n\t\t\t\tprefixId: null,\n\t\t\t\tisSticky: threadResult.isSticky || false,\n\t\t\t\tisLocked: threadResult.isLocked || false,\n\t\t\t\tisHidden: false,\n\t\t\t\tviewCount: threadResult.viewCount || 0,\n\t\t\t\tpostCount: threadResult.postCount || 0,\n\t\t\t\tfirstPostLikeCount: 0,\n\t\t\t\tlastPostAt: threadResult.lastPostAt\n\t\t\t\t\t? new Date(threadResult.lastPostAt).toISOString()\n\t\t\t\t\t: null,\n\t\t\t\tcreatedAt: threadResult.createdAt\n\t\t\t\t\t? new Date(threadResult.createdAt).toISOString()\n\t\t\t\t\t: new Date().toISOString(),\n\t\t\t\tupdatedAt: threadResult.updatedAt ? new Date(threadResult.updatedAt).toISOString() : null,\n\t\t\t\tisSolved: threadResult.isSolved || false,\n\t\t\t\tsolvingPostId: null,\n\n\t\t\t\t// User relationship\n\t\t\t\tuser: {\n\t\t\t\t\tid: threadResult.userId,\n\t\t\t\t\tusername: userResult?.username || 'Unknown',\n\t\t\t\t\tavatarUrl: userResult?.avatarUrl || null,\n\t\t\t\t\tactiveAvatarUrl: userResult?.activeAvatarUrl || null,\n\t\t\t\t\trole: userResult?.role || 'user'\n\t\t\t\t},\n\n\t\t\t\t// Category relationship (legacy compatibility)\n\t\t\t\tcategory: {\n\t\t\t\t\tid: threadResult.structureId,\n\t\t\t\t\tname: structureResult?.name || 'Unknown',\n\t\t\t\t\tslug: structureResult?.slug || 'unknown'\n\t\t\t\t},\n\n\t\t\t\t// Zone relationship (required for theming)\n\t\t\t\tzone: zoneInfo || {\n\t\t\t\t\tid: threadResult.structureId,\n\t\t\t\t\tname: structureResult?.name || 'Unknown',\n\t\t\t\t\tslug: structureResult?.slug || 'unknown',\n\t\t\t\t\tcolorTheme: 'default'\n\t\t\t\t},\n\n\t\t\t\ttags: [],\n\t\t\t\tcanEdit: false,\n\t\t\t\tcanDelete: false,\n\t\t\t\texcerpt: excerpt || undefined\n\t\t\t};\n\n\t\t\treturn formattedThread;\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadService', 'Error fetching thread by ID', { threadId, error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get thread by slug with author and zone details\n\t * Returns ThreadDisplay compatible format with proper zone data\n\t */\n\tasync getThreadBySlug(slug: string): Promise<ThreadWithUserAndCategory | null> {\n\t\ttry {\n\t\t\t// First, try a simple query to isolate the issue\n\t\t\tconst [threadResult] = await db.select().from(threads).where(eq(threads.slug, slug));\n\n\t\t\tif (!threadResult) return null;\n\n\t\t\t// Get user information separately\n\t\t\tconst [userResult] = await db\n\t\t\t\t.select({\n\t\t\t\t\tusername: usersTable.username,\n\t\t\t\t\tavatarUrl: usersTable.avatarUrl,\n\t\t\t\t\tactiveAvatarUrl: usersTable.activeAvatarUrl,\n\t\t\t\t\trole: usersTable.role\n\t\t\t\t})\n\t\t\t\t.from(usersTable)\n\t\t\t\t.where(eq(usersTable.id, threadResult.userId));\n\n\t\t\t// Get structure information separately\n\t\t\tconst [structureResult] = await db\n\t\t\t\t.select({\n\t\t\t\t\tname: forumStructure.name,\n\t\t\t\t\tslug: forumStructure.slug,\n\t\t\t\t\ttype: forumStructure.type\n\t\t\t\t})\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(eq(forumStructure.id, threadResult.structureId));\n\n\t\t\t// Get zone information for theming\n\t\t\tconst zoneInfo = await this.getZoneInfo(threadResult.structureId);\n\n\t\t\t// Get excerpt\n\t\t\tconst excerpt = await this.getFirstPostExcerpt(threadResult.id);\n\n\t\t\t// Format as ThreadDisplay-compatible object\n\t\t\tconst formattedThread = {\n\t\t\t\tid: threadResult.id,\n\t\t\t\ttitle: threadResult.title,\n\t\t\t\tslug: threadResult.slug ?? this.generateSlug(threadResult.title),\n\t\t\t\tuserId: threadResult.userId,\n\t\t\t\tstructureId: threadResult.structureId,\n\t\t\t\tprefixId: null,\n\t\t\t\tisSticky: threadResult.isSticky || false,\n\t\t\t\tisLocked: threadResult.isLocked || false,\n\t\t\t\tisHidden: false,\n\t\t\t\tviewCount: threadResult.viewCount || 0,\n\t\t\t\tpostCount: threadResult.postCount || 0,\n\t\t\t\tfirstPostLikeCount: 0,\n\t\t\t\tlastPostAt: threadResult.lastPostAt\n\t\t\t\t\t? new Date(threadResult.lastPostAt).toISOString()\n\t\t\t\t\t: null,\n\t\t\t\tcreatedAt: threadResult.createdAt\n\t\t\t\t\t? new Date(threadResult.createdAt).toISOString()\n\t\t\t\t\t: new Date().toISOString(),\n\t\t\t\tupdatedAt: threadResult.updatedAt ? new Date(threadResult.updatedAt).toISOString() : null,\n\t\t\t\tisSolved: threadResult.isSolved || false,\n\t\t\t\tsolvingPostId: null,\n\n\t\t\t\t// User relationship\n\t\t\t\tuser: {\n\t\t\t\t\tid: threadResult.userId,\n\t\t\t\t\tusername: userResult?.username || 'Unknown',\n\t\t\t\t\tavatarUrl: userResult?.avatarUrl || null,\n\t\t\t\t\tactiveAvatarUrl: userResult?.activeAvatarUrl || null,\n\t\t\t\t\trole: userResult?.role || 'user'\n\t\t\t\t},\n\n\t\t\t\t// Category relationship (legacy compatibility)\n\t\t\t\tcategory: {\n\t\t\t\t\tid: threadResult.structureId,\n\t\t\t\t\tname: structureResult?.name || 'Unknown',\n\t\t\t\t\tslug: structureResult?.slug || 'unknown'\n\t\t\t\t},\n\n\t\t\t\t// Zone relationship (required for theming)\n\t\t\t\tzone: zoneInfo || {\n\t\t\t\t\tid: threadResult.structureId,\n\t\t\t\t\tname: structureResult?.name || 'Unknown',\n\t\t\t\t\tslug: structureResult?.slug || 'unknown',\n\t\t\t\t\tcolorTheme: 'default'\n\t\t\t\t},\n\n\t\t\t\ttags: [],\n\t\t\t\tcanEdit: false,\n\t\t\t\tcanDelete: false,\n\t\t\t\texcerpt: excerpt || undefined\n\t\t\t};\n\n\t\t\treturn formattedThread;\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadService', 'Error fetching thread by slug', { slug, error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Create a new thread\n\t */\n\tasync createThread(input: ThreadCreateInput): Promise<ThreadWithUserAndCategory> {\n\t\ttry {\n\t\t\tconst { title, content, structureId, userId, tags: tagNames, ...options } = input;\n\n\t\t\t// Generate slug from title\n\t\t\tconst slug = this.generateSlug(title);\n\n\t\t\t// Create thread (note: threads table doesn't have content field)\n\t\t\tconst [newThread] = await db\n\t\t\t\t.insert(threads)\n\t\t\t\t.values({\n\t\t\t\t\ttitle,\n\t\t\t\t\tslug,\n\t\t\t\t\tstructureId,\n\t\t\t\t\tuserId,\n\t\t\t\t\tisLocked: options.isLocked || false,\n\t\t\t\t\tisSticky: options.isPinned || false, // Map isPinned option to isSticky field\n\t\t\t\t\tpostCount: 0,\n\t\t\t\t\tviewCount: 0,\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// 1️⃣  Create the very first post inside this thread so the UI has content\n\t\t\tawait postService.createPost({\n\t\t\t\tcontent,\n\t\t\t\tthreadId: newThread.id,\n\t\t\t\tuserId,\n\t\t\t\treplyToPostId: undefined\n\t\t\t});\n\n\t\t\t// 2️⃣  Handle tags if provided\n\t\t\tif (tagNames && tagNames.length > 0) {\n\t\t\t\tawait this.addTagsToThread(newThread.id, tagNames);\n\t\t\t}\n\n\t\t\t// 3️⃣  Emit event-log for analytics / notifications\n\t\t\ttry {\n\t\t\t\tawait eventLogger.logThreadCreated(userId, String(newThread.id));\n\t\t\t} catch (err) {\n\t\t\t\tlogger.warn('ThreadService', 'Failed to emit thread_created event', { err });\n\t\t\t}\n\n\t\t\t// Emit achievement event\n\t\t\ttry {\n\t\t\t\tawait AchievementEventEmitter.emitThreadCreated(userId, {\n\t\t\t\t\tid: newThread.id,\n\t\t\t\t\tforumId: newThread.structureId,\n\t\t\t\t\ttitle: newThread.title,\n\t\t\t\t\ttags: tagNames || [],\n\t\t\t\t\tcreatedAt: newThread.createdAt\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tlogger.warn('ThreadService', 'Failed to emit achievement thread_created event', { err });\n\t\t\t}\n\n\t\t\t// 4️⃣  Fetch the complete thread with first-post count updated\n\t\t\tconst completeThread = await this.getThreadById(newThread.id);\n\n\t\t\tif (!completeThread) {\n\t\t\t\tthrow new Error('Failed to retrieve created thread');\n\t\t\t}\n\n\t\t\tlogger.info('ThreadService', 'Thread created successfully', {\n\t\t\t\tthreadId: newThread.id,\n\t\t\t\ttitle,\n\t\t\t\tstructureId\n\t\t\t});\n\n\t\t\treturn completeThread;\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadService', 'Error creating thread', { input, error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Update thread view count\n\t */\n\tasync incrementViewCount(threadId: ThreadId): Promise<void> {\n\t\ttry {\n\t\t\tawait db\n\t\t\t\t.update(threads)\n\t\t\t\t.set({\n\t\t\t\t\tviewCount: sql`${threads.viewCount} + 1`,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(threads.id, threadId));\n\n\t\t\tlogger.debug('ThreadService', 'Thread view count incremented', { threadId });\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadService', 'Error incrementing view count', { threadId, error });\n\t\t\t// Don't throw error for view count updates\n\t\t}\n\t}\n\n\t/**\n\t * Update thread post count\n\t */\n\tasync updatePostCount(threadId: ThreadId): Promise<void> {\n\t\ttry {\n\t\t\tconst [{ postCount }] = await db\n\t\t\t\t.select({ postCount: count(posts.id) })\n\t\t\t\t.from(posts)\n\t\t\t\t.where(eq(posts.threadId, threadId));\n\n\t\t\tawait db\n\t\t\t\t.update(threads)\n\t\t\t\t.set({\n\t\t\t\t\tpostCount,\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\tlastPostAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(threads.id, threadId));\n\n\t\t\tlogger.debug('ThreadService', 'Thread post count updated', { threadId, postCount });\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadService', 'Error updating post count', { threadId, error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Update thread solved status\n\t */\n\tasync updateThreadSolvedStatus(params: {\n\t\tthreadId: ThreadId;\n\t\tsolvingPostId?: PostId | null;\n\t}): Promise<ThreadWithUserAndCategory | null> {\n\t\ttry {\n\t\t\tconst { threadId, solvingPostId } = params;\n\n\t\t\tawait db\n\t\t\t\t.update(threads)\n\t\t\t\t.set({\n\t\t\t\t\tisSolved: !!solvingPostId,\n\t\t\t\t\tsolvingPostId: solvingPostId || null,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(threads.id, threadId));\n\n\t\t\t// Return updated thread\n\t\t\tconst updatedThread = await this.getThreadById(threadId);\n\n\t\t\tlogger.info('ThreadService', 'Thread solved status updated', {\n\t\t\t\tthreadId,\n\t\t\t\tisSolved: !!solvingPostId,\n\t\t\t\tsolvingPostId\n\t\t\t});\n\n\t\t\treturn updatedThread;\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadService', 'Error updating thread solved status', { params, error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Add tags to thread\n\t */\n\tprivate async addTagsToThread(threadId: ThreadId, tagNames: string[]): Promise<void> {\n\t\ttry {\n\t\t\t// Get or create tags\n\t\t\tconst tagIds: TagId[] = [];\n\n\t\t\tfor (const tagName of tagNames) {\n\t\t\t\tlet [tag] = await db.select({ id: tags.id }).from(tags).where(eq(tags.name, tagName));\n\n\t\t\t\tif (!tag) {\n\t\t\t\t\t[tag] = await db\n\t\t\t\t\t\t.insert(tags)\n\t\t\t\t\t\t.values({ name: tagName, slug: this.generateSlug(tagName) })\n\t\t\t\t\t\t.returning({ id: tags.id });\n\t\t\t\t}\n\n\t\t\t\ttagIds.push(tag.id);\n\t\t\t}\n\n\t\t\t// Link tags to thread\n\t\t\tconst threadTagValues = tagIds.map((tagId) => ({\n\t\t\t\tthreadId,\n\t\t\t\ttagId\n\t\t\t}));\n\n\t\t\tawait db.insert(threadTags).values(threadTagValues);\n\n\t\t\tlogger.debug('ThreadService', 'Tags added to thread', { threadId, tagNames });\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadService', 'Error adding tags to thread', { threadId, tagNames, error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Generate URL-friendly slug from title\n\t */\n\tprivate generateSlug(title: string): string {\n\t\treturn title\n\t\t\t.toLowerCase()\n\t\t\t.replace(/[^a-z0-9\\s-]/g, '')\n\t\t\t.replace(/\\s+/g, '-')\n\t\t\t.replace(/-+/g, '-')\n\t\t\t.trim()\n\t\t\t.substring(0, 100);\n\t}\n\n\t/**\n\t * Get zone information for a given structure ID\n\t * Traverses up the hierarchy to find the top-level zone\n\t */\n\tprivate async getZoneInfo(structureId: StructureId): Promise<{\n\t\tid: StructureId;\n\t\tname: string;\n\t\tslug: string;\n\t\tcolorTheme: string;\n\t} | null> {\n\t\ttry {\n\t\t\t// First get the structure node\n\t\t\tconst [structure] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(eq(forumStructure.id, structureId));\n\n\t\t\tif (!structure) return null;\n\n\t\t\t// If it's already a zone, return it\n\t\t\tif (structure.type === 'zone') {\n\t\t\t\treturn {\n\t\t\t\t\tid: structure.id,\n\t\t\t\t\tname: structure.name,\n\t\t\t\t\tslug: structure.slug,\n\t\t\t\t\tcolorTheme: structure.colorTheme || 'default'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Otherwise, traverse up to find the zone\n\t\t\tlet currentNode = structure;\n\t\t\tlet maxDepth = 5; // Prevent infinite loops\n\n\t\t\twhile (currentNode.parentId && maxDepth > 0) {\n\t\t\t\tconst [parent] = await db\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(forumStructure)\n\t\t\t\t\t.where(eq(forumStructure.id, currentNode.parentId));\n\n\t\t\t\tif (!parent) break;\n\n\t\t\t\tif (parent.type === 'zone') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: parent.id,\n\t\t\t\t\t\tname: parent.name,\n\t\t\t\t\t\tslug: parent.slug,\n\t\t\t\t\t\tcolorTheme: parent.colorTheme || 'default'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tcurrentNode = parent;\n\t\t\t\tmaxDepth--;\n\t\t\t}\n\n\t\t\t// If we couldn't find a zone, return the current structure as fallback\n\t\t\treturn {\n\t\t\t\tid: structure.id,\n\t\t\t\tname: structure.name,\n\t\t\t\tslug: structure.slug,\n\t\t\t\tcolorTheme: structure.colorTheme || structure.color || 'default'\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ThreadService', 'Error fetching zone info', { structureId, error });\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate stripMarkup(raw: string): string {\n\t\t// Removes HTML tags\n\t\tlet text = raw.replace(/<[^>]*>/g, '');\n\t\t// Removes simple BBCode tags like [b], [/url], etc.\n\t\ttext = text.replace(/\\[.*?\\]/g, '');\n\t\treturn text;\n\t}\n\n\t/**\n\t * Fetch first post excerpt (plain-text, 150 chars max) for a thread\n\t */\n\tprivate async getFirstPostExcerpt(threadId: ThreadId): Promise<string | null> {\n\t\ttry {\n\t\t\tconst [firstPost] = await db\n\t\t\t\t.select({ content: posts.content })\n\t\t\t\t.from(posts)\n\t\t\t\t.where(eq(posts.threadId, threadId))\n\t\t\t\t.orderBy(asc(posts.createdAt))\n\t\t\t\t.limit(1);\n\n\t\t\tif (!firstPost) return null;\n\n\t\t\tconst plain = this.stripMarkup(firstPost.content || '');\n\t\t\treturn plain.substring(0, 150);\n\t\t} catch (error) {\n\t\t\tlogger.warn('ThreadService', 'Failed to fetch excerpt', { threadId, error });\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Batch fetch first post excerpts for multiple threads (fixes N+1)\n\t */\n\tprivate async getFirstPostExcerptsBatch(\n\t\tthreadIds: ThreadId[]\n\t): Promise<Array<{ threadId: ThreadId; excerpt: string | null }>> {\n\t\tif (threadIds.length === 0) return [];\n\n\t\ttry {\n\t\t\t// Get first post for each thread using a more compatible approach\n\t\t\tconst firstPosts = await db\n\t\t\t\t.select({\n\t\t\t\t\tthreadId: posts.threadId,\n\t\t\t\t\tcontent: posts.content\n\t\t\t\t})\n\t\t\t\t.from(posts)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\tinArray(posts.threadId, threadIds),\n\t\t\t\t\t\t// Only get posts that are the earliest for their thread\n\t\t\t\t\t\tsql`${posts.createdAt} = (SELECT MIN(${posts.createdAt}) FROM ${posts} p2 WHERE p2.${posts.threadId} = ${posts.threadId})`\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\treturn firstPosts.map((post) => ({\n\t\t\t\tthreadId: post.threadId,\n\t\t\t\texcerpt: post.content ? this.stripMarkup(post.content).substring(0, 150) : null\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tlogger.warn('ThreadService', 'Failed to batch fetch excerpts', {\n\t\t\t\tthreadIds: threadIds.length,\n\t\t\t\terror\n\t\t\t});\n\t\t\t// Fallback: return empty excerpts for all threads\n\t\t\treturn threadIds.map((threadId) => ({ threadId, excerpt: null }));\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const threadService = new ThreadService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/sub-domains/reports/reports.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/sub-domains/reports/reports.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/sub-domains/reports/reports.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/sub-domains/reports/reports.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/transformers/forum.transformer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/forum/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/achievement.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/achievement.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/achievement.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":64},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":66,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":72},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'badges' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userBadges' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'titles' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userTitles' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":17,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metadata' is defined but never used.","line":282,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":282,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'type' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":471,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":471,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'conditions' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":471,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":471,"endColumn":47},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":506,"column":6,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":510,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":577,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":577,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement System Service\n *\n * Handles achievement tracking, reward distribution, and progress monitoring\n * for the comprehensive gamification system.\n */\n\nimport { db } from '../../core/db';\nimport { eq, and, desc, asc, gte, lte, count, sum, sql, inArray, isNull } from 'drizzle-orm';\nimport {\n\tachievements,\n\tuserAchievements,\n\tusers,\n\tbadges,\n\tuserBadges,\n\ttitles,\n\tuserTitles,\n\ttransactions,\n\tposts,\n\tthreads,\n\txpAdjustmentLogs\n} from '@schema';\nimport { logger } from '../../core/logger';\nimport { XpService } from '../xp/xp.service';\nimport type { UserId, AchievementId } from '@shared/types/ids';\n\nexport interface AchievementDefinition {\n\tid: AchievementId;\n\tname: string;\n\tdescription: string;\n\ticonUrl?: string;\n\trewardXp: number;\n\trewardPoints: number;\n\trequirement: AchievementRequirement;\n\tisActive: boolean;\n\trarity: 'common' | 'rare' | 'epic' | 'legendary' | 'mythic';\n\tcategory: 'social' | 'content' | 'economy' | 'progression' | 'special';\n}\n\nexport interface AchievementRequirement {\n\ttype: 'count' | 'threshold' | 'streak' | 'composite';\n\taction: string;\n\ttarget: number;\n\ttimeframe?: 'daily' | 'weekly' | 'monthly' | 'lifetime';\n\tconditions?: Record<string, any>;\n}\n\nexport interface UserAchievementProgress {\n\tuserId: UserId;\n\tachievementId: AchievementId;\n\tcurrentProgress: number;\n\tisCompleted: boolean;\n\tearnedAt?: Date;\n\tprogressPercentage: number;\n\tachievement: AchievementDefinition;\n}\n\nexport interface AchievementStats {\n\ttotalAchievements: number;\n\tcompletedAchievements: number;\n\tcompletionRate: number;\n\ttotalRewardXp: number;\n\ttotalRewardPoints: number;\n\trecentEarned: Array<{\n\t\tachievement: AchievementDefinition;\n\t\tearnedAt: Date;\n\t}>;\n\tcategories: Record<\n\t\tstring,\n\t\t{\n\t\t\ttotal: number;\n\t\t\tcompleted: number;\n\t\t\trate: number;\n\t\t}\n\t>;\n}\n\nexport class AchievementService {\n\tprivate xpService: XpService;\n\n\tconstructor() {\n\t\tthis.xpService = new XpService();\n\t}\n\n\t/**\n\t * Get all available achievements\n\t */\n\tasync getAllAchievements(activeOnly: boolean = true): Promise<AchievementDefinition[]> {\n\t\ttry {\n\t\t\tlet query = db.select().from(achievements);\n\n\t\t\tif (activeOnly) {\n\t\t\t\tquery = query.where(eq(achievements.isActive, true));\n\t\t\t}\n\n\t\t\tconst achievementsData = await query.orderBy(achievements.name);\n\n\t\t\treturn achievementsData.map((a) => ({\n\t\t\t\tid: a.id,\n\t\t\t\tname: a.name,\n\t\t\t\tdescription: a.description || '',\n\t\t\t\ticonUrl: a.iconUrl || undefined,\n\t\t\t\trewardXp: a.rewardXp,\n\t\t\t\trewardPoints: a.rewardPoints,\n\t\t\t\trequirement: a.requirement as AchievementRequirement,\n\t\t\t\tisActive: a.isActive,\n\t\t\t\trarity: this.determineRarity(a.rewardXp, a.rewardPoints),\n\t\t\t\tcategory: this.categorizeAchievement(a.requirement as AchievementRequirement)\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_SERVICE', 'Error getting all achievements:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get user's achievement progress and statistics\n\t */\n\tasync getUserAchievementStats(userId: UserId): Promise<AchievementStats> {\n\t\ttry {\n\t\t\t// Get all achievements\n\t\t\tconst allAchievements = await this.getAllAchievements();\n\n\t\t\t// Get user's completed achievements\n\t\t\tconst userAchievementsData = await db\n\t\t\t\t.select({\n\t\t\t\t\tachievement: achievements,\n\t\t\t\t\tuserAchievement: userAchievements\n\t\t\t\t})\n\t\t\t\t.from(userAchievements)\n\t\t\t\t.innerJoin(achievements, eq(userAchievements.achievementId, achievements.id))\n\t\t\t\t.where(eq(userAchievements.userId, userId))\n\t\t\t\t.orderBy(desc(userAchievements.earnedAt));\n\n\t\t\tconst completed = userAchievementsData.length;\n\t\t\tconst total = allAchievements.length;\n\t\t\tconst completionRate = total > 0 ? (completed / total) * 100 : 0;\n\n\t\t\t// Calculate total rewards earned\n\t\t\tconst totalRewardXp = userAchievementsData.reduce(\n\t\t\t\t(sum, ua) => sum + ua.achievement.rewardXp,\n\t\t\t\t0\n\t\t\t);\n\t\t\tconst totalRewardPoints = userAchievementsData.reduce(\n\t\t\t\t(sum, ua) => sum + ua.achievement.rewardPoints,\n\t\t\t\t0\n\t\t\t);\n\n\t\t\t// Get recent achievements (last 10)\n\t\t\tconst recentEarned = userAchievementsData.slice(0, 10).map((ua) => ({\n\t\t\t\tachievement: {\n\t\t\t\t\tid: ua.achievement.id,\n\t\t\t\t\tname: ua.achievement.name,\n\t\t\t\t\tdescription: ua.achievement.description || '',\n\t\t\t\t\ticonUrl: ua.achievement.iconUrl || undefined,\n\t\t\t\t\trewardXp: ua.achievement.rewardXp,\n\t\t\t\t\trewardPoints: ua.achievement.rewardPoints,\n\t\t\t\t\trequirement: ua.achievement.requirement as AchievementRequirement,\n\t\t\t\t\tisActive: ua.achievement.isActive,\n\t\t\t\t\trarity: this.determineRarity(ua.achievement.rewardXp, ua.achievement.rewardPoints),\n\t\t\t\t\tcategory: this.categorizeAchievement(ua.achievement.requirement as AchievementRequirement)\n\t\t\t\t},\n\t\t\t\tearnedAt: ua.userAchievement.earnedAt\n\t\t\t}));\n\n\t\t\t// Calculate category statistics\n\t\t\tconst categories: Record<string, { total: number; completed: number; rate: number }> = {};\n\n\t\t\tallAchievements.forEach((achievement) => {\n\t\t\t\tconst category = achievement.category;\n\t\t\t\tif (!categories[category]) {\n\t\t\t\t\tcategories[category] = { total: 0, completed: 0, rate: 0 };\n\t\t\t\t}\n\t\t\t\tcategories[category].total++;\n\t\t\t});\n\n\t\t\tuserAchievementsData.forEach((ua) => {\n\t\t\t\tconst category = this.categorizeAchievement(\n\t\t\t\t\tua.achievement.requirement as AchievementRequirement\n\t\t\t\t);\n\t\t\t\tif (categories[category]) {\n\t\t\t\t\tcategories[category].completed++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tObject.keys(categories).forEach((category) => {\n\t\t\t\tconst cat = categories[category];\n\t\t\t\tcat.rate = cat.total > 0 ? (cat.completed / cat.total) * 100 : 0;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttotalAchievements: total,\n\t\t\t\tcompletedAchievements: completed,\n\t\t\t\tcompletionRate,\n\t\t\t\ttotalRewardXp,\n\t\t\t\ttotalRewardPoints,\n\t\t\t\trecentEarned,\n\t\t\t\tcategories\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_SERVICE', 'Error getting user achievement stats:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get user's progress towards specific achievements\n\t */\n\tasync getUserAchievementProgress(\n\t\tuserId: UserId,\n\t\tachievementIds?: AchievementId[]\n\t): Promise<UserAchievementProgress[]> {\n\t\ttry {\n\t\t\t// Get achievements to check\n\t\t\tlet targetAchievements = await this.getAllAchievements();\n\n\t\t\tif (achievementIds) {\n\t\t\t\ttargetAchievements = targetAchievements.filter((a) => achievementIds.includes(a.id));\n\t\t\t}\n\n\t\t\tconst progress: UserAchievementProgress[] = [];\n\n\t\t\tfor (const achievement of targetAchievements) {\n\t\t\t\t// Check if user already has this achievement\n\t\t\t\tconst existingAchievement = await db\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(userAchievements)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(userAchievements.userId, userId),\n\t\t\t\t\t\t\teq(userAchievements.achievementId, achievement.id)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tif (existingAchievement.length > 0) {\n\t\t\t\t\t// Already earned\n\t\t\t\t\tprogress.push({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tachievementId: achievement.id,\n\t\t\t\t\t\tcurrentProgress: achievement.requirement.target,\n\t\t\t\t\t\tisCompleted: true,\n\t\t\t\t\t\tearnedAt: existingAchievement[0].earnedAt,\n\t\t\t\t\t\tprogressPercentage: 100,\n\t\t\t\t\t\tachievement\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Calculate current progress\n\t\t\t\t\tconst currentProgress = await this.calculateAchievementProgress(\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tachievement.requirement\n\t\t\t\t\t);\n\t\t\t\t\tconst progressPercentage = Math.min(\n\t\t\t\t\t\t100,\n\t\t\t\t\t\t(currentProgress / achievement.requirement.target) * 100\n\t\t\t\t\t);\n\n\t\t\t\t\tprogress.push({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tachievementId: achievement.id,\n\t\t\t\t\t\tcurrentProgress,\n\t\t\t\t\t\tisCompleted: false,\n\t\t\t\t\t\tprogressPercentage,\n\t\t\t\t\t\tachievement\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn progress.sort((a, b) => b.progressPercentage - a.progressPercentage);\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_SERVICE', 'Error getting user achievement progress:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Check and award achievements for a user action\n\t */\n\tasync checkAndAwardAchievements(\n\t\tuserId: UserId,\n\t\tactionType: string,\n\t\tmetadata?: any\n\t): Promise<AchievementDefinition[]> {\n\t\ttry {\n\t\t\t// Get all achievements that could be triggered by this action\n\t\t\tconst relevantAchievements = await db\n\t\t\t\t.select()\n\t\t\t\t.from(achievements)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(achievements.isActive, true),\n\t\t\t\t\t\tsql`${achievements.requirement}->>'action' = ${actionType}`\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tconst awardedAchievements: AchievementDefinition[] = [];\n\n\t\t\tfor (const achievement of relevantAchievements) {\n\t\t\t\t// Check if user already has this achievement\n\t\t\t\tconst existingAchievement = await db\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(userAchievements)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(userAchievements.userId, userId),\n\t\t\t\t\t\t\teq(userAchievements.achievementId, achievement.id)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tif (existingAchievement.length > 0) {\n\t\t\t\t\tcontinue; // Already earned\n\t\t\t\t}\n\n\t\t\t\t// Check if requirement is met\n\t\t\t\tconst requirement = achievement.requirement as AchievementRequirement;\n\t\t\t\tconst currentProgress = await this.calculateAchievementProgress(userId, requirement);\n\n\t\t\t\tif (currentProgress >= requirement.target) {\n\t\t\t\t\t// Award the achievement\n\t\t\t\t\tawait this.awardAchievement(userId, achievement.id);\n\n\t\t\t\t\tconst achievementDef: AchievementDefinition = {\n\t\t\t\t\t\tid: achievement.id,\n\t\t\t\t\t\tname: achievement.name,\n\t\t\t\t\t\tdescription: achievement.description || '',\n\t\t\t\t\t\ticonUrl: achievement.iconUrl || undefined,\n\t\t\t\t\t\trewardXp: achievement.rewardXp,\n\t\t\t\t\t\trewardPoints: achievement.rewardPoints,\n\t\t\t\t\t\trequirement,\n\t\t\t\t\t\tisActive: achievement.isActive,\n\t\t\t\t\t\trarity: this.determineRarity(achievement.rewardXp, achievement.rewardPoints),\n\t\t\t\t\t\tcategory: this.categorizeAchievement(requirement)\n\t\t\t\t\t};\n\n\t\t\t\t\tawardedAchievements.push(achievementDef);\n\n\t\t\t\t\tlogger.info('ACHIEVEMENT_SERVICE', `Achievement awarded: ${achievement.name}`, {\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tachievementId: achievement.id,\n\t\t\t\t\t\tactionType,\n\t\t\t\t\t\tcurrentProgress\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn awardedAchievements;\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_SERVICE', 'Error checking and awarding achievements:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Manually award an achievement to a user\n\t */\n\tasync awardAchievement(userId: UserId, achievementId: AchievementId): Promise<void> {\n\t\ttry {\n\t\t\tconst achievement = await db\n\t\t\t\t.select()\n\t\t\t\t.from(achievements)\n\t\t\t\t.where(eq(achievements.id, achievementId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (achievement.length === 0) {\n\t\t\t\tthrow new Error(`Achievement ${achievementId} not found`);\n\t\t\t}\n\n\t\t\tconst achievementData = achievement[0];\n\n\t\t\t// Insert user achievement record\n\t\t\tawait db\n\t\t\t\t.insert(userAchievements)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\tachievementId,\n\t\t\t\t\tearnedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.onConflictDoNothing();\n\n\t\t\t// Award XP if specified\n\t\t\tif (achievementData.rewardXp > 0) {\n\t\t\t\tawait this.xpService.updateUserXp(userId, achievementData.rewardXp, 'add', {\n\t\t\t\t\treason: `Achievement: ${achievementData.name}`,\n\t\t\t\t\tskipTriggers: true\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Award DGT points if specified\n\t\t\tif (achievementData.rewardPoints > 0) {\n\t\t\t\tawait db.insert(transactions).values({\n\t\t\t\t\tuserId,\n\t\t\t\t\tamount: achievementData.rewardPoints,\n\t\t\t\t\ttype: 'ACHIEVEMENT_REWARD',\n\t\t\t\t\tstatus: 'COMPLETED',\n\t\t\t\t\tdescription: `Achievement reward: ${achievementData.name}`,\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tachievementId,\n\t\t\t\t\t\tsource: 'achievement_reward'\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlogger.info('ACHIEVEMENT_SERVICE', `Achievement awarded successfully`, {\n\t\t\t\tuserId,\n\t\t\t\tachievementId,\n\t\t\t\tname: achievementData.name,\n\t\t\t\trewardXp: achievementData.rewardXp,\n\t\t\t\trewardPoints: achievementData.rewardPoints\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_SERVICE', 'Error awarding achievement:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Create a new achievement\n\t */\n\tasync createAchievement(data: {\n\t\tname: string;\n\t\tdescription: string;\n\t\ticonUrl?: string;\n\t\trewardXp: number;\n\t\trewardPoints: number;\n\t\trequirement: AchievementRequirement;\n\t\tisActive?: boolean;\n\t}): Promise<AchievementDefinition> {\n\t\ttry {\n\t\t\tconst result = await db\n\t\t\t\t.insert(achievements)\n\t\t\t\t.values({\n\t\t\t\t\tname: data.name,\n\t\t\t\t\tdescription: data.description,\n\t\t\t\t\ticonUrl: data.iconUrl,\n\t\t\t\t\trewardXp: data.rewardXp,\n\t\t\t\t\trewardPoints: data.rewardPoints,\n\t\t\t\t\trequirement: data.requirement,\n\t\t\t\t\tisActive: data.isActive ?? true\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\tconst achievement = result[0];\n\n\t\t\treturn {\n\t\t\t\tid: achievement.id,\n\t\t\t\tname: achievement.name,\n\t\t\t\tdescription: achievement.description || '',\n\t\t\t\ticonUrl: achievement.iconUrl || undefined,\n\t\t\t\trewardXp: achievement.rewardXp,\n\t\t\t\trewardPoints: achievement.rewardPoints,\n\t\t\t\trequirement: achievement.requirement as AchievementRequirement,\n\t\t\t\tisActive: achievement.isActive,\n\t\t\t\trarity: this.determineRarity(achievement.rewardXp, achievement.rewardPoints),\n\t\t\t\tcategory: this.categorizeAchievement(achievement.requirement as AchievementRequirement)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_SERVICE', 'Error creating achievement:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Calculate current progress for an achievement requirement\n\t */\n\tprivate async calculateAchievementProgress(\n\t\tuserId: UserId,\n\t\trequirement: AchievementRequirement\n\t): Promise<number> {\n\t\ttry {\n\t\t\tconst { type, action, timeframe, conditions } = requirement;\n\n\t\t\t// Build time filter if specified\n\t\t\tlet timeFilter: Date | undefined;\n\t\t\tif (timeframe) {\n\t\t\t\ttimeFilter = new Date();\n\t\t\t\tswitch (timeframe) {\n\t\t\t\t\tcase 'daily':\n\t\t\t\t\t\ttimeFilter.setDate(timeFilter.getDate() - 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'weekly':\n\t\t\t\t\t\ttimeFilter.setDate(timeFilter.getDate() - 7);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'monthly':\n\t\t\t\t\t\ttimeFilter.setDate(timeFilter.getDate() - 30);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttimeFilter = undefined; // lifetime\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (action) {\n\t\t\t\tcase 'posts_created':\n\t\t\t\t\treturn await this.countUserPosts(userId, timeFilter);\n\n\t\t\t\tcase 'threads_created':\n\t\t\t\t\treturn await this.countUserThreads(userId, timeFilter);\n\n\t\t\t\tcase 'xp_earned':\n\t\t\t\t\treturn await this.sumUserXp(userId, timeFilter);\n\n\t\t\t\tcase 'consecutive_logins':\n\t\t\t\t\treturn await this.calculateLoginStreak(userId);\n\n\t\t\t\tcase 'level_reached':\n\t\t\t\t\tconst user = await db\n\t\t\t\t\t\t.select({ level: users.level })\n\t\t\t\t\t\t.from(users)\n\t\t\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t\t\t.limit(1);\n\t\t\t\t\treturn user[0]?.level || 0;\n\n\t\t\t\tcase 'likes_received':\n\t\t\t\t\t// TODO: Implement when likes system is available\n\t\t\t\t\treturn 0;\n\n\t\t\t\tcase 'tips_given':\n\t\t\t\t\treturn await this.countUserTips(userId, timeFilter);\n\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.warn('ACHIEVEMENT_SERVICE', `Unknown action type: ${action}`);\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_SERVICE', 'Error calculating achievement progress:', error);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Helper methods for progress calculation\n\t */\n\tprivate async countUserPosts(userId: UserId, timeFilter?: Date): Promise<number> {\n\t\tlet query = db.select({ count: count() }).from(posts).where(eq(posts.userId, userId));\n\n\t\tif (timeFilter) {\n\t\t\tquery = query.where(and(eq(posts.userId, userId), gte(posts.createdAt, timeFilter)));\n\t\t}\n\n\t\tconst result = await query;\n\t\treturn result[0]?.count || 0;\n\t}\n\n\tprivate async countUserThreads(userId: UserId, timeFilter?: Date): Promise<number> {\n\t\tlet query = db.select({ count: count() }).from(threads).where(eq(threads.userId, userId));\n\n\t\tif (timeFilter) {\n\t\t\tquery = query.where(and(eq(threads.userId, userId), gte(threads.createdAt, timeFilter)));\n\t\t}\n\n\t\tconst result = await query;\n\t\treturn result[0]?.count || 0;\n\t}\n\n\tprivate async sumUserXp(userId: UserId, timeFilter?: Date): Promise<number> {\n\t\tlet query = db\n\t\t\t.select({ total: sum(xpAdjustmentLogs.amount) })\n\t\t\t.from(xpAdjustmentLogs)\n\t\t\t.where(\n\t\t\t\tand(eq(xpAdjustmentLogs.userId, userId), sql`${xpAdjustmentLogs.adjustmentType} = 'add'`)\n\t\t\t);\n\n\t\tif (timeFilter) {\n\t\t\tquery = query.where(\n\t\t\t\tand(\n\t\t\t\t\teq(xpAdjustmentLogs.userId, userId),\n\t\t\t\t\tsql`${xpAdjustmentLogs.adjustmentType} = 'add'`,\n\t\t\t\t\tgte(xpAdjustmentLogs.createdAt, timeFilter)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst result = await query;\n\t\treturn parseInt(result[0]?.total || '0');\n\t}\n\n\tprivate async calculateLoginStreak(userId: UserId): Promise<number> {\n\t\t// TODO: Implement login streak calculation\n\t\t// This would require a login tracking system\n\t\treturn 0;\n\t}\n\n\tprivate async countUserTips(userId: UserId, timeFilter?: Date): Promise<number> {\n\t\tlet query = db\n\t\t\t.select({ count: count() })\n\t\t\t.from(transactions)\n\t\t\t.where(and(eq(transactions.userId, userId), sql`${transactions.type} = 'TIP'`));\n\n\t\tif (timeFilter) {\n\t\t\tquery = query.where(\n\t\t\t\tand(\n\t\t\t\t\teq(transactions.userId, userId),\n\t\t\t\t\tsql`${transactions.type} = 'TIP'`,\n\t\t\t\t\tgte(transactions.updatedAt, timeFilter)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst result = await query;\n\t\treturn result[0]?.count || 0;\n\t}\n\n\t/**\n\t * Determine achievement rarity based on rewards\n\t */\n\tprivate determineRarity(\n\t\trewardXp: number,\n\t\trewardPoints: number\n\t): 'common' | 'rare' | 'epic' | 'legendary' | 'mythic' {\n\t\tconst totalReward = rewardXp + rewardPoints * 2; // Weight points higher\n\n\t\tif (totalReward >= 1000) return 'mythic';\n\t\tif (totalReward >= 500) return 'legendary';\n\t\tif (totalReward >= 200) return 'epic';\n\t\tif (totalReward >= 100) return 'rare';\n\t\treturn 'common';\n\t}\n\n\t/**\n\t * Categorize achievement based on requirement type\n\t */\n\tprivate categorizeAchievement(\n\t\trequirement: AchievementRequirement\n\t): 'social' | 'content' | 'economy' | 'progression' | 'special' {\n\t\tconst { action } = requirement;\n\n\t\tif (action.includes('tip') || action.includes('like')) return 'social';\n\t\tif (action.includes('post') || action.includes('thread')) return 'content';\n\t\tif (action.includes('dgt') || action.includes('purchase')) return 'economy';\n\t\tif (action.includes('level') || action.includes('xp')) return 'progression';\n\t\treturn 'special';\n\t}\n\n\t/**\n\t * Get achievement leaderboard\n\t */\n\tasync getAchievementLeaderboard(limit: number = 50): Promise<\n\t\tArray<{\n\t\t\tuserId: UserId;\n\t\t\tusername: string;\n\t\t\tachievementCount: number;\n\t\t\ttotalXpReward: number;\n\t\t\ttotalPointsReward: number;\n\t\t\trank: number;\n\t\t}>\n\t> {\n\t\ttry {\n\t\t\tconst leaderboard = await db\n\t\t\t\t.select({\n\t\t\t\t\tuserId: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tachievementCount: count(userAchievements.id),\n\t\t\t\t\ttotalXpReward: sum(achievements.rewardXp),\n\t\t\t\t\ttotalPointsReward: sum(achievements.rewardPoints)\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.leftJoin(userAchievements, eq(users.id, userAchievements.userId))\n\t\t\t\t.leftJoin(achievements, eq(userAchievements.achievementId, achievements.id))\n\t\t\t\t.groupBy(users.id, users.username)\n\t\t\t\t.orderBy(desc(count(userAchievements.id)), desc(sum(achievements.rewardXp)))\n\t\t\t\t.limit(limit);\n\n\t\t\treturn leaderboard.map((entry, index) => ({\n\t\t\t\tuserId: entry.userId,\n\t\t\t\tusername: entry.username,\n\t\t\t\tachievementCount: entry.achievementCount,\n\t\t\t\ttotalXpReward: parseInt(entry.totalXpReward || '0'),\n\t\t\t\ttotalPointsReward: parseInt(entry.totalPointsReward || '0'),\n\t\t\t\trank: index + 1\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_SERVICE', 'Error getting achievement leaderboard:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Create default achievements for the platform\n\t */\n\tasync createDefaultAchievements(): Promise<void> {\n\t\tconst defaultAchievements = [\n\t\t\t{\n\t\t\t\tname: 'First Steps',\n\t\t\t\tdescription: 'Create your first post',\n\t\t\t\trewardXp: 50,\n\t\t\t\trewardPoints: 10,\n\t\t\t\trequirement: {\n\t\t\t\t\ttype: 'count' as const,\n\t\t\t\t\taction: 'posts_created',\n\t\t\t\t\ttarget: 1\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Conversation Starter',\n\t\t\t\tdescription: 'Create your first thread',\n\t\t\t\trewardXp: 75,\n\t\t\t\trewardPoints: 15,\n\t\t\t\trequirement: {\n\t\t\t\t\ttype: 'count' as const,\n\t\t\t\t\taction: 'threads_created',\n\t\t\t\t\ttarget: 1\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Prolific Poster',\n\t\t\t\tdescription: 'Create 100 posts',\n\t\t\t\trewardXp: 500,\n\t\t\t\trewardPoints: 100,\n\t\t\t\trequirement: {\n\t\t\t\t\ttype: 'count' as const,\n\t\t\t\t\taction: 'posts_created',\n\t\t\t\t\ttarget: 100\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Level Up',\n\t\t\t\tdescription: 'Reach level 10',\n\t\t\t\trewardXp: 200,\n\t\t\t\trewardPoints: 50,\n\t\t\t\trequirement: {\n\t\t\t\t\ttype: 'threshold' as const,\n\t\t\t\t\taction: 'level_reached',\n\t\t\t\t\ttarget: 10\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'XP Grinder',\n\t\t\t\tdescription: 'Earn 10,000 XP',\n\t\t\t\trewardXp: 1000,\n\t\t\t\trewardPoints: 200,\n\t\t\t\trequirement: {\n\t\t\t\t\ttype: 'threshold' as const,\n\t\t\t\t\taction: 'xp_earned',\n\t\t\t\t\ttarget: 10000\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'Generous Soul',\n\t\t\t\tdescription: 'Give 10 tips',\n\t\t\t\trewardXp: 300,\n\t\t\t\trewardPoints: 75,\n\t\t\t\trequirement: {\n\t\t\t\t\ttype: 'count' as const,\n\t\t\t\t\taction: 'tips_given',\n\t\t\t\t\ttarget: 10\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\tfor (const achievementData of defaultAchievements) {\n\t\t\ttry {\n\t\t\t\tawait this.createAchievement(achievementData);\n\t\t\t\tlogger.info('ACHIEVEMENT_SERVICE', `Created default achievement: ${achievementData.name}`);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'ACHIEVEMENT_SERVICE',\n\t\t\t\t\t`Failed to create achievement ${achievementData.name}:`,\n\t\t\t\t\terror\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport const achievementService = new AchievementService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/achievements/achievement-admin.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ilike' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Admin Service\n *\n * Handles administrative operations for achievements including CRUD operations,\n * bulk management, and validation. Provides backend support for admin panel.\n */\n\nimport { db } from '@db';\nimport { eq, and, desc, count, sql, ilike, inArray } from 'drizzle-orm';\nimport { achievements, userAchievements, users } from '@schema';\nimport type {\n\tAchievement,\n\tInsertAchievement,\n\tAchievementCategory,\n\tAchievementTier,\n\tAchievementTriggerType\n} from '@schema';\nimport { logger } from '../../../core/logger';\nimport { DegenAchievementEvaluators } from './evaluators/degen-evaluators';\nimport type { AchievementId, UserId } from '@shared/types/ids';\n\nexport interface AchievementFilters {\n\tcategory?: AchievementCategory;\n\ttier?: AchievementTier;\n\ttriggerType?: AchievementTriggerType;\n\tisActive?: boolean;\n\tisSecret?: boolean;\n\tsearch?: string;\n}\n\nexport interface AchievementStats {\n\ttotalAchievements: number;\n\tactiveAchievements: number;\n\tsecretAchievements: number;\n\ttotalCompletions: number;\n\tcategoryBreakdown: Record<AchievementCategory, number>;\n\ttierBreakdown: Record<AchievementTier, number>;\n}\n\nexport interface AchievementWithStats extends Achievement {\n\tcompletionCount: number;\n\tcompletionRate: number;\n\taverageProgress: number;\n}\n\nexport class AchievementAdminService {\n\tprivate evaluators = new DegenAchievementEvaluators();\n\n\t/**\n\t * Get all achievements with optional filtering and pagination\n\t */\n\tasync getAchievements(\n\t\tfilters: AchievementFilters = {},\n\t\tpage: number = 1,\n\t\tlimit: number = 50\n\t): Promise<{ achievements: AchievementWithStats[]; total: number }> {\n\t\ttry {\n\t\t\tconst offset = (page - 1) * limit;\n\t\t\tconst whereConditions: any[] = [];\n\n\t\t\t// Build where conditions based on filters\n\t\t\tif (filters.category) {\n\t\t\t\twhereConditions.push(eq(achievements.category, filters.category));\n\t\t\t}\n\t\t\tif (filters.tier) {\n\t\t\t\twhereConditions.push(eq(achievements.tier, filters.tier));\n\t\t\t}\n\t\t\tif (filters.triggerType) {\n\t\t\t\twhereConditions.push(eq(achievements.triggerType, filters.triggerType));\n\t\t\t}\n\t\t\tif (filters.isActive !== undefined) {\n\t\t\t\twhereConditions.push(eq(achievements.isActive, filters.isActive));\n\t\t\t}\n\t\t\tif (filters.isSecret !== undefined) {\n\t\t\t\twhereConditions.push(eq(achievements.isSecret, filters.isSecret));\n\t\t\t}\n\t\t\tif (filters.search) {\n\t\t\t\twhereConditions.push(\n\t\t\t\t\tsql`(${achievements.name} ILIKE ${`%${filters.search}%`} OR ${achievements.description} ILIKE ${`%${filters.search}%`})`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Get achievements with stats\n\t\t\tconst achievementResults = await db\n\t\t\t\t.select({\n\t\t\t\t\t...achievements,\n\t\t\t\t\tcompletionCount: sql<number>`COALESCE(completion_stats.completion_count, 0)`,\n\t\t\t\t\ttotalUsers: sql<number>`COALESCE(user_stats.total_users, 0)`\n\t\t\t\t})\n\t\t\t\t.from(achievements)\n\t\t\t\t.leftJoin(\n\t\t\t\t\tsql`(\n\t\t\t\t\t\tSELECT \n\t\t\t\t\t\t\tachievement_id, \n\t\t\t\t\t\t\tCOUNT(*) as completion_count \n\t\t\t\t\t\tFROM user_achievements \n\t\t\t\t\t\tWHERE is_completed = true \n\t\t\t\t\t\tGROUP BY achievement_id\n\t\t\t\t\t) as completion_stats`,\n\t\t\t\t\tsql`completion_stats.achievement_id = ${achievements.id}`\n\t\t\t\t)\n\t\t\t\t.leftJoin(\n\t\t\t\t\tsql`(SELECT COUNT(DISTINCT id) as total_users FROM users) as user_stats`,\n\t\t\t\t\tsql`true`\n\t\t\t\t)\n\t\t\t\t.where(whereConditions.length > 0 ? and(...whereConditions) : undefined)\n\t\t\t\t.orderBy(desc(achievements.createdAt))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\t// Calculate additional stats\n\t\t\tconst achievementsWithStats: AchievementWithStats[] = achievementResults.map((result) => {\n\t\t\t\tconst completionRate =\n\t\t\t\t\tresult.totalUsers > 0 ? (result.completionCount / result.totalUsers) * 100 : 0;\n\n\t\t\t\treturn {\n\t\t\t\t\t...result,\n\t\t\t\t\tcompletionRate,\n\t\t\t\t\taverageProgress: 0 // TODO: Calculate from user_achievements progress\n\t\t\t\t};\n\t\t\t});\n\n\t\t\t// Get total count for pagination\n\t\t\tconst totalResult = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(achievements)\n\t\t\t\t.where(whereConditions.length > 0 ? and(...whereConditions) : undefined);\n\n\t\t\treturn {\n\t\t\t\tachievements: achievementsWithStats,\n\t\t\t\ttotal: totalResult[0]?.count || 0\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_ADMIN', 'Failed to get achievements', {\n\t\t\t\tfilters,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get achievement statistics for dashboard\n\t */\n\tasync getAchievementStats(): Promise<AchievementStats> {\n\t\ttry {\n\t\t\t// Get basic counts\n\t\t\tconst totalResult = await db.select({ count: count() }).from(achievements);\n\t\t\tconst activeResult = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(achievements)\n\t\t\t\t.where(eq(achievements.isActive, true));\n\t\t\tconst secretResult = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(achievements)\n\t\t\t\t.where(eq(achievements.isSecret, true));\n\t\t\tconst completionsResult = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userAchievements)\n\t\t\t\t.where(eq(userAchievements.isCompleted, true));\n\n\t\t\t// Get category breakdown\n\t\t\tconst categoryResults = await db\n\t\t\t\t.select({\n\t\t\t\t\tcategory: achievements.category,\n\t\t\t\t\tcount: count()\n\t\t\t\t})\n\t\t\t\t.from(achievements)\n\t\t\t\t.groupBy(achievements.category);\n\n\t\t\t// Get tier breakdown\n\t\t\tconst tierResults = await db\n\t\t\t\t.select({\n\t\t\t\t\ttier: achievements.tier,\n\t\t\t\t\tcount: count()\n\t\t\t\t})\n\t\t\t\t.from(achievements)\n\t\t\t\t.groupBy(achievements.tier);\n\n\t\t\t// Build breakdowns\n\t\t\tconst categoryBreakdown: Record<AchievementCategory, number> = {\n\t\t\t\tparticipation: 0,\n\t\t\t\txp: 0,\n\t\t\t\tcultural: 0,\n\t\t\t\tsecret: 0,\n\t\t\t\tsocial: 0,\n\t\t\t\teconomy: 0,\n\t\t\t\tprogression: 0,\n\t\t\t\tspecial: 0\n\t\t\t};\n\n\t\t\tconst tierBreakdown: Record<AchievementTier, number> = {\n\t\t\t\tcommon: 0,\n\t\t\t\trare: 0,\n\t\t\t\tepic: 0,\n\t\t\t\tlegendary: 0,\n\t\t\t\tmythic: 0\n\t\t\t};\n\n\t\t\tcategoryResults.forEach((result) => {\n\t\t\t\tcategoryBreakdown[result.category as AchievementCategory] = result.count;\n\t\t\t});\n\n\t\t\ttierResults.forEach((result) => {\n\t\t\t\ttierBreakdown[result.tier as AchievementTier] = result.count;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttotalAchievements: totalResult[0]?.count || 0,\n\t\t\t\tactiveAchievements: activeResult[0]?.count || 0,\n\t\t\t\tsecretAchievements: secretResult[0]?.count || 0,\n\t\t\t\ttotalCompletions: completionsResult[0]?.count || 0,\n\t\t\t\tcategoryBreakdown,\n\t\t\t\ttierBreakdown\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_ADMIN', 'Failed to get achievement stats', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Create a new achievement\n\t */\n\tasync createAchievement(\n\t\tdata: Omit<InsertAchievement, 'id' | 'createdAt' | 'updatedAt'>\n\t): Promise<Achievement> {\n\t\ttry {\n\t\t\t// Validate trigger configuration\n\t\t\tthis.validateTriggerConfig(data.triggerType || 'count', data.triggerConfig as any);\n\n\t\t\t// Generate unique key if not provided\n\t\t\tif (!data.key) {\n\t\t\t\tdata.key = this.generateAchievementKey(data.name);\n\t\t\t}\n\n\t\t\tconst result = await db\n\t\t\t\t.insert(achievements)\n\t\t\t\t.values({\n\t\t\t\t\t...data,\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\tlogger.info('ACHIEVEMENT_ADMIN', 'Created new achievement', {\n\t\t\t\tachievementId: result[0].id,\n\t\t\t\tkey: result[0].key,\n\t\t\t\tname: result[0].name,\n\t\t\t\tcategory: result[0].category\n\t\t\t});\n\n\t\t\treturn result[0];\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_ADMIN', 'Failed to create achievement', {\n\t\t\t\tdata,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Update an existing achievement\n\t */\n\tasync updateAchievement(id: AchievementId, data: Partial<InsertAchievement>): Promise<Achievement> {\n\t\ttry {\n\t\t\t// Validate trigger configuration if provided\n\t\t\tif (data.triggerType && data.triggerConfig) {\n\t\t\t\tthis.validateTriggerConfig(data.triggerType, data.triggerConfig as any);\n\t\t\t}\n\n\t\t\tconst result = await db\n\t\t\t\t.update(achievements)\n\t\t\t\t.set({\n\t\t\t\t\t...data,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(achievements.id, id))\n\t\t\t\t.returning();\n\n\t\t\tif (!result.length) {\n\t\t\t\tthrow new Error(`Achievement with id ${id} not found`);\n\t\t\t}\n\n\t\t\tlogger.info('ACHIEVEMENT_ADMIN', 'Updated achievement', {\n\t\t\t\tachievementId: id,\n\t\t\t\tupdatedFields: Object.keys(data)\n\t\t\t});\n\n\t\t\treturn result[0];\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_ADMIN', 'Failed to update achievement', {\n\t\t\t\tid,\n\t\t\t\tdata,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Delete an achievement (soft delete by deactivating)\n\t */\n\tasync deleteAchievement(id: AchievementId): Promise<void> {\n\t\ttry {\n\t\t\tconst result = await db\n\t\t\t\t.update(achievements)\n\t\t\t\t.set({\n\t\t\t\t\tisActive: false,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(achievements.id, id))\n\t\t\t\t.returning();\n\n\t\t\tif (!result.length) {\n\t\t\t\tthrow new Error(`Achievement with id ${id} not found`);\n\t\t\t}\n\n\t\t\tlogger.info('ACHIEVEMENT_ADMIN', 'Deleted (deactivated) achievement', {\n\t\t\t\tachievementId: id,\n\t\t\t\tname: result[0].name\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_ADMIN', 'Failed to delete achievement', {\n\t\t\t\tid,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Bulk update achievements\n\t */\n\tasync bulkUpdateAchievements(\n\t\tids: AchievementId[],\n\t\tupdates: Partial<InsertAchievement>\n\t): Promise<Achievement[]> {\n\t\ttry {\n\t\t\tconst result = await db\n\t\t\t\t.update(achievements)\n\t\t\t\t.set({\n\t\t\t\t\t...updates,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(inArray(achievements.id, ids))\n\t\t\t\t.returning();\n\n\t\t\tlogger.info('ACHIEVEMENT_ADMIN', 'Bulk updated achievements', {\n\t\t\t\tachievementIds: ids,\n\t\t\t\tupdatedCount: result.length,\n\t\t\t\tupdatedFields: Object.keys(updates)\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_ADMIN', 'Failed to bulk update achievements', {\n\t\t\t\tids,\n\t\t\t\tupdates,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get achievement by ID with detailed stats\n\t */\n\tasync getAchievementById(id: AchievementId): Promise<AchievementWithStats | null> {\n\t\ttry {\n\t\t\tconst result = await db\n\t\t\t\t.select({\n\t\t\t\t\t...achievements,\n\t\t\t\t\tcompletionCount: sql<number>`COALESCE(completion_stats.completion_count, 0)`,\n\t\t\t\t\ttotalUsers: sql<number>`COALESCE(user_stats.total_users, 0)`,\n\t\t\t\t\tavgProgress: sql<number>`COALESCE(progress_stats.avg_progress, 0)`\n\t\t\t\t})\n\t\t\t\t.from(achievements)\n\t\t\t\t.leftJoin(\n\t\t\t\t\tsql`(\n\t\t\t\t\t\tSELECT \n\t\t\t\t\t\t\tachievement_id, \n\t\t\t\t\t\t\tCOUNT(*) as completion_count \n\t\t\t\t\t\tFROM user_achievements \n\t\t\t\t\t\tWHERE is_completed = true \n\t\t\t\t\t\tGROUP BY achievement_id\n\t\t\t\t\t) as completion_stats`,\n\t\t\t\t\tsql`completion_stats.achievement_id = ${achievements.id}`\n\t\t\t\t)\n\t\t\t\t.leftJoin(\n\t\t\t\t\tsql`(SELECT COUNT(DISTINCT id) as total_users FROM users) as user_stats`,\n\t\t\t\t\tsql`true`\n\t\t\t\t)\n\t\t\t\t.leftJoin(\n\t\t\t\t\tsql`(\n\t\t\t\t\t\tSELECT \n\t\t\t\t\t\t\tachievement_id,\n\t\t\t\t\t\t\tAVG(CAST(progress_percentage AS DECIMAL)) as avg_progress\n\t\t\t\t\t\tFROM user_achievements \n\t\t\t\t\t\tGROUP BY achievement_id\n\t\t\t\t\t) as progress_stats`,\n\t\t\t\t\tsql`progress_stats.achievement_id = ${achievements.id}`\n\t\t\t\t)\n\t\t\t\t.where(eq(achievements.id, id))\n\t\t\t\t.limit(1);\n\n\t\t\tif (!result.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst achievement = result[0];\n\t\t\tconst completionRate =\n\t\t\t\tachievement.totalUsers > 0\n\t\t\t\t\t? (achievement.completionCount / achievement.totalUsers) * 100\n\t\t\t\t\t: 0;\n\n\t\t\treturn {\n\t\t\t\t...achievement,\n\t\t\t\tcompletionRate,\n\t\t\t\taverageProgress: achievement.avgProgress\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_ADMIN', 'Failed to get achievement by ID', {\n\t\t\t\tid,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get user completions for a specific achievement\n\t */\n\tasync getAchievementCompletions(\n\t\tachievementId: AchievementId,\n\t\tpage: number = 1,\n\t\tlimit: number = 50\n\t): Promise<{ completions: any[]; total: number }> {\n\t\ttry {\n\t\t\tconst offset = (page - 1) * limit;\n\n\t\t\tconst completions = await db\n\t\t\t\t.select({\n\t\t\t\t\tuserId: userAchievements.userId,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tcompletedAt: userAchievements.completedAt,\n\t\t\t\t\tprogressPercentage: userAchievements.progressPercentage,\n\t\t\t\t\tcompletionData: userAchievements.completionData\n\t\t\t\t})\n\t\t\t\t.from(userAchievements)\n\t\t\t\t.innerJoin(users, eq(userAchievements.userId, users.id))\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userAchievements.achievementId, achievementId),\n\t\t\t\t\t\teq(userAchievements.isCompleted, true)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.orderBy(desc(userAchievements.completedAt))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\tconst totalResult = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userAchievements)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userAchievements.achievementId, achievementId),\n\t\t\t\t\t\teq(userAchievements.isCompleted, true)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tcompletions,\n\t\t\t\ttotal: totalResult[0]?.count || 0\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_ADMIN', 'Failed to get achievement completions', {\n\t\t\t\tachievementId,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Manually award achievement to user(s)\n\t */\n\tasync manuallyAwardAchievement(\n\t\tachievementId: AchievementId,\n\t\tuserIds: string[],\n\t\treason?: string\n\t): Promise<void> {\n\t\ttry {\n\t\t\tconst achievement = await db\n\t\t\t\t.select()\n\t\t\t\t.from(achievements)\n\t\t\t\t.where(eq(achievements.id, achievementId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (!achievement.length) {\n\t\t\t\tthrow new Error(`Achievement with id ${achievementId} not found`);\n\t\t\t}\n\n\t\t\t// Award to each user\n\t\t\tfor (const userId of userIds) {\n\t\t\t\tawait db\n\t\t\t\t\t.insert(userAchievements)\n\t\t\t\t\t.values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tachievementId,\n\t\t\t\t\t\tisCompleted: true,\n\t\t\t\t\t\tcompletedAt: new Date(),\n\t\t\t\t\t\tprogressPercentage: '100',\n\t\t\t\t\t\tcompletionData: {\n\t\t\t\t\t\t\tmanuallyAwarded: true,\n\t\t\t\t\t\t\tawardedBy: 'admin',\n\t\t\t\t\t\t\treason: reason || 'Manually awarded by admin',\n\t\t\t\t\t\t\tawardedAt: new Date().toISOString()\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.onConflictDoUpdate({\n\t\t\t\t\t\ttarget: [userAchievements.userId, userAchievements.achievementId],\n\t\t\t\t\t\tset: {\n\t\t\t\t\t\t\tisCompleted: true,\n\t\t\t\t\t\t\tcompletedAt: new Date(),\n\t\t\t\t\t\t\tprogressPercentage: '100',\n\t\t\t\t\t\t\tcompletionData: {\n\t\t\t\t\t\t\t\tmanuallyAwarded: true,\n\t\t\t\t\t\t\t\tawardedBy: 'admin',\n\t\t\t\t\t\t\t\treason: reason || 'Manually awarded by admin',\n\t\t\t\t\t\t\t\tawardedAt: new Date().toISOString()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tlogger.info('ACHIEVEMENT_ADMIN', 'Manually awarded achievement', {\n\t\t\t\tachievementId,\n\t\t\t\tuserIds,\n\t\t\t\treason,\n\t\t\t\tuserCount: userIds.length\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_ADMIN', 'Failed to manually award achievement', {\n\t\t\t\tachievementId,\n\t\t\t\tuserIds,\n\t\t\t\treason,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Validate trigger configuration\n\t */\n\tprivate validateTriggerConfig(triggerType: string, config: any): void {\n\t\tswitch (triggerType) {\n\t\t\tcase 'count':\n\t\t\t\tif (!config.action || typeof config.target !== 'number') {\n\t\t\t\t\tthrow new Error('Count trigger requires action and numeric target');\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'threshold':\n\t\t\t\tif (!config.metric || typeof config.target !== 'number') {\n\t\t\t\t\tthrow new Error('Threshold trigger requires metric and numeric target');\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'event':\n\t\t\t\tif (!config.eventType) {\n\t\t\t\t\tthrow new Error('Event trigger requires eventType');\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'composite':\n\t\t\t\tif (!Array.isArray(config.requirements) || config.requirements.length === 0) {\n\t\t\t\t\tthrow new Error('Composite trigger requires requirements array');\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'custom':\n\t\t\t\tif (!config.evaluator || !this.evaluators.canHandle(config.evaluator)) {\n\t\t\t\t\tthrow new Error('Custom trigger requires valid evaluator');\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'manual':\n\t\t\t\t// Manual triggers don't need validation\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown trigger type: ${triggerType}`);\n\t\t}\n\t}\n\n\t/**\n\t * Generate a unique key from achievement name\n\t */\n\tprivate generateAchievementKey(name: string): string {\n\t\treturn name\n\t\t\t.toLowerCase()\n\t\t\t.replace(/[^a-z0-9\\s]/g, '')\n\t\t\t.replace(/\\s+/g, '_')\n\t\t\t.substring(0, 100);\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/achievements/achievement-processor.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":15},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":486,"column":5,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":494,"endColumn":8},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":498,"column":5,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":506,"endColumn":8},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":528,"column":6,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":528,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eventData' is defined but never used.","line":558,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":558,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Processor Service\n *\n * Processes achievement events and updates user progress.\n * Handles the core logic for checking requirements and awarding achievements.\n */\n\nimport { db } from '@db';\nimport { eq, and, desc, count, sql } from 'drizzle-orm';\nimport { achievements, userAchievements, achievementEvents } from '@schema';\nimport type { Achievement, UserAchievement } from '@schema';\nimport type { AchievementEventType } from '@schema';\nimport { users } from '@schema';\nimport { logger } from '../../../core/logger';\nimport { XpService } from '../../xp/xp.service';\nimport { DegenAchievementEvaluators } from './evaluators/degen-evaluators';\nimport type { UserId, AchievementId } from '@shared/types/ids';\n\nexport interface AchievementProgress {\n\tcurrent: number;\n\ttarget: number;\n\tpercentage: number;\n\tisCompleted: boolean;\n\tdata?: any;\n}\n\nexport class AchievementProcessorService {\n\tprivate xpService = new XpService();\n\tprivate evaluators = new DegenAchievementEvaluators();\n\n\t/**\n\t * Process a single achievement event\n\t */\n\tasync processEvent(\n\t\teventType: AchievementEventType,\n\t\tuserId: UserId,\n\t\teventData: any\n\t): Promise<void> {\n\t\ttry {\n\t\t\t// Get all active achievements that could be triggered by this event\n\t\t\tconst triggeredAchievements = await this.getTriggeredAchievements(eventType);\n\n\t\t\tfor (const achievement of triggeredAchievements) {\n\t\t\t\tawait this.updateUserProgress(userId, achievement, eventData);\n\t\t\t}\n\n\t\t\t// Mark event as processed\n\t\t\tawait this.markEventProcessed(eventType, userId, eventData);\n\n\t\t\tlogger.info('ACHIEVEMENT_PROCESSOR', `Processed ${eventType} for user ${userId}`, {\n\t\t\t\teventType,\n\t\t\t\tuserId,\n\t\t\t\tachievementCount: triggeredAchievements.length\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_PROCESSOR', `Failed to process ${eventType} event`, {\n\t\t\t\teventType,\n\t\t\t\tuserId,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get achievements that can be triggered by an event type\n\t */\n\tprivate async getTriggeredAchievements(eventType: AchievementEventType): Promise<Achievement[]> {\n\t\t// Get achievements where the trigger config matches this event type\n\t\tconst allAchievements = await db\n\t\t\t.select()\n\t\t\t.from(achievements)\n\t\t\t.where(eq(achievements.isActive, true));\n\n\t\treturn allAchievements.filter((achievement) => {\n\t\t\tconst config = achievement.triggerConfig as any;\n\n\t\t\t// Check different trigger types\n\t\t\tswitch (achievement.triggerType) {\n\t\t\t\tcase 'count':\n\t\t\t\tcase 'threshold':\n\t\t\t\t\treturn config.action && this.mapEventToAction(eventType) === config.action;\n\n\t\t\t\tcase 'event':\n\t\t\t\t\treturn config.eventType === eventType;\n\n\t\t\t\tcase 'custom':\n\t\t\t\t\treturn (\n\t\t\t\t\t\tconfig.eventTypes?.includes(eventType) ||\n\t\t\t\t\t\tthis.evaluators.canHandle(config.evaluator, eventType)\n\t\t\t\t\t);\n\n\t\t\t\tcase 'composite':\n\t\t\t\t\treturn config.requirements?.some(\n\t\t\t\t\t\t(req: any) => this.mapEventToAction(eventType) === req.action\n\t\t\t\t\t);\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Map event types to action names for trigger matching\n\t */\n\tprivate mapEventToAction(eventType: AchievementEventType): string {\n\t\tconst mapping: Record<AchievementEventType, string> = {\n\t\t\tpost_created: 'posts_created',\n\t\t\tthread_created: 'threads_created',\n\t\t\tuser_login: 'login_count',\n\t\t\ttip_sent: 'tips_sent',\n\t\t\ttip_received: 'tips_received',\n\t\t\tshoutbox_message: 'shoutbox_messages',\n\t\t\tlike_given: 'likes_given',\n\t\t\tlike_received: 'likes_received',\n\t\t\tuser_mentioned: 'mentions_received',\n\t\t\tdaily_streak: 'daily_streaks',\n\t\t\twallet_loss: 'wallet_losses',\n\t\t\tthread_necromancy: 'thread_necromancies',\n\t\t\tcrash_sentiment: 'crash_sentiments',\n\t\t\tdiamond_hands: 'diamond_hands_events',\n\t\t\tpaper_hands: 'paper_hands_events',\n\t\t\tmarket_prediction: 'market_predictions',\n\t\t\tthread_locked: 'threads_locked',\n\t\t\tcustom_event: 'custom_events'\n\t\t};\n\n\t\treturn mapping[eventType] || eventType;\n\t}\n\n\t/**\n\t * Update user progress for a specific achievement\n\t */\n\tprivate async updateUserProgress(\n\t\tuserId: UserId,\n\t\tachievement: Achievement,\n\t\teventData: any\n\t): Promise<void> {\n\t\ttry {\n\t\t\t// Get current user achievement record\n\t\t\tconst userAchievement = await this.getUserAchievement(userId, achievement.id);\n\n\t\t\t// Skip if already completed\n\t\t\tif (userAchievement?.isCompleted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate new progress\n\t\t\tconst progress = await this.calculateProgress(achievement, userId, eventData);\n\n\t\t\tif (progress.isCompleted && !userAchievement?.isCompleted) {\n\t\t\t\tawait this.completeAchievement(userId, achievement, progress);\n\t\t\t} else if (progress.current > 0) {\n\t\t\t\tawait this.updateProgress(userId, achievement, progress);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_PROCESSOR', 'Failed to update user progress', {\n\t\t\t\tuserId,\n\t\t\t\tachievementId: achievement.id,\n\t\t\t\tachievementKey: achievement.key,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculate achievement progress based on trigger type\n\t */\n\tprivate async calculateProgress(\n\t\tachievement: Achievement,\n\t\tuserId: UserId,\n\t\teventData: any\n\t): Promise<AchievementProgress> {\n\t\tconst config = achievement.triggerConfig as any;\n\n\t\tswitch (achievement.triggerType) {\n\t\t\tcase 'count':\n\t\t\t\treturn await this.calculateCountProgress(achievement, userId, config);\n\n\t\t\tcase 'threshold':\n\t\t\t\treturn await this.calculateThresholdProgress(achievement, userId, config);\n\n\t\t\tcase 'event':\n\t\t\t\treturn await this.calculateEventProgress(achievement, userId, config, eventData);\n\n\t\t\tcase 'composite':\n\t\t\t\treturn await this.calculateCompositeProgress(achievement, userId, config);\n\n\t\t\tcase 'custom':\n\t\t\t\treturn await this.calculateCustomProgress(achievement, userId, config, eventData);\n\n\t\t\tdefault:\n\t\t\t\treturn { current: 0, target: 1, percentage: 0, isCompleted: false };\n\t\t}\n\t}\n\n\t/**\n\t * Calculate progress for count-based achievements\n\t */\n\tprivate async calculateCountProgress(\n\t\tachievement: Achievement,\n\t\tuserId: UserId,\n\t\tconfig: any\n\t): Promise<AchievementProgress> {\n\t\tconst action = config.action;\n\t\tconst target = config.target || 1;\n\n\t\t// Count relevant events for this user\n\t\tconst eventType = this.actionToEventType(action);\n\t\tconst result = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, eventType),\n\t\t\t\t\teq(achievementEvents.processingStatus, 'completed')\n\t\t\t\t)\n\t\t\t);\n\n\t\tconst current = result[0]?.count || 0;\n\t\tconst percentage = Math.min((current / target) * 100, 100);\n\n\t\treturn {\n\t\t\tcurrent,\n\t\t\ttarget,\n\t\t\tpercentage,\n\t\t\tisCompleted: current >= target\n\t\t};\n\t}\n\n\t/**\n\t * Calculate progress for threshold-based achievements\n\t */\n\tprivate async calculateThresholdProgress(\n\t\tachievement: Achievement,\n\t\tuserId: UserId,\n\t\tconfig: any\n\t): Promise<AchievementProgress> {\n\t\t// Similar to count but may use different data sources\n\t\tconst metric = config.metric;\n\t\tconst target = config.target;\n\n\t\t// Get current value from user data or calculated metric\n\t\tconst current = await this.getUserMetric(userId, metric);\n\t\tconst percentage = Math.min((current / target) * 100, 100);\n\n\t\treturn {\n\t\t\tcurrent,\n\t\t\ttarget,\n\t\t\tpercentage,\n\t\t\tisCompleted: current >= target\n\t\t};\n\t}\n\n\t/**\n\t * Calculate progress for event-based achievements (single occurrence)\n\t */\n\tprivate async calculateEventProgress(\n\t\tachievement: Achievement,\n\t\tuserId: UserId,\n\t\tconfig: any,\n\t\teventData: any\n\t): Promise<AchievementProgress> {\n\t\t// Check if the event conditions are met\n\t\tconst conditionsMet = await this.checkEventConditions(config.conditions || [], eventData);\n\n\t\treturn {\n\t\t\tcurrent: conditionsMet ? 1 : 0,\n\t\t\ttarget: 1,\n\t\t\tpercentage: conditionsMet ? 100 : 0,\n\t\t\tisCompleted: conditionsMet\n\t\t};\n\t}\n\n\t/**\n\t * Calculate progress for composite achievements (multiple requirements)\n\t */\n\tprivate async calculateCompositeProgress(\n\t\tachievement: Achievement,\n\t\tuserId: UserId,\n\t\tconfig: any\n\t): Promise<AchievementProgress> {\n\t\tconst requirements = config.requirements || [];\n\t\tconst operator = config.operator || 'AND';\n\n\t\tlet completedRequirements = 0;\n\n\t\tfor (const requirement of requirements) {\n\t\t\tconst reqProgress = await this.calculateCountProgress(achievement, userId, requirement);\n\t\t\tif (reqProgress.isCompleted) {\n\t\t\t\tcompletedRequirements++;\n\t\t\t}\n\t\t}\n\n\t\tconst isCompleted =\n\t\t\toperator === 'AND'\n\t\t\t\t? completedRequirements === requirements.length\n\t\t\t\t: completedRequirements > 0;\n\n\t\tconst percentage = (completedRequirements / requirements.length) * 100;\n\n\t\treturn {\n\t\t\tcurrent: completedRequirements,\n\t\t\ttarget: requirements.length,\n\t\t\tpercentage,\n\t\t\tisCompleted\n\t\t};\n\t}\n\n\t/**\n\t * Calculate progress for custom achievements using evaluators\n\t */\n\tprivate async calculateCustomProgress(\n\t\tachievement: Achievement,\n\t\tuserId: UserId,\n\t\tconfig: any,\n\t\teventData: any\n\t): Promise<AchievementProgress> {\n\t\tconst evaluator = config.evaluator;\n\n\t\tif (!this.evaluators.canHandle(evaluator)) {\n\t\t\tlogger.warn('ACHIEVEMENT_PROCESSOR', `Unknown evaluator: ${evaluator}`);\n\t\t\treturn { current: 0, target: 1, percentage: 0, isCompleted: false };\n\t\t}\n\n\t\tconst isCompleted = await this.evaluators.evaluate(evaluator, userId, config.config || {});\n\n\t\treturn {\n\t\t\tcurrent: isCompleted ? 1 : 0,\n\t\t\ttarget: 1,\n\t\t\tpercentage: isCompleted ? 100 : 0,\n\t\t\tisCompleted,\n\t\t\tdata: eventData\n\t\t};\n\t}\n\n\t/**\n\t * Complete an achievement for a user\n\t */\n\tprivate async completeAchievement(\n\t\tuserId: UserId,\n\t\tachievement: Achievement,\n\t\tprogress: AchievementProgress\n\t): Promise<void> {\n\t\ttry {\n\t\t\t// Mark achievement as completed\n\t\t\tawait db\n\t\t\t\t.insert(userAchievements)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\tachievementId: achievement.id,\n\t\t\t\t\tcurrentProgress: progress.data || {},\n\t\t\t\t\tprogressPercentage: progress.percentage.toString(),\n\t\t\t\t\tisCompleted: true,\n\t\t\t\t\tcompletedAt: new Date(),\n\t\t\t\t\tcompletionData: {\n\t\t\t\t\t\tcompletedAt: new Date().toISOString(),\n\t\t\t\t\t\tfinalProgress: progress\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.onConflictDoUpdate({\n\t\t\t\t\ttarget: [userAchievements.userId, userAchievements.achievementId],\n\t\t\t\t\tset: {\n\t\t\t\t\t\tisCompleted: true,\n\t\t\t\t\t\tcompletedAt: new Date(),\n\t\t\t\t\t\tprogressPercentage: progress.percentage.toString(),\n\t\t\t\t\t\tcompletionData: {\n\t\t\t\t\t\t\tcompletedAt: new Date().toISOString(),\n\t\t\t\t\t\t\tfinalProgress: progress\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t// Distribute rewards\n\t\t\tawait this.distributeRewards(userId, achievement);\n\n\t\t\t// Log achievement completion\n\t\t\tlogger.info(\n\t\t\t\t'ACHIEVEMENT_COMPLETED',\n\t\t\t\t`User ${userId} completed achievement ${achievement.key}`,\n\t\t\t\t{\n\t\t\t\t\tuserId,\n\t\t\t\t\tachievementId: achievement.id,\n\t\t\t\t\tachievementKey: achievement.key,\n\t\t\t\t\tachievementName: achievement.name,\n\t\t\t\t\trewardXp: achievement.rewardXp,\n\t\t\t\t\trewardDgt: achievement.rewardDgt\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_PROCESSOR', 'Failed to complete achievement', {\n\t\t\t\tuserId,\n\t\t\t\tachievementId: achievement.id,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update achievement progress (partial completion)\n\t */\n\tprivate async updateProgress(\n\t\tuserId: UserId,\n\t\tachievement: Achievement,\n\t\tprogress: AchievementProgress\n\t): Promise<void> {\n\t\tawait db\n\t\t\t.insert(userAchievements)\n\t\t\t.values({\n\t\t\t\tuserId,\n\t\t\t\tachievementId: achievement.id,\n\t\t\t\tcurrentProgress: progress.data || {},\n\t\t\t\tprogressPercentage: progress.percentage.toString(),\n\t\t\t\tisCompleted: false\n\t\t\t})\n\t\t\t.onConflictDoUpdate({\n\t\t\t\ttarget: [userAchievements.userId, userAchievements.achievementId],\n\t\t\t\tset: {\n\t\t\t\t\tcurrentProgress: progress.data || {},\n\t\t\t\t\tprogressPercentage: progress.percentage.toString()\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Distribute rewards for completed achievement\n\t */\n\tprivate async distributeRewards(userId: UserId, achievement: Achievement): Promise<void> {\n\t\ttry {\n\t\t\t// Award XP\n\t\t\tif (achievement.rewardXp > 0) {\n\t\t\t\tawait this.xpService.awardXP(userId, achievement.rewardXp, 'achievement_unlock');\n\t\t\t}\n\n\t\t\t// Award DGT (integrate with existing DGT service)\n\t\t\tif (achievement.rewardDgt > 0) {\n\t\t\t\t// TODO: Integrate with DGT service\n\t\t\t\tlogger.info(\n\t\t\t\t\t'ACHIEVEMENT_REWARD',\n\t\t\t\t\t`Would award ${achievement.rewardDgt} DGT to user ${userId}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Award Clout (integrate with existing Clout service)\n\t\t\tif (achievement.rewardClout > 0) {\n\t\t\t\t// TODO: Integrate with Clout service\n\t\t\t\tlogger.info(\n\t\t\t\t\t'ACHIEVEMENT_REWARD',\n\t\t\t\t\t`Would award ${achievement.rewardClout} Clout to user ${userId}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// TODO: Handle title and badge rewards when those systems are integrated\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_PROCESSOR', 'Failed to distribute rewards', {\n\t\t\t\tuserId,\n\t\t\t\tachievementId: achievement.id,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Helper methods\n\t */\n\tprivate async getUserAchievement(\n\t\tuserId: UserId,\n\t\tachievementId: AchievementId\n\t): Promise<UserAchievement | null> {\n\t\tconst result = await db\n\t\t\t.select()\n\t\t\t.from(userAchievements)\n\t\t\t.where(\n\t\t\t\tand(eq(userAchievements.userId, userId), eq(userAchievements.achievementId, achievementId))\n\t\t\t)\n\t\t\t.limit(1);\n\n\t\treturn result[0] || null;\n\t}\n\n\tprivate async getUserMetric(userId: UserId, metric: string): Promise<number> {\n\t\t// Get user metrics from users table or calculate from events\n\t\tswitch (metric) {\n\t\t\tcase 'total_posts':\n\t\t\t\tconst posts = await db\n\t\t\t\t\t.select({ count: count() })\n\t\t\t\t\t.from(achievementEvents)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\t\t\teq(achievementEvents.eventType, 'post_created')\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\treturn posts[0]?.count || 0;\n\n\t\t\tcase 'total_threads':\n\t\t\t\tconst threads = await db\n\t\t\t\t\t.select({ count: count() })\n\t\t\t\t\t.from(achievementEvents)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\t\t\teq(achievementEvents.eventType, 'thread_created')\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\treturn threads[0]?.count || 0;\n\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate async checkEventConditions(conditions: any[], eventData: any): Promise<boolean> {\n\t\treturn conditions.every((condition) => {\n\t\t\tconst fieldValue = this.getNestedValue(eventData, condition.field);\n\n\t\t\tswitch (condition.operation) {\n\t\t\t\tcase 'equals':\n\t\t\t\t\treturn fieldValue === condition.value;\n\t\t\t\tcase 'greater_than':\n\t\t\t\t\treturn fieldValue > condition.value;\n\t\t\t\tcase 'less_than':\n\t\t\t\t\treturn fieldValue < condition.value;\n\t\t\t\tcase 'contains':\n\t\t\t\t\treturn String(fieldValue).includes(condition.value);\n\t\t\t\tcase 'within_seconds':\n\t\t\t\t\tconst timeDiff = Date.now() - new Date(fieldValue).getTime();\n\t\t\t\t\treturn timeDiff <= condition.value * 1000;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate getNestedValue(obj: any, path: string): any {\n\t\treturn path.split('.').reduce((current, key) => current?.[key], obj);\n\t}\n\n\tprivate actionToEventType(action: string): AchievementEventType {\n\t\tconst mapping: Record<string, AchievementEventType> = {\n\t\t\tposts_created: 'post_created',\n\t\t\tthreads_created: 'thread_created',\n\t\t\tlogin_count: 'user_login',\n\t\t\ttips_sent: 'tip_sent',\n\t\t\ttips_received: 'tip_received',\n\t\t\tshoutbox_messages: 'shoutbox_message',\n\t\t\tlikes_given: 'like_given',\n\t\t\tlikes_received: 'like_received'\n\t\t};\n\n\t\treturn mapping[action] || 'custom_event';\n\t}\n\n\tprivate async markEventProcessed(\n\t\teventType: AchievementEventType,\n\t\tuserId: UserId,\n\t\teventData: any\n\t): Promise<void> {\n\t\tawait db\n\t\t\t.update(achievementEvents)\n\t\t\t.set({\n\t\t\t\tprocessingStatus: 'completed',\n\t\t\t\tprocessedAt: new Date()\n\t\t\t})\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, eventType),\n\t\t\t\t\teq(achievementEvents.processingStatus, 'pending')\n\t\t\t\t)\n\t\t\t);\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/achievements/achievement.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":21,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'category' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":36,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tier' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":36,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":480,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":480,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'__' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":481,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":481,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'___' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":482,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":482,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'____' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":483,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":483,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Controller\n *\n * HTTP endpoints for achievement management, admin operations,\n * and user achievement tracking.\n */\n\nimport type { Request, Response } from 'express';\nimport type { AchievementId } from '@shared/types/ids';\nimport { AchievementProcessorService } from './achievement-processor.service';\nimport { AchievementAdminService } from './achievement-admin.service';\nimport { AchievementEventEmitter } from '../../../core/events/achievement-events.service';\nimport {\n\tgetAllAchievementTemplates,\n\tgetTemplateById,\n\tgetTemplatesByTags,\n\tgetTemplatesByCategory\n} from './templates/achievement-templates';\nimport { logger } from '../../../core/logger';\nimport { db } from '@db';\nimport { eq, and, desc, count } from 'drizzle-orm';\nimport { achievements, userAchievements } from '@schema';\nimport type { AchievementEventType } from '@schema';\n\nexport class AchievementController {\n\tprivate processorService = new AchievementProcessorService();\n\tprivate adminService = new AchievementAdminService();\n\n\t/**\n\t * Get user's achievements with progress\n\t * GET /api/achievements/user/:userId\n\t */\n\tasync getUserAchievements(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { userId } = req.params;\n\t\t\tconst { completed, category, tier } = req.query;\n\n\t\t\tconst whereConditions: any[] = [eq(userAchievements.userId, userId)];\n\n\t\t\tif (completed === 'true') {\n\t\t\t\twhereConditions.push(eq(userAchievements.isCompleted, true));\n\t\t\t} else if (completed === 'false') {\n\t\t\t\twhereConditions.push(eq(userAchievements.isCompleted, false));\n\t\t\t}\n\n\t\t\tconst userAchievementsData = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: userAchievements.id,\n\t\t\t\t\tachievementId: userAchievements.achievementId,\n\t\t\t\t\tcurrentProgress: userAchievements.currentProgress,\n\t\t\t\t\tprogressPercentage: userAchievements.progressPercentage,\n\t\t\t\t\tisCompleted: userAchievements.isCompleted,\n\t\t\t\t\tcompletedAt: userAchievements.completedAt,\n\t\t\t\t\tachievement: {\n\t\t\t\t\t\tid: achievements.id,\n\t\t\t\t\t\tkey: achievements.key,\n\t\t\t\t\t\tname: achievements.name,\n\t\t\t\t\t\tdescription: achievements.description,\n\t\t\t\t\t\tcategory: achievements.category,\n\t\t\t\t\t\ttier: achievements.tier,\n\t\t\t\t\t\ticonUrl: achievements.iconUrl,\n\t\t\t\t\t\ticonEmoji: achievements.iconEmoji,\n\t\t\t\t\t\trewardXp: achievements.rewardXp,\n\t\t\t\t\t\trewardDgt: achievements.rewardDgt,\n\t\t\t\t\t\trewardClout: achievements.rewardClout,\n\t\t\t\t\t\tisSecret: achievements.isSecret,\n\t\t\t\t\t\tunlockMessage: achievements.unlockMessage\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.from(userAchievements)\n\t\t\t\t.innerJoin(achievements, eq(userAchievements.achievementId, achievements.id))\n\t\t\t\t.where(and(...whereConditions))\n\t\t\t\t.orderBy(desc(userAchievements.completedAt));\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: userAchievementsData\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to get user achievements', {\n\t\t\t\tuserId: req.params.userId,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to get user achievements'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get all available achievements\n\t * GET /api/achievements\n\t */\n\tasync getAchievements(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst {\n\t\t\t\tcategory,\n\t\t\t\ttier,\n\t\t\t\ttriggerType,\n\t\t\t\tisActive = 'true',\n\t\t\t\tisSecret,\n\t\t\t\tsearch,\n\t\t\t\tpage = '1',\n\t\t\t\tlimit = '50'\n\t\t\t} = req.query;\n\n\t\t\tconst filters = {\n\t\t\t\tcategory: category as any,\n\t\t\t\ttier: tier as any,\n\t\t\t\ttriggerType: triggerType as any,\n\t\t\t\tisActive: isActive === 'true',\n\t\t\t\tisSecret: isSecret === 'true' ? true : isSecret === 'false' ? false : undefined,\n\t\t\t\tsearch: search as string\n\t\t\t};\n\n\t\t\tconst result = await this.adminService.getAchievements(\n\t\t\t\tfilters,\n\t\t\t\tparseInt(page as string),\n\t\t\t\tparseInt(limit as string)\n\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: result.achievements,\n\t\t\t\tpagination: {\n\t\t\t\t\tpage: parseInt(page as string),\n\t\t\t\t\tlimit: parseInt(limit as string),\n\t\t\t\t\ttotal: result.total,\n\t\t\t\t\tpages: Math.ceil(result.total / parseInt(limit as string))\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to get achievements', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to get achievements'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get achievement statistics\n\t * GET /api/achievements/stats\n\t */\n\tasync getAchievementStats(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst stats = await this.adminService.getAchievementStats();\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: stats\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to get achievement stats', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to get achievement stats'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get specific achievement details\n\t * GET /api/achievements/:id\n\t */\n\tasync getAchievementById(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\tconst achievement = await this.adminService.getAchievementById(id as AchievementId);\n\n\t\t\tif (!achievement) {\n\t\t\t\tres.status(404).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Achievement not found'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: achievement\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to get achievement', {\n\t\t\t\tid: req.params.id,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to get achievement'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create new achievement\n\t * POST /api/achievements\n\t */\n\tasync createAchievement(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst achievement = await this.adminService.createAchievement(req.body);\n\n\t\t\tres.status(201).json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: achievement\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to create achievement', {\n\t\t\t\tbody: req.body,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to create achievement'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update achievement\n\t * PUT /api/achievements/:id\n\t */\n\tasync updateAchievement(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\tconst achievement = await this.adminService.updateAchievement(id as AchievementId, req.body);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: achievement\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to update achievement', {\n\t\t\t\tid: req.params.id,\n\t\t\t\tbody: req.body,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to update achievement'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Delete achievement\n\t * DELETE /api/achievements/:id\n\t */\n\tasync deleteAchievement(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\tawait this.adminService.deleteAchievement(id as AchievementId);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Achievement deleted successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to delete achievement', {\n\t\t\t\tid: req.params.id,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to delete achievement'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Bulk update achievements\n\t * PUT /api/achievements/bulk\n\t */\n\tasync bulkUpdateAchievements(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { ids, updates } = req.body;\n\t\t\tconst achievements = await this.adminService.bulkUpdateAchievements(ids, updates);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: achievements,\n\t\t\t\tmessage: `Updated ${achievements.length} achievements`\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to bulk update achievements', {\n\t\t\t\tbody: req.body,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to bulk update achievements'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get achievement completions\n\t * GET /api/achievements/:id/completions\n\t */\n\tasync getAchievementCompletions(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\tconst { page = '1', limit = '50' } = req.query;\n\n\t\t\tconst result = await this.adminService.getAchievementCompletions(\n\t\t\t\tid as AchievementId,\n\t\t\t\tparseInt(page as string),\n\t\t\t\tparseInt(limit as string)\n\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: result.completions,\n\t\t\t\tpagination: {\n\t\t\t\t\tpage: parseInt(page as string),\n\t\t\t\t\tlimit: parseInt(limit as string),\n\t\t\t\t\ttotal: result.total,\n\t\t\t\t\tpages: Math.ceil(result.total / parseInt(limit as string))\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to get achievement completions', {\n\t\t\t\tid: req.params.id,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to get achievement completions'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Manually award achievement\n\t * POST /api/achievements/:id/award\n\t */\n\tasync manuallyAwardAchievement(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { id } = req.params;\n\t\t\tconst { userIds, reason } = req.body;\n\n\t\t\tawait this.adminService.manuallyAwardAchievement(id as AchievementId, userIds, reason);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Achievement awarded to ${userIds.length} users`\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to manually award achievement', {\n\t\t\t\tid: req.params.id,\n\t\t\t\tbody: req.body,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to award achievement'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Emit achievement event (for testing/debugging)\n\t * POST /api/achievements/events/emit\n\t */\n\tasync emitAchievementEvent(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { eventType, userId, eventData } = req.body;\n\n\t\t\t// Validate event type\n\t\t\tconst validEventTypes: AchievementEventType[] = [\n\t\t\t\t'post_created',\n\t\t\t\t'thread_created',\n\t\t\t\t'user_login',\n\t\t\t\t'tip_sent',\n\t\t\t\t'tip_received',\n\t\t\t\t'shoutbox_message',\n\t\t\t\t'wallet_loss',\n\t\t\t\t'thread_necromancy',\n\t\t\t\t'like_given',\n\t\t\t\t'like_received',\n\t\t\t\t'thread_locked',\n\t\t\t\t'user_mentioned',\n\t\t\t\t'daily_streak',\n\t\t\t\t'crash_sentiment',\n\t\t\t\t'diamond_hands',\n\t\t\t\t'paper_hands',\n\t\t\t\t'market_prediction',\n\t\t\t\t'custom_event'\n\t\t\t];\n\n\t\t\tif (!validEventTypes.includes(eventType)) {\n\t\t\t\tres.status(400).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Invalid event type'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit the event\n\t\t\tawait AchievementEventEmitter.emitCustomEvent(eventType, userId, eventData);\n\n\t\t\t// Process the event\n\t\t\tawait this.processorService.processEvent(eventType, userId, eventData);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Event emitted and processed successfully'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to emit achievement event', {\n\t\t\t\tbody: req.body,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to emit event'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get achievement templates\n\t * GET /api/achievements/templates\n\t */\n\tasync getAchievementTemplates(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { category, tags } = req.query;\n\n\t\t\tlet templates;\n\n\t\t\tif (category) {\n\t\t\t\ttemplates = getTemplatesByCategory(category as string);\n\t\t\t} else if (tags) {\n\t\t\t\tconst tagArray = (tags as string).split(',').map((tag) => tag.trim());\n\t\t\t\ttemplates = getTemplatesByTags(tagArray);\n\t\t\t} else {\n\t\t\t\ttemplates = getAllAchievementTemplates();\n\t\t\t}\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: templates\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to get achievement templates', {\n\t\t\t\tquery: req.query,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'Failed to get achievement templates'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create achievement from template\n\t * POST /api/achievements/templates/:templateId/create\n\t */\n\tasync createFromTemplate(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst { templateId } = req.params;\n\t\t\tconst template = getTemplateById(templateId);\n\n\t\t\tif (!template) {\n\t\t\t\tres.status(404).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Template not found'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Extract achievement data from template (remove template-specific fields)\n\t\t\tconst {\n\t\t\t\ttemplateId: _,\n\t\t\t\ttemplateName: __,\n\t\t\t\ttemplateDescription: ___,\n\t\t\t\ttags: ____,\n\t\t\t\t...achievementData\n\t\t\t} = template;\n\n\t\t\t// Create achievement with optional overrides from request body\n\t\t\tconst finalData = {\n\t\t\t\t...achievementData,\n\t\t\t\t...req.body\n\t\t\t};\n\n\t\t\tconst achievement = await this.adminService.createAchievement(finalData);\n\n\t\t\tres.status(201).json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: achievement,\n\t\t\t\tmessage: `Achievement created from template: ${template.templateName}`\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ACHIEVEMENT_CONTROLLER', 'Failed to create achievement from template', {\n\t\t\t\ttemplateId: req.params.templateId,\n\t\t\t\tbody: req.body,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error instanceof Error ? error.message : 'Failed to create achievement from template'\n\t\t\t});\n\t\t}\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/achievements/achievement.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/achievements/evaluators/degen-evaluators.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'between' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eventType' is defined but never used.","line":22,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'crashKeywords' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":333,"column":4,"nodeType":"Identifier","messageId":"unusedVar","endLine":333,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resistedSellSignals' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":366,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":366,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Degen Achievement Evaluators\n *\n * Custom evaluators for culturally-specific \"degen\" achievements that require\n * complex logic beyond simple counting or thresholds.\n */\n\nimport { db } from '@db';\nimport { eq, and, count, desc, sql, gte, lte, between } from 'drizzle-orm';\nimport { achievementEvents, users } from '@schema';\nimport { logger } from '../../../../core/logger';\nimport type { AchievementEventType } from '@schema';\n\nexport interface EvaluatorConfig {\n\t[key: string]: any;\n}\n\nexport class DegenAchievementEvaluators {\n\t/**\n\t * Check if this evaluator can handle a specific achievement\n\t */\n\tcanHandle(evaluator: string, eventType?: AchievementEventType): boolean {\n\t\tconst handlers = [\n\t\t\t'check_wallet_loss',\n\t\t\t'check_diamond_hands',\n\t\t\t'check_paper_hands',\n\t\t\t'check_crash_sentiment',\n\t\t\t'check_thread_necromancy',\n\t\t\t'check_shoutbox_spam',\n\t\t\t'check_tip_whale',\n\t\t\t'check_market_prophet',\n\t\t\t'check_degen_combo',\n\t\t\t'check_panic_poster',\n\t\t\t'check_hodl_mentality',\n\t\t\t'check_fomo_master',\n\t\t\t'check_loss_recovery',\n\t\t\t'check_weekend_warrior',\n\t\t\t'check_night_owl',\n\t\t\t'check_meme_lord',\n\t\t\t'check_contrarian',\n\t\t\t'check_moon_mission'\n\t\t];\n\n\t\treturn handlers.includes(evaluator);\n\t}\n\n\t/**\n\t * Evaluate a specific achievement condition\n\t */\n\tasync evaluate(evaluator: string, userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\ttry {\n\t\t\tswitch (evaluator) {\n\t\t\t\tcase 'check_wallet_loss':\n\t\t\t\t\treturn await this.checkWalletLoss(userId, config);\n\n\t\t\t\tcase 'check_diamond_hands':\n\t\t\t\t\treturn await this.checkDiamondHands(userId, config);\n\n\t\t\t\tcase 'check_paper_hands':\n\t\t\t\t\treturn await this.checkPaperHands(userId, config);\n\n\t\t\t\tcase 'check_crash_sentiment':\n\t\t\t\t\treturn await this.checkCrashSentiment(userId, config);\n\n\t\t\t\tcase 'check_thread_necromancy':\n\t\t\t\t\treturn await this.checkThreadNecromancy(userId, config);\n\n\t\t\t\tcase 'check_shoutbox_spam':\n\t\t\t\t\treturn await this.checkShoutboxSpam(userId, config);\n\n\t\t\t\tcase 'check_tip_whale':\n\t\t\t\t\treturn await this.checkTipWhale(userId, config);\n\n\t\t\t\tcase 'check_market_prophet':\n\t\t\t\t\treturn await this.checkMarketProphet(userId, config);\n\n\t\t\t\tcase 'check_degen_combo':\n\t\t\t\t\treturn await this.checkDegenCombo(userId, config);\n\n\t\t\t\tcase 'check_panic_poster':\n\t\t\t\t\treturn await this.checkPanicPoster(userId, config);\n\n\t\t\t\tcase 'check_hodl_mentality':\n\t\t\t\t\treturn await this.checkHodlMentality(userId, config);\n\n\t\t\t\tcase 'check_fomo_master':\n\t\t\t\t\treturn await this.checkFomoMaster(userId, config);\n\n\t\t\t\tcase 'check_loss_recovery':\n\t\t\t\t\treturn await this.checkLossRecovery(userId, config);\n\n\t\t\t\tcase 'check_weekend_warrior':\n\t\t\t\t\treturn await this.checkWeekendWarrior(userId, config);\n\n\t\t\t\tcase 'check_night_owl':\n\t\t\t\t\treturn await this.checkNightOwl(userId, config);\n\n\t\t\t\tcase 'check_meme_lord':\n\t\t\t\t\treturn await this.checkMemeLord(userId, config);\n\n\t\t\t\tcase 'check_contrarian':\n\t\t\t\t\treturn await this.checkContrarian(userId, config);\n\n\t\t\t\tcase 'check_moon_mission':\n\t\t\t\t\treturn await this.checkMoonMission(userId, config);\n\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.warn('DEGEN_EVALUATOR', `Unknown evaluator: ${evaluator}`);\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('DEGEN_EVALUATOR', `Failed to evaluate ${evaluator}`, {\n\t\t\t\tevaluator,\n\t\t\t\tuserId,\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Check for significant wallet losses (bag holder achievements)\n\t */\n\tprivate async checkWalletLoss(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { minimumLoss = 1000, timeframe = 24 } = config;\n\n\t\tconst lossEvents = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'wallet_loss'),\n\t\t\t\t\tgte(achievementEvents.triggeredAt, sql`now() - interval '${timeframe} hours'`)\n\t\t\t\t)\n\t\t\t);\n\n\t\tconst totalLoss = lossEvents.reduce((sum, event) => {\n\t\t\tconst data = event.eventData as any;\n\t\t\treturn sum + (data.lossAmount || 0);\n\t\t}, 0);\n\n\t\treturn totalLoss >= minimumLoss;\n\t}\n\n\t/**\n\t * Check for diamond hands behavior (holding through adversity)\n\t */\n\tprivate async checkDiamondHands(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { minimumHoldDays = 30, minimumDrawdown = 50 } = config;\n\n\t\tconst diamondEvents = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(eq(achievementEvents.userId, userId), eq(achievementEvents.eventType, 'diamond_hands'))\n\t\t\t);\n\n\t\treturn diamondEvents.some((event) => {\n\t\t\tconst data = event.eventData as any;\n\t\t\treturn data.holdDuration >= minimumHoldDays && data.maxDrawdown >= minimumDrawdown;\n\t\t});\n\t}\n\n\t/**\n\t * Check for paper hands behavior (panic selling)\n\t */\n\tprivate async checkPaperHands(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { requiredPanicSells = 3, timeframe = 168 } = config; // 1 week\n\n\t\tconst panicSells = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'paper_hands'),\n\t\t\t\t\tgte(achievementEvents.triggeredAt, sql`now() - interval '${timeframe} hours'`)\n\t\t\t\t)\n\t\t\t);\n\n\t\treturn (panicSells[0]?.count || 0) >= requiredPanicSells;\n\t}\n\n\t/**\n\t * Check for crash sentiment posting (doom posting during market crashes)\n\t */\n\tprivate async checkCrashSentiment(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { requiredPosts = 5, sentimentThreshold = 0.7 } = config;\n\n\t\tconst crashPosts = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'crash_sentiment')\n\t\t\t\t)\n\t\t\t);\n\n\t\tconst qualifyingPosts = crashPosts.filter((event) => {\n\t\t\tconst data = event.eventData as any;\n\t\t\treturn data.confidence >= sentimentThreshold;\n\t\t});\n\n\t\treturn qualifyingPosts.length >= requiredPosts;\n\t}\n\n\t/**\n\t * Check for thread necromancy (reviving old threads)\n\t */\n\tprivate async checkThreadNecromancy(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { requiredNecromancies = 3, minimumThreadAge = 90 } = config;\n\n\t\tconst necromancies = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'thread_necromancy')\n\t\t\t\t)\n\t\t\t);\n\n\t\tconst qualifyingNecromancies = necromancies.filter((event) => {\n\t\t\tconst data = event.eventData as any;\n\t\t\treturn data.threadAge >= minimumThreadAge;\n\t\t});\n\n\t\treturn qualifyingNecromancies.length >= requiredNecromancies;\n\t}\n\n\t/**\n\t * Check for shoutbox spam patterns\n\t */\n\tprivate async checkShoutboxSpam(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { messagesPerHour = 50, timeframe = 1 } = config;\n\n\t\tconst messages = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'shoutbox_message'),\n\t\t\t\t\tgte(achievementEvents.triggeredAt, sql`now() - interval '${timeframe} hours'`)\n\t\t\t\t)\n\t\t\t);\n\n\t\treturn (messages[0]?.count || 0) >= messagesPerHour;\n\t}\n\n\t/**\n\t * Check for whale-level tipping behavior\n\t */\n\tprivate async checkTipWhale(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { minimumTipAmount = 10000, timeframe = 24 } = config;\n\n\t\tconst tips = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'tip_sent'),\n\t\t\t\t\tgte(achievementEvents.triggeredAt, sql`now() - interval '${timeframe} hours'`)\n\t\t\t\t)\n\t\t\t);\n\n\t\treturn tips.some((tip) => {\n\t\t\tconst data = tip.eventData as any;\n\t\t\treturn data.amount >= minimumTipAmount;\n\t\t});\n\t}\n\n\t/**\n\t * Check for accurate market predictions\n\t */\n\tprivate async checkMarketProphet(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { minimumAccuracy = 0.8, minimumPredictions = 10 } = config;\n\n\t\tconst predictions = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'market_prediction')\n\t\t\t\t)\n\t\t\t);\n\n\t\tif (predictions.length < minimumPredictions) return false;\n\n\t\tconst accuratePredictions = predictions.filter((pred) => {\n\t\t\tconst data = pred.eventData as any;\n\t\t\treturn data.accuracy >= minimumAccuracy;\n\t\t});\n\n\t\tconst overallAccuracy = accuratePredictions.length / predictions.length;\n\t\treturn overallAccuracy >= minimumAccuracy;\n\t}\n\n\t/**\n\t * Check for multiple degen activities in sequence\n\t */\n\tprivate async checkDegenCombo(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { requiredEvents = ['wallet_loss', 'paper_hands', 'crash_sentiment'], timeframe = 24 } =\n\t\t\tconfig;\n\n\t\tconst events = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\tgte(achievementEvents.triggeredAt, sql`now() - interval '${timeframe} hours'`)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(desc(achievementEvents.triggeredAt));\n\n\t\tconst eventTypes = events.map((e) => e.eventType);\n\t\treturn requiredEvents.every((eventType) =>\n\t\t\teventTypes.includes(eventType as AchievementEventType)\n\t\t);\n\t}\n\n\t/**\n\t * Check for panic posting behavior (high activity during market stress)\n\t */\n\tprivate async checkPanicPoster(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst {\n\t\t\tpostsPerHour = 10,\n\t\t\tcrashKeywords = ['crash', 'dump', 'rekt', 'bear'],\n\t\t\ttimeframe = 4\n\t\t} = config;\n\n\t\tconst posts = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'post_created'),\n\t\t\t\t\tgte(achievementEvents.triggeredAt, sql`now() - interval '${timeframe} hours'`)\n\t\t\t\t)\n\t\t\t);\n\n\t\tconst crashSentiments = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'crash_sentiment'),\n\t\t\t\t\tgte(achievementEvents.triggeredAt, sql`now() - interval '${timeframe} hours'`)\n\t\t\t\t)\n\t\t\t);\n\n\t\treturn (posts[0]?.count || 0) >= postsPerHour && (crashSentiments[0]?.count || 0) > 0;\n\t}\n\n\t/**\n\t * Check for long-term holding mentality\n\t */\n\tprivate async checkHodlMentality(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { minimumHoldPeriod = 365, resistedSellSignals = 5 } = config;\n\n\t\t// Look for diamond hands events with long hold periods\n\t\tconst holdEvents = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(eq(achievementEvents.userId, userId), eq(achievementEvents.eventType, 'diamond_hands'))\n\t\t\t);\n\n\t\treturn holdEvents.some((event) => {\n\t\t\tconst data = event.eventData as any;\n\t\t\treturn data.holdDuration >= minimumHoldPeriod;\n\t\t});\n\t}\n\n\t/**\n\t * Check for FOMO behavior patterns\n\t */\n\tprivate async checkFomoMaster(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { requiredFomoActions = 10, timeframe = 168 } = config; // 1 week\n\n\t\t// Count rapid buying/posting activity during market pumps\n\t\tconst fomoActivities = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\tgte(achievementEvents.triggeredAt, sql`now() - interval '${timeframe} hours'`)\n\t\t\t\t)\n\t\t\t);\n\n\t\treturn (fomoActivities[0]?.count || 0) >= requiredFomoActions;\n\t}\n\n\t/**\n\t * Check for recovery from major losses\n\t */\n\tprivate async checkLossRecovery(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { minimumLoss = 5000, recoveryMultiplier = 1.5 } = config;\n\n\t\t// Check for wallet loss followed by diamond hands\n\t\tconst lossEvents = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(eq(achievementEvents.userId, userId), eq(achievementEvents.eventType, 'wallet_loss'))\n\t\t\t);\n\n\t\tconst diamondEvents = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(eq(achievementEvents.userId, userId), eq(achievementEvents.eventType, 'diamond_hands'))\n\t\t\t);\n\n\t\t// Check if there's a diamond hands event after a significant loss\n\t\treturn lossEvents.some((loss) => {\n\t\t\tconst lossData = loss.eventData as any;\n\t\t\tif (lossData.lossAmount < minimumLoss) return false;\n\n\t\t\treturn diamondEvents.some((diamond) => {\n\t\t\t\tconst diamondData = diamond.eventData as any;\n\t\t\t\treturn (\n\t\t\t\t\tdiamond.triggeredAt > loss.triggeredAt &&\n\t\t\t\t\tdiamondData.finalReturn >= lossData.lossAmount * recoveryMultiplier\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Check for weekend trading activity\n\t */\n\tprivate async checkWeekendWarrior(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { weekendPostsRequired = 20 } = config;\n\n\t\t// Count posts made on weekends (Saturday/Sunday)\n\t\tconst weekendPosts = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'post_created'),\n\t\t\t\t\tsql`EXTRACT(DOW FROM triggered_at) IN (0, 6)` // Sunday = 0, Saturday = 6\n\t\t\t\t)\n\t\t\t);\n\n\t\treturn (weekendPosts[0]?.count || 0) >= weekendPostsRequired;\n\t}\n\n\t/**\n\t * Check for late night posting activity\n\t */\n\tprivate async checkNightOwl(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { nightPostsRequired = 50, startHour = 22, endHour = 6 } = config;\n\n\t\t// Count posts made between 10 PM and 6 AM\n\t\tconst nightPosts = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'post_created'),\n\t\t\t\t\tsql`EXTRACT(HOUR FROM triggered_at) >= ${startHour} OR EXTRACT(HOUR FROM triggered_at) <= ${endHour}`\n\t\t\t\t)\n\t\t\t);\n\n\t\treturn (nightPosts[0]?.count || 0) >= nightPostsRequired;\n\t}\n\n\t/**\n\t * Check for meme posting mastery\n\t */\n\tprivate async checkMemeLord(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { memePostsRequired = 100 } = config;\n\n\t\t// Count posts with meme-related content or high engagement\n\t\tconst posts = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(eq(achievementEvents.userId, userId), eq(achievementEvents.eventType, 'post_created'))\n\t\t\t);\n\n\t\t// Simple heuristic: posts with certain keywords or patterns\n\t\tconst memePosts = posts.filter((post) => {\n\t\t\tconst data = post.eventData as any;\n\t\t\tconst content = data.content?.toLowerCase() || '';\n\t\t\tconst memeKeywords = [\n\t\t\t\t'pepe',\n\t\t\t\t'wojak',\n\t\t\t\t'chad',\n\t\t\t\t'based',\n\t\t\t\t'cringe',\n\t\t\t\t'moon',\n\t\t\t\t'lambo',\n\t\t\t\t'diamond hands',\n\t\t\t\t'paper hands'\n\t\t\t];\n\t\t\treturn memeKeywords.some((keyword) => content.includes(keyword));\n\t\t});\n\n\t\treturn memePosts.length >= memePostsRequired;\n\t}\n\n\t/**\n\t * Check for contrarian behavior (posting opposite sentiment)\n\t */\n\tprivate async checkContrarian(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { contrarianPostsRequired = 25 } = config;\n\n\t\t// Look for posts that go against market sentiment\n\t\tconst contrarianEvents = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(achievementEvents.userId, userId),\n\t\t\t\t\teq(achievementEvents.eventType, 'crash_sentiment')\n\t\t\t\t)\n\t\t\t);\n\n\t\t// Simple implementation - could be enhanced with sentiment analysis\n\t\treturn (contrarianEvents[0]?.count || 0) >= contrarianPostsRequired;\n\t}\n\n\t/**\n\t * Check for moon mission posting (extreme optimism)\n\t */\n\tprivate async checkMoonMission(userId: string, config: EvaluatorConfig): Promise<boolean> {\n\t\tconst { moonPostsRequired = 50 } = config;\n\n\t\t// Count posts with extremely bullish sentiment\n\t\tconst posts = await db\n\t\t\t.select()\n\t\t\t.from(achievementEvents)\n\t\t\t.where(\n\t\t\t\tand(eq(achievementEvents.userId, userId), eq(achievementEvents.eventType, 'post_created'))\n\t\t\t);\n\n\t\tconst moonPosts = posts.filter((post) => {\n\t\t\tconst data = post.eventData as any;\n\t\t\tconst content = data.content?.toLowerCase() || '';\n\t\t\tconst moonKeywords = [\n\t\t\t\t'moon',\n\t\t\t\t'lambo',\n\t\t\t\t'rocket',\n\t\t\t\t'🚀',\n\t\t\t\t'to the moon',\n\t\t\t\t'100x',\n\t\t\t\t'1000x',\n\t\t\t\t'diamond hands'\n\t\t\t];\n\t\t\treturn moonKeywords.some((keyword) => content.includes(keyword));\n\t\t});\n\n\t\treturn moonPosts.length >= moonPostsRequired;\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/achievements/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/achievements/templates/achievement-templates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/admin.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/analytics.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/analytics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/analytics.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'between' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":62,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'levels' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":22,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Gamification Analytics Service\n *\n * Comprehensive analytics and reporting for all gamification systems:\n * - User progression tracking\n * - Achievement completion analytics\n * - Mission engagement metrics\n * - Leveling progression insights\n * - System performance monitoring\n */\n\nimport { db } from '@db';\nimport { eq, and, desc, asc, gte, lte, count, sum, avg, sql, between } from 'drizzle-orm';\nimport {\n\tusers,\n\tlevels,\n\tachievements,\n\tuserAchievements,\n\tmissions,\n\tuserMissionProgress,\n\txpAdjustmentLogs,\n\ttransactions\n} from '@schema';\nimport { logger } from '../../core/logger';\nimport type { UserId } from '@shared/types/ids';\nimport { AchievementId } from \"@shared/types/ids\";\n\nexport interface ProgressionMetrics {\n\tperiod: string;\n\ttotalUsers: number;\n\tactiveUsers: number;\n\tavgLevelGain: number;\n\tavgXpGain: number;\n\tlevelUps: number;\n\ttopLevelReached: number;\n\tprogressionRate: number; // Users progressing vs stagnating\n}\n\nexport interface AchievementMetrics {\n\tperiod: string;\n\ttotalAchievements: number;\n\ttotalCompletions: number;\n\tavgCompletionRate: number;\n\tpopularAchievements: Array<{\n\t\tachievementId: AchievementId;\n\t\tname: string;\n\t\tcompletions: number;\n\t\tcompletionRate: number;\n\t}>;\n\trareAchievements: Array<{\n\t\tachievementId: AchievementId;\n\t\tname: string;\n\t\tcompletions: number;\n\t\trarity: number;\n\t}>;\n}\n\nexport interface MissionMetrics {\n\tperiod: string;\n\ttotalMissions: number;\n\ttotalCompletions: number;\n\tdailyMissionRate: number;\n\tweeklyMissionRate: number;\n\tavgCompletionTime: number;\n\tstreakData: {\n\t\tavgStreak: number;\n\t\tmaxStreak: number;\n\t\tusersWithStreaks: number;\n\t};\n}\n\nexport interface EngagementMetrics {\n\tperiod: string;\n\ttotalEngagements: number;\n\tuniqueUsers: number;\n\tavgSessionLength: number;\n\tretentionRate: number;\n\tchurnRate: number;\n\tpowerUsers: number; // Users in top 10% of activity\n}\n\nexport interface SystemHealth {\n\ttimestamp: string;\n\tresponseTime: number;\n\terrorRate: number;\n\tthroughput: number;\n\tmemoryUsage: number;\n\talerts: Array<{\n\t\ttype: 'warning' | 'error' | 'info';\n\t\tmessage: string;\n\t\ttimestamp: string;\n\t}>;\n}\n\nexport interface GamificationDashboard {\n\toverview: {\n\t\ttotalUsers: number;\n\t\tactiveToday: number;\n\t\tlevelUpsToday: number;\n\t\tachievementsEarned: number;\n\t\tmissionsCompleted: number;\n\t\ttotalXpAwarded: number;\n\t};\n\tprogression: ProgressionMetrics;\n\tachievements: AchievementMetrics;\n\tmissions: MissionMetrics;\n\tengagement: EngagementMetrics;\n\ttopPerformers: Array<{\n\t\tuserId: UserId;\n\t\tusername: string;\n\t\tlevel: number;\n\t\txp: number;\n\t\tachievements: number;\n\t\trank: number;\n\t}>;\n\ttrends: {\n\t\txpGrowth: Array<{ date: string; value: number }>;\n\t\tuserActivity: Array<{ date: string; value: number }>;\n\t\tcompletionRates: Array<{ date: string; achievements: number; missions: number }>;\n\t};\n}\n\nexport class GamificationAnalyticsService {\n\t/**\n\t * Generate comprehensive gamification dashboard\n\t */\n\tasync generateDashboard(\n\t\ttimeframe: 'day' | 'week' | 'month' = 'week'\n\t): Promise<GamificationDashboard> {\n\t\ttry {\n\t\t\tconst timeFilter = this.getTimeFilter(timeframe);\n\n\t\t\t// Parallel data fetching for performance\n\t\t\tconst [\n\t\t\t\toverview,\n\t\t\t\tprogressionMetrics,\n\t\t\t\tachievementMetrics,\n\t\t\t\tmissionMetrics,\n\t\t\t\tengagementMetrics,\n\t\t\t\ttopPerformers,\n\t\t\t\ttrends\n\t\t\t] = await Promise.all([\n\t\t\t\tthis.getOverviewStats(timeFilter),\n\t\t\t\tthis.getProgressionMetrics(timeframe, timeFilter),\n\t\t\t\tthis.getAchievementMetrics(timeframe, timeFilter),\n\t\t\t\tthis.getMissionMetrics(timeframe, timeFilter),\n\t\t\t\tthis.getEngagementMetrics(timeframe, timeFilter),\n\t\t\t\tthis.getTopPerformers(10),\n\t\t\t\tthis.getTrendData(timeframe)\n\t\t\t]);\n\n\t\t\treturn {\n\t\t\t\toverview,\n\t\t\t\tprogression: progressionMetrics,\n\t\t\t\tachievements: achievementMetrics,\n\t\t\t\tmissions: missionMetrics,\n\t\t\t\tengagement: engagementMetrics,\n\t\t\t\ttopPerformers,\n\t\t\t\ttrends\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ANALYTICS_SERVICE', 'Error generating dashboard:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get overview statistics\n\t */\n\tprivate async getOverviewStats(timeFilter: Date) {\n\t\tconst [\n\t\t\ttotalUsers,\n\t\t\tactiveToday,\n\t\t\tlevelUpsToday,\n\t\t\tachievementsEarned,\n\t\t\tmissionsCompleted,\n\t\t\ttotalXpAwarded\n\t\t] = await Promise.all([\n\t\t\tdb.select({ count: count() }).from(users),\n\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(users)\n\t\t\t\t.where(gte(users.lastLoginAt || users.createdAt, timeFilter)),\n\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(xpAdjustmentLogs)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\tgte(xpAdjustmentLogs.createdAt, timeFilter),\n\t\t\t\t\t\tsql`${xpAdjustmentLogs.reason} LIKE '%Level up%'`\n\t\t\t\t\t)\n\t\t\t\t),\n\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userAchievements)\n\t\t\t\t.where(gte(userAchievements.earnedAt, timeFilter)),\n\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userMissionProgress)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userMissionProgress.isCompleted, true),\n\t\t\t\t\t\tgte(userMissionProgress.completedAt || userMissionProgress.updatedAt, timeFilter)\n\t\t\t\t\t)\n\t\t\t\t),\n\n\t\t\tdb\n\t\t\t\t.select({ total: sum(xpAdjustmentLogs.amount) })\n\t\t\t\t.from(xpAdjustmentLogs)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\tgte(xpAdjustmentLogs.createdAt, timeFilter),\n\t\t\t\t\t\tsql`${xpAdjustmentLogs.adjustmentType} = 'add'`\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t]);\n\n\t\treturn {\n\t\t\ttotalUsers: totalUsers[0]?.count || 0,\n\t\t\tactiveToday: activeToday[0]?.count || 0,\n\t\t\tlevelUpsToday: levelUpsToday[0]?.count || 0,\n\t\t\tachievementsEarned: achievementsEarned[0]?.count || 0,\n\t\t\tmissionsCompleted: missionsCompleted[0]?.count || 0,\n\t\t\ttotalXpAwarded: parseInt(totalXpAwarded[0]?.total || '0')\n\t\t};\n\t}\n\n\t/**\n\t * Get progression metrics\n\t */\n\tprivate async getProgressionMetrics(\n\t\ttimeframe: string,\n\t\ttimeFilter: Date\n\t): Promise<ProgressionMetrics> {\n\t\t// Get user level distribution changes\n\t\tconst levelGains = await db\n\t\t\t.select({\n\t\t\t\tuserId: xpAdjustmentLogs.userId,\n\t\t\t\tlevelGain: count()\n\t\t\t})\n\t\t\t.from(xpAdjustmentLogs)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\tgte(xpAdjustmentLogs.createdAt, timeFilter),\n\t\t\t\t\tsql`${xpAdjustmentLogs.reason} LIKE '%Level up%'`\n\t\t\t\t)\n\t\t\t)\n\t\t\t.groupBy(xpAdjustmentLogs.userId);\n\n\t\tconst xpGains = await db\n\t\t\t.select({\n\t\t\t\ttotal: sum(xpAdjustmentLogs.amount),\n\t\t\t\tavg: avg(xpAdjustmentLogs.amount),\n\t\t\t\tcount: count()\n\t\t\t})\n\t\t\t.from(xpAdjustmentLogs)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\tgte(xpAdjustmentLogs.createdAt, timeFilter),\n\t\t\t\t\tsql`${xpAdjustmentLogs.adjustmentType} = 'add'`\n\t\t\t\t)\n\t\t\t);\n\n\t\tconst topLevel = await db.select({ maxLevel: sql<number>`MAX(${users.level})` }).from(users);\n\n\t\tconst activeUsers = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(users)\n\t\t\t.where(gte(users.lastLoginAt || users.createdAt, timeFilter));\n\n\t\tconst totalUsers = await db.select({ count: count() }).from(users);\n\n\t\treturn {\n\t\t\tperiod: timeframe,\n\t\t\ttotalUsers: totalUsers[0]?.count || 0,\n\t\t\tactiveUsers: activeUsers[0]?.count || 0,\n\t\t\tavgLevelGain:\n\t\t\t\tlevelGains.length > 0\n\t\t\t\t\t? levelGains.reduce((sum, g) => sum + g.levelGain, 0) / levelGains.length\n\t\t\t\t\t: 0,\n\t\t\tavgXpGain: parseFloat(xpGains[0]?.avg || '0'),\n\t\t\tlevelUps: levelGains.reduce((sum, g) => sum + g.levelGain, 0),\n\t\t\ttopLevelReached: topLevel[0]?.maxLevel || 0,\n\t\t\tprogressionRate:\n\t\t\t\ttotalUsers[0]?.count > 0 ? (levelGains.length / totalUsers[0].count) * 100 : 0\n\t\t};\n\t}\n\n\t/**\n\t * Get achievement metrics\n\t */\n\tprivate async getAchievementMetrics(\n\t\ttimeframe: string,\n\t\ttimeFilter: Date\n\t): Promise<AchievementMetrics> {\n\t\tconst totalAchievements = await db.select({ count: count() }).from(achievements);\n\n\t\tconst totalCompletions = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(userAchievements)\n\t\t\t.where(gte(userAchievements.earnedAt, timeFilter));\n\n\t\t// Get popular achievements\n\t\tconst popularAchievements = await db\n\t\t\t.select({\n\t\t\t\tachievementId: achievements.id,\n\t\t\t\tname: achievements.name,\n\t\t\t\tcompletions: count(userAchievements.id)\n\t\t\t})\n\t\t\t.from(achievements)\n\t\t\t.leftJoin(userAchievements, eq(achievements.id, userAchievements.achievementId))\n\t\t\t.where(gte(userAchievements.earnedAt, timeFilter))\n\t\t\t.groupBy(achievements.id, achievements.name)\n\t\t\t.orderBy(desc(count(userAchievements.id)))\n\t\t\t.limit(10);\n\n\t\t// Calculate completion rates\n\t\tconst totalUsers = await db.select({ count: count() }).from(users);\n\t\tconst userCount = totalUsers[0]?.count || 1;\n\n\t\tconst enrichedPopular = popularAchievements.map((a) => ({\n\t\t\tachievementId: a.achievementId,\n\t\t\tname: a.name,\n\t\t\tcompletions: a.completions,\n\t\t\tcompletionRate: (a.completions / userCount) * 100\n\t\t}));\n\n\t\t// Get rare achievements (low completion rate)\n\t\tconst rareAchievements = enrichedPopular\n\t\t\t.filter((a) => a.completionRate < 5)\n\t\t\t.map((a) => ({\n\t\t\t\tachievementId: a.achievementId,\n\t\t\t\tname: a.name,\n\t\t\t\tcompletions: a.completions,\n\t\t\t\trarity: 100 - a.completionRate\n\t\t\t}))\n\t\t\t.slice(0, 10);\n\n\t\treturn {\n\t\t\tperiod: timeframe,\n\t\t\ttotalAchievements: totalAchievements[0]?.count || 0,\n\t\t\ttotalCompletions: totalCompletions[0]?.count || 0,\n\t\t\tavgCompletionRate:\n\t\t\t\tenrichedPopular.length > 0\n\t\t\t\t\t? enrichedPopular.reduce((sum, a) => sum + a.completionRate, 0) / enrichedPopular.length\n\t\t\t\t\t: 0,\n\t\t\tpopularAchievements: enrichedPopular,\n\t\t\trareAchievements\n\t\t};\n\t}\n\n\t/**\n\t * Get mission metrics\n\t */\n\tprivate async getMissionMetrics(timeframe: string, timeFilter: Date): Promise<MissionMetrics> {\n\t\tconst totalMissions = await db.select({ count: count() }).from(missions);\n\n\t\tconst completions = await db\n\t\t\t.select({\n\t\t\t\tcount: count(),\n\t\t\t\tdaily: sum(sql`CASE WHEN ${missions.isDaily} THEN 1 ELSE 0 END`),\n\t\t\t\tweekly: sum(sql`CASE WHEN ${missions.isWeekly} THEN 1 ELSE 0 END`)\n\t\t\t})\n\t\t\t.from(userMissionProgress)\n\t\t\t.innerJoin(missions, eq(userMissionProgress.missionId, missions.id))\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(userMissionProgress.isCompleted, true),\n\t\t\t\t\tgte(userMissionProgress.completedAt || userMissionProgress.updatedAt, timeFilter)\n\t\t\t\t)\n\t\t\t);\n\n\t\tconst completionData = completions[0];\n\n\t\treturn {\n\t\t\tperiod: timeframe,\n\t\t\ttotalMissions: totalMissions[0]?.count || 0,\n\t\t\ttotalCompletions: completionData?.count || 0,\n\t\t\tdailyMissionRate: parseInt(completionData?.daily || '0'),\n\t\t\tweeklyMissionRate: parseInt(completionData?.weekly || '0'),\n\t\t\tavgCompletionTime: 0, // TODO: Implement completion time tracking\n\t\t\tstreakData: {\n\t\t\t\tavgStreak: 0, // TODO: Implement streak calculation\n\t\t\t\tmaxStreak: 0,\n\t\t\t\tusersWithStreaks: 0\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Get engagement metrics\n\t */\n\tprivate async getEngagementMetrics(\n\t\ttimeframe: string,\n\t\ttimeFilter: Date\n\t): Promise<EngagementMetrics> {\n\t\t// Count unique users with any gamification activity\n\t\tconst engagements = await db\n\t\t\t.select({\n\t\t\t\tuserId: userAchievements.userId,\n\t\t\t\tachievements: count(userAchievements.id)\n\t\t\t})\n\t\t\t.from(userAchievements)\n\t\t\t.where(gte(userAchievements.earnedAt, timeFilter))\n\t\t\t.groupBy(userAchievements.userId);\n\n\t\tconst missionEngagements = await db\n\t\t\t.select({\n\t\t\t\tuserId: userMissionProgress.userId,\n\t\t\t\tmissions: count(userMissionProgress.id)\n\t\t\t})\n\t\t\t.from(userMissionProgress)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(userMissionProgress.isCompleted, true),\n\t\t\t\t\tgte(userMissionProgress.completedAt || userMissionProgress.updatedAt, timeFilter)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.groupBy(userMissionProgress.userId);\n\n\t\tconst uniqueUsers = new Set([\n\t\t\t...engagements.map((e) => e.userId),\n\t\t\t...missionEngagements.map((e) => e.userId)\n\t\t]).size;\n\n\t\tconst totalEngagements =\n\t\t\tengagements.reduce((sum, e) => sum + e.achievements, 0) +\n\t\t\tmissionEngagements.reduce((sum, e) => sum + e.missions, 0);\n\n\t\treturn {\n\t\t\tperiod: timeframe,\n\t\t\ttotalEngagements,\n\t\t\tuniqueUsers,\n\t\t\tavgSessionLength: 0, // TODO: Implement session tracking\n\t\t\tretentionRate: 0, // TODO: Implement retention calculation\n\t\t\tchurnRate: 0, // TODO: Implement churn calculation\n\t\t\tpowerUsers: Math.floor(uniqueUsers * 0.1) // Top 10%\n\t\t};\n\t}\n\n\t/**\n\t * Get top performers\n\t */\n\tprivate async getTopPerformers(limit: number = 10) {\n\t\tconst topUsers = await db\n\t\t\t.select({\n\t\t\t\tuserId: users.id,\n\t\t\t\tusername: users.username,\n\t\t\t\tlevel: users.level,\n\t\t\t\txp: users.xp,\n\t\t\t\tachievements: count(userAchievements.id)\n\t\t\t})\n\t\t\t.from(users)\n\t\t\t.leftJoin(userAchievements, eq(users.id, userAchievements.userId))\n\t\t\t.groupBy(users.id, users.username, users.level, users.xp)\n\t\t\t.orderBy(desc(users.level), desc(users.xp))\n\t\t\t.limit(limit);\n\n\t\treturn topUsers.map((user, index) => ({\n\t\t\tuserId: user.userId,\n\t\t\tusername: user.username,\n\t\t\tlevel: user.level,\n\t\t\txp: user.xp,\n\t\t\tachievements: user.achievements,\n\t\t\trank: index + 1\n\t\t}));\n\t}\n\n\t/**\n\t * Get trend data for charts\n\t */\n\tprivate async getTrendData(timeframe: string) {\n\t\t// Generate date range for the past period\n\t\tconst dates = this.generateDateRange(timeframe);\n\n\t\t// TODO: Implement actual trend data queries\n\t\t// This would require daily/hourly aggregation tables for performance\n\n\t\treturn {\n\t\t\txpGrowth: dates.map((date) => ({ date, value: Math.random() * 1000 })),\n\t\t\tuserActivity: dates.map((date) => ({ date, value: Math.random() * 100 })),\n\t\t\tcompletionRates: dates.map((date) => ({\n\t\t\t\tdate,\n\t\t\t\tachievements: Math.random() * 50,\n\t\t\t\tmissions: Math.random() * 30\n\t\t\t}))\n\t\t};\n\t}\n\n\t/**\n\t * Helper methods\n\t */\n\tprivate getTimeFilter(timeframe: 'day' | 'week' | 'month'): Date {\n\t\tconst now = new Date();\n\t\tswitch (timeframe) {\n\t\t\tcase 'day':\n\t\t\t\tnow.setDate(now.getDate() - 1);\n\t\t\t\tbreak;\n\t\t\tcase 'week':\n\t\t\t\tnow.setDate(now.getDate() - 7);\n\t\t\t\tbreak;\n\t\t\tcase 'month':\n\t\t\t\tnow.setDate(now.getDate() - 30);\n\t\t\t\tbreak;\n\t\t}\n\t\treturn now;\n\t}\n\n\tprivate generateDateRange(timeframe: string): string[] {\n\t\tconst dates: string[] = [];\n\t\tconst now = new Date();\n\n\t\tconst days = timeframe === 'day' ? 7 : timeframe === 'week' ? 30 : 90;\n\n\t\tfor (let i = days; i >= 0; i--) {\n\t\t\tconst date = new Date(now);\n\t\t\tdate.setDate(date.getDate() - i);\n\t\t\tdates.push(date.toISOString().split('T')[0]);\n\t\t}\n\n\t\treturn dates;\n\t}\n\n\t/**\n\t * Export analytics data for external systems\n\t */\n\tasync exportAnalytics(format: 'json' | 'csv' = 'json', timeframe: 'week' | 'month' = 'week') {\n\t\ttry {\n\t\t\tconst dashboard = await this.generateDashboard(timeframe);\n\n\t\t\tif (format === 'json') {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tdata: dashboard,\n\t\t\t\t\texported_at: new Date().toISOString(),\n\t\t\t\t\ttimeframe\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// TODO: Implement CSV export\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: 'CSV export not yet implemented'\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ANALYTICS_SERVICE', 'Error exporting analytics:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Real-time system health monitoring\n\t */\n\tasync getSystemHealth(): Promise<SystemHealth> {\n\t\ttry {\n\t\t\tconst startTime = Date.now();\n\n\t\t\t// Simple health checks\n\t\t\tawait db.select({ count: count() }).from(users).limit(1);\n\n\t\t\tconst responseTime = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\tresponseTime,\n\t\t\t\terrorRate: 0, // TODO: Implement error rate tracking\n\t\t\t\tthroughput: 0, // TODO: Implement throughput tracking\n\t\t\t\tmemoryUsage: process.memoryUsage().heapUsed / 1024 / 1024, // MB\n\t\t\t\talerts: [] // TODO: Implement alert system\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ANALYTICS_SERVICE', 'Error getting system health:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport const gamificationAnalyticsService = new GamificationAnalyticsService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/gamification.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/leveling.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/leveling.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/leveling.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":64},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'badges' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'titles' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":8}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Comprehensive Leveling Service\n *\n * Handles level calculations, progression tracking, reward distribution,\n * and advancement analytics for the DegenTalk gamification system.\n */\n\nimport { db } from '@db';\nimport { eq, and, desc, asc, gte, lte, count, sum, sql, inArray } from 'drizzle-orm';\nimport {\n\tusers,\n\tlevels,\n\txpAdjustmentLogs,\n\tachievements,\n\tuserAchievements,\n\tbadges,\n\tuserBadges,\n\ttitles,\n\tuserTitles,\n\ttransactions,\n\tmissions,\n\tuserMissionProgress\n} from '@schema';\nimport { logger } from '../../core/logger';\nimport { XpService } from '../xp/xp.service';\nimport type { UserId } from '@shared/types/ids';\nimport { TitleId, BadgeId, EntityId } from \"@shared/types/ids\";\n\nexport interface LevelInfo {\n\tlevel: number;\n\tname: string;\n\tminXp: number;\n\tnextLevelXp?: number;\n\ticonUrl?: string;\n\trarity: string;\n\tframeUrl?: string;\n\tcolorTheme?: string;\n\tanimationEffect?: string;\n\tunlocks?: any;\n\trewards: {\n\t\tdgt?: number;\n\t\ttitleId?: TitleId;\n\t\tbadgeId?: BadgeId;\n\t};\n}\n\nexport interface UserProgression {\n\tuserId: UserId;\n\tusername: string;\n\tcurrentLevel: number;\n\tcurrentXp: number;\n\ttotalXp: number;\n\txpForNextLevel: number;\n\tprogressPercentage: number;\n\tlevelInfo: LevelInfo;\n\tnextLevelInfo?: LevelInfo;\n\trecentLevelUps: number;\n\tweeklyXpGain: number;\n\trank: number;\n\tachievements: {\n\t\ttotal: number;\n\t\trecent: any[];\n\t};\n\tmissions: {\n\t\tcompleted: number;\n\t\tavailable: number;\n\t\tstreak: number;\n\t};\n}\n\nexport interface LeaderboardEntry {\n\tuserId: UserId;\n\tusername: string;\n\tlevel: number;\n\ttotalXp: number;\n\tweeklyXp: number;\n\trank: number;\n\tbadge?: string;\n\tframe?: string;\n\ttrend: 'up' | 'down' | 'stable';\n}\n\nexport interface ProgressionAnalytics {\n\tuserDistribution: Array<{ level: number; count: number }>;\n\taverageProgression: {\n\t\txpPerDay: number;\n\t\tlevelsPerWeek: number;\n\t\tcompletionRate: number;\n\t};\n\ttopPerformers: LeaderboardEntry[];\n\tengagementMetrics: {\n\t\tactiveUsers: number;\n\t\tlevelUpsToday: number;\n\t\tmissionCompletions: number;\n\t};\n}\n\nexport class LevelingService {\n\tprivate xpService: XpService;\n\n\tconstructor() {\n\t\tthis.xpService = new XpService();\n\t}\n\n\t/**\n\t * Get detailed level information including rewards and visual customization\n\t */\n\tasync getLevelInfo(levelNumber: number): Promise<LevelInfo | null> {\n\t\ttry {\n\t\t\tconst levelData = await db\n\t\t\t\t.select()\n\t\t\t\t.from(levels)\n\t\t\t\t.where(eq(levels.level, levelNumber))\n\t\t\t\t.limit(1);\n\n\t\t\tif (levelData.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst level = levelData[0];\n\n\t\t\t// Get next level for XP requirement calculation\n\t\t\tconst nextLevelData = await db\n\t\t\t\t.select()\n\t\t\t\t.from(levels)\n\t\t\t\t.where(gte(levels.level, levelNumber + 1))\n\t\t\t\t.orderBy(asc(levels.level))\n\t\t\t\t.limit(1);\n\n\t\t\treturn {\n\t\t\t\tlevel: level.level,\n\t\t\t\tname: level.name || `Level ${level.level}`,\n\t\t\t\tminXp: level.minXp,\n\t\t\t\tnextLevelXp: nextLevelData.length > 0 ? nextLevelData[0].minXp : undefined,\n\t\t\t\ticonUrl: level.iconUrl || undefined,\n\t\t\t\trarity: level.rarity || 'common',\n\t\t\t\tframeUrl: level.frameUrl || undefined,\n\t\t\t\tcolorTheme: level.colorTheme || undefined,\n\t\t\t\tanimationEffect: level.animationEffect || undefined,\n\t\t\t\tunlocks: level.unlocks,\n\t\t\t\trewards: {\n\t\t\t\t\tdgt: level.rewardDgt || undefined,\n\t\t\t\t\ttitleId: level.rewardTitleId || undefined,\n\t\t\t\t\tbadgeId: level.rewardBadgeId || undefined\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('LEVELING_SERVICE', 'Error getting level info:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get comprehensive user progression data\n\t */\n\tasync getUserProgression(userId: UserId): Promise<UserProgression | null> {\n\t\ttry {\n\t\t\t// Get user basic info\n\t\t\tconst userData = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\txp: users.xp\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userData.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst user = userData[0];\n\n\t\t\t// Get current and next level info\n\t\t\tconst currentLevelInfo = await this.getLevelInfo(user.level);\n\t\t\tconst nextLevelInfo = await this.getLevelInfo(user.level + 1);\n\n\t\t\tif (!currentLevelInfo) {\n\t\t\t\tthrow new Error(`Level ${user.level} not found`);\n\t\t\t}\n\n\t\t\t// Calculate progression\n\t\t\tconst xpForNextLevel = nextLevelInfo ? nextLevelInfo.minXp - user.xp : 0;\n\t\t\tconst progressPercentage = nextLevelInfo\n\t\t\t\t? ((user.xp - currentLevelInfo.minXp) / (nextLevelInfo.minXp - currentLevelInfo.minXp)) *\n\t\t\t\t\t100\n\t\t\t\t: 100;\n\n\t\t\t// Get recent level ups (last 30 days)\n\t\t\tconst thirtyDaysAgo = new Date();\n\t\t\tthirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n\t\t\tconst recentLevelUps = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(xpAdjustmentLogs)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(xpAdjustmentLogs.userId, userId),\n\t\t\t\t\t\tgte(xpAdjustmentLogs.createdAt, thirtyDaysAgo),\n\t\t\t\t\t\tsql`${xpAdjustmentLogs.reason} LIKE '%Level up%'`\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t// Get weekly XP gain\n\t\t\tconst weekAgo = new Date();\n\t\t\tweekAgo.setDate(weekAgo.getDate() - 7);\n\n\t\t\tconst weeklyXpGain = await db\n\t\t\t\t.select({ total: sum(xpAdjustmentLogs.amount) })\n\t\t\t\t.from(xpAdjustmentLogs)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(xpAdjustmentLogs.userId, userId),\n\t\t\t\t\t\tgte(xpAdjustmentLogs.createdAt, weekAgo),\n\t\t\t\t\t\tsql`${xpAdjustmentLogs.adjustmentType} = 'add'`\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t// Get user rank\n\t\t\tconst higherRankedUsers = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(users)\n\t\t\t\t.where(and(sql`${users.xp} > ${user.xp}`, sql`${users.level} >= ${user.level}`));\n\n\t\t\tconst rank = (higherRankedUsers[0]?.count || 0) + 1;\n\n\t\t\t// Get achievement stats\n\t\t\tconst achievementStats = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userAchievements)\n\t\t\t\t.where(eq(userAchievements.userId, userId));\n\n\t\t\tconst recentAchievements = await db\n\t\t\t\t.select({\n\t\t\t\t\tachievement: achievements,\n\t\t\t\t\tearnedAt: userAchievements.earnedAt\n\t\t\t\t})\n\t\t\t\t.from(userAchievements)\n\t\t\t\t.innerJoin(achievements, eq(userAchievements.achievementId, achievements.id))\n\t\t\t\t.where(eq(userAchievements.userId, userId))\n\t\t\t\t.orderBy(desc(userAchievements.earnedAt))\n\t\t\t\t.limit(5);\n\n\t\t\t// Get mission stats\n\t\t\tconst missionStats = await db\n\t\t\t\t.select({\n\t\t\t\t\ttotal: count(),\n\t\t\t\t\tcompleted: sum(sql`CASE WHEN ${userMissionProgress.isCompleted} THEN 1 ELSE 0 END`),\n\t\t\t\t\tstreak: count() // TODO: Implement streak calculation\n\t\t\t\t})\n\t\t\t\t.from(userMissionProgress)\n\t\t\t\t.where(eq(userMissionProgress.userId, userId));\n\n\t\t\tconst availableMissions = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(missions)\n\t\t\t\t.where(eq(missions.isActive, true));\n\n\t\t\treturn {\n\t\t\t\tuserId: user.id,\n\t\t\t\tusername: user.username,\n\t\t\t\tcurrentLevel: user.level,\n\t\t\t\tcurrentXp: user.xp,\n\t\t\t\ttotalXp: user.xp,\n\t\t\t\txpForNextLevel,\n\t\t\t\tprogressPercentage: Math.min(100, Math.max(0, progressPercentage)),\n\t\t\t\tlevelInfo: currentLevelInfo,\n\t\t\t\t...(nextLevelInfo ? { nextLevelInfo } : {}),\n\t\t\t\trecentLevelUps: recentLevelUps[0]?.count || 0,\n\t\t\t\tweeklyXpGain: parseInt(weeklyXpGain[0]?.total || '0'),\n\t\t\t\trank,\n\t\t\t\tachievements: {\n\t\t\t\t\ttotal: achievementStats[0]?.count || 0,\n\t\t\t\t\trecent: recentAchievements.map((a: { achievement: any; earnedAt: Date }) => ({\n\t\t\t\t\t\t...a.achievement,\n\t\t\t\t\t\tearnedAt: a.earnedAt\n\t\t\t\t\t}))\n\t\t\t\t},\n\t\t\t\tmissions: {\n\t\t\t\t\tcompleted: parseInt(missionStats[0]?.completed || '0'),\n\t\t\t\t\tavailable: availableMissions[0]?.count || 0,\n\t\t\t\t\tstreak: parseInt(missionStats[0]?.streak || '0')\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('LEVELING_SERVICE', 'Error getting user progression:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get leaderboard with various sorting options\n\t */\n\tasync getLeaderboard(\n\t\ttype: 'level' | 'xp' | 'weekly' | 'monthly' = 'xp',\n\t\tlimit: number = 50,\n\t\toffset: number = 0\n\t): Promise<LeaderboardEntry[]> {\n\t\ttry {\n\t\t\tlet orderBy;\n\t\t\tlet timeFilter;\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'level':\n\t\t\t\t\torderBy = [desc(users.level), desc(users.xp)];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'weekly':\n\t\t\t\t\ttimeFilter = new Date();\n\t\t\t\t\ttimeFilter.setDate(timeFilter.getDate() - 7);\n\t\t\t\t\torderBy = [desc(users.xp)]; // TODO: Implement weekly XP tracking\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'monthly':\n\t\t\t\t\ttimeFilter = new Date();\n\t\t\t\t\ttimeFilter.setDate(timeFilter.getDate() - 30);\n\t\t\t\t\torderBy = [desc(users.xp)]; // TODO: Implement monthly XP tracking\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\torderBy = [desc(users.xp)];\n\t\t\t}\n\n\t\t\tconst leaderboardData = await db\n\t\t\t\t.select({\n\t\t\t\t\tuserId: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\ttotalXp: users.xp,\n\t\t\t\t\tavatarUrl: users.avatarUrl\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.orderBy(...orderBy)\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\t// Enrich with additional data\n\t\t\tconst enrichedData: LeaderboardEntry[] = [];\n\n\t\t\tfor (let i = 0; i < leaderboardData.length; i++) {\n\t\t\t\tconst user = leaderboardData[i];\n\n\t\t\t\t// Get weekly XP for this user (if needed)\n\t\t\t\tlet weeklyXp = 0;\n\t\t\t\tif (type === 'weekly' || type === 'monthly') {\n\t\t\t\t\tconst timeFilter = new Date();\n\t\t\t\t\ttimeFilter.setDate(timeFilter.getDate() - (type === 'weekly' ? 7 : 30));\n\n\t\t\t\t\tconst weeklyData = await db\n\t\t\t\t\t\t.select({ total: sum(xpAdjustmentLogs.amount) })\n\t\t\t\t\t\t.from(xpAdjustmentLogs)\n\t\t\t\t\t\t.where(\n\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\teq(xpAdjustmentLogs.userId, user.userId),\n\t\t\t\t\t\t\t\tgte(xpAdjustmentLogs.createdAt, timeFilter),\n\t\t\t\t\t\t\t\tsql`${xpAdjustmentLogs.adjustmentType} = 'add'`\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\tweeklyXp = parseInt(weeklyData[0]?.total || '0');\n\t\t\t\t}\n\n\t\t\t\tenrichedData.push({\n\t\t\t\t\tuserId: user.userId,\n\t\t\t\t\tusername: user.username,\n\t\t\t\t\tlevel: user.level,\n\t\t\t\t\ttotalXp: user.totalXp,\n\t\t\t\t\tweeklyXp,\n\t\t\t\t\trank: offset + i + 1,\n\t\t\t\t\ttrend: 'stable' // TODO: Implement trend calculation\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn enrichedData;\n\t\t} catch (error) {\n\t\t\tlogger.error('LEVELING_SERVICE', 'Error getting leaderboard:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Calculate and award level up rewards\n\t */\n\tasync processLevelUp(\n\t\tuserId: UserId,\n\t\toldLevel: number,\n\t\tnewLevel: number\n\t): Promise<{\n\t\trewards: any[];\n\t\tunlocks: any[];\n\t}> {\n\t\ttry {\n\t\t\tconst rewards: any[] = [];\n\t\t\tconst unlocks: any[] = [];\n\n\t\t\t// Process rewards for each level gained\n\t\t\tfor (let level = oldLevel + 1; level <= newLevel; level++) {\n\t\t\t\tconst levelInfo = await this.getLevelInfo(level);\n\t\t\t\tif (!levelInfo) continue;\n\n\t\t\t\t// Award DGT tokens\n\t\t\t\tif (levelInfo.rewards.dgt && levelInfo.rewards.dgt > 0) {\n\t\t\t\t\tawait db.insert(transactions).values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tamount: levelInfo.rewards.dgt,\n\t\t\t\t\t\ttype: 'LEVEL_REWARD',\n\t\t\t\t\t\tstatus: 'COMPLETED',\n\t\t\t\t\t\tdescription: `Level ${level} DGT reward`,\n\t\t\t\t\t\tmetadata: { level, source: 'level_up' }\n\t\t\t\t\t});\n\n\t\t\t\t\trewards.push({\n\t\t\t\t\t\ttype: 'dgt',\n\t\t\t\t\t\tamount: levelInfo.rewards.dgt,\n\t\t\t\t\t\tlevel\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Award title\n\t\t\t\tif (levelInfo.rewards.titleId) {\n\t\t\t\t\tawait db\n\t\t\t\t\t\t.insert(userTitles)\n\t\t\t\t\t\t.values({\n\t\t\t\t\t\t\tuserId,\n\t\t\t\t\t\t\ttitleId: levelInfo.rewards.titleId,\n\t\t\t\t\t\t\tisActive: false, // User needs to manually activate\n\t\t\t\t\t\t\tearnedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.onConflictDoNothing();\n\n\t\t\t\t\trewards.push({\n\t\t\t\t\t\ttype: 'title',\n\t\t\t\t\t\ttitleId: levelInfo.rewards.titleId,\n\t\t\t\t\t\tlevel\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Award badge\n\t\t\t\tif (levelInfo.rewards.badgeId) {\n\t\t\t\t\tawait db\n\t\t\t\t\t\t.insert(userBadges)\n\t\t\t\t\t\t.values({\n\t\t\t\t\t\t\tuserId,\n\t\t\t\t\t\t\tbadgeId: levelInfo.rewards.badgeId,\n\t\t\t\t\t\t\tearnedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.onConflictDoNothing();\n\n\t\t\t\t\trewards.push({\n\t\t\t\t\t\ttype: 'badge',\n\t\t\t\t\t\tbadgeId: levelInfo.rewards.badgeId,\n\t\t\t\t\t\tlevel\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Process unlocks\n\t\t\t\tif (levelInfo.unlocks) {\n\t\t\t\t\tunlocks.push({\n\t\t\t\t\t\tlevel,\n\t\t\t\t\t\tunlocks: levelInfo.unlocks\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.info('LEVELING_SERVICE', `Processed level up rewards for user ${userId}`, {\n\t\t\t\toldLevel,\n\t\t\t\tnewLevel,\n\t\t\t\trewardsCount: rewards.length,\n\t\t\t\tunlocksCount: unlocks.length\n\t\t\t});\n\n\t\t\treturn { rewards, unlocks };\n\t\t} catch (error) {\n\t\t\tlogger.error('LEVELING_SERVICE', 'Error processing level up rewards:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get progression analytics for admin dashboard\n\t */\n\tasync getProgressionAnalytics(\n\t\ttimeframe: 'day' | 'week' | 'month' = 'week'\n\t): Promise<ProgressionAnalytics> {\n\t\ttry {\n\t\t\tconst timeFilter = new Date();\n\t\t\tswitch (timeframe) {\n\t\t\t\tcase 'day':\n\t\t\t\t\ttimeFilter.setDate(timeFilter.getDate() - 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'week':\n\t\t\t\t\ttimeFilter.setDate(timeFilter.getDate() - 7);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'month':\n\t\t\t\t\ttimeFilter.setDate(timeFilter.getDate() - 30);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// User distribution by level\n\t\t\tconst userDistribution = await db\n\t\t\t\t.select({\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\tcount: count()\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.groupBy(users.level)\n\t\t\t\t.orderBy(users.level);\n\n\t\t\t// Active users count\n\t\t\tconst activeUsers = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(users)\n\t\t\t\t.where(gte(users.lastLogin, timeFilter));\n\n\t\t\t// Level ups today\n\t\t\tconst levelUpsToday = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(xpAdjustmentLogs)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\tgte(xpAdjustmentLogs.createdAt, timeFilter),\n\t\t\t\t\t\tsql`${xpAdjustmentLogs.reason} LIKE '%Level up%'`\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t// Mission completions\n\t\t\tconst missionCompletions = await db\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userMissionProgress)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userMissionProgress.isCompleted, true),\n\t\t\t\t\t\tgte(userMissionProgress.completedAt || userMissionProgress.updatedAt, timeFilter)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t// Average progression metrics\n\t\t\tconst avgXpPerDay = await db\n\t\t\t\t.select({ avg: sql<number>`AVG(${xpAdjustmentLogs.amount})` })\n\t\t\t\t.from(xpAdjustmentLogs)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\tgte(xpAdjustmentLogs.createdAt, timeFilter),\n\t\t\t\t\t\tsql`${xpAdjustmentLogs.adjustmentType} = 'add'`\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t// Top performers\n\t\t\tconst topPerformers = await this.getLeaderboard('weekly', 10);\n\n\t\t\treturn {\n\t\t\t\tuserDistribution: userDistribution.map((d: { level: number; count: number }) => ({\n\t\t\t\t\tlevel: d.level,\n\t\t\t\t\tcount: d.count\n\t\t\t\t})),\n\t\t\t\taverageProgression: {\n\t\t\t\t\txpPerDay: avgXpPerDay[0]?.avg || 0,\n\t\t\t\t\tlevelsPerWeek: 0.5, // TODO: Calculate actual\n\t\t\t\t\tcompletionRate: 0.8 // TODO: Calculate actual\n\t\t\t\t},\n\t\t\t\ttopPerformers,\n\t\t\t\tengagementMetrics: {\n\t\t\t\t\tactiveUsers: activeUsers[0]?.count || 0,\n\t\t\t\t\tlevelUpsToday: levelUpsToday[0]?.count || 0,\n\t\t\t\t\tmissionCompletions: missionCompletions[0]?.count || 0\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('LEVELING_SERVICE', 'Error getting progression analytics:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Create or update level configurations\n\t */\n\tasync createLevel(levelData: {\n\t\tlevel: number;\n\t\tminXp: number;\n\t\tname?: string;\n\t\ticonUrl?: string;\n\t\trarity?: string;\n\t\tframeUrl?: string;\n\t\tcolorTheme?: string;\n\t\tanimationEffect?: string;\n\t\tunlocks?: any;\n\t\trewardDgt?: number;\n\t\trewardTitleId?: EntityId;\n\t\trewardBadgeId?: EntityId;\n\t}): Promise<LevelInfo> {\n\t\ttry {\n\t\t\tconst result = await db\n\t\t\t\t.insert(levels)\n\t\t\t\t.values(levelData)\n\t\t\t\t.onConflictDoUpdate({\n\t\t\t\t\ttarget: levels.level,\n\t\t\t\t\tset: levelData\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\tlogger.info('LEVELING_SERVICE', `Created/updated level ${levelData.level}`, levelData);\n\n\t\t\treturn this.getLevelInfo(result[0].level) as Promise<LevelInfo>;\n\t\t} catch (error) {\n\t\t\tlogger.error('LEVELING_SERVICE', 'Error creating level:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get all levels configuration\n\t */\n\tasync getAllLevels(): Promise<LevelInfo[]> {\n\t\ttry {\n\t\t\tconst levelsData = await db.select().from(levels).orderBy(asc(levels.level));\n\n\t\t\tconst levelInfos: LevelInfo[] = [];\n\t\t\tfor (const level of levelsData) {\n\t\t\t\tconst levelInfo = await this.getLevelInfo(level.level);\n\t\t\t\tif (levelInfo) {\n\t\t\t\t\tlevelInfos.push(levelInfo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn levelInfos;\n\t\t} catch (error) {\n\t\t\tlogger.error('LEVELING_SERVICE', 'Error getting all levels:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Calculate optimal XP curve for balanced progression\n\t */\n\tasync generateXpCurve(\n\t\tmaxLevel: number = 100,\n\t\tbaseXp: number = 100\n\t): Promise<Array<{ level: number; minXp: number }>> {\n\t\tconst curve: Array<{ level: number; minXp: number }> = [];\n\n\t\tfor (let level = 1; level <= maxLevel; level++) {\n\t\t\t// Exponential curve with diminishing returns\n\t\t\tconst multiplier = Math.pow(level, 1.8) * 1.2;\n\t\t\tconst minXp = Math.floor(baseXp * multiplier);\n\n\t\t\tcurve.push({ level, minXp });\n\t\t}\n\n\t\treturn curve;\n\t}\n\n\t/**\n\t * Bulk import levels from XP curve\n\t */\n\tasync importXpCurve(curve: Array<{ level: number; minXp: number }>): Promise<void> {\n\t\ttry {\n\t\t\tconst levelValues = curve.map((c) => ({\n\t\t\t\tlevel: c.level,\n\t\t\t\tminXp: c.minXp,\n\t\t\t\tname: `Level ${c.level}`,\n\t\t\t\trarity: this.getLevelRarity(c.level)\n\t\t\t}));\n\n\t\t\tawait db.insert(levels).values(levelValues).onConflictDoNothing();\n\n\t\t\tlogger.info('LEVELING_SERVICE', `Imported ${curve.length} levels`, {\n\t\t\t\tmaxLevel: Math.max(...curve.map((c) => c.level)),\n\t\t\t\tmaxXp: Math.max(...curve.map((c) => c.minXp))\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('LEVELING_SERVICE', 'Error importing XP curve:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Helper to determine level rarity based on level number\n\t */\n\tprivate getLevelRarity(level: number): string {\n\t\tif (level >= 90) return 'mythic';\n\t\tif (level >= 75) return 'legendary';\n\t\tif (level >= 50) return 'epic';\n\t\tif (level >= 25) return 'rare';\n\t\treturn 'common';\n\t}\n}\n\nexport const levelingService = new LevelingService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/mission.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/mission.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/gamification/transformers/clout.transformer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'requestingUser' is defined but never used.","line":206,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":206,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'user' is defined but never used.","line":363,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":363,"endColumn":60}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Clout Transformer - Security-First Implementation\n * \n * Transforms raw database clout records into role-appropriate\n * response objects with GDPR compliance and admin data protection.\n */\n\nimport type { \n  UserId,\n  AchievementId,\n  CloutAmount \n} from '@shared/types/ids';\n// import { UserTransformer } from '../../users/transformers/user.transformer'; // TODO: Add when available\n\n// Public clout data (leaderboards, etc.)\nexport interface PublicCloutAchievement {\n  id: AchievementId;\n  name: string;\n  description?: string;\n  iconUrl?: string;\n  cloutReward: CloutAmount;\n  isEnabled: boolean;\n}\n\n// Authenticated user viewing achievements\nexport interface AuthenticatedCloutAchievement extends PublicCloutAchievement {\n  // User progress tracking\n  userProgress?: {\n    isCompleted: boolean;\n    progress: number;\n    maxProgress: number;\n    completedAt?: string;\n  };\n  \n  // Display criteria (sanitized)\n  criteria: {\n    type: string;\n    description: string;\n    target: number;\n  };\n}\n\n// Admin view with full management data\nexport interface AdminCloutAchievement extends AuthenticatedCloutAchievement {\n  // System fields\n  achievementKey: string;\n  criteriaType?: string;\n  criteriaValue?: number;\n  \n  // Admin metadata\n  createdAt: string;\n  adminNotes?: string;\n  \n  // Usage statistics\n  stats: {\n    totalCompletions: number;\n    completionRate: number;\n    avgTimeToComplete?: number;\n    lastAwarded?: string;\n  };\n}\n\n// Clout log entries for different views\nexport interface PublicCloutLog {\n  id: string;\n  amount: CloutAmount;\n  reason: string;\n  timestamp: string;\n  \n  // Public user info (if enabled by user)\n  user?: {\n    id: UserId;\n    username: string;\n    avatarUrl?: string;\n    level: number;\n  };\n}\n\nexport interface AuthenticatedCloutLog extends PublicCloutLog {\n  // Enhanced context for own logs\n  source: 'achievement' | 'admin_grant' | 'event' | 'system';\n  achievement?: {\n    id: AchievementId;\n    name: string;\n    iconUrl?: string;\n  };\n}\n\nexport interface AdminCloutLog extends AuthenticatedCloutLog {\n  // Full admin data\n  systemData: {\n    userId: UserId;\n    achievementId?: AchievementId;\n    adminId?: UserId;\n    ipHash?: string; // Anonymized\n  };\n  \n  // Admin metadata\n  reviewedBy?: UserId;\n  flagged: boolean;\n  flagReason?: string;\n}\n\nexport class CloutTransformer {\n  \n  /**\n   * Transform achievement for public consumption\n   * Only shows basic achievement info for leaderboards/public displays\n   */\n  static toPublicAchievement(dbAchievement: any): PublicCloutAchievement {\n    if (!dbAchievement) {\n      throw new Error('Invalid achievement data provided to transformer');\n    }\n\n    return {\n      id: dbAchievement.id as AchievementId,\n      name: dbAchievement.name,\n      description: this.sanitizeDescription(dbAchievement.description),\n      iconUrl: dbAchievement.iconUrl || undefined,\n      cloutReward: this.sanitizeCloutAmount(dbAchievement.cloutReward),\n      isEnabled: dbAchievement.enabled === true\n    };\n  }\n\n  /**\n   * Transform achievement for authenticated users\n   * Includes user progress and sanitized criteria\n   */\n  static toAuthenticatedAchievement(dbAchievement: any, requestingUser: any, userProgress?: any): AuthenticatedCloutAchievement {\n    const publicData = this.toPublicAchievement(dbAchievement);\n    \n    return {\n      ...publicData,\n      \n      // User progress (if available)\n      userProgress: userProgress ? {\n        isCompleted: userProgress.isCompleted === true,\n        progress: userProgress.progress || 0,\n        maxProgress: userProgress.maxProgress || dbAchievement.criteriaValue || 1,\n        completedAt: userProgress.completedAt?.toISOString()\n      } : undefined,\n      \n      // Sanitized criteria\n      criteria: {\n        type: this.normalizeCriteriaType(dbAchievement.criteriaType),\n        description: this.generateCriteriaDescription(dbAchievement),\n        target: dbAchievement.criteriaValue || 0\n      }\n    };\n  }\n\n  /**\n   * Transform achievement for admin view\n   * Includes all system data and usage statistics\n   */\n  static toAdminAchievement(dbAchievement: any, stats?: any): AdminCloutAchievement {\n    // Get authenticated data with admin permissions\n    const authenticatedData = this.toAuthenticatedAchievement(dbAchievement, { role: 'admin' });\n    \n    return {\n      ...authenticatedData,\n      \n      // System fields\n      achievementKey: dbAchievement.achievementKey,\n      criteriaType: dbAchievement.criteriaType,\n      criteriaValue: dbAchievement.criteriaValue,\n      \n      // Admin metadata\n      createdAt: dbAchievement.createdAt.toISOString(),\n      adminNotes: dbAchievement.adminNotes,\n      \n      // Usage statistics\n      stats: {\n        totalCompletions: stats?.totalCompletions || 0,\n        completionRate: this.calculateCompletionRate(stats),\n        avgTimeToComplete: stats?.avgTimeToComplete,\n        lastAwarded: stats?.lastAwarded?.toISOString()\n      }\n    };\n  }\n\n  /**\n   * Transform clout log for public consumption\n   * Only shows basic info for public activity feeds\n   */\n  static toPublicCloutLog(dbLog: any): PublicCloutLog {\n    return {\n      id: dbLog.id,\n      amount: this.sanitizeCloutAmount(dbLog.cloutEarned),\n      reason: this.sanitizeReason(dbLog.reason, 'public'),\n      timestamp: dbLog.createdAt.toISOString(),\n      \n      // Public user info (if enabled)\n      user: dbLog.user ? {\n        id: dbLog.user.id as UserId,\n        username: dbLog.user.username || '[deleted]',\n        avatarUrl: dbLog.user.avatarUrl,\n        level: this.calculateLevel(dbLog.user.xp || 0)\n      } : undefined\n    };\n  }\n\n  /**\n   * Transform clout log for authenticated users viewing their own logs\n   */\n  static toAuthenticatedCloutLog(dbLog: any, requestingUser: any): AuthenticatedCloutLog {\n    const publicData = this.toPublicCloutLog(dbLog);\n    \n    return {\n      ...publicData,\n      \n      // Enhanced source identification\n      source: this.identifyLogSource(dbLog),\n      \n      // Achievement context (if applicable)\n      achievement: dbLog.achievement ? {\n        id: dbLog.achievement.id as AchievementId,\n        name: dbLog.achievement.name,\n        iconUrl: dbLog.achievement.iconUrl\n      } : undefined\n    };\n  }\n\n  /**\n   * Transform clout log for admin view\n   * Includes all system data and moderation info\n   */\n  static toAdminCloutLog(dbLog: any): AdminCloutLog {\n    // Get authenticated data with admin permissions\n    const authenticatedData = this.toAuthenticatedCloutLog(dbLog, { role: 'admin' });\n    \n    return {\n      ...authenticatedData,\n      \n      // System tracking\n      systemData: {\n        userId: dbLog.userId as UserId,\n        achievementId: dbLog.achievementId as AchievementId,\n        adminId: dbLog.adminId as UserId,\n        ipHash: this.anonymizeIP(dbLog.ipAddress)\n      },\n      \n      // Admin metadata\n      reviewedBy: dbLog.reviewedBy as UserId,\n      flagged: dbLog.flagged === true,\n      flagReason: dbLog.flagReason\n    };\n  }\n\n  /**\n   * Transform multiple achievements for list views\n   */\n  static toAchievementList(achievements: any[], requestingUser: any, viewType: 'public' | 'authenticated' | 'admin' = 'public') {\n    switch (viewType) {\n      case 'admin':\n        return achievements.map(achievement => this.toAdminAchievement(achievement));\n      case 'authenticated':\n        return achievements.map(achievement => this.toAuthenticatedAchievement(achievement, requestingUser));\n      default:\n        return achievements.map(achievement => this.toPublicAchievement(achievement));\n    }\n  }\n\n  /**\n   * Transform clout logs with pagination and summary\n   */\n  static toCloutLogHistory(logs: any[], requestingUser: any, viewType: 'public' | 'authenticated' | 'admin' = 'public') {\n    let transformedLogs;\n    \n    switch (viewType) {\n      case 'admin':\n        transformedLogs = logs.map(log => this.toAdminCloutLog(log));\n        break;\n      case 'authenticated':\n        transformedLogs = logs.map(log => this.toAuthenticatedCloutLog(log, requestingUser));\n        break;\n      default:\n        transformedLogs = logs.map(log => this.toPublicCloutLog(log));\n    }\n\n    return {\n      logs: transformedLogs,\n      summary: this.calculateLogSummary(logs, requestingUser)\n    };\n  }\n\n  // ==========================================\n  // PRIVATE UTILITY METHODS\n  // ==========================================\n\n  private static sanitizeCloutAmount(amount: any): CloutAmount {\n    const parsed = parseInt(amount?.toString() || '0', 10);\n    return (isNaN(parsed) ? 0 : Math.max(0, parsed)) as CloutAmount;\n  }\n\n  private static sanitizeDescription(description: string): string {\n    if (!description) return '';\n    return description.trim().substring(0, 200); // Limit length for security\n  }\n\n  private static sanitizeReason(reason: string, level: 'public' | 'authenticated'): string {\n    if (!reason) return 'Achievement earned';\n    \n    if (level === 'public') {\n      // More aggressive sanitization for public view\n      return reason.replace(/admin|internal|system/gi, '').trim() || 'Achievement earned';\n    }\n    \n    return reason.trim();\n  }\n\n  private static normalizeCriteriaType(criteriaType: string): string {\n    const typeMap: Record<string, string> = {\n      'posts_created': 'Create Posts',\n      'likes_received': 'Receive Likes',\n      'threads_created': 'Create Threads',\n      'days_active': 'Active Days',\n      'dgt_earned': 'Earn DGT',\n      'tips_given': 'Give Tips'\n    };\n    \n    return typeMap[criteriaType] || 'Complete Action';\n  }\n\n  private static generateCriteriaDescription(achievement: any): string {\n    const { criteriaType, criteriaValue } = achievement;\n    \n    switch (criteriaType) {\n      case 'posts_created':\n        return `Create ${criteriaValue} posts`;\n      case 'likes_received':\n        return `Receive ${criteriaValue} likes`;\n      case 'threads_created':\n        return `Start ${criteriaValue} threads`;\n      case 'days_active':\n        return `Be active for ${criteriaValue} days`;\n      case 'dgt_earned':\n        return `Earn ${criteriaValue} DGT`;\n      case 'tips_given':\n        return `Give ${criteriaValue} tips`;\n      default:\n        return achievement.description || 'Complete the required action';\n    }\n  }\n\n  private static identifyLogSource(dbLog: any): 'achievement' | 'admin_grant' | 'event' | 'system' {\n    if (dbLog.achievementId) return 'achievement';\n    if (dbLog.reason?.includes('Admin')) return 'admin_grant';\n    if (dbLog.reason?.includes('Event') || dbLog.reason?.includes('Rain')) return 'event';\n    return 'system';\n  }\n\n  private static calculateLevel(xp: number): number {\n    // Basic level calculation - replace with actual level system\n    return Math.floor(Math.sqrt(xp / 100)) + 1;\n  }\n\n  private static calculateCompletionRate(stats: any): number {\n    if (!stats || !stats.totalUsers) return 0;\n    return Math.round((stats.totalCompletions / stats.totalUsers) * 100);\n  }\n\n  private static calculateLogSummary(logs: any[], user: any) {\n    const totalClout = logs.reduce((sum, log) => sum + (log.cloutEarned || 0), 0);\n    const achievementLogs = logs.filter(log => log.achievementId);\n    const adminLogs = logs.filter(log => log.reason?.includes('Admin'));\n    \n    return {\n      totalClout,\n      totalEntries: logs.length,\n      fromAchievements: achievementLogs.length,\n      fromAdminGrants: adminLogs.length,\n      fromEvents: logs.length - achievementLogs.length - adminLogs.length\n    };\n  }\n\n  private static anonymizeIP(ip?: string): string {\n    if (!ip) return 'unknown';\n    \n    if (ip.includes(':')) {\n      // IPv6\n      const parts = ip.split(':');\n      return parts.slice(0, 4).join(':') + '::***';\n    } else {\n      // IPv4\n      const parts = ip.split('.');\n      return parts.slice(0, 3).join('.') + '.***';\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/messaging/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/messaging/message.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdmin' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Messaging Routes\n *\n * Defines API routes for user-to-user messaging functionality.\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport type { UserId } from '@shared/types/ids';\nimport { z } from 'zod';\nimport { db } from '@db';\nimport { eq } from 'drizzle-orm';\nimport { users } from '@schema';\nimport { getUserIdFromRequest } from '@server/src/utils/auth';\nimport { isAuthenticated, isAdminOrModerator, isAdmin } from '../auth/middleware/auth.middleware';\nimport { MessageTransformer } from './transformers/message.transformer';\nimport { MessageService } from './message.service';\nimport { logger } from \"../../core/logger\";\n\nconst router = Router();\n\n// Get all conversations for the current user\nrouter.get('/conversations', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = getUserIdFromRequest(req);\n\t\tif (userId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\n\t\t// Get conversations using the service\n\t\tconst conversations = await MessageService.getConversations(userId);\n\n\t\t// Get current user for transformation\n\t\tconst [currentUser] = await db\n\t\t\t.select()\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, userId))\n\t\t\t.limit(1);\n\t\t\n\t\t// Transform conversations for authenticated user\n\t\tconst transformedConversations = conversations.map(conversation => \n\t\t\tMessageTransformer.toAuthenticatedConversation(conversation, currentUser, conversation.participants)\n\t\t);\n\t\t\n\t\tres.json(transformedConversations);\n\t} catch (error) {\n\t\tlogger.error('Error getting conversations:', error);\n\t\tres.status(500).json({ message: 'Failed to get conversations' });\n\t}\n});\n\n// Get messages for a specific conversation\nrouter.get('/conversation/:userId', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst currentUserId = getUserIdFromRequest(req);\n\t\tif (currentUserId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\t\tconst otherUserId = req.params.userId as UserId;\n\n\t\tif (isNaN(otherUserId)) {\n\t\t\treturn res.status(400).json({ message: 'Invalid user ID' });\n\t\t}\n\n\t\t// Get messages using the service\n\t\tconst conversationMessages = await MessageService.getMessageThread(currentUserId, otherUserId);\n\n\t\t// Get other user details\n\t\tconst [otherUser] = await db\n\t\t\t.select()\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, otherUserId))\n\t\t\t.limit(1);\n\n\t\t// Get current user details\n\t\tconst [currentUser] = await db\n\t\t\t.select()\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, currentUserId))\n\t\t\t.limit(1);\n\n\t\t// Transform messages for authenticated user\n\t\tconst messageThread = {\n\t\t\tparticipants: [currentUser, otherUser],\n\t\t\tmessages: conversationMessages.map(message => \n\t\t\t\tMessageTransformer.toAuthenticatedMessage(message, currentUser)\n\t\t\t),\n\t\t\ttotalCount: conversationMessages.length\n\t\t};\n\n\t\tres.json(messageThread);\n\t} catch (error) {\n\t\tlogger.error('Error getting conversation messages:', error);\n\t\tres.status(500).json({ message: 'Failed to get conversation messages' });\n\t}\n});\n\n// Send a new message\nrouter.post('/send', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst sendMessageSchema = z.object({\n\t\t\trecipientId: z.string().uuid(),\n\t\t\tcontent: z.string().min(1).max(2000)\n\t\t});\n\n\t\tconst { recipientId, content } = sendMessageSchema.parse(req.body);\n\t\tconst senderId = getUserIdFromRequest(req);\n\n\t\tif (senderId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\n\t\t// Send message using the service\n\t\tconst newMessage = await MessageService.sendMessage(senderId, { recipientId, content });\n\n\t\t// Get current user details for transformation\n\t\tconst [currentUser] = await db\n\t\t\t.select()\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, senderId))\n\t\t\t.limit(1);\n\n\t\t// Transform the message before sending response\n\t\tconst transformedMessage = MessageTransformer.toAuthenticatedMessage(\n\t\t\tnewMessage,\n\t\t\tcurrentUser\n\t\t);\n\n\t\tres.status(201).json(transformedMessage);\n\t} catch (error) {\n\t\tlogger.error('Error sending message:', error);\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn res.status(400).json({ message: 'Invalid message data', errors: error.errors });\n\t\t}\n\t\tres.status(500).json({ message: 'Failed to send message' });\n\t}\n});\n\n// Mark messages as read\nrouter.post('/mark-read/:userId', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst currentUserId = getUserIdFromRequest(req);\n\t\tif (currentUserId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\t\tconst senderId = req.params.userId as UserId;\n\n\t\tif (isNaN(senderId)) {\n\t\t\treturn res.status(400).json({ message: 'Invalid user ID' });\n\t\t}\n\n\t\t// Mark messages as read using the service\n\t\tawait MessageService.markMessagesAsRead(currentUserId, senderId);\n\n\t\tres.json({ success: true, message: 'Messages marked as read' });\n\t} catch (error) {\n\t\tlogger.error('Error marking messages as read:', error);\n\t\tres.status(500).json({ message: 'Failed to mark messages as read' });\n\t}\n});\n\n// Delete a conversation\nrouter.delete('/conversation/:userId', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst currentUserId = getUserIdFromRequest(req);\n\t\tif (currentUserId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\t\tconst otherUserId = req.params.userId as UserId;\n\n\t\tif (isNaN(otherUserId)) {\n\t\t\treturn res.status(400).json({ message: 'Invalid user ID' });\n\t\t}\n\n\t\t// Delete conversation using the service\n\t\tawait MessageService.deleteConversation(currentUserId, otherUserId);\n\n\t\tres.json({ success: true, message: 'Conversation deleted' });\n\t} catch (error) {\n\t\tlogger.error('Error deleting conversation:', error);\n\t\tres.status(500).json({ message: 'Failed to delete conversation' });\n\t}\n});\n\n// Get unread message count\nrouter.get('/unread-count', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = getUserIdFromRequest(req);\n\t\tif (userId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\n\t\t// Get unread count using the service\n\t\tconst total = await MessageService.getUnreadCount(userId);\n\n\t\tres.json({ total });\n\t} catch (error) {\n\t\tlogger.error('Error getting unread count:', error);\n\t\tres.status(500).json({ message: 'Failed to get unread message count' });\n\t}\n});\n\n// Edit a message\nrouter.put('/message/:messageId', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst editMessageSchema = z.object({\n\t\t\tcontent: z.string().min(1).max(2000)\n\t\t});\n\n\t\tconst { content } = editMessageSchema.parse(req.body);\n\t\tconst messageId = req.params.messageId;\n\t\tconst userId = getUserIdFromRequest(req);\n\n\t\tif (userId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\n\t\tawait MessageService.editMessage(messageId, userId, content);\n\n\t\tres.json({ success: true, message: 'Message edited successfully' });\n\t} catch (error) {\n\t\tlogger.error('Error editing message:', error);\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn res.status(400).json({ message: 'Invalid message data', errors: error.errors });\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\treturn res.status(400).json({ message: error.message });\n\t\t}\n\t\tres.status(500).json({ message: 'Failed to edit message' });\n\t}\n});\n\n// Delete a single message\nrouter.delete('/message/:messageId', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst messageId = req.params.messageId;\n\t\tconst userId = getUserIdFromRequest(req);\n\n\t\tif (userId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\n\t\tawait MessageService.deleteMessage(messageId, userId);\n\n\t\tres.json({ success: true, message: 'Message deleted successfully' });\n\t} catch (error) {\n\t\tlogger.error('Error deleting message:', error);\n\t\tif (error instanceof Error) {\n\t\t\treturn res.status(400).json({ message: error.message });\n\t\t}\n\t\tres.status(500).json({ message: 'Failed to delete message' });\n\t}\n});\n\n// Admin: Get all messages for moderation\nrouter.get('/admin/messages', isAdminOrModerator, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst { userId, page = 1, limit = 50 } = req.query;\n\t\t\n\t\t// Get messages for admin moderation view\n\t\tconst messages = await MessageService.getMessagesForModeration({ \n\t\t\tuserId: userId as string, \n\t\t\tpage: parseInt(page as string), \n\t\t\tlimit: parseInt(limit as string) \n\t\t});\n\t\t\n\t\t// Transform messages for admin view\n\t\tconst transformedMessages = messages.map(message => \n\t\t\tMessageTransformer.toAdminMessage(message)\n\t\t);\n\t\t\n\t\tres.json({ \n\t\t\tmessages: transformedMessages,\n\t\t\ttotal: messages.length,\n\t\t\tpage: parseInt(page as string),\n\t\t\tlimit: parseInt(limit as string)\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Error getting messages for moderation:', error);\n\t\tres.status(500).json({ message: 'Failed to get messages for moderation' });\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/messaging/message.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'directMessages' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":243,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":243,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'blockedUserId' is defined but never used.","line":243,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":243,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'messageId' is defined but never used.","line":252,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":252,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'reporterId' is defined but never used.","line":252,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":252,"endColumn":70},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'reason' is defined but never used.","line":252,"column":72,"nodeType":"Identifier","messageId":"unusedVar","endLine":252,"endColumn":86}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Message Service\n * \n * Business logic for messaging functionality\n */\n\nimport { db } from '@db';\nimport { eq, and, or, sql, desc } from 'drizzle-orm';\nimport { messages, users, directMessages } from '@schema';\nimport type { UserId, MessageId } from '@shared/types/ids';\nimport { MessageTransformer } from './transformers';\nimport type { SendMessageRequest } from './types';\nimport { randomUUID } from 'crypto';\n\nexport class MessageService {\n  /**\n   * Get all conversations for a user\n   */\n  static async getConversations(userId: UserId) {\n    const conversations = await db.execute(sql`\n      WITH latest_messages AS (\n        SELECT \n          CASE \n            WHEN sender_id = ${userId} THEN recipient_id\n            ELSE sender_id\n          END AS conversation_user_id,\n          MAX(id) as latest_message_id\n        FROM messages\n        WHERE sender_id = ${userId} OR recipient_id = ${userId}\n        GROUP BY conversation_user_id\n      ),\n      unread_counts AS (\n        SELECT \n          sender_id,\n          COUNT(*) as unread_count\n        FROM messages\n        WHERE recipient_id = ${userId} AND is_read = false\n        GROUP BY sender_id\n      )\n      SELECT \n        u.id as user_id,\n        u.username,\n        u.avatar_url as \"avatarUrl\",\n        m.content as \"lastMessage\",\n        m.created_at as \"lastMessageTime\",\n        COALESCE(uc.unread_count, 0) as \"unreadCount\"\n      FROM latest_messages lm\n      JOIN messages m ON m.id = lm.latest_message_id\n      JOIN users u ON u.id = lm.conversation_user_id\n      LEFT JOIN unread_counts uc ON uc.sender_id = lm.conversation_user_id\n      ORDER BY m.created_at DESC\n    `);\n\n    return conversations.rows;\n  }\n\n  /**\n   * Get messages between two users\n   */\n  static async getMessageThread(currentUserId: UserId, otherUserId: UserId) {\n    const conversationMessages = await db\n      .select()\n      .from(messages)\n      .where(\n        or(\n          and(eq(messages.senderId, currentUserId), eq(messages.recipientId, otherUserId)),\n          and(eq(messages.senderId, otherUserId), eq(messages.recipientId, currentUserId))\n        )\n      )\n      .orderBy(messages.createdAt);\n\n    return conversationMessages;\n  }\n\n  /**\n   * Send a new message\n   */\n  static async sendMessage(senderId: UserId, payload: SendMessageRequest) {\n    const { recipientId, content } = payload;\n\n    // Validate recipient exists\n    const recipientExists = await db\n      .select({ id: users.id })\n      .from(users)\n      .where(eq(users.id, recipientId))\n      .limit(1);\n\n    if (recipientExists.length === 0) {\n      throw new Error('Recipient not found');\n    }\n\n    // Don't allow self-messaging\n    if (senderId === recipientId) {\n      throw new Error('Cannot send messages to yourself');\n    }\n\n    // Create the message\n    const [newMessage] = await db\n      .insert(messages)\n      .values({\n        id: parseInt(Date.now().toString().slice(-9)),\n        uuid: randomUUID(),\n        senderId,\n        recipientId,\n        content,\n        isRead: false,\n        isDeleted: false,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      })\n      .returning();\n\n    return newMessage;\n  }\n\n  /**\n   * Mark messages as read\n   */\n  static async markMessagesAsRead(recipientId: UserId, senderId: UserId) {\n    await db\n      .update(messages)\n      .set({\n        isRead: true,\n        updatedAt: new Date()\n      })\n      .where(\n        and(\n          eq(messages.senderId, senderId),\n          eq(messages.recipientId, recipientId),\n          eq(messages.isRead, false)\n        )\n      );\n  }\n\n  /**\n   * Delete a conversation (soft delete)\n   */\n  static async deleteConversation(userId: UserId, otherUserId: UserId) {\n    await db\n      .update(messages)\n      .set({\n        isDeleted: true,\n        updatedAt: new Date()\n      })\n      .where(\n        or(\n          and(eq(messages.senderId, userId), eq(messages.recipientId, otherUserId)),\n          and(eq(messages.senderId, otherUserId), eq(messages.recipientId, userId))\n        )\n      );\n  }\n\n  /**\n   * Get unread message count for a user\n   */\n  static async getUnreadCount(userId: UserId): Promise<number> {\n    const result = await db\n      .select({ count: sql<number>`count(*)` })\n      .from(messages)\n      .where(\n        and(\n          eq(messages.recipientId, userId),\n          eq(messages.isRead, false),\n          eq(messages.isDeleted, false)\n        )\n      );\n\n    return result[0]?.count || 0;\n  }\n\n  /**\n   * Delete a single message\n   */\n  static async deleteMessage(messageId: MessageId, userId: UserId) {\n    // First check if user has permission to delete\n    const [message] = await db\n      .select()\n      .from(messages)\n      .where(eq(messages.id, messageId))\n      .limit(1);\n\n    if (!message) {\n      throw new Error('Message not found');\n    }\n\n    // User can only delete their own messages\n    if (message.senderId !== userId && message.recipientId !== userId) {\n      throw new Error('Unauthorized to delete this message');\n    }\n\n    await db\n      .update(messages)\n      .set({\n        isDeleted: true,\n        deletedAt: new Date(),\n        deletedBy: userId\n      })\n      .where(eq(messages.id, messageId));\n  }\n\n  /**\n   * Edit a message\n   */\n  static async editMessage(messageId: MessageId, userId: UserId, newContent: string) {\n    // First check if user has permission to edit\n    const [message] = await db\n      .select()\n      .from(messages)\n      .where(eq(messages.id, messageId))\n      .limit(1);\n\n    if (!message) {\n      throw new Error('Message not found');\n    }\n\n    // Only sender can edit\n    if (message.senderId !== userId) {\n      throw new Error('Only the sender can edit messages');\n    }\n\n    // Check time limit (15 minutes)\n    const messageAge = Date.now() - new Date(message.createdAt).getTime();\n    const fifteenMinutes = 15 * 60 * 1000;\n    \n    if (messageAge > fifteenMinutes) {\n      throw new Error('Messages can only be edited within 15 minutes');\n    }\n\n    await db\n      .update(messages)\n      .set({\n        content: newContent,\n        isEdited: true,\n        editedAt: new Date(),\n        updatedAt: new Date()\n      })\n      .where(eq(messages.id, messageId));\n  }\n\n  /**\n   * Block a user from messaging\n   */\n  static async blockUser(userId: UserId, blockedUserId: UserId) {\n    // Implementation would depend on your blocking system\n    // This is a placeholder\n    throw new Error('Blocking system not yet implemented');\n  }\n\n  /**\n   * Report a message\n   */\n  static async reportMessage(messageId: MessageId, reporterId: UserId, reason: string) {\n    // Implementation would depend on your reporting system\n    // This is a placeholder\n    throw new Error('Reporting system not yet implemented');\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/messaging/transformers/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/messaging/transformers/message.transformer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createHash' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":19,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'analytics' is defined but never used.","line":117,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":117,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":403,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":403,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'messageId' is defined but never used.","line":408,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":408,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":408,"column":48,"nodeType":"Identifier","messageId":"unusedVar","endLine":408,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'messageId' is defined but never used.","line":413,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":413,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":413,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":413,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'user' is defined but never used.","line":476,"column":60,"nodeType":"Identifier","messageId":"unusedVar","endLine":476,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'conversationId' is defined but never used.","line":496,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":496,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":496,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":496,"endColumn":70},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'conversationId' is defined but never used.","line":501,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":501,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":501,"column":58,"nodeType":"Identifier","messageId":"unusedVar","endLine":501,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'conversationId' is defined but never used.","line":506,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":506,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":506,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":506,"endColumn":70},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'conversationId' is defined but never used.","line":511,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":511,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":511,"column":60,"nodeType":"Identifier","messageId":"unusedVar","endLine":511,"endColumn":71},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'conversationId' is defined but never used.","line":553,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":553,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":553,"column":67,"nodeType":"Identifier","messageId":"unusedVar","endLine":553,"endColumn":78}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Message Transformer\n * \n * Security-first data transformation for private messaging and conversations\n * Implements three-tier access: Public → Authenticated → Admin\n * Follows established patterns from Users, Forums, Economy, and Shop domains\n */\n\nimport type { UserId } from '@shared/types/ids';\nimport type { PublicMessage, AuthenticatedMessage, AdminMessage, PublicConversation, AuthenticatedConversation, AdminConversation, MessageSearchResult, TypingStatus } from '../types';\n\nimport type { \n  MessageId, \n  ConversationId,\n  DgtAmount\n} from '@shared/types';\n\nimport { UserTransformer } from '../../users/transformers/user.transformer';\nimport { createHash } from 'crypto';\n\nexport class MessageTransformer {\n  \n  // ==========================================\n  // MESSAGE TRANSFORMERS\n  // ==========================================\n\n  /**\n   * Transform message for public view (system messages and announcements only)\n   * Minimal data exposure for non-participants\n   */\n  static toPublicMessage(dbMessage: any): PublicMessage {\n    return {\n      id: dbMessage.id as MessageId,\n      content: this.sanitizeContent(dbMessage.content, 'public'),\n      timestamp: dbMessage.createdAt.toISOString(),\n      type: dbMessage.type || 'system',\n      \n      // Minimal sender info for system messages only\n      sender: dbMessage.type === 'system' ? {\n        id: dbMessage.senderId as UserId,\n        username: dbMessage.senderUsername || 'System',\n        level: dbMessage.senderLevel || 0\n      } : undefined,\n      \n      // System metadata\n      isSystem: dbMessage.type === 'system',\n      isEdited: dbMessage.editedAt !== null\n    };\n  }\n\n  /**\n   * Transform message for authenticated participants\n   * Shows full message content with interaction permissions\n   */\n  static toAuthenticatedMessage(dbMessage: any, requestingUser: any, conversation?: any): AuthenticatedMessage {\n    const isParticipant = this.isUserParticipant(requestingUser?.id, conversation);\n    \n    if (!isParticipant && dbMessage.type !== 'system') {\n      throw new Error('User is not a participant in this conversation');\n    }\n\n    return {\n      id: dbMessage.id as MessageId,\n      conversationId: dbMessage.conversationId as ConversationId,\n      senderId: dbMessage.senderId as UserId,\n      content: this.sanitizeContent(dbMessage.content, 'authenticated'),\n      timestamp: dbMessage.createdAt.toISOString(),\n      type: dbMessage.type || 'text',\n      \n      // Sender details\n      sender: {\n        id: dbMessage.senderId as UserId,\n        username: dbMessage.senderUsername,\n        avatarUrl: dbMessage.senderAvatarUrl,\n        level: dbMessage.senderLevel || 1,\n        isOnline: this.isUserOnline(dbMessage.senderId),\n        lastSeen: dbMessage.senderLastSeen?.toISOString()\n      },\n      \n      // Message state\n      isEdited: dbMessage.editedAt !== null,\n      editedAt: dbMessage.editedAt?.toISOString(),\n      isDeleted: dbMessage.deletedAt !== null,\n      deletedAt: dbMessage.deletedAt?.toISOString(),\n      \n      // Read status for current user\n      isRead: this.isMessageRead(dbMessage.id, requestingUser?.id),\n      readAt: this.getReadTimestamp(dbMessage.id, requestingUser?.id),\n      \n      // Interaction permissions\n      canEdit: this.canUserEditMessage(dbMessage, requestingUser),\n      canDelete: this.canUserDeleteMessage(dbMessage, requestingUser),\n      canReact: this.canUserReactToMessage(dbMessage, requestingUser),\n      \n      // Reactions\n      reactions: this.transformReactions(dbMessage.reactions, requestingUser?.id),\n      \n      // Tip amount (if applicable)\n      tipAmount: dbMessage.tipAmount ? this.sanitizeDgtAmount(dbMessage.tipAmount) : undefined,\n      \n      // Reply context\n      replyTo: dbMessage.replyToId ? {\n        messageId: dbMessage.replyToId as MessageId,\n        content: this.truncateContent(dbMessage.replyToContent, 100),\n        senderUsername: dbMessage.replyToSenderUsername\n      } : undefined,\n      \n      // File attachments\n      attachments: this.transformAttachments(dbMessage.attachments, requestingUser)\n    };\n  }\n\n  /**\n   * Transform message for admin/moderation view\n   * Includes all system data and moderation information\n   */\n  static toAdminMessage(dbMessage: any, analytics?: any): AdminMessage {\n    // Get authenticated data first (with admin permissions)\n    const authenticatedData = this.toAuthenticatedMessage(dbMessage, { role: 'admin', id: 'admin' });\n    \n    return {\n      ...authenticatedData,\n      \n      // System tracking (anonymized for GDPR)\n      ipAddress: this.anonymizeIP(dbMessage.ipAddress),\n      userAgent: dbMessage.userAgent,\n      \n      // Moderation data\n      reportCount: dbMessage.reportCount || 0,\n      isFlagged: dbMessage.isFlagged === true,\n      flagReason: dbMessage.flagReason,\n      moderationNotes: dbMessage.moderationNotes,\n      \n      // Technical metadata\n      messageSize: this.calculateMessageSize(dbMessage),\n      deliveryStatus: dbMessage.deliveryStatus || 'sent',\n      encryptionStatus: dbMessage.encryptionStatus || 'plain',\n      \n      // Edit history for audit\n      editHistory: this.getEditHistory(dbMessage),\n      \n      // Admin actions\n      moderatedBy: dbMessage.moderatedBy as UserId || undefined,\n      moderatedAt: dbMessage.moderatedAt?.toISOString(),\n      moderationAction: dbMessage.moderationAction || 'none'\n    };\n  }\n\n  // ==========================================\n  // CONVERSATION TRANSFORMERS\n  // ==========================================\n\n  /**\n   * Transform conversation for public view (system announcements only)\n   */\n  static toPublicConversation(dbConversation: any): PublicConversation {\n    // Only show system conversations publicly\n    if (dbConversation.type !== 'system' && dbConversation.type !== 'announcement') {\n      throw new Error('Conversation is not public');\n    }\n\n    return {\n      id: dbConversation.id as ConversationId,\n      type: dbConversation.type,\n      title: dbConversation.title,\n      \n      // Basic public stats\n      participantCount: dbConversation.participantCount || 0,\n      messageCount: dbConversation.messageCount || 0,\n      \n      // Latest message preview (sanitized)\n      lastMessage: dbConversation.lastMessage ? {\n        content: this.truncateContent(dbConversation.lastMessage.content, 50),\n        timestamp: dbConversation.lastMessage.createdAt.toISOString(),\n        senderUsername: dbConversation.lastMessage.senderUsername\n      } : undefined,\n      \n      // System flags\n      isSystem: dbConversation.type === 'system',\n      isActive: dbConversation.isActive !== false\n    };\n  }\n\n  /**\n   * Transform conversation for authenticated participants\n   * Shows full conversation data with user-specific state\n   */\n  static toAuthenticatedConversation(dbConversation: any, requestingUser: any, participants?: any[]): AuthenticatedConversation {\n    const isParticipant = this.isUserParticipant(requestingUser?.id, dbConversation);\n    \n    if (!isParticipant && dbConversation.type !== 'system') {\n      throw new Error('User is not a participant in this conversation');\n    }\n\n    return {\n      id: dbConversation.id as ConversationId,\n      type: dbConversation.type || 'direct',\n      title: dbConversation.title,\n      \n      // Participants with online status\n      participants: (participants || []).map(participant => ({\n        id: participant.userId as UserId,\n        username: participant.username,\n        avatarUrl: participant.avatarUrl,\n        level: participant.level || 1,\n        isOnline: this.isUserOnline(participant.userId),\n        role: participant.role || 'member'\n      })),\n      \n      // User-specific state\n      lastReadAt: this.getUserLastReadTime(dbConversation.id, requestingUser?.id),\n      unreadCount: this.getUserUnreadCount(dbConversation.id, requestingUser?.id),\n      isMuted: this.isConversationMuted(dbConversation.id, requestingUser?.id),\n      isPinned: this.isConversationPinned(dbConversation.id, requestingUser?.id),\n      \n      // Conversation metadata\n      createdAt: dbConversation.createdAt.toISOString(),\n      createdBy: dbConversation.createdBy as UserId,\n      messageCount: dbConversation.messageCount || 0,\n      \n      // Latest message\n      lastMessage: dbConversation.lastMessage ? {\n        id: dbConversation.lastMessage.id as MessageId,\n        content: this.truncateContent(dbConversation.lastMessage.content, 100),\n        timestamp: dbConversation.lastMessage.createdAt.toISOString(),\n        senderId: dbConversation.lastMessage.senderId as UserId,\n        senderUsername: dbConversation.lastMessage.senderUsername,\n        type: dbConversation.lastMessage.type || 'text'\n      } : undefined,\n      \n      // User permissions in this conversation\n      canSendMessages: this.canUserSendMessages(dbConversation, requestingUser),\n      canAddParticipants: this.canUserAddParticipants(dbConversation, requestingUser),\n      canLeave: this.canUserLeaveConversation(dbConversation, requestingUser),\n      canDelete: this.canUserDeleteConversation(dbConversation, requestingUser),\n      \n      // User settings for this conversation\n      settings: this.getUserConversationSettings(dbConversation.id, requestingUser?.id)\n    };\n  }\n\n  /**\n   * Transform conversation for admin view\n   * Includes comprehensive analytics and moderation data\n   */\n  static toAdminConversation(dbConversation: any, analytics?: any): AdminConversation {\n    // Get authenticated data with admin permissions\n    const authenticatedData = this.toAuthenticatedConversation(dbConversation, { role: 'admin', id: 'admin' });\n    \n    return {\n      ...authenticatedData,\n      \n      // System data (anonymized)\n      createdByIp: this.anonymizeIP(dbConversation.createdByIp),\n      totalDataSize: this.calculateConversationSize(dbConversation),\n      \n      // Moderation\n      reportCount: dbConversation.reportCount || 0,\n      isFlagged: dbConversation.isFlagged === true,\n      flagReason: dbConversation.flagReason,\n      moderationNotes: dbConversation.moderationNotes,\n      \n      // Analytics\n      activityMetrics: {\n        messagesLast24h: analytics?.messagesLast24h || 0,\n        messagesLast7d: analytics?.messagesLast7d || 0,\n        averageResponseTime: analytics?.averageResponseTime || 0,\n        mostActiveParticipant: analytics?.mostActiveParticipant as UserId\n      },\n      \n      // Technical details\n      encryptionEnabled: dbConversation.encryptionEnabled === true,\n      backupStatus: dbConversation.backupStatus || 'current',\n      lastBackupAt: dbConversation.lastBackupAt?.toISOString(),\n      \n      // Admin metadata\n      moderatedBy: dbConversation.moderatedBy as UserId || undefined,\n      moderatedAt: dbConversation.moderatedAt?.toISOString(),\n      adminNotes: dbConversation.adminNotes\n    };\n  }\n\n  // ==========================================\n  // UTILITY TRANSFORMERS\n  // ==========================================\n\n  /**\n   * Transform search results with proper context\n   */\n  static toMessageSearchResult(searchResult: any, requestingUser: any): MessageSearchResult {\n    return {\n      message: this.toAuthenticatedMessage(searchResult.message, requestingUser, searchResult.conversation),\n      conversation: {\n        id: searchResult.conversation.id as ConversationId,\n        title: searchResult.conversation.title,\n        participantCount: searchResult.conversation.participantCount,\n        unreadCount: this.getUserUnreadCount(searchResult.conversation.id, requestingUser?.id),\n        lastActivity: searchResult.conversation.lastMessageAt.toISOString(),\n        type: searchResult.conversation.type,\n        isActive: searchResult.conversation.isActive !== false\n      },\n      context: {\n        beforeMessages: searchResult.beforeMessages.map((msg: any) => ({\n          id: msg.id as MessageId,\n          content: this.truncateContent(msg.content, 100),\n          timestamp: msg.createdAt.toISOString(),\n          sender: {\n            id: msg.senderId as UserId,\n            username: msg.senderUsername,\n            avatarUrl: msg.senderAvatarUrl,\n            level: msg.senderLevel || 1,\n            isOnline: false,\n            lastSeen: undefined\n          }\n        })),\n        afterMessages: searchResult.afterMessages.map((msg: any) => ({\n          id: msg.id as MessageId,\n          content: this.truncateContent(msg.content, 100),\n          timestamp: msg.createdAt.toISOString(),\n          sender: {\n            id: msg.senderId as UserId,\n            username: msg.senderUsername,\n            avatarUrl: msg.senderAvatarUrl,\n            level: msg.senderLevel || 1,\n            isOnline: false,\n            lastSeen: undefined\n          }\n        }))\n      },\n      matchScore: searchResult.matchScore || 0\n    };\n  }\n\n  /**\n   * Transform typing status for real-time updates\n   */\n  static toTypingStatus(dbTyping: any): TypingStatus {\n    return {\n      conversationId: dbTyping.conversationId as ConversationId,\n      userId: dbTyping.userId as UserId,\n      username: dbTyping.username,\n      startedAt: dbTyping.startedAt.toISOString(),\n      expiresAt: dbTyping.expiresAt.toISOString()\n    };\n  }\n\n  // ==========================================\n  // PRIVATE UTILITY METHODS\n  // ==========================================\n\n  private static sanitizeContent(content: string, level: 'public' | 'authenticated'): string {\n    if (!content) return '';\n    \n    // Basic sanitization\n    let sanitized = content.trim();\n    \n    if (level === 'public') {\n      // More aggressive sanitization for public content\n      sanitized = sanitized.replace(/@\\w+/g, '[mention]'); // Remove mentions\n      sanitized = sanitized.replace(/https?:\\/\\/[^\\s]+/g, '[link]'); // Remove links\n    }\n    \n    return sanitized;\n  }\n\n  private static truncateContent(content: string, maxLength: number): string {\n    if (!content) return '';\n    if (content.length <= maxLength) return content;\n    return content.substring(0, maxLength - 3) + '...';\n  }\n\n  private static sanitizeDgtAmount(amount: any): DgtAmount {\n    const parsed = parseFloat(amount?.toString() || '0');\n    return (isNaN(parsed) ? 0 : Math.max(0, parsed)) as DgtAmount;\n  }\n\n  private static anonymizeIP(ip?: string): string {\n    if (!ip) return 'unknown';\n    \n    if (ip.includes(':')) {\n      // IPv6\n      const parts = ip.split(':');\n      return parts.slice(0, 4).join(':') + '::***';\n    } else {\n      // IPv4\n      const parts = ip.split('.');\n      return parts.slice(0, 3).join('.') + '.***';\n    }\n  }\n\n  private static isUserParticipant(userId: any, conversation: any): boolean {\n    if (!userId || !conversation) return false;\n    \n    // System conversations are open to all authenticated users\n    if (conversation.type === 'system' || conversation.type === 'announcement') {\n      return true;\n    }\n    \n    // Check participant list\n    return conversation.participants?.some((p: any) => p.userId === userId) || false;\n  }\n\n  private static isUserOnline(userId: any): boolean {\n    // This would integrate with a real-time presence system\n    return false; // Placeholder\n  }\n\n  private static isMessageRead(messageId: any, userId: any): boolean {\n    // This would check read receipts table\n    return false; // Placeholder\n  }\n\n  private static getReadTimestamp(messageId: any, userId: any): string | undefined {\n    // This would get actual read timestamp\n    return undefined; // Placeholder\n  }\n\n  private static canUserEditMessage(dbMessage: any, user: any): boolean {\n    if (!user?.id) return false;\n    \n    // User can edit their own messages within 15 minutes\n    if (dbMessage.senderId === user.id) {\n      const editWindow = 15 * 60 * 1000; // 15 minutes\n      const messageAge = Date.now() - new Date(dbMessage.createdAt).getTime();\n      return messageAge < editWindow;\n    }\n    \n    // Admins and moderators can edit any message\n    return user.role === 'admin' || user.role === 'moderator';\n  }\n\n  private static canUserDeleteMessage(dbMessage: any, user: any): boolean {\n    if (!user?.id) return false;\n    \n    // User can delete their own messages\n    if (dbMessage.senderId === user.id) return true;\n    \n    // Admins and moderators can delete any message\n    return user.role === 'admin' || user.role === 'moderator';\n  }\n\n  private static canUserReactToMessage(dbMessage: any, user: any): boolean {\n    if (!user?.id) return false;\n    \n    // Can't react to deleted messages\n    if (dbMessage.deletedAt) return false;\n    \n    // Can't react to your own messages (optional business rule)\n    if (dbMessage.senderId === user.id) return false;\n    \n    return true;\n  }\n\n  private static transformReactions(reactions: any, userId: any): any[] | undefined {\n    if (!reactions) return undefined;\n    \n    return reactions.map((reaction: any) => ({\n      emoji: reaction.emoji,\n      count: reaction.count || 0,\n      userReacted: reaction.userIds?.includes(userId) || false\n    }));\n  }\n\n  private static transformAttachments(attachments: any, user: any): any[] | undefined {\n    if (!attachments) return undefined;\n    \n    return attachments.map((attachment: any) => ({\n      id: attachment.id,\n      filename: attachment.filename,\n      size: attachment.size || 0,\n      mimeType: attachment.mimeType,\n      downloadUrl: this.generateDownloadUrl(attachment.id, user)\n    }));\n  }\n\n  private static generateDownloadUrl(attachmentId: string, user: any): string {\n    // Generate secure download URL with user authentication\n    return `/api/messaging/attachments/${attachmentId}/download`;\n  }\n\n  private static calculateMessageSize(dbMessage: any): number {\n    const contentSize = (dbMessage.content || '').length;\n    const attachmentSize = dbMessage.attachments?.reduce((sum: number, att: any) => sum + (att.size || 0), 0) || 0;\n    return contentSize + attachmentSize;\n  }\n\n  private static getEditHistory(dbMessage: any): any[] | undefined {\n    if (!dbMessage.editHistory) return undefined;\n    \n    return dbMessage.editHistory.map((edit: any) => ({\n      editedAt: edit.editedAt.toISOString(),\n      oldContent: this.truncateContent(edit.oldContent, 200) // Truncated for audit\n    }));\n  }\n\n  private static getUserLastReadTime(conversationId: any, userId: any): string | undefined {\n    // This would get user's last read time for this conversation\n    return undefined; // Placeholder\n  }\n\n  private static getUserUnreadCount(conversationId: any, userId: any): number {\n    // This would calculate unread messages for user in conversation\n    return 0; // Placeholder\n  }\n\n  private static isConversationMuted(conversationId: any, userId: any): boolean {\n    // This would check user's mute settings\n    return false; // Placeholder\n  }\n\n  private static isConversationPinned(conversationId: any, userId: any): boolean {\n    // This would check user's pin settings\n    return false; // Placeholder\n  }\n\n  private static canUserSendMessages(conversation: any, user: any): boolean {\n    if (!user?.id) return false;\n    \n    // Check if conversation is active\n    if (conversation.isActive === false) return false;\n    \n    // Check user permissions or bans\n    return true; // Placeholder\n  }\n\n  private static canUserAddParticipants(conversation: any, user: any): boolean {\n    if (!user?.id) return false;\n    \n    // Only group conversations allow adding participants\n    if (conversation.type !== 'group') return false;\n    \n    // Check if user is owner or admin\n    return conversation.createdBy === user.id || user.role === 'admin';\n  }\n\n  private static canUserLeaveConversation(conversation: any, user: any): boolean {\n    if (!user?.id) return false;\n    \n    // Can't leave direct conversations (they just become inactive)\n    if (conversation.type === 'direct') return false;\n    \n    // Can leave group conversations\n    return conversation.type === 'group';\n  }\n\n  private static canUserDeleteConversation(conversation: any, user: any): boolean {\n    if (!user?.id) return false;\n    \n    // Only creator or admin can delete\n    return conversation.createdBy === user.id || user.role === 'admin';\n  }\n\n  private static getUserConversationSettings(conversationId: any, userId: any): any | undefined {\n    // This would get user's settings for this conversation\n    return {\n      notifications: true,\n      soundEnabled: true,\n      autoMarkRead: false\n    }; // Placeholder\n  }\n\n  private static calculateConversationSize(conversation: any): number {\n    // This would calculate total data size of conversation\n    return conversation.messageCount * 100; // Placeholder estimate\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/messaging/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/missions/missions.admin.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asyncHandler' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin Missions Controller\n *\n * Handles admin-specific mission management functionality\n */\n\nimport type { Request, Response, NextFunction } from 'express';\nimport { MissionsService } from './missions.service';\n// import { MissionSchema, MissionUpdateSchema } from './missions.validators'; // Removed as file not found and schemas not used\n// import { MissionAlreadyExistsError } from './missions.errors'; // Removed as file not found and error not used\nimport { logger } from '../../core/logger';\nimport { asyncHandler } from '../../core/errors';\n\n/**\n * Admin-specific functions for mission management\n *\n * Note: The missions.controller.ts file already contains the admin endpoints.\n * This file exists for future admin-specific mission operations that may\n * be needed beyond what's in the main controller.\n *\n * Currently, all admin functionality is implemented in missions.controller.ts:\n * - getAllMissions\n * - createMission\n * - updateMission\n * - getUserMissionProgressById\n * - initializeDefaultMissions\n * - resetDailyMissions\n * - resetWeeklyMissions\n */\n\n/**\n * Example admin-only function for future use\n */\nexport const getMissionAuditLog = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// This would be implemented when we add mission audit logging\n\t\t// For now, just return a placeholder response\n\n\t\tres.status(200).json({\n\t\t\tmessage: 'Mission audit log feature coming soon',\n\t\t\ttimestamp: new Date()\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'Error getting mission audit log:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\n// Export existing mission controller functions\nexport * from './missions.controller';\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/missions/missions.admin.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAuthenticated' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdmin' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// REFACTORED: Updated auth middleware imports to use canonical path\n/**\n * Admin Missions Routes\n *\n * API endpoints for mission management in the admin panel\n */\n\nimport { Router } from 'express';\nimport type { Request, Response, NextFunction } from 'express';\nimport * as missionsController from './missions.controller';\nimport { isAuthenticated, isAdmin } from '../auth/middleware/auth.middleware';\n\nconst router = Router();\n\n// Create a simple asyncHandler utility\nconst asyncHandler = (fn) => (req, res, next) => {\n\tPromise.resolve(fn(req, res, next)).catch(next);\n};\n\n// Get all missions (admin view)\nrouter.get('/all', asyncHandler(missionsController.getAllMissions));\n\n// Create a new mission\nrouter.post('/create', asyncHandler(missionsController.createMission));\n\n// Update a mission\nrouter.put('/:id', asyncHandler(missionsController.updateMission));\n\n// Get a specific user's mission progress\nrouter.get('/progress/:userId', asyncHandler(missionsController.getUserMissionProgressById));\n\n// Initialize default missions\nrouter.post('/initialize-defaults', asyncHandler(missionsController.initializeDefaultMissions));\n\n// Reset missions\nrouter.post('/reset-daily', asyncHandler(missionsController.resetDailyMissions));\nrouter.post('/reset-weekly', asyncHandler(missionsController.resetWeeklyMissions));\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/missions/missions.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/missions/missions.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/missions/missions.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'startOfDay' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isBefore' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'format' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'parse' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":64},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metadata' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":334,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":334,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '../../core/db';\nimport type { UserId, MissionId } from '@shared/types';\nimport { eq, and, gte, lte, SQL, isNull, inArray } from 'drizzle-orm';\nimport {\n\tmissions,\n\tuserMissionProgress,\n\t// MissionType, // Assuming MissionType is defined locally or this import is not strictly needed from schema\n\ttype Mission,\n\ttype UserMissionProgress,\n\ttype InsertMission\n} from '@schema';\nimport { logger } from '../../core/logger';\nimport { addDays, startOfDay, endOfDay, isBefore, format, parse, addWeeks } from 'date-fns';\nimport { MissionId } from \"@shared/types\";\n\ninterface MissionProgressUpdate {\n\tuserId: UserId;\n\tactionType: MissionType;\n\tmetadata?: Record<string, any>;\n}\n\n/**\n * Service for managing daily/weekly missions and user progress\n */\nexport class MissionsService {\n\t/**\n\t * Get all missions (for admin)\n\t */\n\tasync getAllMissions(): Promise<Mission[]> {\n\t\ttry {\n\t\t\treturn await db.select().from(missions).orderBy(missions.sortOrder);\n\t\t} catch (error: any) {\n\t\t\tlogger.error(\n\t\t\t\t'Error getting all missions:',\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get active missions\n\t */\n\tasync getActiveMissions(userLevel?: number): Promise<Mission[]> {\n\t\ttry {\n\t\t\tlet query = db\n\t\t\t\t.select()\n\t\t\t\t.from(missions)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(missions.isActive, true),\n\t\t\t\t\t\tisNull(missions.expiresAt).or(gte(missions.expiresAt, new Date()))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.orderBy(missions.sortOrder);\n\n\t\t\t// If userLevel is provided, filter by level requirement\n\t\t\tif (userLevel !== undefined) {\n\t\t\t\tquery = query.where(lte(missions.minLevel, userLevel));\n\t\t\t}\n\n\t\t\treturn await query;\n\t\t} catch (error: any) {\n\t\t\tlogger.error(\n\t\t\t\t'Error getting active missions:',\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get a mission by ID\n\t */\n\tasync getMission(id: MissionId): Promise<Mission | null> {\n\t\ttry {\n\t\t\tconst result = await db.select().from(missions).where(eq(missions.id, id)).limit(1);\n\n\t\t\treturn result.length > 0 ? result[0] : null;\n\t\t} catch (error: any) {\n\t\t\tlogger.error(\n\t\t\t\t'Error getting mission:',\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Create a new mission\n\t */\n\tasync createMission(data: InsertMission): Promise<Mission> {\n\t\ttry {\n\t\t\t// Set expiration for daily/weekly missions\n\t\t\tlet expiresAt = data.expiresAt;\n\n\t\t\tif (!expiresAt) {\n\t\t\t\tif (data.isDaily) {\n\t\t\t\t\texpiresAt = endOfDay(addDays(new Date(), 1));\n\t\t\t\t} else if (data.isWeekly) {\n\t\t\t\t\texpiresAt = endOfDay(addWeeks(new Date(), 1));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = await db\n\t\t\t\t.insert(missions)\n\t\t\t\t.values({\n\t\t\t\t\t...data,\n\t\t\t\t\texpiresAt\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\treturn result[0];\n\t\t} catch (error: any) {\n\t\t\tlogger.error(\n\t\t\t\t'Error creating mission:',\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Update a mission\n\t */\n\tasync updateMission(id: MissionId, data: Partial<Mission>): Promise<Mission | null> {\n\t\ttry {\n\t\t\tconst result = await db.update(missions).set(data).where(eq(missions.id, id)).returning();\n\n\t\t\treturn result.length > 0 ? result[0] : null;\n\t\t} catch (error: any) {\n\t\t\tlogger.error(\n\t\t\t\t'Error updating mission:',\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Get user's mission progress\n\t */\n\tasync getUserMissionProgress(\n\t\tuserId: UserId\n\t): Promise<(UserMissionProgress & { mission: Mission })[]> {\n\t\ttry {\n\t\t\t// Get all active missions\n\t\t\tconst activeMissions = await this.getActiveMissions();\n\n\t\t\t// Get user's progress for active missions\n\t\t\tconst progress = await db\n\t\t\t\t.select({\n\t\t\t\t\tprogress: userMissionProgress,\n\t\t\t\t\tmission: missions\n\t\t\t\t})\n\t\t\t\t.from(userMissionProgress)\n\t\t\t\t.innerJoin(missions, eq(userMissionProgress.missionId, missions.id))\n\t\t\t\t.where(and(eq(userMissionProgress.userId, userId), eq(missions.isActive, true)));\n\n\t\t\t// If user doesn't have progress entries for some active missions, initialize them\n\t\t\tconst existingMissionIds = progress.map((p) => p.mission.id);\n\t\t\tconst missingMissions = activeMissions.filter((m) => !existingMissionIds.includes(m.id));\n\n\t\t\tif (missingMissions.length > 0) {\n\t\t\t\t// Initialize progress for missing missions\n\t\t\t\tawait this.initializeMissionsForUser(userId, missingMissions);\n\n\t\t\t\t// Fetch the updated progress\n\t\t\t\treturn this.getUserMissionProgress(userId);\n\t\t\t}\n\n\t\t\t// Map the result to the expected format\n\t\t\treturn progress.map((p: any) => ({\n\t\t\t\t...p.progress,\n\t\t\t\tmission: p.mission\n\t\t\t}));\n\t\t} catch (error: any) {\n\t\t\tlogger.error(\n\t\t\t\t'Error getting user mission progress:',\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Initialize mission progress records for a user\n\t * Called when a user accesses missions for the first time or when new missions are added\n\t */\n\tprivate async initializeMissionsForUser(\n\t\tuserId: UserId,\n\t\tmissionsToInit: Mission[]\n\t): Promise<void> {\n\t\ttry {\n\t\t\tif (missionsToInit.length === 0) return;\n\n\t\t\tconst values = missionsToInit.map((mission) => ({\n\t\t\t\tuserId,\n\t\t\t\tmissionId: mission.id,\n\t\t\t\tcurrentCount: 0,\n\t\t\t\tisCompleted: false,\n\t\t\t\tisRewardClaimed: false\n\t\t\t}));\n\n\t\t\tawait db.insert(userMissionProgress).values(values);\n\t\t} catch (error: any) {\n\t\t\tlogger.error(\n\t\t\t\t'Error initializing missions for user:',\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Reset expired daily missions\n\t * This should be called by a cron job daily\n\t */\n\tasync resetDailyMissions(): Promise<void> {\n\t\ttry {\n\t\t\t// Get expired daily missions\n\t\t\tconst expiredMissions = await db\n\t\t\t\t.select()\n\t\t\t\t.from(missions)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(missions.isDaily, true),\n\t\t\t\t\t\teq(missions.isActive, true),\n\t\t\t\t\t\tlte(missions.expiresAt as SQL, new Date())\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tif (expiredMissions.length === 0) return;\n\n\t\t\tconst today = new Date();\n\t\t\tconst tomorrow = endOfDay(addDays(today, 1));\n\n\t\t\t// Update expired missions with new expiration date\n\t\t\tawait db.update(missions).set({ expiresAt: tomorrow }).where(eq(missions.isDaily, true));\n\n\t\t\t// Reset user progress for these missions\n\t\t\tawait db\n\t\t\t\t.update(userMissionProgress)\n\t\t\t\t.set({\n\t\t\t\t\tcurrentCount: 0,\n\t\t\t\t\tisCompleted: false,\n\t\t\t\t\tisRewardClaimed: false,\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\tcompletedAt: null,\n\t\t\t\t\tclaimedAt: null\n\t\t\t\t})\n\t\t\t\t.where(\n\t\t\t\t\tinArray(\n\t\t\t\t\t\tmissions.id,\n\t\t\t\t\t\texpiredMissions.map((m: Mission) => m.id)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t} catch (error: any) {\n\t\t\tlogger.error(\n\t\t\t\t'Error resetting daily missions:',\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Reset expired weekly missions\n\t * This should be called by a cron job weekly\n\t */\n\tasync resetWeeklyMissions(): Promise<void> {\n\t\ttry {\n\t\t\t// Get expired weekly missions\n\t\t\tconst expiredMissions = await db\n\t\t\t\t.select()\n\t\t\t\t.from(missions)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(missions.isWeekly, true),\n\t\t\t\t\t\teq(missions.isActive, true),\n\t\t\t\t\t\tlte(missions.expiresAt as SQL, new Date())\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tif (expiredMissions.length === 0) return;\n\n\t\t\tconst today = new Date();\n\t\t\tconst nextWeek = endOfDay(addWeeks(today, 1));\n\n\t\t\t// Update expired missions with new expiration date\n\t\t\tconst updateWeeklyMissionsQuery = db\n\t\t\t\t.update(missions)\n\t\t\t\t.set({ expiresAt: nextWeek })\n\t\t\t\t.where(eq(missions.isWeekly, true));\n\t\t\tlogger.info(\n\t\t\t\t'MISSION_RESET',\n\t\t\t\t`Update Weekly Missions Query: ${updateWeeklyMissionsQuery.getQuery()}`\n\t\t\t);\n\t\t\tawait updateWeeklyMissionsQuery;\n\n\t\t\t// Reset user progress for these missions\n\t\t\tawait db\n\t\t\t\t.update(userMissionProgress)\n\t\t\t\t.set({\n\t\t\t\t\tcurrentCount: 0,\n\t\t\t\t\tisCompleted: false,\n\t\t\t\t\tisRewardClaimed: false,\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\tcompletedAt: null,\n\t\t\t\t\tclaimedAt: null\n\t\t\t\t})\n\t\t\t\t.where(\n\t\t\t\t\tinArray(\n\t\t\t\t\t\tmissions.id,\n\t\t\t\t\t\texpiredMissions.map((m: Mission) => m.id)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t} catch (error: any) {\n\t\t\tlogger.error(\n\t\t\t\t'Error resetting weekly missions:',\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Update mission progress based on user actions\n\t * This is called whenever a user performs an action that might progress a mission\n\t */\n\tasync updateMissionProgress({\n\t\tuserId,\n\t\tactionType,\n\t\tmetadata = {}\n\t}: MissionProgressUpdate): Promise<UserMissionProgress[]> {\n\t\ttry {\n\t\t\t// Find active missions matching this action type\n\t\t\tconst activeMissions = await db\n\t\t\t\t.select()\n\t\t\t\t.from(missions)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(missions.isActive, true),\n\t\t\t\t\t\teq(missions.type, actionType),\n\t\t\t\t\t\tisNull(missions.expiresAt).or(gte(missions.expiresAt, new Date()))\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tif (activeMissions.length === 0) return [];\n\n\t\t\t// Get current progress for these missions\n\t\t\tconst userProgress = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userMissionProgress)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userMissionProgress.userId, userId),\n\t\t\t\t\t\tuserMissionProgress.missionId.in(activeMissions.map((m) => m.id))\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t// Initialize progress if it doesn't exist\n\t\t\tif (userProgress.length < activeMissions.length) {\n\t\t\t\tconst existingMissionIds = userProgress.map((p) => p.missionId);\n\t\t\t\tconst missingMissions = activeMissions.filter((m) => !existingMissionIds.includes(m.id));\n\t\t\t\tawait this.initializeMissionsForUser(userId, missingMissions);\n\t\t\t}\n\n\t\t\t// Update progress for each matching mission\n\t\t\tconst updatedProgress: UserMissionProgress[] = [];\n\n\t\t\tfor (const mission of activeMissions) {\n\t\t\t\t// Skip if mission is already completed\n\t\t\t\tlet progress = userProgress.find((p) => p.missionId === mission.id);\n\n\t\t\t\tif (progress?.isCompleted) continue;\n\n\t\t\t\t// Progress not found means it was just initialized\n\t\t\t\tif (!progress) {\n\t\t\t\t\tconst freshProgress = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(userMissionProgress)\n\t\t\t\t\t\t.where(\n\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\teq(userMissionProgress.userId, userId),\n\t\t\t\t\t\t\t\teq(userMissionProgress.missionId, mission.id)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.limit(1);\n\n\t\t\t\t\tif (freshProgress.length === 0) continue; // Should never happen\n\t\t\t\t\tprogress = freshProgress[0];\n\t\t\t\t}\n\n\t\t\t\t// Update progress count\n\t\t\t\tconst newCount = progress.currentCount + 1;\n\t\t\t\tconst isCompleted = newCount >= mission.requiredCount;\n\n\t\t\t\tconst updated = await db\n\t\t\t\t\t.update(userMissionProgress)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tcurrentCount: newCount,\n\t\t\t\t\t\tisCompleted,\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t\tcompletedAt: isCompleted ? new Date() : null\n\t\t\t\t\t})\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(eq(userMissionProgress.id, progress.id), eq(userMissionProgress.isCompleted, false))\n\t\t\t\t\t)\n\t\t\t\t\t.returning();\n\n\t\t\t\tif (updated.length > 0) {\n\t\t\t\t\tupdatedProgress.push(updated[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn updatedProgress;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error updating mission progress:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Claim rewards for a completed mission\n\t */\n\tasync claimMissionReward(\n\t\tuserId: UserId,\n\t\tmissionId: MissionId\n\t): Promise<{\n\t\tsuccess: boolean;\n\t\trewards?: {\n\t\t\txp?: number;\n\t\t\tdgt?: number;\n\t\t\tbadge?: string;\n\t\t};\n\t\tmessage?: string;\n\t}> {\n\t\ttry {\n\t\t\t// Get mission and progress\n\t\t\tconst missionResult = await db\n\t\t\t\t.select({\n\t\t\t\t\tmission: missions,\n\t\t\t\t\tprogress: userMissionProgress\n\t\t\t\t})\n\t\t\t\t.from(missions)\n\t\t\t\t.innerJoin(\n\t\t\t\t\tuserMissionProgress,\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userMissionProgress.missionId, missions.id),\n\t\t\t\t\t\teq(userMissionProgress.userId, userId)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.where(eq(missions.id, missionId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (missionResult.length === 0) {\n\t\t\t\treturn { success: false, message: 'Mission not found' };\n\t\t\t}\n\n\t\t\tconst { mission, progress } = missionResult[0];\n\n\t\t\t// Check if mission is completed and not already claimed\n\t\t\tif (!progress.isCompleted) {\n\t\t\t\treturn { success: false, message: 'Mission not completed' };\n\t\t\t}\n\n\t\t\tif (progress.isRewardClaimed) {\n\t\t\t\treturn { success: false, message: 'Reward already claimed' };\n\t\t\t}\n\n\t\t\t// Update mission progress to claimed\n\t\t\tawait db\n\t\t\t\t.update(userMissionProgress)\n\t\t\t\t.set({\n\t\t\t\t\tisRewardClaimed: true,\n\t\t\t\t\tclaimedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(userMissionProgress.id, progress.id));\n\n\t\t\t// Collect rewards to return\n\t\t\tconst rewards: { xp?: number; dgt?: number; badge?: string } = {};\n\n\t\t\t// Process XP reward\n\t\t\tif (mission.xpReward > 0) {\n\t\t\t\trewards.xp = mission.xpReward;\n\t\t\t\t// XP reward needs to be handled by the XP service\n\t\t\t\t// which should be injected or called from the controller\n\t\t\t}\n\n\t\t\t// Process DGT reward\n\t\t\tif (mission.dgtReward && mission.dgtReward > 0) {\n\t\t\t\trewards.dgt = mission.dgtReward;\n\t\t\t\t// DGT reward needs to be handled by the Wallet service\n\t\t\t\t// which should be injected or called from the controller\n\t\t\t}\n\n\t\t\t// Process badge reward\n\t\t\tif (mission.badgeReward) {\n\t\t\t\trewards.badge = mission.badgeReward;\n\t\t\t\t// Badge reward needs to be handled by the Badge service\n\t\t\t\t// which should be injected or called from the controller\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\trewards\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error claiming mission reward:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Create default missions (for initial setup)\n\t */\n\tasync createDefaultMissions(): Promise<void> {\n\t\tconst defaultMissions: InsertMission[] = [\n\t\t\t{\n\t\t\t\ttitle: 'Daily Login',\n\t\t\t\tdescription: 'Log in to the forum today',\n\t\t\t\ttype: 'LOGIN',\n\t\t\t\trequiredAction: 'login',\n\t\t\t\trequiredCount: 1,\n\t\t\t\txpReward: 10,\n\t\t\t\tisDaily: true,\n\t\t\t\tisActive: true,\n\t\t\t\ticon: 'log-in'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: 'Create a Post',\n\t\t\t\tdescription: 'Create a new post today',\n\t\t\t\ttype: 'POST_CREATE',\n\t\t\t\trequiredAction: 'create_post',\n\t\t\t\trequiredCount: 1,\n\t\t\t\txpReward: 15,\n\t\t\t\tisDaily: true,\n\t\t\t\tisActive: true,\n\t\t\t\ticon: 'message-square-plus'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: 'Serial Liker',\n\t\t\t\tdescription: 'Like 5 posts today',\n\t\t\t\ttype: 'POST_LIKE',\n\t\t\t\trequiredAction: 'like_post',\n\t\t\t\trequiredCount: 5,\n\t\t\t\txpReward: 20,\n\t\t\t\tisDaily: true,\n\t\t\t\tisActive: true,\n\t\t\t\ticon: 'thumbs-up'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: 'Start a Conversation',\n\t\t\t\tdescription: 'Reply to 10 threads this week',\n\t\t\t\ttype: 'THREAD_CREATE',\n\t\t\t\trequiredAction: 'create_thread',\n\t\t\t\trequiredCount: 1,\n\t\t\t\txpReward: 30,\n\t\t\t\tdgtReward: 5,\n\t\t\t\tisWeekly: true,\n\t\t\t\tisDaily: false,\n\t\t\t\tisActive: true,\n\t\t\t\ticon: 'plus-circle'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: 'Active Commenter',\n\t\t\t\tdescription: 'Reply to 10 threads this week',\n\t\t\t\ttype: 'THREAD_REPLY',\n\t\t\t\trequiredAction: 'reply_thread',\n\t\t\t\trequiredCount: 10,\n\t\t\t\txpReward: 50,\n\t\t\t\tdgtReward: 10,\n\t\t\t\tisWeekly: true,\n\t\t\t\tisDaily: false,\n\t\t\t\tisActive: true,\n\t\t\t\ticon: 'reply'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: 'Support the Community',\n\t\t\t\tdescription: 'Tip 3 posts with DGT this week',\n\t\t\t\ttype: 'DGT_TIP',\n\t\t\t\trequiredAction: 'tip_post',\n\t\t\t\trequiredCount: 3,\n\t\t\t\txpReward: 100,\n\t\t\t\tbadgeReward: 'Generous Tipper',\n\t\t\t\tisWeekly: true,\n\t\t\t\tisDaily: false,\n\t\t\t\tisActive: true,\n\t\t\t\tminLevel: 5,\n\t\t\t\ticon: 'gift'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: 'Support the Community',\n\t\t\t\tdescription: 'Tip 3 posts with DGT this week',\n\t\t\t\ttype: 'DGT_TIP',\n\t\t\t\trequiredAction: 'tip_post',\n\t\t\t\trequiredCount: 3,\n\t\t\t\txpReward: 100,\n\t\t\t\tbadgeReward: 'Generous Tipper',\n\t\t\t\tisWeekly: true,\n\t\t\t\tisDaily: false,\n\t\t\t\tisActive: true,\n\t\t\t\tminLevel: 5,\n\t\t\t\ticon: 'gift'\n\t\t\t}\n\t\t];\n\n\t\t// Set expiration dates\n\t\tconst today = new Date();\n\t\tconst tomorrow = endOfDay(addDays(today, 1));\n\t\tconst nextWeek = endOfDay(addWeeks(today, 1));\n\n\t\t// Insert missions\n\t\tfor (const missionData of defaultMissions) {\n\t\t\t// Skip if a similar mission already exists\n\t\t\tconst existing = await db\n\t\t\t\t.select()\n\t\t\t\t.from(missions)\n\t\t\t\t.where(and(eq(missions.title, missionData.title), eq(missions.type, missionData.type)))\n\t\t\t\t.limit(1);\n\n\t\t\tif (existing.length > 0) continue;\n\n\t\t\t// Set expiration\n\t\t\tif (missionData.isDaily) {\n\t\t\t\tmissionData.expiresAt = tomorrow;\n\t\t\t} else if (missionData.isWeekly) {\n\t\t\t\tmissionData.expiresAt = nextWeek;\n\t\t\t}\n\n\t\t\tawait db.insert(missions).values(missionData);\n\t\t}\n\t}\n}\n\n// Export a singleton instance\nexport const missionsService = new MissionsService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/notifications/event-notification-listener.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/notifications/notification-generator.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/notifications/notification.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'authenticate' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Notifications Routes\n *\n * Defines API routes for user notifications.\n */\n\nimport express from 'express';\nimport { authenticate } from '../../middleware/authenticate';\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { logger, LogLevel, LogAction } from '../../../src/core/logger';\nimport {\n\tgetNotifications,\n\tmarkNotificationAsRead,\n\tmarkAllNotificationsAsRead,\n\tgetUnreadNotificationCount\n} from './notification.service';\nimport { isAuthenticated } from '../auth';\n\nconst router = express.Router();\n\n// Apply auth middleware to all notifications routes\nrouter.use(isAuthenticated);\n\n/**\n * GET /api/notifications\n * Get paginated notifications for the authenticated user\n */\nrouter.get('/getPaginatedNotifications', async (req, res) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\treturn res.status(401).json({ error: 'Unauthorized' });\n\t\t}\n\n\t\tconst page = parseInt(req.query.page as string) || 0;\n\t\tconst pageSize = parseInt(req.query.pageSize as string) || 10;\n\t\tconst offset = page * pageSize;\n\n\t\tconst notifications = await getNotifications(userId, pageSize, offset);\n\n\t\tres.json({ page, pageSize, notifications });\n\t} catch (error) {\n\t\tlogger.error('NOTIFICATIONS', 'Error getting notifications', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to retrieve user notifications'\n\t\t});\n\t}\n});\n\n/**\n * GET /api/notifications/unread/count\n * Get count of unread notifications for the authenticated user\n */\nrouter.get('/unread/count', async (req, res) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\treturn res.status(401).json({ error: 'Unauthorized' });\n\t\t}\n\n\t\tconst count = await getUnreadNotificationCount(userId);\n\n\t\tres.json({ count });\n\t} catch (error) {\n\t\tlogger.error('NOTIFICATIONS', 'Error getting unread notification count', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to retrieve unread notification count'\n\t\t});\n\t}\n});\n\n/**\n * PUT /api/notifications/:id/read\n * Mark a notification as read\n */\nrouter.put('/:id/read', async (req, res) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\treturn res.status(401).json({ error: 'Unauthorized' });\n\t\t}\n\n\t\tconst notificationId = req.params.id;\n\t\tconst success = await markNotificationAsRead(notificationId, userId);\n\n\t\tif (success) {\n\t\t\tres.json({ success: true });\n\t\t} else {\n\t\t\tres.status(404).json({ error: 'Notification not found or not owned by user' });\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('NOTIFICATIONS', 'Error marking notification as read', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to mark notification as read'\n\t\t});\n\t}\n});\n\n/**\n * PUT /api/notifications/read-all\n * Mark all notifications as read for the authenticated user\n */\nrouter.put('/read-all', async (req, res) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\treturn res.status(401).json({ error: 'Unauthorized' });\n\t\t}\n\n\t\tconst count = await markAllNotificationsAsRead(userId);\n\n\t\tres.json({ success: true, count });\n\t} catch (error) {\n\t\tlogger.error('NOTIFICATIONS', 'Error marking all notifications as read', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to mark all notifications as read'\n\t\t});\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/notifications/notification.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/paths/paths.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdminOrModerator' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdmin' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { UserId } from '@shared/types';\n/**\n * XP Path Routes\n * Handles API endpoints for the XP path specialization system\n */\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { PathService } from '../../../services/path-service';\n// import { XpProcessor } from '@server/src/utils/xpProcessor';  // File doesn't exist - commenting out\nimport { db } from '@db';\nimport { sql } from 'drizzle-orm';\n\nimport { isAuthenticated, isAdminOrModerator, isAdmin } from '../auth/middleware/auth.middleware';\nimport { getUserId } from '../auth/services/auth.service';\nimport { isValidId } from '@shared/utils/id';\nimport { logger } from \"../../core/logger\";\n\n// Using shared isAuthenticated middleware from middleware/auth.ts\n\nexport function registerPathRoutes(router: Router) {\n\t/**\n\t * Get all XP paths\n\t * @route GET /api/paths\n\t * @access Public\n\t */\n\trouter.get('/paths', async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst paths = await PathService.getPaths();\n\t\t\tres.json(paths);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching paths:', error);\n\t\t\tres.status(500).json({ message: 'Server error' });\n\t\t}\n\t});\n\n\t/**\n\t * Get specific XP path\n\t * @route GET /api/paths/:pathId\n\t * @access Public\n\t */\n\trouter.get('/paths/:pathId', async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst pathId = req.params.pathId;\n\t\t\tconst path = await PathService.getPathById(pathId);\n\n\t\t\tif (!path) {\n\t\t\t\treturn res.status(404).json({ message: 'Path not found' });\n\t\t\t}\n\n\t\t\tres.json(path);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching path:', error);\n\t\t\tres.status(500).json({ message: 'Server error' });\n\t\t}\n\t});\n\n\t/**\n\t * Get my paths\n\t * @route GET /api/paths/user/me\n\t * @access Private\n\t */\n\trouter.get('/paths/user/me', isAuthenticated, async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst userId = userService.getUserFromRequest(req);\n\t\t\tconst userPaths = await PathService.getUserPaths(userId);\n\t\t\tres.json(userPaths);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching user paths:', error);\n\t\t\tres.status(500).json({ message: 'Server error' });\n\t\t}\n\t});\n\n\t/**\n\t * Get my primary path\n\t * @route GET /api/paths/user/me/primary\n\t * @access Private\n\t */\n\trouter.get('/paths/user/me/primary', isAuthenticated, async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst userId = userService.getUserFromRequest(req);\n\t\t\tconst primaryPath = await PathService.getUserPrimaryPath(userId);\n\n\t\t\tif (!primaryPath) {\n\t\t\t\treturn res.status(404).json({ message: 'No primary path set' });\n\t\t\t}\n\n\t\t\tres.json(primaryPath);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching primary path:', error);\n\t\t\tres.status(500).json({ message: 'Server error' });\n\t\t}\n\t});\n\n\t/**\n\t * Set my primary path\n\t * @route POST /api/paths/user/me/primary/:pathId\n\t * @access Private\n\t */\n\trouter.post(\n\t\t'/paths/user/me/primary/:pathId',\n\t\tisAuthenticated,\n\t\tasync (req: Request, res: Response) => {\n\t\t\ttry {\n\t\t\t\tconst userId = userService.getUserFromRequest(req);\n\t\t\t\tconst pathId = req.params.pathId;\n\n\t\t\t\t// Check if path exists\n\t\t\t\tconst pathExists = await PathService.getPathById(pathId);\n\n\t\t\t\tif (!pathExists) {\n\t\t\t\t\treturn res.status(404).json({ message: 'Path not found' });\n\t\t\t\t}\n\n\t\t\t\t// Set primary path\n\t\t\t\tawait PathService.setUserPrimaryPath(userId, pathId);\n\n\t\t\t\tres.json({ success: true, message: 'Primary path updated successfully' });\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('Error setting primary path:', error);\n\t\t\t\tres.status(500).json({ message: 'Server error' });\n\t\t\t}\n\t\t}\n\t);\n\n\t/**\n\t * Get path leaderboard\n\t * @route GET /api/paths/:pathId/leaderboard\n\t * @access Public\n\t */\n\trouter.get('/paths/:pathId/leaderboard', async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst pathId = req.params.pathId;\n\t\t\tconst limit = parseInt(req.query.limit as string) || 10;\n\t\t\tconst offset = parseInt(req.query.offset as string) || 0;\n\n\t\t\t// Check if path exists\n\t\t\tconst pathExists = await PathService.getPathById(pathId);\n\n\t\t\tif (!pathExists) {\n\t\t\t\treturn res.status(404).json({ message: 'Path not found' });\n\t\t\t}\n\n\t\t\tconst leaderboard = await PathService.getPathLeaderboard(pathId, limit, offset);\n\t\t\tres.json(leaderboard);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching path leaderboard:', error);\n\t\t\tres.status(500).json({ message: 'Server error' });\n\t\t}\n\t});\n\n\t/**\n\t * Get user's path progression\n\t * @route GET /api/paths/user/:userId/:pathId\n\t * @access Public\n\t */\n\trouter.get('/paths/user/:userId/:pathId', async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst userId = req.params.userId as UserId;\n\t\t\tconst pathId = req.params.pathId;\n\n\t\t\tif (!userId || !isValidId(userId)) {\n\t\t\t\treturn res.status(400).json({ message: 'Invalid user ID' });\n\t\t\t}\n\n\t\t\t// Check if user exists\n\t\t\tconst userExists = await db.execute(sql`\n        SELECT COUNT(*) FROM users WHERE user_id = ${userId}\n      `);\n\n\t\t\tif (parseInt(userExists.rows[0].count) === 0) {\n\t\t\t\treturn res.status(404).json({ message: 'User not found' });\n\t\t\t}\n\n\t\t\t// Check if path exists\n\t\t\tconst pathExists = await PathService.getPathById(pathId);\n\n\t\t\tif (!pathExists) {\n\t\t\t\treturn res.status(404).json({ message: 'Path not found' });\n\t\t\t}\n\n\t\t\tconst userPath = await PathService.getUserPath(userId, pathId);\n\n\t\t\tif (!userPath) {\n\t\t\t\treturn res.status(404).json({ message: 'User has not started this path' });\n\t\t\t}\n\n\t\t\tres.json(userPath);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching user path:', error);\n\t\t\tres.status(500).json({ message: 'Server error' });\n\t\t}\n\t});\n\n\t/**\n\t * Get user's path summary\n\t * @route GET /api/paths/user/:userId/summary\n\t * @access Public\n\t */\n\trouter.get('/paths/user/:userId/summary', async (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst userId = req.params.userId as UserId;\n\n\t\t\tif (!userId || !isValidId(userId)) {\n\t\t\t\treturn res.status(400).json({ message: 'Invalid user ID' });\n\t\t\t}\n\n\t\t\t// Check if user exists\n\t\t\tconst userExists = await db.execute(sql`\n        SELECT COUNT(*) FROM users WHERE user_id = ${userId}\n      `);\n\n\t\t\tif (parseInt(userExists.rows[0].count) === 0) {\n\t\t\t\treturn res.status(404).json({ message: 'User not found' });\n\t\t\t}\n\n\t\t\tconst summary = await PathService.getUserPathSummary(userId);\n\t\t\tres.json(summary);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching user path summary:', error);\n\t\t\tres.status(500).json({ message: 'Server error' });\n\t\t}\n\t});\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/preferences/preferences.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":29,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":30,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAuthenticatedOptional' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":34,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n// REFACTORED: Updated auth middleware imports to use canonical path\n/**\n * Preferences Routes\n *\n * Defines API routes for user preferences management.\n */\n\nimport express from 'express';\nimport { authenticate } from '../../middleware/authenticate';\nimport { validateBody } from '../../middleware/validate';\nimport {\n\tprofileSettingsSchema,\n\taccountSettingsSchema,\n\tnotificationSettingsSchema,\n\tpasswordChangeSchema\n} from './preferences.validators';\nimport {\n\tgetAllPreferences,\n\tupdateProfilePreferences,\n\tupdateAccountPreferences,\n\tupdateNotificationPreferences,\n\tchangePassword,\n\tupdateDisplayPreferences\n} from './preferences.service';\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { db } from '../../core/db';\nimport { users, userSettings as userPreferencesSchema } from '@schema';\nimport { eq, and } from 'drizzle-orm';\nimport { sql } from 'drizzle-orm';\nimport { z } from 'zod';\nimport { WebSocket } from 'ws';\nimport { isAuthenticated, isAuthenticatedOptional } from '../auth/middleware/auth.middleware';\nimport { logger, LogLevel, LogAction } from '../../../src/core/logger';\nimport { displayPreferencesSchema } from './preferences.validators';\nimport { getUserIdFromRequest } from '@server/src/utils/auth';\nimport { UserPreferencesService } from '../user/user-preferences.service';\n\n// Define validation schema for the shoutbox position\nconst updateShoutboxPositionSchema = z.object({\n\tposition: z\n\t\t.string()\n\t\t.refine((val) => ['sidebar-top', 'sidebar-bottom', 'floating', 'hidden'].includes(val), {\n\t\t\tmessage: 'Position must be one of: sidebar-top, sidebar-bottom, floating, hidden'\n\t\t})\n});\n\n// Social privacy preferences schema\nconst socialPreferencesSchema = z.object({\n\t// Mentions preferences\n\tallowMentions: z.boolean().optional(),\n\tmentionPermissions: z.enum(['everyone', 'friends', 'followers', 'none']).optional(),\n\tmentionNotifications: z.boolean().optional(),\n\tmentionEmailNotifications: z.boolean().optional(),\n\n\t// Following preferences\n\tallowFollowers: z.boolean().optional(),\n\tfollowerApprovalRequired: z.boolean().optional(),\n\thideFollowerCount: z.boolean().optional(),\n\thideFollowingCount: z.boolean().optional(),\n\tallowWhaleDesignation: z.boolean().optional(),\n\n\t// Friends preferences\n\tallowFriendRequests: z.boolean().optional(),\n\tfriendRequestPermissions: z.enum(['everyone', 'mutuals', 'followers', 'none']).optional(),\n\tautoAcceptMutualFollows: z.boolean().optional(),\n\thideOnlineStatus: z.boolean().optional(),\n\thideFriendsList: z.boolean().optional(),\n\n\t// General privacy\n\tshowSocialActivity: z.boolean().optional(),\n\tallowDirectMessages: z.enum(['friends', 'followers', 'everyone', 'none']).optional(),\n\tshowProfileToPublic: z.boolean().optional(),\n\tallowSocialDiscovery: z.boolean().optional()\n});\n\nconst router = express.Router();\n\n/**\n * GET /api/users/me/preferences-all\n * Get all preferences for the authenticated user\n */\nrouter.get('/me/preferences-all', authenticate, async (req, res) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req).id;\n\t\tconst preferences = await getAllPreferences(userId);\n\t\tres.json({ preferences });\n\t} catch (error) {\n\t\tlogger.error('PREFERENCES', 'Error getting user preferences', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to retrieve user preferences',\n\t\t\tmessage: error.message\n\t\t});\n\t}\n});\n\n/**\n * PUT /api/users/me/preferences/profile\n * Update profile preferences for the authenticated user\n */\nrouter.put(\n\t'/me/preferences/profile',\n\tauthenticate,\n\tvalidateBody(profileSettingsSchema),\n\tasync (req, res) => {\n\t\ttry {\n\t\t\tconst userId = userService.getUserFromRequest(req).id;\n\t\t\tconst ipAddress = req.ip;\n\t\t\tconst result = await updateProfilePreferences(userId, req.body, ipAddress);\n\t\t\tres.json({ success: true, data: result });\n\t\t} catch (error) {\n\t\t\tlogger.error('PREFERENCES', 'Error updating profile preferences', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to update profile preferences',\n\t\t\t\tmessage: error.message\n\t\t\t});\n\t\t}\n\t}\n);\n\n/**\n * PUT /api/users/me/preferences/account\n * Update account preferences for the authenticated user\n */\nrouter.put(\n\t'/me/preferences/account',\n\tauthenticate,\n\tvalidateBody(accountSettingsSchema),\n\tasync (req, res) => {\n\t\ttry {\n\t\t\tconst userId = userService.getUserFromRequest(req).id;\n\t\t\tconst ipAddress = req.ip;\n\t\t\tconst result = await updateAccountPreferences(userId, req.body, ipAddress);\n\t\t\tres.json({ success: true, data: result });\n\t\t} catch (error) {\n\t\t\tlogger.error('PREFERENCES', 'Error updating account preferences', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to update account preferences',\n\t\t\t\tmessage: error.message\n\t\t\t});\n\t\t}\n\t}\n);\n\n/**\n * PUT /api/users/me/preferences/notifications\n * Update notification preferences for the authenticated user\n */\nrouter.put(\n\t'/me/preferences/notifications',\n\tauthenticate,\n\tvalidateBody(notificationSettingsSchema),\n\tasync (req, res) => {\n\t\ttry {\n\t\t\tconst userId = userService.getUserFromRequest(req).id;\n\t\t\tconst ipAddress = req.ip;\n\t\t\tconst result = await updateNotificationPreferences(userId, req.body, ipAddress);\n\t\t\tres.json({ success: true, data: result });\n\t\t} catch (error) {\n\t\t\tlogger.error('PREFERENCES', 'Error updating notification preferences', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to update notification preferences',\n\t\t\t\tmessage: error.message\n\t\t\t});\n\t\t}\n\t}\n);\n\n/**\n * PUT /api/users/me/preferences/display\n * Update display preferences for the authenticated user\n */\nrouter.put(\n\t'/me/preferences/display',\n\tauthenticate,\n\tvalidateBody(displayPreferencesSchema),\n\tasync (req, res) => {\n\t\ttry {\n\t\t\tconst userId = userService.getUserFromRequest(req).id;\n\t\t\tconst ipAddress = req.ip;\n\t\t\tconst result = await updateDisplayPreferences(userId, req.body, ipAddress);\n\t\t\tres.json({ success: true, data: result });\n\t\t} catch (error) {\n\t\t\tlogger.error('PREFERENCES', 'Error updating display preferences', error);\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to update display preferences',\n\t\t\t\tmessage: error.message\n\t\t\t});\n\t\t}\n\t}\n);\n\n/**\n * POST /api/users/me/security/change-password\n * Change password for the authenticated user\n */\nrouter.post(\n\t'/me/security/change-password',\n\tauthenticate,\n\tvalidateBody(passwordChangeSchema),\n\tasync (req, res) => {\n\t\ttry {\n\t\t\tconst userId = userService.getUserFromRequest(req).id;\n\t\t\tconst ipAddress = req.ip;\n\t\t\tconst result = await changePassword(userId, req.body, ipAddress);\n\t\t\tres.json({ success: true, data: result });\n\t\t} catch (error) {\n\t\t\tlogger.error('PREFERENCES', 'Error changing password', error);\n\t\t\tres.status(400).json({\n\t\t\t\terror: 'Failed to change password',\n\t\t\t\tmessage: error.message\n\t\t\t});\n\t\t}\n\t}\n);\n\n// Get user preferences\nrouter.get('/', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = getUserIdFromRequest(req);\n\n\t\t// Ensure userId is valid\n\t\tif (userId === undefined) {\n\t\t\tlogger.error('PREFERENCES', 'Invalid or missing user ID in authenticated request', {\n\t\t\t\tuser: userService.getUserFromRequest(req),\n\t\t\t\tderivedUserId: userId\n\t\t\t});\n\t\t\t// In development, default to a known mock user ID for consistency\n\t\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\t\tlogger.info(\n\t\t\t\t\t'PREFERENCES',\n\t\t\t\t\t`🔧 Defaulting to mock user ID 1 for preferences fetch (dev mode only) due to undefined userId`\n\t\t\t\t);\n\t\t\t\tconst mockPreferences = {\n\t\t\t\t\tuserId: 1, // Default to mock user ID 1\n\t\t\t\t\ttheme: 'auto',\n\t\t\t\t\tshoutboxPosition: 'sidebar-top',\n\t\t\t\t\tsidebarState: {},\n\t\t\t\t\tnotificationPrefs: {},\n\t\t\t\t\tprofileVisibility: 'public',\n\t\t\t\t\tlanguage: 'en'\n\t\t\t\t};\n\t\t\t\treturn res.status(200).json(mockPreferences);\n\t\t\t}\n\t\t\treturn res.status(500).json({ message: 'Failed to identify user' });\n\t\t}\n\n\t\t// Check if user preferences exist\n\t\tconst userSettingsData = await db\n\t\t\t.select()\n\t\t\t.from(userPreferencesSchema)\n\t\t\t.where(eq(userPreferencesSchema.userId, userId))\n\t\t\t.limit(1);\n\n\t\tif (!userSettingsData || userSettingsData.length === 0) {\n\t\t\tconst defaultPreferences = {\n\t\t\t\tuserId,\n\t\t\t\ttheme: 'auto',\n\t\t\t\tshoutboxPosition: 'sidebar-top',\n\t\t\t\tsidebarState: {},\n\t\t\t\tnotificationPrefs: {},\n\t\t\t\tprofileVisibility: 'public',\n\t\t\t\tlanguage: 'en'\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tawait db.insert(userPreferencesSchema).values(defaultPreferences);\n\t\t\t\treturn res.status(200).json(defaultPreferences);\n\t\t\t} catch (insertError) {\n\t\t\t\tlogger.error('PREFERENCES', 'Error creating default user preferences', insertError);\n\n\t\t\t\t// Even in development, if insert fails, it's better to return the default preferences directly\n\t\t\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t'PREFERENCES',\n\t\t\t\t\t\t`🔧 Returning default mock preferences for user ${userId} after insert failure (dev mode only)`\n\t\t\t\t\t);\n\t\t\t\t\treturn res.status(200).json(defaultPreferences);\n\t\t\t\t}\n\n\t\t\t\treturn res.status(500).json({ message: 'Failed to create user preferences' });\n\t\t\t}\n\t\t}\n\n\t\treturn res.status(200).json(userSettingsData[0]);\n\t} catch (error) {\n\t\tlogger.error('PREFERENCES', 'Error fetching user preferences', error);\n\n\t\t// For development mode, return mock preferences consistently if any error occurs\n\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\tconst userId = getUserIdFromRequest(req); // Re-derive userId for logging consistency\n\t\t\tlogger.info(\n\t\t\t\t'PREFERENCES',\n\t\t\t\t`🔧 Returning mock preferences for user ${userId ?? 'UNKNOWN (error fallback)'} on error (dev mode only)`\n\t\t\t);\n\t\t\tconst mockPreferences = {\n\t\t\t\tuserId: userId ?? 1, // Default to 1 if still undefined in dev error\n\t\t\t\ttheme: 'auto',\n\t\t\t\tshoutboxPosition: 'sidebar-top',\n\t\t\t\tsidebarState: {},\n\t\t\t\tnotificationPrefs: {},\n\t\t\t\tprofileVisibility: 'public',\n\t\t\t\tlanguage: 'en'\n\t\t\t};\n\t\t\treturn res.status(200).json(mockPreferences);\n\t\t}\n\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n});\n\n// Update shoutbox position\nrouter.put(\n\t'/preferences/shoutbox-position',\n\tisAuthenticated,\n\tasync (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst userId = getUserIdFromRequest(req);\n\t\t\tif (userId === undefined) {\n\t\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t\t}\n\t\t\tconst validation = updateShoutboxPositionSchema.safeParse(req.body);\n\n\t\t\tif (!validation.success) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\tmessage: 'Invalid position format',\n\t\t\t\t\terrors: validation.error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { position } = validation.data;\n\n\t\t\t// Check if user preferences exist\n\t\t\tconst userSettingsData = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userPreferencesSchema)\n\t\t\t\t.where(eq(userPreferencesSchema.userId, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (!userSettingsData || userSettingsData.length === 0) {\n\t\t\t\t// Create preferences record if it doesn't exist\n\t\t\t\tawait db.insert(userPreferencesSchema).values({\n\t\t\t\t\tuserId,\n\t\t\t\t\tshoutboxPosition: position\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Update existing preferences\n\t\t\t\tawait db\n\t\t\t\t\t.update(userPreferencesSchema)\n\t\t\t\t\t.set({ shoutboxPosition: position })\n\t\t\t\t\t.where(eq(userPreferencesSchema.userId, userId));\n\t\t\t}\n\n\t\t\t// Log the change in user_settings_history table\n\t\t\tawait db.execute(sql`\n      INSERT INTO user_settings_history \n      (user_id, changed_field, old_value, new_value, ip_address, user_agent)\n      VALUES \n      (${userId}, 'shoutbox_position', ${userSettingsData?.[0]?.shoutboxPosition || 'sidebar-top'}, ${position}, ${req.ip || 'unknown'}, ${req.headers['user-agent'] || 'unknown'})\n    `);\n\n\t\t\t// Broadcast the position change via WebSocket if the WebSocket server is available\n\t\t\ttry {\n\t\t\t\tconst wss = (req.app as any).wss;\n\t\t\t\tif (wss && wss.clients) {\n\t\t\t\t\tconst username = (userService.getUserFromRequest(req) as any).username;\n\n\t\t\t\t\t// Create broadcast message with position update\n\t\t\t\t\tconst broadcastMessage = JSON.stringify({\n\t\t\t\t\t\ttype: 'shoutbox_position_update',\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tusername,\n\t\t\t\t\t\tposition,\n\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t});\n\n\t\t\t\t\t// Broadcast to all connected clients\n\t\t\t\t\twss.clients.forEach((client: any) => {\n\t\t\t\t\t\tif (client.readyState === WebSocket.OPEN) {\n\t\t\t\t\t\t\tclient.send(broadcastMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tlogger.info('PREFERENCES', `Broadcast shoutbox position update for user ${username}`);\n\t\t\t\t}\n\t\t\t} catch (broadcastError) {\n\t\t\t\tlogger.error('PREFERENCES', 'Error broadcasting position change', broadcastError);\n\t\t\t\t// Continue with the response even if broadcast fails\n\t\t\t}\n\n\t\t\treturn res.status(200).json({\n\t\t\t\tmessage: 'Shoutbox position updated successfully',\n\t\t\t\tposition\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('PREFERENCES', 'Error updating shoutbox position', error);\n\t\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t\t}\n\t}\n);\n\n/**\n * GET /api/users/social-preferences\n * Get user's social privacy preferences\n */\nrouter.get('/social-preferences', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst userId = getUserIdFromRequest(req);\n\t\tif (userId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\n\t\tconst preferences = await UserPreferencesService.getSocialPreferences(userId);\n\t\tres.json({ preferences });\n\t} catch (error) {\n\t\tlogger.error('PREFERENCES', 'Error fetching social preferences', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to fetch social preferences',\n\t\t\tdetails: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * PUT /api/users/social-preferences\n * Update user's social privacy preferences\n */\nrouter.put('/social-preferences', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst userId = getUserIdFromRequest(req);\n\t\tif (userId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\n\t\tconst validation = socialPreferencesSchema.safeParse(req.body);\n\t\tif (!validation.success) {\n\t\t\treturn res.status(400).json({\n\t\t\t\terror: 'Invalid preferences data',\n\t\t\t\tdetails: validation.error.errors\n\t\t\t});\n\t\t}\n\n\t\tconst updatedPreferences = await UserPreferencesService.updateSocialPreferences(\n\t\t\tuserId,\n\t\t\tvalidation.data\n\t\t);\n\n\t\tres.json({ preferences: updatedPreferences });\n\t} catch (error) {\n\t\tlogger.error('PREFERENCES', 'Error updating social preferences', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to update social preferences',\n\t\t\tdetails: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * GET /api/users/privacy-summary\n * Get a summary of user's privacy settings for quick overview\n */\nrouter.get('/privacy-summary', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst userId = getUserIdFromRequest(req);\n\t\tif (userId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\n\t\tconst summary = await UserPreferencesService.getPrivacySummary(userId);\n\t\tres.json({ summary });\n\t} catch (error) {\n\t\tlogger.error('PREFERENCES', 'Error fetching privacy summary', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to fetch privacy summary',\n\t\t\tdetails: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\n/**\n * POST /api/users/reset-social-preferences\n * Reset social preferences to defaults\n */\nrouter.post('/reset-social-preferences', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst userId = getUserIdFromRequest(req);\n\t\tif (userId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'Unauthorized - User ID not found' });\n\t\t}\n\n\t\tconst defaultPreferences = await UserPreferencesService.resetSocialPreferences(userId);\n\t\tres.json({ preferences: defaultPreferences });\n\t} catch (error) {\n\t\tlogger.error('PREFERENCES', 'Error resetting social preferences', error);\n\t\tres.status(500).json({\n\t\t\terror: 'Failed to reset social preferences',\n\t\t\tdetails: error instanceof Error ? error.message : 'Unknown error'\n\t\t});\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/preferences/preferences.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '../../core/db';\nimport {\n\tusers,\n\tuserSettings as userPreferencesSchema,\n\tnotificationSettings as notificationPreferencesSchema,\n\tdisplayPreferences as displayPreferencesSchema,\n\tuserSettingsHistory,\n\ttype User,\n\ttype UserSetting as UserPreference,\n\ttype NotificationSetting as NotificationPreference,\n\ttype DisplayPreference\n} from '@schema';\nimport { eq, and, sql } from 'drizzle-orm';\nimport { logger } from '../../../src/core/logger';\nimport type {\n\tProfileSettingsInput,\n\tAccountSettingsInput,\n\tNotificationSettingsInput,\n\tPasswordChangeInput,\n\tDisplayPreferencesInput\n} from './preferences.validators';\nimport type { UserId } from '@shared/types';\nimport bcrypt from 'bcrypt';\n\n/**\n * Fetches all preferences for a user (profile, account, notifications, display)\n * @param userId The user ID\n */\nexport const getAllPreferences = async (userId: UserId) => {\n\t// Fetch the user's profile data\n\tconst user = await db.query.users.findFirst({\n\t\twhere: eq(users.id, userId),\n\t\tcolumns: {\n\t\t\tid: true,\n\t\t\tusername: true,\n\t\t\temail: true,\n\t\t\tbio: true,\n\t\t\tsignature: true,\n\t\t\tavatarUrl: true,\n\t\t\tprofileBannerUrl: true,\n\t\t\tdiscordHandle: true,\n\t\t\ttwitterHandle: true,\n\t\t\twebsite: true,\n\t\t\ttelegramHandle: true,\n\t\t\tactiveTitleId: true,\n\t\t\tactiveBadgeId: true,\n\t\t\tactiveFrameId: true\n\t\t}\n\t});\n\n\tif (!user) {\n\t\tthrow new Error('User not found');\n\t}\n\n\t// Fetch the user's preferences (account settings)\n\tconst preferences = await db.query.userSettings.findFirst({\n\t\twhere: eq(userPreferencesSchema.userId, userId)\n\t});\n\n\t// Fetch the user's notification preferences\n\tconst notifPreferences = await db.query.notificationSettings.findFirst({\n\t\twhere: eq(notificationPreferencesSchema.userId, userId)\n\t});\n\n\t// Fetch the user's display preferences\n\tconst displayPreferences = await db.query.displayPreferences.findFirst({\n\t\twhere: eq(displayPreferencesSchema.userId, userId)\n\t});\n\n\treturn {\n\t\tprofile: user,\n\t\tpreferences: preferences || {},\n\t\tnotifications: notifPreferences || {},\n\t\tdisplay: displayPreferences || {}\n\t};\n};\n\n/**\n * Updates a user's profile preferences\n * @param userId The user ID\n * @param data Profile preferences to update\n * @param ipAddress The IP address of the requester\n */\nexport const updateProfilePreferences = async (\n\tuserId: UserId,\n\tdata: ProfileSettingsInput,\n\tipAddress?: string\n) => {\n\t// Get current profile data for change tracking\n\tconst currentProfile = await db.query.users.findFirst({\n\t\twhere: eq(users.id, userId)\n\t});\n\n\tif (!currentProfile) {\n\t\tthrow new Error('User not found');\n\t}\n\n\t// Track changes in preferences history\n\tconst trackedFields = [\n\t\t'bio',\n\t\t'signature',\n\t\t'avatarUrl',\n\t\t'profileBannerUrl',\n\t\t'discordHandle',\n\t\t'twitterHandle',\n\t\t'website',\n\t\t'telegramHandle',\n\t\t'activeTitleId',\n\t\t'activeBadgeId',\n\t\t'activeFrameId'\n\t];\n\n\tfor (const field of trackedFields) {\n\t\tif (\n\t\t\tfield in data &&\n\t\t\tdata[field as keyof ProfileSettingsInput] !== currentProfile[field as keyof User]\n\t\t) {\n\t\t\tawait db.insert(userSettingsHistory).values({\n\t\t\t\tuserId,\n\t\t\t\tsettingKey: `profile.${field}`,\n\t\t\t\toldValue: currentProfile[field as keyof User]?.toString() || null,\n\t\t\t\tnewValue: data[field as keyof ProfileSettingsInput]?.toString() || null,\n\t\t\t\tchangedAt: new Date(),\n\t\t\t\tchangedByIp: ipAddress\n\t\t\t});\n\t\t}\n\t}\n\n\t// Update the user's profile\n\tawait db.update(users).set(data).where(eq(users.id, userId));\n\n\treturn { success: true };\n};\n\n/**\n * Updates a user's account preferences\n * @param userId The user ID\n * @param data Account preferences to update\n * @param ipAddress The IP address of the requester\n */\nexport const updateAccountPreferences = async (\n\tuserId: UserId,\n\tdata: AccountSettingsInput,\n\tipAddress?: string\n) => {\n\t// Check if preferences exist\n\tconst existingPreferences = await db.query.userPreferencesSchema.findFirst({\n\t\twhere: eq(userPreferencesSchema.userId, userId)\n\t});\n\n\t// If no preferences exist yet, create them\n\tif (!existingPreferences) {\n\t\tawait db.insert(userPreferencesSchema).values({\n\t\t\tuserId,\n\t\t\t...data,\n\t\t\tcreatedAt: new Date(),\n\t\t\tupdatedAt: new Date()\n\t\t});\n\t\treturn { success: true };\n\t}\n\n\t// Track changes in preferences history\n\tconst trackedFields = ['theme', 'language', 'timezone', 'shoutboxPosition', 'profileVisibility'];\n\n\tfor (const field of trackedFields) {\n\t\tif (\n\t\t\tfield in data &&\n\t\t\tdata[field as keyof AccountSettingsInput] !==\n\t\t\t\texistingPreferences[field as keyof UserPreference]\n\t\t) {\n\t\t\tawait db.insert(userSettingsHistory).values({\n\t\t\t\tuserId,\n\t\t\t\tsettingKey: `account.${field}`,\n\t\t\t\toldValue: existingPreferences[field as keyof UserPreference]?.toString() || null,\n\t\t\t\tnewValue: data[field as keyof AccountSettingsInput]?.toString() || null,\n\t\t\t\tchangedAt: new Date(),\n\t\t\t\tchangedByIp: ipAddress\n\t\t\t});\n\t\t}\n\t}\n\n\t// Handle the sidebarState separately as it's a JSON object\n\tif (\n\t\tdata.sidebarState &&\n\t\tJSON.stringify(data.sidebarState) !== JSON.stringify(existingPreferences.sidebarState)\n\t) {\n\t\tawait db.insert(userSettingsHistory).values({\n\t\t\tuserId,\n\t\t\tsettingKey: 'account.sidebarState',\n\t\t\toldValue: JSON.stringify(existingPreferences.sidebarState),\n\t\t\tnewValue: JSON.stringify(data.sidebarState),\n\t\t\tchangedAt: new Date(),\n\t\t\tchangedByIp: ipAddress\n\t\t});\n\t}\n\n\t// Update the preferences\n\tawait db\n\t\t.update(userPreferencesSchema)\n\t\t.set({\n\t\t\t...data,\n\t\t\tupdatedAt: new Date()\n\t\t})\n\t\t.where(eq(userPreferencesSchema.userId, userId));\n\n\treturn { success: true };\n};\n\n/**\n * Updates a user's notification preferences\n * @param userId The user ID\n * @param data Notification preferences to update\n * @param ipAddress The IP address of the requester\n */\nexport const updateNotificationPreferences = async (\n\tuserId: UserId,\n\tdata: NotificationSettingsInput,\n\tipAddress?: string\n) => {\n\t// Check if notification preferences exist\n\tconst existingPreferences = await db.query.notificationPreferencesSchema.findFirst({\n\t\twhere: eq(notificationPreferencesSchema.userId, userId)\n\t});\n\n\t// If no preferences exist yet, create them\n\tif (!existingPreferences) {\n\t\tawait db.insert(notificationPreferencesSchema).values({\n\t\t\tuserId,\n\t\t\t...data,\n\t\t\tcreatedAt: new Date(),\n\t\t\tupdatedAt: new Date()\n\t\t});\n\t\treturn { success: true };\n\t}\n\n\t// Track changes in preferences history\n\tconst trackedFields = [\n\t\t'receiveEmailNotifications',\n\t\t'notifyOnMentions',\n\t\t'notifyOnNewReplies',\n\t\t'notifyOnLevelUp',\n\t\t'notifyOnMissionUpdates',\n\t\t'notifyOnWalletTransactions'\n\t];\n\n\tfor (const field of trackedFields) {\n\t\tif (\n\t\t\tfield in data &&\n\t\t\tdata[field as keyof NotificationSettingsInput] !==\n\t\t\t\texistingPreferences[field as keyof NotificationPreference]\n\t\t) {\n\t\t\tawait db.insert(userSettingsHistory).values({\n\t\t\t\tuserId,\n\t\t\t\tsettingKey: `notifications.${field}`,\n\t\t\t\toldValue: existingPreferences[field as keyof NotificationPreference]?.toString() || null,\n\t\t\t\tnewValue: data[field as keyof NotificationSettingsInput]?.toString() || null,\n\t\t\t\tchangedAt: new Date(),\n\t\t\t\tchangedByIp: ipAddress\n\t\t\t});\n\t\t}\n\t}\n\n\t// Update the notification preferences\n\tawait db\n\t\t.update(notificationPreferencesSchema)\n\t\t.set({\n\t\t\t...data,\n\t\t\tupdatedAt: new Date()\n\t\t})\n\t\t.where(eq(notificationPreferencesSchema.userId, userId));\n\n\treturn { success: true };\n};\n\n/**\n * Updates a user's display preferences\n * @param userId The user ID\n * @param data Display preferences to update\n * @param ipAddress The IP address of the requester\n */\nexport const updateDisplayPreferences = async (\n\tuserId: UserId,\n\tdata: DisplayPreferencesInput,\n\tipAddress?: string\n) => {\n\t// Check if display preferences exist\n\tconst existingPreferences = await db.query.displayPreferencesSchema.findFirst({\n\t\twhere: eq(displayPreferencesSchema.userId, userId)\n\t});\n\n\t// If no preferences exist yet, create them\n\tif (!existingPreferences) {\n\t\tawait db.insert(displayPreferencesSchema).values({\n\t\t\tuserId,\n\t\t\t...data,\n\t\t\tcreatedAt: new Date(),\n\t\t\tupdatedAt: new Date()\n\t\t});\n\t\treturn { success: true };\n\t}\n\n\t// Track changes in preferences history\n\tconst trackedFields: Array<keyof DisplayPreferencesInput> = [\n\t\t'theme',\n\t\t'fontSize',\n\t\t'threadDisplayMode',\n\t\t'reducedMotion',\n\t\t'hideNsfw',\n\t\t'showMatureContent',\n\t\t'showOfflineUsers'\n\t];\n\n\tfor (const field of trackedFields) {\n\t\tif (field in data && data[field] !== existingPreferences[field as keyof DisplayPreference]) {\n\t\t\tawait db.insert(userSettingsHistory).values({\n\t\t\t\tuserId,\n\t\t\t\tsettingKey: `display.${field}`,\n\t\t\t\toldValue: existingPreferences[field as keyof DisplayPreference]?.toString() || null,\n\t\t\t\tnewValue: data[field]?.toString() || null,\n\t\t\t\tchangedAt: new Date(),\n\t\t\t\tchangedByIp: ipAddress\n\t\t\t});\n\t\t}\n\t}\n\n\t// Update the display preferences\n\tawait db\n\t\t.update(displayPreferencesSchema)\n\t\t.set({\n\t\t\t...data,\n\t\t\tupdatedAt: new Date()\n\t\t})\n\t\t.where(eq(displayPreferencesSchema.userId, userId));\n\n\treturn { success: true };\n};\n\n/**\n * Changes a user's password\n * @param userId The user ID\n * @param data Password change input\n * @param ipAddress The IP address of the requester\n */\nexport const changePassword = async (\n\tuserId: UserId,\n\tdata: PasswordChangeInput,\n\tipAddress?: string\n) => {\n\t// Get the user\n\tconst user = await db.query.users.findFirst({\n\t\twhere: eq(users.id, userId),\n\t\tcolumns: {\n\t\t\tid: true,\n\t\t\tpassword: true\n\t\t}\n\t});\n\n\tif (!user) {\n\t\tthrow new Error('User not found');\n\t}\n\n\t// Verify current password\n\tconst isPasswordValid = await bcrypt.compare(data.currentPassword, user.password || '');\n\tif (!isPasswordValid) {\n\t\tthrow new Error('Invalid current password');\n\t}\n\n\t// Hash new password\n\tconst hashedPassword = await bcrypt.hash(data.newPassword, 10); // 10 is the salt rounds\n\n\t// Update the password\n\tawait db.update(users).set({ password: hashedPassword }).where(eq(users.id, userId));\n\n\t// Log the password change (without storing the actual passwords)\n\tawait db.insert(userSettingsHistory).values({\n\t\tuserId,\n\t\tsettingKey: 'account.password',\n\t\toldValue: '[redacted]',\n\t\tnewValue: '[redacted]',\n\t\tchangedAt: new Date(),\n\t\tchangedByIp: ipAddress\n\t});\n\n\treturn { success: true, message: 'Password updated successfully' };\n};\n\n/**\n * Creates default preferences for a new user\n * @param userId The ID of the user to create preferences for\n */\nexport const createDefaultPreferences = async (userId: UserId) => {\n\tconst defaultProfilePreferences = {\n\t\tuserId,\n\t\tbio: null,\n\t\tsignature: null,\n\t\tavatarUrl: null,\n\t\tprofileBannerUrl: null,\n\t\tdiscordHandle: null,\n\t\ttwitterHandle: null,\n\t\twebsite: null,\n\t\ttelegramHandle: null,\n\t\tactiveTitleId: null,\n\t\tactiveBadgeId: null,\n\t\tactiveFrameId: null\n\t};\n\n\tconst defaultUserPreferences = {\n\t\tuserId,\n\t\ttheme: 'auto',\n\t\tshoutboxPosition: 'sidebar-top',\n\t\tsidebarState: {},\n\t\tprofileVisibility: 'public',\n\t\tlanguage: 'en',\n\t\ttimezone: 'UTC',\n\t\tcreatedAt: new Date(),\n\t\tupdatedAt: new Date()\n\t};\n\n\tconst defaultNotificationPreferences = {\n\t\tuserId,\n\t\treceiveEmailNotifications: true,\n\t\tnotifyOnMentions: true,\n\t\tnotifyOnNewReplies: true,\n\t\tnotifyOnLevelUp: true,\n\t\tnotifyOnMissionUpdates: true,\n\t\tnotifyOnWalletTransactions: true,\n\t\tcreatedAt: new Date(),\n\t\tupdatedAt: new Date()\n\t};\n\n\tconst defaultDisplayPreferences = {\n\t\tuserId,\n\t\ttheme: 'system',\n\t\tfontSize: 'medium',\n\t\tthreadDisplayMode: 'card',\n\t\treducedMotion: false,\n\t\thideNsfw: true,\n\t\tshowMatureContent: false,\n\t\tshowOfflineUsers: true,\n\t\tcreatedAt: new Date(),\n\t\tupdatedAt: new Date()\n\t};\n\n\tawait db.transaction(async (tx) => {\n\t\tawait tx.insert(users).values(defaultProfilePreferences); // Assuming users table is for profile preferences\n\t\tawait tx.insert(userPreferencesSchema).values(defaultUserPreferences);\n\t\tawait tx.insert(notificationPreferencesSchema).values(defaultNotificationPreferences);\n\t\tawait tx.insert(displayPreferencesSchema).values(defaultDisplayPreferences);\n\t});\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/preferences/preferences.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/profile-stats.controller.ts","messages":[{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":166,"column":8,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":166,"endColumn":10},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":167,"column":8,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":167,"endColumn":10},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":168,"column":8,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":168,"endColumn":10},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":169,"column":8,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":169,"endColumn":10},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":170,"column":8,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":170,"endColumn":10},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":171,"column":8,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":171,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { Request, Response } from 'express';\nimport { ProfileStatsService } from './profile-stats.service';\nimport { handleControllerError } from '../../lib/error-handler';\nimport { z } from 'zod';\nimport { logger } from \"../../core/logger\";\n\n// Request validation schemas\nconst GetProfileStatsSchema = z.object({\n\tusername: z.string().min(1).max(50)\n});\n\nconst ProfileEngagementSchema = z.object({\n\tprofileUsername: z.string().min(1).max(50),\n\tmetrics: z.object({\n\t\ttimeSpent: z.number().min(0),\n\t\ttabSwitches: z.number().min(0),\n\t\tactionsPerformed: z.number().min(0),\n\t\tscrollDepth: z.number().min(0).max(1),\n\t\tengagementScore: z.number().min(0).max(100)\n\t}),\n\teventCount: z.number().min(0),\n\tsessionDuration: z.number().min(0),\n\ttimestamp: z.number()\n});\n\nexport class ProfileStatsController {\n\t/**\n\t * GET /api/profile/:username/stats\n\t * Get comprehensive profile statistics for enhanced widgets\n\t */\n\tstatic async getExtendedProfileStats(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst { username } = GetProfileStatsSchema.parse(req.params);\n\n\t\t\t// Optional: Track profile view for analytics\n\t\t\tif (userService.getUserFromRequest(req)?.id) {\n\t\t\t\tawait ProfileStatsService.updateLastSeen(userService.getUserFromRequest(req).id);\n\t\t\t}\n\n\t\t\tconst stats = await ProfileStatsService.getExtendedProfileStats(username);\n\n\t\t\tif (!stats) {\n\t\t\t\treturn res.status(404).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Profile not found'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove sensitive data if not own profile\n\t\t\tconst sanitizedStats = this.sanitizeProfileStats(\n\t\t\t\tstats,\n\t\t\t\tuserService.getUserFromRequest(req)?.id === stats.id\n\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: sanitizedStats,\n\t\t\t\tcached: false,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\thandleControllerError(error, res, 'Failed to fetch profile statistics');\n\t\t}\n\t}\n\n\t/**\n\t * POST /api/analytics/profile-engagement\n\t * Track profile engagement analytics\n\t */\n\tstatic async trackProfileEngagement(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst engagementData = ProfileEngagementSchema.parse(req.body);\n\n\t\t\t// Store engagement analytics (implement based on your analytics system)\n\t\t\tawait this.storeEngagementAnalytics({\n\t\t\t\t...engagementData,\n\t\t\t\tviewerId: userService.getUserFromRequest(req)?.id || null,\n\t\t\t\tuserAgent: req.headers['user-agent'] || null,\n\t\t\t\tip: req.ip,\n\t\t\t\ttimestamp: new Date()\n\t\t\t});\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Engagement data recorded'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\thandleControllerError(error, res, 'Failed to record engagement analytics');\n\t\t}\n\t}\n\n\t/**\n\t * GET /api/profile/:username/quick-stats\n\t * Get minimal stats for quick profile previews\n\t */\n\tstatic async getQuickProfileStats(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst { username } = GetProfileStatsSchema.parse(req.params);\n\n\t\t\tconst stats = await ProfileStatsService.getExtendedProfileStats(username);\n\n\t\t\tif (!stats) {\n\t\t\t\treturn res.status(404).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Profile not found'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Return only essential stats for quick previews\n\t\t\tconst quickStats = {\n\t\t\t\tid: stats.id,\n\t\t\t\tusername: stats.username,\n\t\t\t\tavatarUrl: stats.avatarUrl,\n\t\t\t\tlevel: stats.level,\n\t\t\t\treputation: stats.reputation,\n\t\t\t\tisOnline: this.isRecentlyActive(stats.lastSeenAt),\n\t\t\t\ttrustLevel: this.calculateTrustLevel(stats.reputation, stats.level),\n\t\t\t\tprimaryActivity: this.getPrimaryActivity(stats)\n\t\t\t};\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: quickStats,\n\t\t\t\tcached: true,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\thandleControllerError(error, res, 'Failed to fetch quick profile stats');\n\t\t}\n\t}\n\n\t/**\n\t * Sanitize profile stats based on privacy settings and viewer relationship\n\t */\n\tprivate static sanitizeProfileStats(stats: any, isOwnProfile: boolean) {\n\t\tif (isOwnProfile) {\n\t\t\treturn stats; // Return all data for own profile\n\t\t}\n\n\t\t// Remove sensitive financial data for non-own profiles\n\t\tconst sanitized = { ...stats };\n\n\t\t// Only show approximate wallet data\n\t\tif (sanitized.dgtBalance > 10000) {\n\t\t\tsanitized.dgtBalance = Math.round(sanitized.dgtBalance / 1000) * 1000; // Round to nearest thousand\n\t\t}\n\n\t\t// Hide exact USDT and pending withdrawals\n\t\tdelete sanitized.walletBalanceUSDT;\n\t\tdelete sanitized.walletPendingWithdrawals;\n\t\tdelete sanitized.dgtPoints;\n\n\t\t// Hide detailed security info\n\t\tdelete sanitized.lastLogin;\n\n\t\treturn sanitized;\n\t}\n\n\t/**\n\t * Store engagement analytics (implement based on your analytics infrastructure)\n\t */\n\tprivate static async storeEngagementAnalytics(data: any) {\n\t\t// Example implementation - replace with your analytics service\n\t\tlogger.info('Profile Engagement Analytics:', {\n        \t\t\tprofileUsername: data.profileUsername,\n        \t\t\tviewerId: data.viewerId,\n        \t\t\tengagementScore: data.metrics.engagementScore,\n        \t\t\tsessionDuration: data.sessionDuration,\n        \t\t\ttimestamp: data.timestamp\n        \t\t});\n\n\t\t// TODO: Implement actual analytics storage\n\t\t// - Send to analytics service (Mixpanel, Amplitude, etc.)\n\t\t// - Store in analytics database table\n\t\t// - Update user engagement metrics\n\t\t// - Trigger behavioral insights\n\t}\n\n\t/**\n\t * Check if user was recently active (within 5 minutes)\n\t */\n\tprivate static isRecentlyActive(lastSeenAt: string | null): boolean {\n\t\tif (!lastSeenAt) return false;\n\n\t\tconst fiveMinutesAgo = Date.now() - 5 * 60 * 1000;\n\t\treturn new Date(lastSeenAt).getTime() > fiveMinutesAgo;\n\t}\n\n\t/**\n\t * Calculate trust level based on reputation and level\n\t */\n\tprivate static calculateTrustLevel(reputation: number, level: number): string {\n\t\tif (reputation >= 10000 || level >= 50) return 'Elite';\n\t\tif (reputation >= 5000 || level >= 25) return 'Veteran';\n\t\tif (reputation >= 1000 || level >= 10) return 'Trusted';\n\t\tif (reputation >= 100 || level >= 5) return 'Member';\n\t\treturn 'Newcomer';\n\t}\n\n\t/**\n\t * Determine user's primary activity type\n\t */\n\tprivate static getPrimaryActivity(stats: any): string {\n\t\tconst { totalPosts, totalThreads, totalTips, posterRank } = stats;\n\n\t\tif (totalTips > totalPosts && totalTips > 1000) return 'Generous Tipper';\n\t\tif (posterRank && posterRank <= 100) return 'Top Contributor';\n\t\tif (totalThreads > totalPosts * 0.3) return 'Discussion Starter';\n\t\tif (totalPosts > 1000) return 'Active Member';\n\t\tif (totalPosts > 100) return 'Regular Poster';\n\t\treturn 'Community Member';\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/profile-stats.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/profile-stats.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'walletTransactions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '../../../db';\nimport {\n\tusers,\n\tuserStats,\n\tuserRelationships,\n\tsubscriptions,\n\troles,\n\twalletTransactions\n} from '../../../db/schema';\nimport { eq, sql, and, desc, count } from 'drizzle-orm';\nimport { logger } from \"../../core/logger\";\n\nexport interface ExtendedProfileStats {\n\t// Core profile data\n\tid: string;\n\tusername: string;\n\tavatarUrl: string | null;\n\tbio: string | null;\n\tlevel: number;\n\txp: number;\n\tnextLevelXp: number;\n\tjoinedAt: string;\n\n\t// Reputation & trust\n\tclout: number;\n\treputation: number;\n\tdailyXpGained: number;\n\tlastXpGainDate: string | null;\n\n\t// Activity metrics\n\ttotalPosts: number;\n\ttotalThreads: number;\n\ttotalLikes: number;\n\ttotalTips: number;\n\tthreadViewCount: number;\n\tposterRank: number | null;\n\ttipperRank: number | null;\n\tlikerRank: number | null;\n\n\t// Wallet & economy\n\tdgtBalance: number;\n\twalletBalanceUSDT: number;\n\twalletPendingWithdrawals: number;\n\tdgtPoints: number;\n\n\t// Social graph\n\tfollowersCount: number;\n\tfollowingCount: number;\n\tfriendsCount: number;\n\tfriendRequestsSent: number;\n\tfriendRequestsReceived: number;\n\n\t// Subscriptions & roles\n\tactiveSubscription: {\n\t\ttype: string;\n\t\tstatus: string;\n\t\tendDate: string | null;\n\t\tpricePaid: Id<'pricePaid'>;\n\t} | null;\n\tprimaryRole: {\n\t\tname: string;\n\t\tbadgeImage: string | null;\n\t\ttextColor: string | null;\n\t\txpMultiplier: number;\n\t} | null;\n\tisStaff: boolean;\n\tisModerator: boolean;\n\tisAdmin: boolean;\n\n\t// Referrals & progression\n\treferralLevel: number;\n\treferralsCount: number;\n\n\t// Path XP breakdown\n\tpathXp: Record<string, number>;\n\tpathMultipliers: Record<string, number>;\n\n\t// Account security\n\tlastSeenAt: string | null;\n\tlastLogin: string | null;\n}\n\nexport class ProfileStatsService {\n\t/**\n\t * Get comprehensive profile statistics for enhanced profile widgets\n\t * Optimized with joins to minimize database queries\n\t */\n\tstatic async getExtendedProfileStats(username: string): Promise<ExtendedProfileStats | null> {\n\t\ttry {\n\t\t\t// Main user query with joins\n\t\t\tconst userQuery = await db\n\t\t\t\t.select({\n\t\t\t\t\t// Core user data\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\t\tbio: users.bio,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\txp: users.xp,\n\t\t\t\t\tnextLevelXp: users.nextLevelXp,\n\t\t\t\t\tjoinedAt: users.joinedAt,\n\n\t\t\t\t\t// Reputation & trust\n\t\t\t\t\tclout: users.clout,\n\t\t\t\t\treputation: users.reputation,\n\t\t\t\t\tdailyXpGained: users.dailyXpGained,\n\t\t\t\t\tlastXpGainDate: users.lastXpGainDate,\n\n\t\t\t\t\t// Activity metrics\n\t\t\t\t\ttotalPosts: users.totalPosts,\n\t\t\t\t\ttotalThreads: users.totalThreads,\n\t\t\t\t\ttotalLikes: users.totalLikes,\n\t\t\t\t\ttotalTips: users.totalTips,\n\n\t\t\t\t\t// Wallet data\n\t\t\t\t\tdgtBalance: users.dgtBalance,\n\t\t\t\t\twalletBalanceUSDT: users.walletBalanceUSDT,\n\t\t\t\t\twalletPendingWithdrawals: users.walletPendingWithdrawals,\n\t\t\t\t\tdgtPoints: users.dgtPoints,\n\n\t\t\t\t\t// Referrals\n\t\t\t\t\treferralLevel: users.referralLevel,\n\n\t\t\t\t\t// Path XP\n\t\t\t\t\tpathXp: users.pathXp,\n\t\t\t\t\tpathMultipliers: users.pathMultipliers,\n\n\t\t\t\t\t// Security\n\t\t\t\t\tlastSeenAt: users.lastSeenAt,\n\t\t\t\t\tlastLogin: users.lastLogin,\n\n\t\t\t\t\t// Role flags\n\t\t\t\t\tisStaff: users.isStaff,\n\t\t\t\t\tisModerator: users.isModerator,\n\t\t\t\t\tisAdmin: users.isAdmin,\n\n\t\t\t\t\t// Stats from user_stats table\n\t\t\t\t\tthreadViewCount: userStats.threadViewCount,\n\t\t\t\t\tposterRank: userStats.posterRank,\n\t\t\t\t\ttipperRank: userStats.tipperRank,\n\t\t\t\t\tlikerRank: userStats.likerRank\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.leftJoin(userStats, eq(users.id, userStats.userId))\n\t\t\t\t.where(eq(users.username, username))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userQuery.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst user = userQuery[0];\n\n\t\t\t// Parallel queries for social data and subscriptions\n\t\t\tconst [socialCounts, activeSubscription, primaryRole, referralsCount] = await Promise.all([\n\t\t\t\tthis.getSocialGraphCounts(user.id),\n\t\t\t\tthis.getActiveSubscription(user.id),\n\t\t\t\tthis.getPrimaryRole(user.id),\n\t\t\t\tthis.getReferralsCount(user.id)\n\t\t\t]);\n\n\t\t\t// Calculate next level XP if not set\n\t\t\tconst nextLevelXp = user.nextLevelXp || this.calculateNextLevelXp(user.level);\n\n\t\t\treturn {\n\t\t\t\t// Core profile data\n\t\t\t\tid: user.id,\n\t\t\t\tusername: user.username,\n\t\t\t\tavatarUrl: user.avatarUrl,\n\t\t\t\tbio: user.bio,\n\t\t\t\tlevel: user.level,\n\t\t\t\txp: user.xp,\n\t\t\t\tnextLevelXp,\n\t\t\t\tjoinedAt: user.joinedAt?.toISOString() || new Date().toISOString(),\n\n\t\t\t\t// Reputation & trust\n\t\t\t\tclout: user.clout || 0,\n\t\t\t\treputation: user.reputation || 0,\n\t\t\t\tdailyXpGained: user.dailyXpGained || 0,\n\t\t\t\tlastXpGainDate: user.lastXpGainDate?.toISOString() || null,\n\n\t\t\t\t// Activity metrics\n\t\t\t\ttotalPosts: user.totalPosts || 0,\n\t\t\t\ttotalThreads: user.totalThreads || 0,\n\t\t\t\ttotalLikes: user.totalLikes || 0,\n\t\t\t\ttotalTips: user.totalTips || 0,\n\t\t\t\tthreadViewCount: user.threadViewCount || 0,\n\t\t\t\tposterRank: user.posterRank,\n\t\t\t\ttipperRank: user.tipperRank,\n\t\t\t\tlikerRank: user.likerRank,\n\n\t\t\t\t// Wallet & economy\n\t\t\t\tdgtBalance: user.dgtBalance || 0,\n\t\t\t\twalletBalanceUSDT: user.walletBalanceUSDT || 0,\n\t\t\t\twalletPendingWithdrawals: user.walletPendingWithdrawals || 0,\n\t\t\t\tdgtPoints: user.dgtPoints || 0,\n\n\t\t\t\t// Social graph\n\t\t\t\tfollowersCount: socialCounts.followersCount,\n\t\t\t\tfollowingCount: socialCounts.followingCount,\n\t\t\t\tfriendsCount: socialCounts.friendsCount,\n\t\t\t\tfriendRequestsSent: socialCounts.friendRequestsSent,\n\t\t\t\tfriendRequestsReceived: socialCounts.friendRequestsReceived,\n\n\t\t\t\t// Subscriptions & roles\n\t\t\t\tactiveSubscription,\n\t\t\t\tprimaryRole,\n\t\t\t\tisStaff: user.isStaff || false,\n\t\t\t\tisModerator: user.isModerator || false,\n\t\t\t\tisAdmin: user.isAdmin || false,\n\n\t\t\t\t// Referrals & progression\n\t\t\t\treferralLevel: user.referralLevel || 0,\n\t\t\t\treferralsCount,\n\n\t\t\t\t// Path XP breakdown\n\t\t\t\tpathXp: (user.pathXp as Record<string, number>) || {},\n\t\t\t\tpathMultipliers: (user.pathMultipliers as Record<string, number>) || {},\n\n\t\t\t\t// Account security\n\t\t\t\tlastSeenAt: user.lastSeenAt?.toISOString() || null,\n\t\t\t\tlastLogin: user.lastLogin?.toISOString() || null\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error fetching extended profile stats:', error);\n\t\t\tthrow new Error('Failed to fetch profile statistics');\n\t\t}\n\t}\n\n\t/**\n\t * Get social graph counts with optimized queries\n\t */\n\tprivate static async getSocialGraphCounts(userId: string) {\n\t\tconst [\n\t\t\tfollowersResult,\n\t\t\tfollowingResult,\n\t\t\tfriendsResult,\n\t\t\tsentRequestsResult,\n\t\t\treceivedRequestsResult\n\t\t] = await Promise.all([\n\t\t\t// Followers count\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userRelationships)\n\t\t\t\t.where(\n\t\t\t\t\tand(eq(userRelationships.targetUserId, userId), eq(userRelationships.type, 'follow'))\n\t\t\t\t),\n\n\t\t\t// Following count\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userRelationships)\n\t\t\t\t.where(and(eq(userRelationships.userId, userId), eq(userRelationships.type, 'follow'))),\n\n\t\t\t// Friends count (mutual follows or explicit friends)\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userRelationships)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userRelationships.userId, userId),\n\t\t\t\t\t\teq(userRelationships.type, 'friend'),\n\t\t\t\t\t\teq(userRelationships.status, 'accepted')\n\t\t\t\t\t)\n\t\t\t\t),\n\n\t\t\t// Friend requests sent\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userRelationships)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userRelationships.userId, userId),\n\t\t\t\t\t\teq(userRelationships.type, 'friend'),\n\t\t\t\t\t\teq(userRelationships.status, 'pending')\n\t\t\t\t\t)\n\t\t\t\t),\n\n\t\t\t// Friend requests received\n\t\t\tdb\n\t\t\t\t.select({ count: count() })\n\t\t\t\t.from(userRelationships)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userRelationships.targetUserId, userId),\n\t\t\t\t\t\teq(userRelationships.type, 'friend'),\n\t\t\t\t\t\teq(userRelationships.status, 'pending')\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t]);\n\n\t\treturn {\n\t\t\tfollowersCount: followersResult[0]?.count || 0,\n\t\t\tfollowingCount: followingResult[0]?.count || 0,\n\t\t\tfriendsCount: friendsResult[0]?.count || 0,\n\t\t\tfriendRequestsSent: sentRequestsResult[0]?.count || 0,\n\t\t\tfriendRequestsReceived: receivedRequestsResult[0]?.count || 0\n\t\t};\n\t}\n\n\t/**\n\t * Get active subscription details\n\t */\n\tprivate static async getActiveSubscription(userId: string) {\n\t\tconst subscription = await db\n\t\t\t.select({\n\t\t\t\ttype: subscriptions.type,\n\t\t\t\tstatus: subscriptions.status,\n\t\t\t\tendDate: subscriptions.endDate,\n\t\t\t\tpricePaid: subscriptions.pricePaid\n\t\t\t})\n\t\t\t.from(subscriptions)\n\t\t\t.where(and(eq(subscriptions.userId, userId), eq(subscriptions.status, 'active')))\n\t\t\t.orderBy(desc(subscriptions.endDate))\n\t\t\t.limit(1);\n\n\t\treturn subscription[0]\n\t\t\t? {\n\t\t\t\t\ttype: subscription[0].type,\n\t\t\t\t\tstatus: subscription[0].status,\n\t\t\t\t\tendDate: subscription[0].endDate?.toISOString() || null,\n\t\t\t\t\tpricePaid: subscription[0].pricePaid || 0\n\t\t\t\t}\n\t\t\t: null;\n\t}\n\n\t/**\n\t * Get primary role information\n\t */\n\tprivate static async getPrimaryRole(userId: string) {\n\t\tconst role = await db\n\t\t\t.select({\n\t\t\t\tname: roles.name,\n\t\t\t\tbadgeImage: roles.badgeImage,\n\t\t\t\ttextColor: roles.textColor,\n\t\t\t\txpMultiplier: roles.xpMultiplier\n\t\t\t})\n\t\t\t.from(roles)\n\t\t\t.innerJoin(users, eq(users.primaryRoleId, roles.id))\n\t\t\t.where(eq(users.id, userId))\n\t\t\t.limit(1);\n\n\t\treturn role[0]\n\t\t\t? {\n\t\t\t\t\tname: role[0].name,\n\t\t\t\t\tbadgeImage: role[0].badgeImage,\n\t\t\t\t\ttextColor: role[0].textColor,\n\t\t\t\t\txpMultiplier: role[0].xpMultiplier || 1\n\t\t\t\t}\n\t\t\t: null;\n\t}\n\n\t/**\n\t * Get referrals count for user\n\t */\n\tprivate static async getReferralsCount(userId: string): Promise<number> {\n\t\t// Assuming there's a referrals tracking mechanism\n\t\tconst result = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(users)\n\t\t\t.where(eq(users.referrerId, userId));\n\n\t\treturn result[0]?.count || 0;\n\t}\n\n\t/**\n\t * Calculate next level XP requirement\n\t */\n\tprivate static calculateNextLevelXp(currentLevel: number): number {\n\t\t// Standard XP progression: level^2 * 100\n\t\treturn Math.pow(currentLevel + 1, 2) * 100;\n\t}\n\n\t/**\n\t * Update user's last seen timestamp\n\t */\n\tstatic async updateLastSeen(userId: string): Promise<void> {\n\t\tawait db.update(users).set({ lastSeenAt: new Date() }).where(eq(users.id, userId));\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/profile.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'products' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'forumStructure' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userRelationships' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'avatarFrames' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":19,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'not' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'or' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gt' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Profile Routes\n *\n * Defines API routes for user profile functionality.\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { db } from '@db';\nimport {\n\tusers,\n\tuserInventory,\n\tproducts,\n\tforumStructure,\n\tthreads,\n\tposts,\n\tuserRelationships,\n\tavatarFrames,\n\tuserTitles,\n\tuserBadges\n} from '@schema';\nimport { eq, and, sql, desc, not, or, count, gt, isNull } from 'drizzle-orm';\nimport signatureRoutes from './signature.routes'; // Import signature routes\nimport { authenticate } from '../../middleware/authenticate';\nimport { profileService } from './profile.service';\nimport { referralsService } from './referrals.service';\nimport { logger } from \"../../core/logger\";\n\nconst router = Router();\n\n// Mount signature routes\nrouter.use('/signature', signatureRoutes);\n\n// Get profile data by username\nrouter.get('/:username', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst { username } = req.params;\n\n\t\tif (!username) {\n\t\t\treturn res.status(400).json({ message: 'Username is required' });\n\t\t}\n\n\t\t// Fetch user data using simple select (avoiding relational issues)\n\t\tconst [user] = await db.select().from(users).where(eq(users.username, username));\n\n\t\tif (!user) {\n\t\t\treturn res.status(404).json({ message: 'User not found' });\n\t\t}\n\n\t\tconst userId = user.id;\n\n\t\t// Fetch user's inventory (simplified)\n\t\tconst inventory = await db.select().from(userInventory).where(eq(userInventory.userId, userId));\n\n\t\t// Fetch user's badges (simplified)\n\t\tconst badges = await db.select().from(userBadges).where(eq(userBadges.userId, userId));\n\n\t\t// Fetch user's titles (simplified)\n\t\tconst titles = await db.select().from(userTitles).where(eq(userTitles.userId, userId));\n\n\t\t// Get thread count\n\t\tconst threadCountResult = await db\n\t\t\t.select({ value: count() })\n\t\t\t.from(threads)\n\t\t\t.where(eq(threads.userId, userId));\n\t\tconst totalThreads = threadCountResult[0]?.value || 0;\n\n\t\t// Get post count\n\t\tconst postCountResult = await db\n\t\t\t.select({ value: count() })\n\t\t\t.from(posts)\n\t\t\t.where(eq(posts.userId, userId));\n\t\tconst totalPosts = postCountResult[0]?.value || 0;\n\n\t\t// Get total likes received\n\t\tconst likesResult = await db\n\t\t\t.select({ value: sql<number>`COALESCE(SUM(${posts.likeCount}), 0)` })\n\t\t\t.from(posts)\n\t\t\t.where(eq(posts.userId, userId));\n\t\tconst totalLikes = likesResult[0]?.value || 0;\n\n\t\t// Get total tips received\n\t\tconst tipsResult = await db\n\t\t\t.select({ value: sql<number>`COALESCE(SUM(${posts.totalTips}), 0)` })\n\t\t\t.from(posts)\n\t\t\t.where(eq(posts.userId, userId));\n\t\tconst totalTips = tipsResult[0]?.value || 0;\n\n\t\t// Thread view count\n\t\tconst viewCountResult = await db\n\t\t\t.select({ value: sql<number>`COALESCE(SUM(${threads.viewCount}), 0)` })\n\t\t\t.from(threads)\n\t\t\t.where(eq(threads.userId, userId));\n\t\tconst threadViewCount = viewCountResult[0]?.value || 0;\n\n\t\t// Calculate next level XP requirement\n\t\tconst nextLevelXp = (Number(user.level || 1) + 1) * 1000;\n\n\t\t// Placeholder leaderboard ranks (these would come from a separate ranking system)\n\t\tconst posterRank = 1;\n\t\tconst tipperRank = 1;\n\t\tconst likerRank = 1;\n\n\t\t// Assemble profile data\n\t\tconst profileData = {\n\t\t\tid: user.id,\n\t\t\tusername: user.username,\n\t\t\tavatarUrl: user.avatarUrl,\n\t\t\trole: user.role,\n\t\t\tbio: user.bio,\n\t\t\tsignature: user.signature,\n\t\t\tjoinedAt: user.createdAt,\n\t\t\tlastActiveAt: user.lastSeenAt,\n\t\t\temail: user.email,\n\t\t\tdiscordHandle: user.discordHandle,\n\t\t\ttwitterHandle: user.twitterHandle,\n\t\t\twebsite: user.website,\n\t\t\ttelegramHandle: user.telegramHandle,\n\t\t\tdgtBalance: user.dgtWalletBalance,\n\t\t\ttotalPosts,\n\t\t\ttotalThreads,\n\t\t\ttotalLikes,\n\t\t\ttotalTips,\n\t\t\tclout: user.clout,\n\t\t\tlevel: user.level,\n\t\t\txp: user.xp,\n\t\t\tnextLevelXp,\n\t\t\tbannerUrl: user.profileBannerUrl,\n\t\t\tactiveFrameId: user.activeFrameId,\n\t\t\tactiveFrame: user.activeFrame,\n\t\t\tactiveTitleId: user.activeTitleId,\n\t\t\tactiveTitle: user.activeTitle,\n\t\t\tactiveBadgeId: user.activeBadgeId,\n\t\t\tactiveBadge: user.activeBadge,\n\t\t\tbadges: badges.map((b) => b.badge),\n\t\t\ttitles: titles.map((t) => t.title),\n\t\t\tinventory: inventory.map((item) => ({\n\t\t\t\tid: item.id,\n\t\t\t\tproductId: item.productId,\n\t\t\t\tisEquipped: item.equipped,\n\t\t\t\tproductName: item.product.name,\n\t\t\t\tproductType: item.product.category || 'unknown', // Assuming category for productType\n\t\t\t\timageUrl: item.product.imageUrl || '',\n\t\t\t\trarity: item.product.pluginReward?.rarity || 'common'\n\t\t\t})),\n\t\t\trelationships: {\n\t\t\t\tfriends: [], // TODO: Implement friend relationships\n\t\t\t\tfriendRequestsSent: 0,\n\t\t\t\tfriendRequestsReceived: 0\n\t\t\t},\n\t\t\tstats: {\n\t\t\t\tthreadViewCount,\n\t\t\t\tposterRank,\n\t\t\t\ttipperRank,\n\t\t\t\tlikerRank\n\t\t\t}\n\t\t};\n\n\t\treturn res.status(200).json(profileData);\n\t} catch (error) {\n\t\tlogger.error('Error fetching profile:', error);\n\t\treturn res.status(500).json({ message: 'Error fetching profile data' });\n\t}\n});\n\n/**\n * @route   GET /api/profile\n * @desc    Get user profile\n * @access  Private\n */\nrouter.get('/', authenticate, async (req, res) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\treturn res.status(401).json({ success: false, message: 'User not authenticated' });\n\t\t}\n\n\t\tconst profile = await profileService.getUserProfile(userId);\n\t\treturn res.json({ success: true, data: profile });\n\t} catch (error) {\n\t\tlogger.error('Error fetching profile:', error);\n\t\treturn res.status(500).json({ success: false, message: 'Failed to fetch profile' });\n\t}\n});\n\n/**\n * @route   GET /api/profile/referrals\n * @desc    Get user referral stats\n * @access  Private\n */\nrouter.get('/referrals', authenticate, async (req, res) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\treturn res.status(401).json({ success: false, message: 'User not authenticated' });\n\t\t}\n\n\t\tconst referrals = await referralsService.getUserReferrals(userId);\n\t\treturn res.json({ success: true, data: referrals });\n\t} catch (error) {\n\t\tlogger.error('Error fetching referrals:', error);\n\t\treturn res.status(500).json({ success: false, message: 'Failed to fetch referral data' });\n\t}\n});\n\n/**\n * @route   GET /api/profile/referrals/link\n * @desc    Get user's referral link\n * @access  Private\n */\nrouter.get('/referrals/link', authenticate, async (req, res) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\treturn res.status(401).json({ success: false, message: 'User not authenticated' });\n\t\t}\n\n\t\tconst referralLink = await referralsService.getUserReferralLink(userId);\n\t\treturn res.json({ success: true, data: { referralLink } });\n\t} catch (error) {\n\t\tlogger.error('Error generating referral link:', error);\n\t\treturn res.status(500).json({ success: false, message: 'Failed to generate referral link' });\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/profile.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/referrals.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/signature.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/signature.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/social-actions.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":235,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":235,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":251,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":251,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { Request, Response } from 'express';\nimport { SocialActionsService } from './social-actions.service';\nimport { handleControllerError } from '../../lib/error-handler';\nimport { z } from 'zod';\n\n// Request validation schemas\nconst FollowUserSchema = z.object({\n\ttargetUserId: z.string().uuid()\n});\n\nconst FriendRequestSchema = z.object({\n\ttargetUserId: z.string().uuid(),\n\taction: z.enum(['send', 'accept', 'decline'])\n});\n\nconst BlockUserSchema = z.object({\n\ttargetUserId: z.string().uuid()\n});\n\nconst RelationshipStatusSchema = z.object({\n\ttargetUserId: z.string().uuid()\n});\n\nexport class SocialActionsController {\n\t/**\n\t * POST /api/social/follow\n\t * Follow or unfollow a user\n\t */\n\tstatic async toggleFollow(req: Request, res: Response) {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)?.id) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Authentication required'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { targetUserId } = FollowUserSchema.parse(req.body);\n\n\t\t\tconst result = await SocialActionsService.toggleFollow(\n\t\t\t\tuserService.getUserFromRequest(req).id,\n\t\t\t\ttargetUserId\n\t\t\t);\n\n\t\t\tconst statusCode = result.success ? 200 : 400;\n\n\t\t\tres.status(statusCode).json({\n\t\t\t\tsuccess: result.success,\n\t\t\t\tdata: {\n\t\t\t\t\taction: result.action,\n\t\t\t\t\trelationship: result.relationship,\n\t\t\t\t\tmessage: result.message\n\t\t\t\t},\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\thandleControllerError(error, res, 'Failed to update follow status');\n\t\t}\n\t}\n\n\t/**\n\t * POST /api/social/friend\n\t * Send, accept, or decline friend request\n\t */\n\tstatic async manageFriendRequest(req: Request, res: Response) {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)?.id) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Authentication required'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { targetUserId, action } = FriendRequestSchema.parse(req.body);\n\n\t\t\tconst result = await SocialActionsService.manageFriendRequest(\n\t\t\t\tuserService.getUserFromRequest(req).id,\n\t\t\t\ttargetUserId,\n\t\t\t\taction\n\t\t\t);\n\n\t\t\tconst statusCode = result.success ? 200 : 400;\n\n\t\t\tres.status(statusCode).json({\n\t\t\t\tsuccess: result.success,\n\t\t\t\tdata: {\n\t\t\t\t\taction: result.action,\n\t\t\t\t\trelationship: result.relationship,\n\t\t\t\t\tmessage: result.message\n\t\t\t\t},\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\thandleControllerError(error, res, 'Failed to manage friend request');\n\t\t}\n\t}\n\n\t/**\n\t * POST /api/social/block\n\t * Block or unblock a user\n\t */\n\tstatic async toggleBlock(req: Request, res: Response) {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)?.id) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Authentication required'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { targetUserId } = BlockUserSchema.parse(req.body);\n\n\t\t\tconst result = await SocialActionsService.toggleBlock(\n\t\t\t\tuserService.getUserFromRequest(req).id,\n\t\t\t\ttargetUserId\n\t\t\t);\n\n\t\t\tconst statusCode = result.success ? 200 : 400;\n\n\t\t\tres.status(statusCode).json({\n\t\t\t\tsuccess: result.success,\n\t\t\t\tdata: {\n\t\t\t\t\taction: result.action,\n\t\t\t\t\trelationship: result.relationship,\n\t\t\t\t\tmessage: result.message\n\t\t\t\t},\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\thandleControllerError(error, res, 'Failed to update block status');\n\t\t}\n\t}\n\n\t/**\n\t * GET /api/social/relationship/:targetUserId\n\t * Get relationship status with target user\n\t */\n\tstatic async getRelationshipStatus(req: Request, res: Response) {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)?.id) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Authentication required'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { targetUserId } = RelationshipStatusSchema.parse(req.params);\n\n\t\t\tconst status = await SocialActionsService.getRelationshipStatus(\n\t\t\t\tuserService.getUserFromRequest(req).id,\n\t\t\t\ttargetUserId\n\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: status,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\thandleControllerError(error, res, 'Failed to get relationship status');\n\t\t}\n\t}\n\n\t/**\n\t * GET /api/social/suggestions\n\t * Get friend/follow suggestions for user\n\t */\n\tstatic async getSocialSuggestions(req: Request, res: Response) {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)?.id) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Authentication required'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// TODO: Implement suggestion algorithm\n\t\t\t// - Mutual friends/followers\n\t\t\t// - Similar interests/paths\n\t\t\t// - Active users in same forums\n\t\t\t// - Geographic proximity (if available)\n\n\t\t\tconst suggestions = await this.generateSocialSuggestions(\n\t\t\t\tuserService.getUserFromRequest(req).id\n\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\tsuggestions,\n\t\t\t\t\tcount: suggestions.length\n\t\t\t\t},\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\thandleControllerError(error, res, 'Failed to get social suggestions');\n\t\t}\n\t}\n\n\t/**\n\t * GET /api/social/pending-requests\n\t * Get pending friend requests for current user\n\t */\n\tstatic async getPendingFriendRequests(req: Request, res: Response) {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)?.id) {\n\t\t\t\treturn res.status(401).json({\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: 'Authentication required'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// TODO: Implement pending requests query\n\t\t\tconst pendingRequests = await this.getPendingRequests(userService.getUserFromRequest(req).id);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\treceived: pendingRequests.received,\n\t\t\t\t\tsent: pendingRequests.sent,\n\t\t\t\t\tcount: pendingRequests.received.length\n\t\t\t\t},\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\thandleControllerError(error, res, 'Failed to get pending friend requests');\n\t\t}\n\t}\n\n\t/**\n\t * Generate social suggestions for user\n\t * TODO: Implement sophisticated suggestion algorithm\n\t */\n\tprivate static async generateSocialSuggestions(userId: string) {\n\t\t// Placeholder implementation\n\t\t// In production, this would use ML algorithms considering:\n\t\t// - Mutual connections\n\t\t// - Similar activity patterns\n\t\t// - Forum participation overlap\n\t\t// - Geographic/demographic data\n\t\t// - Engagement patterns\n\n\t\treturn [];\n\t}\n\n\t/**\n\t * Get pending friend requests for user\n\t * TODO: Implement full friend request query\n\t */\n\tprivate static async getPendingRequests(userId: string) {\n\t\t// Placeholder implementation\n\t\treturn {\n\t\t\treceived: [],\n\t\t\tsent: []\n\t\t};\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/social-actions.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/profile/social-actions.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":15},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":155,"column":6,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":164,"endColumn":20},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":190,"column":6,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":190,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '../../../db';\nimport { users, userRelationships, notifications } from '../../../db/schema';\nimport { eq, and, or } from 'drizzle-orm';\nimport { logger } from \"../../core/logger\";\n\nexport type RelationshipType = 'follow' | 'friend' | 'block';\nexport type RelationshipStatus = 'pending' | 'accepted' | 'declined';\n\nexport interface SocialActionResult {\n\tsuccess: boolean;\n\taction: string;\n\trelationship?: any;\n\tmessage: string;\n}\n\nexport class SocialActionsService {\n\t/**\n\t * Follow or unfollow a user\n\t */\n\tstatic async toggleFollow(userId: string, targetUserId: string): Promise<SocialActionResult> {\n\t\ttry {\n\t\t\tif (userId === targetUserId) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\taction: 'follow',\n\t\t\t\t\tmessage: 'Cannot follow yourself'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check if already following\n\t\t\tconst existingFollow = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userRelationships)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userRelationships.userId, userId),\n\t\t\t\t\t\teq(userRelationships.targetUserId, targetUserId),\n\t\t\t\t\t\teq(userRelationships.type, 'follow')\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.limit(1);\n\n\t\t\tif (existingFollow.length > 0) {\n\t\t\t\t// Unfollow\n\t\t\t\tawait db\n\t\t\t\t\t.delete(userRelationships)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(userRelationships.userId, userId),\n\t\t\t\t\t\t\teq(userRelationships.targetUserId, targetUserId),\n\t\t\t\t\t\t\teq(userRelationships.type, 'follow')\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\taction: 'unfollow',\n\t\t\t\t\tmessage: 'Successfully unfollowed user'\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// Follow\n\t\t\t\tconst relationship = await db\n\t\t\t\t\t.insert(userRelationships)\n\t\t\t\t\t.values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\ttargetUserId,\n\t\t\t\t\t\ttype: 'follow',\n\t\t\t\t\t\tstatus: 'accepted', // Follows are automatically accepted\n\t\t\t\t\t\tcreatedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.returning();\n\n\t\t\t\t// Create notification for target user\n\t\t\t\tawait this.createNotification(targetUserId, 'follow', `You have a new follower`, {\n\t\t\t\t\tfollowerId: userId\n\t\t\t\t});\n\n\t\t\t\t// Update follower counts (optional - can be done async)\n\t\t\t\tawait this.updateFollowerCounts(userId, targetUserId);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\taction: 'follow',\n\t\t\t\t\trelationship: relationship[0],\n\t\t\t\t\tmessage: 'Successfully followed user'\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('Error toggling follow:', error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\taction: 'follow',\n\t\t\t\tmessage: 'Failed to update follow status'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Send, accept, or decline friend request\n\t */\n\tstatic async manageFriendRequest(\n\t\tuserId: string,\n\t\ttargetUserId: string,\n\t\taction: 'send' | 'accept' | 'decline'\n\t): Promise<SocialActionResult> {\n\t\ttry {\n\t\t\tif (userId === targetUserId) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\taction: 'friend',\n\t\t\t\t\tmessage: 'Cannot send friend request to yourself'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst existingRelationship = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userRelationships)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\tor(\n\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\teq(userRelationships.userId, userId),\n\t\t\t\t\t\t\t\teq(userRelationships.targetUserId, targetUserId)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\teq(userRelationships.userId, targetUserId),\n\t\t\t\t\t\t\t\teq(userRelationships.targetUserId, userId)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t),\n\t\t\t\t\t\teq(userRelationships.type, 'friend')\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.limit(1);\n\n\t\t\tswitch (action) {\n\t\t\t\tcase 'send':\n\t\t\t\t\tif (existingRelationship.length > 0) {\n\t\t\t\t\t\tconst rel = existingRelationship[0];\n\t\t\t\t\t\tif (rel.status === 'accepted') {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\t\taction: 'friend',\n\t\t\t\t\t\t\t\tmessage: 'Already friends with this user'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (rel.status === 'pending') {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\t\taction: 'friend',\n\t\t\t\t\t\t\t\tmessage: 'Friend request already sent'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Send friend request\n\t\t\t\t\tconst friendRequest = await db\n\t\t\t\t\t\t.insert(userRelationships)\n\t\t\t\t\t\t.values({\n\t\t\t\t\t\t\tuserId,\n\t\t\t\t\t\t\ttargetUserId,\n\t\t\t\t\t\t\ttype: 'friend',\n\t\t\t\t\t\t\tstatus: 'pending',\n\t\t\t\t\t\t\tcreatedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.returning();\n\n\t\t\t\t\t// Create notification\n\t\t\t\t\tawait this.createNotification(\n\t\t\t\t\t\ttargetUserId,\n\t\t\t\t\t\t'friend_request',\n\t\t\t\t\t\t`You have a new friend request`,\n\t\t\t\t\t\t{ senderId: userId }\n\t\t\t\t\t);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\taction: 'friend_request_sent',\n\t\t\t\t\t\trelationship: friendRequest[0],\n\t\t\t\t\t\tmessage: 'Friend request sent successfully'\n\t\t\t\t\t};\n\n\t\t\t\tcase 'accept':\n\t\t\t\t\tif (existingRelationship.length === 0) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\taction: 'friend',\n\t\t\t\t\t\t\tmessage: 'No friend request found'\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tconst relationship = existingRelationship[0];\n\t\t\t\t\tif (relationship.targetUserId !== userId) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\taction: 'friend',\n\t\t\t\t\t\t\tmessage: 'Cannot accept your own friend request'\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Accept friend request\n\t\t\t\t\tawait db\n\t\t\t\t\t\t.update(userRelationships)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tstatus: 'accepted',\n\t\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(eq(userRelationships.id, relationship.id));\n\n\t\t\t\t\t// Create reverse relationship for mutual friendship\n\t\t\t\t\tawait db.insert(userRelationships).values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\ttargetUserId: relationship.userId,\n\t\t\t\t\t\ttype: 'friend',\n\t\t\t\t\t\tstatus: 'accepted',\n\t\t\t\t\t\tcreatedAt: new Date()\n\t\t\t\t\t});\n\n\t\t\t\t\t// Notify requester that request was accepted\n\t\t\t\t\tawait this.createNotification(\n\t\t\t\t\t\trelationship.userId,\n\t\t\t\t\t\t'friend_accepted',\n\t\t\t\t\t\t`Your friend request was accepted`,\n\t\t\t\t\t\t{ accepterId: userId }\n\t\t\t\t\t);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\taction: 'friend_accepted',\n\t\t\t\t\t\tmessage: 'Friend request accepted'\n\t\t\t\t\t};\n\n\t\t\t\tcase 'decline':\n\t\t\t\t\tif (existingRelationship.length === 0) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\taction: 'friend',\n\t\t\t\t\t\t\tmessage: 'No friend request found'\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the friend request\n\t\t\t\t\tawait db\n\t\t\t\t\t\t.delete(userRelationships)\n\t\t\t\t\t\t.where(eq(userRelationships.id, existingRelationship[0].id));\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\taction: 'friend_declined',\n\t\t\t\t\t\tmessage: 'Friend request declined'\n\t\t\t\t\t};\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\taction: 'friend',\n\t\t\t\t\t\tmessage: 'Invalid action'\n\t\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('Error managing friend request:', error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\taction: 'friend',\n\t\t\t\tmessage: 'Failed to manage friend request'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Block or unblock a user\n\t */\n\tstatic async toggleBlock(userId: string, targetUserId: string): Promise<SocialActionResult> {\n\t\ttry {\n\t\t\tif (userId === targetUserId) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\taction: 'block',\n\t\t\t\t\tmessage: 'Cannot block yourself'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check if already blocked\n\t\t\tconst existingBlock = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userRelationships)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(userRelationships.userId, userId),\n\t\t\t\t\t\teq(userRelationships.targetUserId, targetUserId),\n\t\t\t\t\t\teq(userRelationships.type, 'block')\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.limit(1);\n\n\t\t\tif (existingBlock.length > 0) {\n\t\t\t\t// Unblock\n\t\t\t\tawait db.delete(userRelationships).where(eq(userRelationships.id, existingBlock[0].id));\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\taction: 'unblock',\n\t\t\t\t\tmessage: 'User unblocked successfully'\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// Block user - first remove any existing relationships\n\t\t\t\tawait db\n\t\t\t\t\t.delete(userRelationships)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\tor(\n\t\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\t\teq(userRelationships.userId, userId),\n\t\t\t\t\t\t\t\t\teq(userRelationships.targetUserId, targetUserId)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\t\teq(userRelationships.userId, targetUserId),\n\t\t\t\t\t\t\t\t\teq(userRelationships.targetUserId, userId)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tor(eq(userRelationships.type, 'follow'), eq(userRelationships.type, 'friend'))\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t// Create block relationship\n\t\t\t\tconst blockRelationship = await db\n\t\t\t\t\t.insert(userRelationships)\n\t\t\t\t\t.values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\ttargetUserId,\n\t\t\t\t\t\ttype: 'block',\n\t\t\t\t\t\tstatus: 'accepted',\n\t\t\t\t\t\tcreatedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.returning();\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\taction: 'block',\n\t\t\t\t\trelationship: blockRelationship[0],\n\t\t\t\t\tmessage: 'User blocked successfully'\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('Error toggling block:', error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\taction: 'block',\n\t\t\t\tmessage: 'Failed to update block status'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Get relationship status between two users\n\t */\n\tstatic async getRelationshipStatus(userId: string, targetUserId: string) {\n\t\ttry {\n\t\t\tconst relationships = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userRelationships)\n\t\t\t\t.where(\n\t\t\t\t\tor(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(userRelationships.userId, userId),\n\t\t\t\t\t\t\teq(userRelationships.targetUserId, targetUserId)\n\t\t\t\t\t\t),\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(userRelationships.userId, targetUserId),\n\t\t\t\t\t\t\teq(userRelationships.targetUserId, userId)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tconst status = {\n\t\t\t\tisFollowing: false,\n\t\t\t\tisFollowedBy: false,\n\t\t\t\tisFriend: false,\n\t\t\t\tfriendRequestSent: false,\n\t\t\t\tfriendRequestReceived: false,\n\t\t\t\tisBlocked: false,\n\t\t\t\tisBlockedBy: false\n\t\t\t};\n\n\t\t\trelationships.forEach((rel) => {\n\t\t\t\tif (rel.userId === userId && rel.targetUserId === targetUserId) {\n\t\t\t\t\t// Current user to target user\n\t\t\t\t\tswitch (rel.type) {\n\t\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t\tstatus.isFollowing = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'friend':\n\t\t\t\t\t\t\tif (rel.status === 'accepted') status.isFriend = true;\n\t\t\t\t\t\t\tif (rel.status === 'pending') status.friendRequestSent = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'block':\n\t\t\t\t\t\t\tstatus.isBlocked = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (rel.userId === targetUserId && rel.targetUserId === userId) {\n\t\t\t\t\t// Target user to current user\n\t\t\t\t\tswitch (rel.type) {\n\t\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t\tstatus.isFollowedBy = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'friend':\n\t\t\t\t\t\t\tif (rel.status === 'accepted') status.isFriend = true;\n\t\t\t\t\t\t\tif (rel.status === 'pending') status.friendRequestReceived = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'block':\n\t\t\t\t\t\t\tstatus.isBlockedBy = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn status;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting relationship status:', error);\n\t\t\tthrow new Error('Failed to get relationship status');\n\t\t}\n\t}\n\n\t/**\n\t * Create notification for user\n\t */\n\tprivate static async createNotification(\n\t\tuserId: string,\n\t\ttype: string,\n\t\tmessage: string,\n\t\tmetadata: any = {}\n\t) {\n\t\ttry {\n\t\t\tawait db.insert(notifications).values({\n\t\t\t\tuserId,\n\t\t\t\ttype,\n\t\t\t\tmessage,\n\t\t\t\tmetadata: JSON.stringify(metadata),\n\t\t\t\tisRead: false,\n\t\t\t\tcreatedAt: new Date()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('Error creating notification:', error);\n\t\t\t// Don't throw - notifications are non-critical\n\t\t}\n\t}\n\n\t/**\n\t * Update follower counts in user stats (can be done async)\n\t */\n\tprivate static async updateFollowerCounts(followerId: string, targetId: string) {\n\t\ttry {\n\t\t\t// This could be implemented as a background job\n\t\t\t// For now, just log the action\n\t\t\tlogger.info(`Follower count update needed: ${followerId} -> ${targetId}`);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error updating follower counts:', error);\n\t\t}\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/share/routes/xShareRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/share/services/xShareService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shop/cosmetics.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { UserId } from '@shared/types/ids';\n/**\n * Cosmetics Routes\n * \n * Enhanced cosmetics management with equipment tracking and vanity analytics\n * Showcases CosmeticsTransformer for role-based cosmetic data exposure\n */\n\nimport { Router } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { isAuthenticated } from '../auth/middleware/auth.middleware';\nimport { logger } from '../../core/logger';\nimport { db } from '@db';\nimport { userInventory, transactions } from '@schema';\nimport { eq, and, inArray } from 'drizzle-orm';\nimport { CosmeticsTransformer } from './transformers/cosmetics.transformer';\nimport { vanitySinkAnalyzer } from './services/vanity-sink.analyzer';\nimport { z } from 'zod';\nimport type { UserId, ItemId } from '@shared/types';\n\nconst router = Router();\n\n// Validation schemas\nconst equipCosmeticSchema = z.object({\n  itemId: z.string(),\n  action: z.enum(['equip', 'unequip'])\n});\n\nconst customizeCosmeticSchema = z.object({\n  itemId: z.string(),\n  customizations: z.record(z.any()),\n  dgtCost: z.number().min(0).optional()\n});\n\n/**\n * GET /api/cosmetics/browse\n * Browse available cosmetics with enhanced social proof\n */\nrouter.get('/browse', async (req, res) => {\n  try {\n    const { type, rarity, page = 1, limit = 20 } = req.query;\n    const requestingUser = userService.getUserFromRequest(req);\n\n    // Mock cosmetics data (in real implementation, this would come from database)\n    const cosmetics = [\n      {\n        id: 'cosmic_frame_001',\n        name: 'Cosmic Nebula Frame',\n        description: 'A shimmering frame with cosmic particle effects',\n        type: 'avatar_frame',\n        rarity: 'legendary',\n        colorHex: '#4338ca',\n        effectType: 'particle',\n        isAnimated: true,\n        isLimited: true,\n        popularityScore: 85,\n        equippedByCount: 1247,\n        tags: ['cosmic', 'particles', 'premium'],\n        createdAt: new Date('2024-01-15'),\n        updatedAt: new Date('2024-01-15'),\n        createdBy: 'admin'\n      },\n      {\n        id: 'golden_username_001',\n        name: 'Golden Radiance',\n        description: 'Luxurious golden username color with subtle glow',\n        type: 'username_color',\n        rarity: 'epic',\n        colorHex: '#fbbf24',\n        effectType: 'glow',\n        isAnimated: false,\n        isLimited: false,\n        popularityScore: 92,\n        equippedByCount: 3421,\n        tags: ['gold', 'luxury', 'glow'],\n        createdAt: new Date('2024-01-10'),\n        updatedAt: new Date('2024-01-10'),\n        createdBy: 'admin'\n      },\n      {\n        id: 'degen_champion_title',\n        name: 'Degen Champion',\n        description: 'Exclusive title for top community contributors',\n        type: 'title',\n        rarity: 'mythic',\n        colorHex: '#ef4444',\n        effectType: 'glow',\n        isAnimated: false,\n        isLimited: true,\n        popularityScore: 98,\n        equippedByCount: 127,\n        tags: ['exclusive', 'champion', 'limited'],\n        createdAt: new Date('2024-01-01'),\n        updatedAt: new Date('2024-01-01'),\n        createdBy: 'admin'\n      }\n    ];\n\n    // Filter cosmetics\n    let filteredCosmetics = cosmetics;\n    \n    if (type && type !== 'all') {\n      filteredCosmetics = filteredCosmetics.filter(c => c.type === type);\n    }\n    \n    if (rarity && rarity !== 'all') {\n      filteredCosmetics = filteredCosmetics.filter(c => c.rarity === rarity);\n    }\n\n    // Pagination\n    const pageNum = parseInt(page as string);\n    const limitNum = parseInt(limit as string);\n    const startIndex = (pageNum - 1) * limitNum;\n    const endIndex = startIndex + limitNum;\n    const paginatedCosmetics = filteredCosmetics.slice(startIndex, endIndex);\n\n    // Transform cosmetics based on user authentication\n    let transformedCosmetics;\n    if (requestingUser) {\n      // Get user inventory for ownership checking\n      const userInventoryData = await db\n        .select()\n        .from(userInventory)\n        .where(eq(userInventory.userId, requestingUser.id));\n\n      transformedCosmetics = paginatedCosmetics.map(cosmetic => \n        CosmeticsTransformer.toOwnedCosmetic(cosmetic, requestingUser, userInventoryData)\n      );\n    } else {\n      transformedCosmetics = paginatedCosmetics.map(cosmetic => \n        CosmeticsTransformer.toPublicCosmetic(cosmetic)\n      );\n    }\n\n    res.json({\n      cosmetics: transformedCosmetics,\n      total: filteredCosmetics.length,\n      page: pageNum,\n      limit: limitNum,\n      totalPages: Math.ceil(filteredCosmetics.length / limitNum),\n      filters: {\n        type: type || 'all',\n        rarity: rarity || 'all'\n      },\n      user: requestingUser ? {\n        isAuthenticated: true,\n        equippedCosmetics: CosmeticsTransformer.getUserEquippedCosmetics(\n          await db.select().from(userInventory).where(and(\n            eq(userInventory.userId, requestingUser.id),\n            eq(userInventory.isEquipped, true)\n          ))\n        )\n      } : { isAuthenticated: false }\n    });\n\n  } catch (error) {\n    logger.error('CosmeticsController', 'Error browsing cosmetics', { error });\n    res.status(500).json({ error: 'Failed to browse cosmetics' });\n  }\n});\n\n/**\n * GET /api/cosmetics/equipped\n * Get user's currently equipped cosmetics\n */\nrouter.get('/equipped', isAuthenticated, async (req, res) => {\n  try {\n    const requestingUser = userService.getUserFromRequest(req);\n    if (!requestingUser?.id) {\n      return res.status(401).json({ error: 'User not authenticated' });\n    }\n\n    // Get equipped cosmetics\n    const equippedItems = await db\n      .select()\n      .from(userInventory)\n      .where(and(\n        eq(userInventory.userId, requestingUser.id),\n        eq(userInventory.isEquipped, true)\n      ));\n\n    // Group by cosmetic type\n    const equippedCosmetics = CosmeticsTransformer.getUserEquippedCosmetics(equippedItems);\n\n    // Get cosmetic details for each equipped item (mock data for now)\n    const cosmeticsWithDetails = Object.entries(equippedCosmetics).map(([type, item]) => ({\n      type,\n      itemId: item.itemId,\n      name: item.name || 'Unknown Item',\n      equippedAt: item.equippedAt,\n      customizations: item.customizations || {}\n    }));\n\n    res.json({\n      equippedCosmetics: cosmeticsWithDetails,\n      totalEquipped: cosmeticsWithDetails.length,\n      availableSlots: {\n        avatar_frame: !equippedCosmetics.avatar_frame,\n        username_color: !equippedCosmetics.username_color,\n        title: !equippedCosmetics.title,\n        badge: !equippedCosmetics.badge,\n        signature_effect: !equippedCosmetics.signature_effect,\n        theme: !equippedCosmetics.theme\n      }\n    });\n\n  } catch (error) {\n    logger.error('CosmeticsController', 'Error getting equipped cosmetics', {\n      error,\n      userId: userService.getUserFromRequest(req)?.id\n    });\n    res.status(500).json({ error: 'Failed to get equipped cosmetics' });\n  }\n});\n\n/**\n * POST /api/cosmetics/equip\n * Equip or unequip a cosmetic item\n */\nrouter.post('/equip', isAuthenticated, async (req, res) => {\n  try {\n    const requestingUser = userService.getUserFromRequest(req);\n    if (!requestingUser?.id) {\n      return res.status(401).json({ error: 'User not authenticated' });\n    }\n\n    const { itemId, action } = equipCosmeticSchema.parse(req.body);\n    const userId = requestingUser.id;\n\n    // Verify user owns the item\n    const ownedItem = await db\n      .select()\n      .from(userInventory)\n      .where(and(\n        eq(userInventory.userId, userId),\n        eq(userInventory.itemId, itemId)\n      ))\n      .limit(1);\n\n    if (ownedItem.length === 0) {\n      return res.status(400).json({ error: 'You do not own this cosmetic item' });\n    }\n\n    const inventoryItem = ownedItem[0];\n\n    if (action === 'equip') {\n      // Check if already equipped\n      if (inventoryItem.isEquipped) {\n        return res.status(400).json({ error: 'Item is already equipped' });\n      }\n\n      // Get user's current inventory for conflict checking\n      const userInventoryData = await db\n        .select()\n        .from(userInventory)\n        .where(eq(userInventory.userId, userId));\n\n      // Mock cosmetic data for validation\n      const cosmeticData = {\n        id: itemId,\n        type: inventoryItem.itemType || 'badge',\n        name: inventoryItem.itemId // Simplified\n      };\n\n      // Validate equipment change\n      const validation = CosmeticsTransformer.validateEquipmentChange(cosmeticData, userInventoryData);\n      \n      if (!validation.canEquip) {\n        return res.status(400).json({ \n          error: 'Cannot equip this item',\n          reason: validation.reason,\n          conflicts: validation.conflicts\n        });\n      }\n\n      // Unequip conflicting items first\n      if (validation.conflicts.length > 0) {\n        await db\n          .update(userInventory)\n          .set({ isEquipped: false, equippedAt: null })\n          .where(and(\n            eq(userInventory.userId, userId),\n            inArray(userInventory.itemId, validation.conflicts)\n          ));\n      }\n\n      // Equip the item\n      await db\n        .update(userInventory)\n        .set({ isEquipped: true, equippedAt: new Date() })\n        .where(and(\n          eq(userInventory.userId, userId),\n          eq(userInventory.itemId, itemId)\n        ));\n\n      logger.info('CosmeticsController', 'Cosmetic equipped', {\n        userId,\n        itemId,\n        conflicts: validation.conflicts\n      });\n\n      res.json({\n        success: true,\n        message: 'Cosmetic equipped successfully',\n        itemId,\n        action: 'equipped',\n        unequippedConflicts: validation.conflicts\n      });\n\n    } else { // unequip\n      if (!inventoryItem.isEquipped) {\n        return res.status(400).json({ error: 'Item is not currently equipped' });\n      }\n\n      // Unequip the item\n      await db\n        .update(userInventory)\n        .set({ isEquipped: false, equippedAt: null })\n        .where(and(\n          eq(userInventory.userId, userId),\n          eq(userInventory.itemId, itemId)\n        ));\n\n      logger.info('CosmeticsController', 'Cosmetic unequipped', {\n        userId,\n        itemId\n      });\n\n      res.json({\n        success: true,\n        message: 'Cosmetic unequipped successfully',\n        itemId,\n        action: 'unequipped'\n      });\n    }\n\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return res.status(400).json({ \n        error: 'Invalid request', \n        details: error.errors \n      });\n    }\n\n    logger.error('CosmeticsController', 'Error equipping/unequipping cosmetic', {\n      error,\n      userId: userService.getUserFromRequest(req)?.id\n    });\n    res.status(500).json({ error: 'Failed to update cosmetic equipment' });\n  }\n});\n\n/**\n * POST /api/cosmetics/customize\n * Customize a cosmetic item (may cost DGT for premium customizations)\n */\nrouter.post('/customize', isAuthenticated, async (req, res) => {\n  try {\n    const requestingUser = userService.getUserFromRequest(req);\n    if (!requestingUser?.id) {\n      return res.status(401).json({ error: 'User not authenticated' });\n    }\n\n    const { itemId, customizations, dgtCost } = customizeCosmeticSchema.parse(req.body);\n    const userId = requestingUser.id;\n\n    // Verify user owns the item\n    const ownedItem = await db\n      .select()\n      .from(userInventory)\n      .where(and(\n        eq(userInventory.userId, userId),\n        eq(userInventory.itemId, itemId)\n      ))\n      .limit(1);\n\n    if (ownedItem.length === 0) {\n      return res.status(400).json({ error: 'You do not own this cosmetic item' });\n    }\n\n    // Handle DGT cost for premium customizations\n    if (dgtCost && dgtCost > 0) {\n      // Track as vanity sink event\n      await vanitySinkAnalyzer.trackCosmeticUpgrade({\n        userId: userId as UserId,\n        itemId: itemId as ItemId,\n        dgtAmount: dgtCost as any,\n        upgradeType: 'color_change', // This would be determined by customizations\n        metadata: {\n          customizations,\n          originalItemType: ownedItem[0].itemType\n        }\n      });\n    }\n\n    // Update item customizations\n    await db\n      .update(userInventory)\n      .set({ \n        customizations: customizations,\n        updatedAt: new Date()\n      })\n      .where(and(\n        eq(userInventory.userId, userId),\n        eq(userInventory.itemId, itemId)\n      ));\n\n    logger.info('CosmeticsController', 'Cosmetic customized', {\n      userId,\n      itemId,\n      dgtCost,\n      customizations: Object.keys(customizations)\n    });\n\n    res.json({\n      success: true,\n      message: 'Cosmetic customized successfully',\n      itemId,\n      customizations,\n      dgtCost: dgtCost || 0,\n      vanityMetrics: dgtCost ? {\n        dgtBurned: dgtCost,\n        burnType: 'customization',\n        contributesToDeflation: true\n      } : undefined\n    });\n\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return res.status(400).json({ \n        error: 'Invalid request', \n        details: error.errors \n      });\n    }\n\n    logger.error('CosmeticsController', 'Error customizing cosmetic', {\n      error,\n      userId: userService.getUserFromRequest(req)?.id\n    });\n    res.status(500).json({ error: 'Failed to customize cosmetic' });\n  }\n});\n\n/**\n * GET /api/cosmetics/preview/:itemIds\n * Generate equipment preview with multiple cosmetics\n */\nrouter.get('/preview/:itemIds', async (req, res) => {\n  try {\n    const { itemIds } = req.params;\n    const requestingUser = userService.getUserFromRequest(req);\n\n    if (!itemIds) {\n      return res.status(400).json({ error: 'Item IDs required' });\n    }\n\n    const itemIdArray = itemIds.split(',');\n\n    // Mock cosmetic data for preview generation\n    const mockCosmetics = itemIdArray.map(id => ({\n      id,\n      name: `Item ${id}`,\n      type: 'badge', // This would be looked up from database\n      previewUrl: `/api/cosmetics/preview/item/${id}`\n    }));\n\n    // Generate composite preview\n    const preview = CosmeticsTransformer.generateEquipmentPreview(\n      mockCosmetics[0], // Target cosmetic\n      mockCosmetics.slice(1) // Current equipment\n    );\n\n    res.json({\n      previewUrl: preview.previewUrl,\n      equipmentSet: preview.equipmentSet,\n      user: requestingUser ? {\n        isAuthenticated: true,\n        canPreview: true\n      } : { isAuthenticated: false, canPreview: true }\n    });\n\n  } catch (error) {\n    logger.error('CosmeticsController', 'Error generating cosmetic preview', {\n      error,\n      itemIds: req.params.itemIds\n    });\n    res.status(500).json({ error: 'Failed to generate preview' });\n  }\n});\n\n/**\n * GET /api/cosmetics/analytics\n * Get cosmetics usage analytics (admin only)\n */\nrouter.get('/analytics', isAuthenticated, async (req, res) => {\n  try {\n    const requestingUser = userService.getUserFromRequest(req);\n    \n    // Basic role check (in real implementation, this would be more sophisticated)\n    if (requestingUser?.role !== 'admin') {\n      return res.status(403).json({ error: 'Admin access required' });\n    }\n\n    // Get real-time vanity sink metrics\n    const vanitySinkMetrics = await vanitySinkAnalyzer.getRealTimeMetrics();\n\n    // Mock additional cosmetics analytics\n    const cosmeticsAnalytics = {\n      totalCosmetics: 156,\n      totalOwned: 2847,\n      totalEquipped: 1923,\n      averageEquipmentRate: 67.5,\n      topCategories: [\n        { category: 'avatar_frame', popularity: 89, equipped: 1247 },\n        { category: 'username_color', popularity: 92, equipped: 887 },\n        { category: 'title', popularity: 78, equipped: 234 },\n        { category: 'badge', popularity: 85, equipped: 445 }\n      ],\n      recentTrends: {\n        equipmentGrowth: 12.3, // % increase in equipment rate\n        newOwnersGrowth: 8.7,   // % increase in cosmetic owners\n        customizationRevenue: 15420 // DGT spent on customizations\n      }\n    };\n\n    res.json({\n      vanitySink: vanitySinkMetrics,\n      cosmetics: cosmeticsAnalytics,\n      generatedAt: new Date().toISOString()\n    });\n\n  } catch (error) {\n    logger.error('CosmeticsController', 'Error getting cosmetics analytics', {\n      error,\n      userId: userService.getUserFromRequest(req)?.id\n    });\n    res.status(500).json({ error: 'Failed to get analytics' });\n  }\n});\n\nexport default router;","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shop/services/vanity-sink.analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userInventory' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'products' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'totalSupply' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":486,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":486,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":503,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":503,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":531,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":531,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'startDate' is defined but never used.","line":531,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":531,"endColumn":72},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'endDate' is defined but never used.","line":531,"column":74,"nodeType":"Identifier","messageId":"unusedVar","endLine":531,"endColumn":87}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { UserId } from '@shared/types/ids';\n/**\n * Vanity Sink Analyzer\n * \n * Tracks DGT burning through vanity purchases for economic analysis\n * Provides real-time metrics on the vanity economy and token deflation\n * Essential for understanding user spending behavior and economic health\n */\n\nimport { logger } from '@server/src/core/logger';\nimport { db } from '@db';\nimport { transactions, userInventory, products } from '@schema';\nimport { eq, and, gte, lte, desc, sql, inArray } from 'drizzle-orm';\nimport type { \n  VanitySinkMetrics, \n  VanitySinkEvent,\n  DgtAmount,\n  UsdAmount,\n  UserId,\n  ItemId,\n  OrderId,\n  ItemCategory\n} from '@shared/types';\n\nexport interface VanitySinkConfig {\n  trackingEnabled: boolean;\n  realTimeUpdates: boolean;\n  retentionDays: number;\n  alertThresholds: {\n    dailyBurnSpike: number;\n    userSpendingLimit: number;\n    deflationRate: number;\n  };\n}\n\nexport class VanitySinkAnalyzer {\n  private config: VanitySinkConfig;\n  private metrics: Map<string, VanitySinkMetrics> = new Map();\n  private realTimeEvents: VanitySinkEvent[] = [];\n  \n  constructor(config: Partial<VanitySinkConfig> = {}) {\n    this.config = {\n      trackingEnabled: true,\n      realTimeUpdates: true,\n      retentionDays: 90,\n      alertThresholds: {\n        dailyBurnSpike: 50000, // DGT\n        userSpendingLimit: 10000, // DGT per day\n        deflationRate: 5 // % of supply\n      },\n      ...config\n    };\n  }\n\n  // ==========================================\n  // BURN EVENT TRACKING\n  // ==========================================\n\n  /**\n   * Track a DGT burn event from vanity purchase\n   */\n  async trackBurn(event: Omit<VanitySinkEvent, 'id' | 'timestamp'>): Promise<void> {\n    if (!this.config.trackingEnabled) return;\n\n    const burnEvent: VanitySinkEvent = {\n      ...event,\n      id: this.generateEventId(),\n      timestamp: new Date().toISOString()\n    };\n\n    try {\n      // Store event for real-time tracking\n      if (this.config.realTimeUpdates) {\n        this.realTimeEvents.push(burnEvent);\n        this.pruneRealTimeEvents();\n      }\n\n      // Log the burn event\n      await this.logBurnEvent(burnEvent);\n\n      // Check for alerts\n      await this.checkBurnAlerts(burnEvent);\n\n      logger.info('VanitySinkAnalyzer', 'DGT burn tracked', {\n        eventId: burnEvent.id,\n        userId: burnEvent.userId,\n        dgtBurned: burnEvent.dgtBurned,\n        burnType: burnEvent.burnType,\n        source: burnEvent.source\n      });\n\n    } catch (error) {\n      logger.error('VanitySinkAnalyzer', 'Failed to track burn event', {\n        event: burnEvent,\n        error: error.message\n      });\n    }\n  }\n\n  /**\n   * Track shop purchase as vanity sink event\n   */\n  async trackShopPurchase(params: {\n    userId: UserId;\n    orderId: OrderId;\n    itemId: ItemId;\n    dgtAmount: DgtAmount;\n    itemCategory: ItemCategory;\n    metadata?: Record<string, any>;\n  }): Promise<void> {\n    await this.trackBurn({\n      userId: params.userId,\n      itemId: params.itemId,\n      orderId: params.orderId,\n      dgtBurned: params.dgtAmount,\n      burnType: 'purchase',\n      source: 'shop',\n      userLevel: await this.getUserLevel(params.userId),\n      userLifetimeSpent: await this.getUserLifetimeSpent(params.userId),\n      metadata: {\n        ...params.metadata,\n        itemCategory: params.itemCategory,\n        burnReason: 'cosmetic_purchase'\n      }\n    });\n  }\n\n  /**\n   * Track cosmetic upgrade/customization as burn event\n   */\n  async trackCosmeticUpgrade(params: {\n    userId: UserId;\n    itemId: ItemId;\n    dgtAmount: DgtAmount;\n    upgradeType: 'color_change' | 'animation_unlock' | 'effect_enhance';\n    metadata?: Record<string, any>;\n  }): Promise<void> {\n    await this.trackBurn({\n      userId: params.userId,\n      itemId: params.itemId,\n      orderId: `upgrade_${Date.now()}` as OrderId,\n      dgtBurned: params.dgtAmount,\n      burnType: 'customization',\n      source: 'game',\n      userLevel: await this.getUserLevel(params.userId),\n      userLifetimeSpent: await this.getUserLifetimeSpent(params.userId),\n      metadata: {\n        ...params.metadata,\n        upgradeType: params.upgradeType,\n        burnReason: 'cosmetic_upgrade'\n      }\n    });\n  }\n\n  // ==========================================\n  // METRICS GENERATION\n  // ==========================================\n\n  /**\n   * Generate comprehensive vanity sink metrics for a time period\n   */\n  async generateSinkReport(params: {\n    startDate: Date;\n    endDate: Date;\n    includeProjections?: boolean;\n  }): Promise<VanitySinkMetrics> {\n    try {\n      logger.info('VanitySinkAnalyzer', 'Generating vanity sink report', {\n        startDate: params.startDate.toISOString(),\n        endDate: params.endDate.toISOString()\n      });\n\n      // Get burn transactions in period\n      const burnTransactions = await this.getBurnTransactions(params.startDate, params.endDate);\n      \n      // Calculate core metrics\n      const totalDgtBurned = this.calculateTotalBurned(burnTransactions);\n      const totalTransactions = burnTransactions.length;\n      const averageBurnPerTransaction = totalTransactions > 0 \n        ? (totalDgtBurned / totalTransactions) as DgtAmount\n        : 0 as DgtAmount;\n\n      // Generate category breakdown\n      const burnByCategory = await this.generateCategoryBreakdown(burnTransactions);\n\n      // Get top spenders\n      const topSpenders = await this.getTopSpenders(params.startDate, params.endDate);\n\n      // Calculate trends\n      const burnTrend = await this.calculateBurnTrend(params.startDate, params.endDate);\n      const projectedMonthlyBurn = params.includeProjections \n        ? await this.projectMonthlyBurn(burnTransactions)\n        : 0 as DgtAmount;\n\n      // Economic impact calculations\n      const burnUsdValue = this.calculateUsdValue(totalDgtBurned);\n      const economicMultiplier = await this.calculateEconomicMultiplier(totalDgtBurned);\n      const deflationaryPressure = await this.calculateDeflationaryPressure(totalDgtBurned);\n\n      const metrics: VanitySinkMetrics = {\n        periodStart: params.startDate.toISOString(),\n        periodEnd: params.endDate.toISOString(),\n        totalDgtBurned,\n        totalTransactions,\n        averageBurnPerTransaction,\n        burnByCategory,\n        topSpenders,\n        burnTrend,\n        projectedMonthlyBurn,\n        burnVelocity: this.calculateBurnVelocity(totalDgtBurned, params.startDate, params.endDate),\n        burnUsdValue,\n        economicMultiplier,\n        deflationaryPressure\n      };\n\n      // Cache metrics\n      const cacheKey = `${params.startDate.toISOString()}_${params.endDate.toISOString()}`;\n      this.metrics.set(cacheKey, metrics);\n\n      logger.info('VanitySinkAnalyzer', 'Vanity sink report generated', {\n        totalBurned: totalDgtBurned,\n        totalTransactions,\n        periodDays: (params.endDate.getTime() - params.startDate.getTime()) / (1000 * 60 * 60 * 24)\n      });\n\n      return metrics;\n\n    } catch (error) {\n      logger.error('VanitySinkAnalyzer', 'Error generating sink report', {\n        error: error.message,\n        startDate: params.startDate,\n        endDate: params.endDate\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get real-time burn metrics for dashboard\n   */\n  async getRealTimeMetrics(): Promise<{\n    last24h: Partial<VanitySinkMetrics>;\n    last7d: Partial<VanitySinkMetrics>;\n    currentMonth: Partial<VanitySinkMetrics>;\n    liveEvents: VanitySinkEvent[];\n  }> {\n    const now = new Date();\n    \n    const [last24h, last7d, currentMonth] = await Promise.all([\n      this.generateSinkReport({\n        startDate: new Date(now.getTime() - 24 * 60 * 60 * 1000),\n        endDate: now\n      }),\n      this.generateSinkReport({\n        startDate: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000),\n        endDate: now\n      }),\n      this.generateSinkReport({\n        startDate: new Date(now.getFullYear(), now.getMonth(), 1),\n        endDate: now,\n        includeProjections: true\n      })\n    ]);\n\n    return {\n      last24h,\n      last7d,\n      currentMonth,\n      liveEvents: this.realTimeEvents.slice(-50) // Last 50 events\n    };\n  }\n\n  /**\n   * Get top spending users for vanity items\n   */\n  async getTopSpenders(startDate: Date, endDate: Date, limit: number = 10): Promise<Array<{\n    userId: UserId;\n    username: string;\n    totalBurned: DgtAmount;\n    transactionCount: number;\n    favoriteCategory: ItemCategory;\n  }>> {\n    try {\n      // Query top spenders from transactions\n      const spenders = await db\n        .select({\n          userId: transactions.fromUserId,\n          totalBurned: sql<number>`SUM(${transactions.amount})`,\n          transactionCount: sql<number>`COUNT(*)`,\n        })\n        .from(transactions)\n        .where(\n          and(\n            eq(transactions.type, 'SHOP_PURCHASE'),\n            gte(transactions.createdAt, startDate),\n            lte(transactions.createdAt, endDate)\n          )\n        )\n        .groupBy(transactions.fromUserId)\n        .orderBy(desc(sql<number>`SUM(${transactions.amount})`))\n        .limit(limit);\n\n      // Enhance with user data and favorite categories\n      const enhancedSpenders = await Promise.all(\n        spenders.map(async (spender) => {\n          const [userData, favoriteCategory] = await Promise.all([\n            this.getUserData(spender.userId as UserId),\n            this.getUserFavoriteCategory(spender.userId as UserId, startDate, endDate)\n          ]);\n\n          return {\n            userId: spender.userId as UserId,\n            username: userData?.username || 'Unknown',\n            totalBurned: spender.totalBurned as DgtAmount,\n            transactionCount: spender.transactionCount,\n            favoriteCategory: favoriteCategory as ItemCategory\n          };\n        })\n      );\n\n      return enhancedSpenders;\n\n    } catch (error) {\n      logger.error('VanitySinkAnalyzer', 'Error getting top spenders', { error });\n      return [];\n    }\n  }\n\n  // ==========================================\n  // PRIVATE HELPER METHODS\n  // ==========================================\n\n  private generateEventId(): string {\n    return `burn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private pruneRealTimeEvents(): void {\n    // Keep only last 1000 events to prevent memory issues\n    if (this.realTimeEvents.length > 1000) {\n      this.realTimeEvents = this.realTimeEvents.slice(-1000);\n    }\n  }\n\n  private async logBurnEvent(event: VanitySinkEvent): Promise<void> {\n    // In a real implementation, this would store to a dedicated burn events table\n    // For now, we'll use the existing transactions table metadata\n    logger.debug('VanitySinkAnalyzer', 'Burn event logged', {\n      eventId: event.id,\n      burnType: event.burnType,\n      dgtAmount: event.dgtBurned\n    });\n  }\n\n  private async checkBurnAlerts(event: VanitySinkEvent): Promise<void> {\n    // Check daily user spending\n    const dailySpending = await this.getUserDailySpending(event.userId);\n    if (dailySpending > this.config.alertThresholds.userSpendingLimit) {\n      logger.warn('VanitySinkAnalyzer', 'High user spending detected', {\n        userId: event.userId,\n        dailySpending,\n        threshold: this.config.alertThresholds.userSpendingLimit\n      });\n    }\n\n    // Check for burn spikes\n    const dailyBurn = await this.getDailyBurnTotal();\n    if (dailyBurn > this.config.alertThresholds.dailyBurnSpike) {\n      logger.warn('VanitySinkAnalyzer', 'Daily burn spike detected', {\n        dailyBurn,\n        threshold: this.config.alertThresholds.dailyBurnSpike\n      });\n    }\n  }\n\n  private async getBurnTransactions(startDate: Date, endDate: Date): Promise<any[]> {\n    return await db\n      .select()\n      .from(transactions)\n      .where(\n        and(\n          eq(transactions.type, 'SHOP_PURCHASE'),\n          gte(transactions.createdAt, startDate),\n          lte(transactions.createdAt, endDate)\n        )\n      )\n      .orderBy(desc(transactions.createdAt));\n  }\n\n  private calculateTotalBurned(transactions: any[]): DgtAmount {\n    return transactions.reduce((total, tx) => total + (tx.amount || 0), 0) as DgtAmount;\n  }\n\n  private async generateCategoryBreakdown(burnTransactions: any[]): Promise<any> {\n    const breakdown: Record<string, any> = {};\n\n    // Group transactions by item category\n    for (const tx of burnTransactions) {\n      const category = tx.metadata?.itemCategory || 'unknown';\n      \n      if (!breakdown[category]) {\n        breakdown[category] = {\n          amount: 0 as DgtAmount,\n          transactions: 0,\n          topItems: []\n        };\n      }\n\n      breakdown[category].amount += tx.amount || 0;\n      breakdown[category].transactions += 1;\n    }\n\n    // Get top items for each category\n    for (const category of Object.keys(breakdown)) {\n      breakdown[category].topItems = await this.getTopItemsForCategory(category, burnTransactions);\n    }\n\n    return breakdown;\n  }\n\n  private async getTopItemsForCategory(category: string, transactions: any[]): Promise<any[]> {\n    const itemTotals = new Map<string, { itemId: string; name: string; burned: number }>();\n\n    for (const tx of transactions) {\n      if (tx.metadata?.itemCategory === category && tx.metadata?.itemId) {\n        const itemId = tx.metadata.itemId;\n        const existing = itemTotals.get(itemId) || { itemId, name: 'Unknown', burned: 0 };\n        existing.burned += tx.amount || 0;\n        itemTotals.set(itemId, existing);\n      }\n    }\n\n    return Array.from(itemTotals.values())\n      .sort((a, b) => b.burned - a.burned)\n      .slice(0, 5)\n      .map(item => ({\n        itemId: item.itemId as ItemId,\n        name: item.name,\n        burned: item.burned as DgtAmount\n      }));\n  }\n\n  private async calculateBurnTrend(startDate: Date, endDate: Date): Promise<'increasing' | 'stable' | 'decreasing'> {\n    // Compare current period with previous period of same length\n    const periodLength = endDate.getTime() - startDate.getTime();\n    const previousStart = new Date(startDate.getTime() - periodLength);\n    \n    const [currentBurn, previousBurn] = await Promise.all([\n      this.getBurnTransactions(startDate, endDate),\n      this.getBurnTransactions(previousStart, startDate)\n    ]);\n\n    const currentTotal = this.calculateTotalBurned(currentBurn);\n    const previousTotal = this.calculateTotalBurned(previousBurn);\n\n    if (currentTotal > previousTotal * 1.1) return 'increasing';\n    if (currentTotal < previousTotal * 0.9) return 'decreasing';\n    return 'stable';\n  }\n\n  private async projectMonthlyBurn(recentTransactions: any[]): Promise<DgtAmount> {\n    if (recentTransactions.length === 0) return 0 as DgtAmount;\n\n    // Simple projection based on recent velocity\n    const totalBurned = this.calculateTotalBurned(recentTransactions);\n    const oldestTx = recentTransactions[recentTransactions.length - 1];\n    const newestTx = recentTransactions[0];\n    \n    const periodDays = (new Date(newestTx.createdAt).getTime() - new Date(oldestTx.createdAt).getTime()) / (1000 * 60 * 60 * 24);\n    const dailyBurnRate = periodDays > 0 ? totalBurned / periodDays : 0;\n    \n    return (dailyBurnRate * 30) as DgtAmount; // 30-day projection\n  }\n\n  private calculateBurnVelocity(totalBurned: DgtAmount, startDate: Date, endDate: Date): number {\n    const periodDays = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);\n    return periodDays > 0 ? totalBurned / periodDays : 0;\n  }\n\n  private calculateUsdValue(dgtAmount: DgtAmount): UsdAmount {\n    const rate = parseFloat(process.env.DGT_USD_RATE || '0.01');\n    return (dgtAmount * rate) as UsdAmount;\n  }\n\n  private async calculateEconomicMultiplier(burnedAmount: DgtAmount): Promise<number> {\n    // Economic multiplier effect of DGT burning on circulation\n    const totalSupply = await this.getTotalDgtSupply();\n    const circulatingSupply = await this.getCirculatingDgtSupply();\n    \n    if (circulatingSupply === 0) return 1.0;\n    \n    // Simple multiplier calculation - reducing supply increases value pressure\n    const burnRatio = burnedAmount / circulatingSupply;\n    return 1 + (burnRatio * 2); // Simplified multiplier\n  }\n\n  private async calculateDeflationaryPressure(burnedAmount: DgtAmount): Promise<number> {\n    const circulatingSupply = await this.getCirculatingDgtSupply();\n    if (circulatingSupply === 0) return 0;\n    \n    return (burnedAmount / circulatingSupply) * 100; // Percentage\n  }\n\n  private async getUserLevel(userId: UserId): Promise<number> {\n    // This would integrate with the user service\n    return 1; // Placeholder\n  }\n\n  private async getUserLifetimeSpent(userId: UserId): Promise<DgtAmount> {\n    try {\n      const result = await db\n        .select({ total: sql<number>`SUM(${transactions.amount})` })\n        .from(transactions)\n        .where(\n          and(\n            eq(transactions.fromUserId, userId),\n            eq(transactions.type, 'SHOP_PURCHASE')\n          )\n        );\n\n      return (result[0]?.total || 0) as DgtAmount;\n    } catch (error) {\n      return 0 as DgtAmount;\n    }\n  }\n\n  private async getUserData(userId: UserId): Promise<{ username: string } | null> {\n    // This would integrate with the user service\n    return { username: `User_${userId}` }; // Placeholder\n  }\n\n  private async getUserFavoriteCategory(userId: UserId, startDate: Date, endDate: Date): Promise<string> {\n    // This would analyze user's purchase patterns\n    return 'avatar_frame'; // Placeholder\n  }\n\n  private async getUserDailySpending(userId: UserId): Promise<number> {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);\n\n    try {\n      const result = await db\n        .select({ total: sql<number>`SUM(${transactions.amount})` })\n        .from(transactions)\n        .where(\n          and(\n            eq(transactions.fromUserId, userId),\n            eq(transactions.type, 'SHOP_PURCHASE'),\n            gte(transactions.createdAt, today),\n            lte(transactions.createdAt, tomorrow)\n          )\n        );\n\n      return result[0]?.total || 0;\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  private async getDailyBurnTotal(): Promise<number> {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);\n\n    try {\n      const result = await db\n        .select({ total: sql<number>`SUM(${transactions.amount})` })\n        .from(transactions)\n        .where(\n          and(\n            eq(transactions.type, 'SHOP_PURCHASE'),\n            gte(transactions.createdAt, today),\n            lte(transactions.createdAt, tomorrow)\n          )\n        );\n\n      return result[0]?.total || 0;\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  private async getTotalDgtSupply(): Promise<number> {\n    // This would integrate with token economics service\n    return 1000000000; // Placeholder - 1B total supply\n  }\n\n  private async getCirculatingDgtSupply(): Promise<number> {\n    // This would integrate with token economics service\n    return 500000000; // Placeholder - 500M circulating\n  }\n}\n\n// Export singleton instance\nexport const vanitySinkAnalyzer = new VanitySinkAnalyzer();","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shop/shop.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'products' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":6,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":7,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'or' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":7,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":7,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":7,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'walletConfig' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":22},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":46,"column":5,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":46,"endColumn":92}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { UserId } from '@shared/types/ids';\nimport { userService } from '@server/src/core/services/user.service';\nimport { Router } from 'express';\nimport { shopItems } from '../../../utils/shop-utils';\nimport { db } from '@db';\nimport { products, userInventory, transactions } from '@schema';\nimport { eq, isNull, or, and, gte, lte } from 'drizzle-orm';\nimport { dgtService } from '../wallet/dgt.service';\nimport { isAuthenticated } from '../auth/middleware/auth.middleware';\nimport { walletConfig } from '@shared/wallet.config';\nimport { logger } from '../../core/logger';\nimport { z } from 'zod';\nimport { EconomyTransformer } from '../economy/transformers/economy.transformer';\nimport { ShopTransformer } from './transformers/shop.transformer';\nimport { vanitySinkAnalyzer } from './services/vanity-sink.analyzer';\nimport type { DgtAmount, UserId, ItemId, OrderId } from '@shared/types';\nimport { EntityId } from \"@shared/types\";\n\nconst router = Router();\n\n// GET /api/shop/items\nrouter.get('/items', async (req, res) => {\n\ttry {\n\t\tconst { category, sort = 'popular', page = 1, limit = 20 } = req.query;\n\t\tconst requestingUser = userService.getUserFromRequest(req);\n\n\t\tlet items = shopItems;\n\n\t\t// Filter by category if specified\n\t\tif (category && category !== 'all') {\n\t\t\titems = items.filter(item => item.category === category);\n\t\t}\n\n\t\t// Sort items\n\t\tswitch (sort) {\n\t\t\tcase 'price_low':\n\t\t\t\titems.sort((a, b) => (a.priceDGT || 0) - (b.priceDGT || 0));\n\t\t\t\tbreak;\n\t\t\tcase 'price_high':\n\t\t\t\titems.sort((a, b) => (b.priceDGT || 0) - (a.priceDGT || 0));\n\t\t\t\tbreak;\n\t\t\tcase 'newest':\n\t\t\t\titems.sort((a, b) => new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime());\n\t\t\t\tbreak;\n\t\t\tcase 'rarity':\n\t\t\t\tconst rarityOrder = { 'mythic': 5, 'legendary': 4, 'epic': 3, 'rare': 2, 'common': 1 };\n\t\t\t\titems.sort((a, b) => (rarityOrder[b.rarity] || 0) - (rarityOrder[a.rarity] || 0));\n\t\t\t\tbreak;\n\t\t\tcase 'popular':\n\t\t\tdefault:\n\t\t\t\titems.sort((a, b) => (b.popularity || 0) - (a.popularity || 0));\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Pagination\n\t\tconst pageNum = parseInt(page as string);\n\t\tconst limitNum = parseInt(limit as string);\n\t\tconst startIndex = (pageNum - 1) * limitNum;\n\t\tconst endIndex = startIndex + limitNum;\n\t\tconst paginatedItems = items.slice(startIndex, endIndex);\n\n\t\t// Transform items based on user authentication status\n\t\tlet transformedItems;\n\t\tif (requestingUser) {\n\t\t\t// Get user inventory for ownership checking\n\t\t\tconst userInventoryData = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userInventory)\n\t\t\t\t.where(eq(userInventory.userId, requestingUser.id));\n\n\t\t\ttransformedItems = paginatedItems.map(item => {\n\t\t\t\t// Convert mock item to database-like format for transformer\n\t\t\t\tconst dbItem = {\n\t\t\t\t\t...item,\n\t\t\t\t\tprice: item.priceDGT,\n\t\t\t\t\tisAvailable: true,\n\t\t\t\t\tisActive: true,\n\t\t\t\t\tpopularityScore: item.popularity || 0\n\t\t\t\t};\n\t\t\t\treturn ShopTransformer.toAuthenticatedShopItem(dbItem, requestingUser, userInventoryData);\n\t\t\t});\n\t\t} else {\n\t\t\ttransformedItems = paginatedItems.map(item => {\n\t\t\t\tconst dbItem = {\n\t\t\t\t\t...item,\n\t\t\t\t\tprice: item.priceDGT,\n\t\t\t\t\tisAvailable: true,\n\t\t\t\t\tisActive: true,\n\t\t\t\t\tpopularityScore: item.popularity || 0\n\t\t\t\t};\n\t\t\t\treturn ShopTransformer.toPublicShopItem(dbItem);\n\t\t\t});\n\t\t}\n\n\t\tres.json({\n\t\t\titems: transformedItems,\n\t\t\ttotal: items.length,\n\t\t\tpage: pageNum,\n\t\t\tlimit: limitNum,\n\t\t\ttotalPages: Math.ceil(items.length / limitNum),\n\t\t\tfilters: {\n\t\t\t\tcategory: category || 'all',\n\t\t\t\tsort: sort\n\t\t\t},\n\t\t\tuser: requestingUser ? {\n\t\t\t\tisAuthenticated: true,\n\t\t\t\tdgtBalance: requestingUser.dgtBalance || 0\n\t\t\t} : { isAuthenticated: false }\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('ShopController', 'Error fetching shop items', { error });\n\t\tres.status(500).json({ error: 'Failed to fetch shop items' });\n\t}\n});\n\n// GET /api/shop/items/:id\nrouter.get('/items/:id', async (req, res) => {\n\ttry {\n\t\tconst { id } = req.params;\n\t\tconst requestingUser = userService.getUserFromRequest(req);\n\n\t\t// Find in mock data for now\n\t\tconst item = shopItems.find((item) => item.id === id);\n\n\t\tif (!item) {\n\t\t\treturn res.status(404).json({ error: 'Item not found' });\n\t\t}\n\n\t\t// Transform item based on user context\n\t\tlet transformedItem;\n\t\tif (requestingUser) {\n\t\t\t// Get user inventory for ownership checking\n\t\t\tconst userInventoryData = await db\n\t\t\t\t.select()\n\t\t\t\t.from(userInventory)\n\t\t\t\t.where(eq(userInventory.userId, requestingUser.id));\n\n\t\t\tconst dbItem = {\n\t\t\t\t...item,\n\t\t\t\tprice: item.priceDGT,\n\t\t\t\tisAvailable: true,\n\t\t\t\tisActive: true,\n\t\t\t\tpopularityScore: item.popularity || 0\n\t\t\t};\n\t\t\ttransformedItem = ShopTransformer.toAuthenticatedShopItem(dbItem, requestingUser, userInventoryData);\n\t\t} else {\n\t\t\tconst dbItem = {\n\t\t\t\t...item,\n\t\t\t\tprice: item.priceDGT,\n\t\t\t\tisAvailable: true,\n\t\t\t\tisActive: true,\n\t\t\t\tpopularityScore: item.popularity || 0\n\t\t\t};\n\t\t\ttransformedItem = ShopTransformer.toPublicShopItem(dbItem);\n\t\t}\n\n\t\tres.json({\n\t\t\titem: transformedItem,\n\t\t\tuser: requestingUser ? {\n\t\t\t\tisAuthenticated: true,\n\t\t\t\tdgtBalance: requestingUser.dgtBalance || 0\n\t\t\t} : { isAuthenticated: false }\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('ShopController', 'Error fetching shop item', { error, itemId: req.params.id });\n\t\tres.status(500).json({ error: 'Failed to fetch shop item' });\n\t}\n});\n\n// Purchase validation schema\nconst purchaseSchema = z.object({\n\titemId: z.string(),\n\tpaymentMethod: z.enum(['DGT', 'USDT'])\n});\n\n// POST /api/shop/purchase\nrouter.post('/purchase', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tif (!userService.getUserFromRequest(req)) {\n\t\t\treturn res.status(401).json({ error: 'User not authenticated' });\n\t\t}\n\n\t\tconst userId = (userService.getUserFromRequest(req) as { id: EntityId }).id;\n\t\tconst { itemId, paymentMethod } = purchaseSchema.parse(req.body);\n\n\t\t// Find the item in mock data (TODO: replace with database query)\n\t\tconst item = shopItems.find((item) => item.id === itemId);\n\t\tif (!item) {\n\t\t\treturn res.status(404).json({ error: 'Item not found' });\n\t\t}\n\n\t\t// Check if user already owns this item\n\t\tconst existingItem = await db\n\t\t\t.select()\n\t\t\t.from(userInventory)\n\t\t\t.where(and(eq(userInventory.userId, userId), eq(userInventory.itemId, itemId)))\n\t\t\t.limit(1);\n\n\t\tif (existingItem.length > 0) {\n\t\t\treturn res.status(400).json({ error: 'You already own this item' });\n\t\t}\n\n\t\t// Get price based on payment method\n\t\tlet price: number;\n\t\tlet currency: string;\n\n\t\tif (paymentMethod === 'DGT') {\n\t\t\tif (!item.priceDGT) {\n\t\t\t\treturn res.status(400).json({ error: 'Item not available for DGT purchase' });\n\t\t\t}\n\t\t\tprice = item.priceDGT;\n\t\t\tcurrency = 'DGT';\n\t\t} else {\n\t\t\tif (!item.priceUSDT) {\n\t\t\t\treturn res.status(400).json({ error: 'Item not available for USDT purchase' });\n\t\t\t}\n\t\t\tprice = item.priceUSDT;\n\t\t\tcurrency = 'USDT';\n\t\t}\n\n\t\t// For DGT payments, check balance and process\n\t\tif (paymentMethod === 'DGT') {\n\t\t\tconst dgtAmountRequired = BigInt(Math.floor(price * 100000000)); // Convert to smallest unit\n\t\t\tconst userBalance = await dgtService.getUserBalance(userId);\n\n\t\t\tif (userBalance < dgtAmountRequired) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\terror: 'Insufficient DGT balance',\n\t\t\t\t\trequired: price,\n\t\t\t\t\tavailable: Number(userBalance) / 100000000\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Create transaction metadata for audit trail\n\t\t\tconst transactionMetadata = {\n\t\t\t\titemId,\n\t\t\t\titemName: item.name,\n\t\t\t\tcategory: item.category,\n\t\t\t\tprice: price as DgtAmount,\n\t\t\t\tsource: 'shop_purchase',\n\t\t\t\tipAddress: req.ip,\n\t\t\t\tuserAgent: req.get('User-Agent')\n\t\t\t};\n\n\t\t\t// Deduct DGT with enhanced audit trail\n\t\t\tconst transactionResult = await dgtService.deductDGT(\n\t\t\t\tuserId,\n\t\t\t\tdgtAmountRequired,\n\t\t\t\t'SHOP_PURCHASE',\n\t\t\t\t`Purchased ${item.name}`,\n\t\t\t\ttransactionMetadata\n\t\t\t);\n\n\t\t\t// Add item to user's inventory\n\t\t\tconst [inventoryItem] = await db\n\t\t\t\t.insert(userInventory)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\titemId,\n\t\t\t\t\titemType: item.category,\n\t\t\t\t\tquantity: 1,\n\t\t\t\t\tacquiredAt: new Date(),\n\t\t\t\t\tpurchasePrice: Math.floor(price * 100), // Store in cents\n\t\t\t\t\tpurchaseCurrency: currency\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\tlogger.info('ShopController', 'Item purchased with DGT', {\n\t\t\t\tuserId,\n\t\t\t\titemId,\n\t\t\t\titemName: item.name,\n\t\t\t\tprice,\n\t\t\t\tcurrency,\n\t\t\t\ttransactionId: transactionResult?.transactionId\n\t\t\t});\n\n\t\t\t// Track vanity sink event for analytics\n\t\t\tawait vanitySinkAnalyzer.trackShopPurchase({\n\t\t\t\tuserId: userId as UserId,\n\t\t\t\torderId: `shop_${Date.now()}` as OrderId,\n\t\t\t\titemId: itemId as ItemId,\n\t\t\t\tdgtAmount: price as DgtAmount,\n\t\t\t\titemCategory: item.category as any,\n\t\t\t\tmetadata: {\n\t\t\t\t\tpurchaseSource: 'web_shop',\n\t\t\t\t\titemRarity: item.rarity,\n\t\t\t\t\tcurrency\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Transform response using both EconomyTransformer and ShopTransformer\n\t\t\tconst transformedTransaction = transactionResult?.transaction \n\t\t\t\t? EconomyTransformer.toAuthenticatedTransaction(transactionResult.transaction, { id: userId })\n\t\t\t\t: undefined;\n\n\t\t\tconst requestingUser = userService.getUserFromRequest(req);\n\t\t\tconst dbItem = {\n\t\t\t\t...item,\n\t\t\t\tprice: item.priceDGT,\n\t\t\t\tisAvailable: true,\n\t\t\t\tisActive: true\n\t\t\t};\n\t\t\tconst transformedItem = ShopTransformer.toAuthenticatedShopItem(\n\t\t\t\tdbItem, \n\t\t\t\t{ ...requestingUser, dgtBalance: (requestingUser?.dgtBalance || 0) - price },\n\t\t\t\t[{ ...inventoryItem, itemId, name: item.name, category: item.category }]\n\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Successfully purchased ${item.name}`,\n\t\t\t\titem: transformedItem,\n\t\t\t\tinventoryId: inventoryItem.id,\n\t\t\t\ttransaction: transformedTransaction,\n\t\t\t\tvanityMetrics: {\n\t\t\t\t\tdgtBurned: price as DgtAmount,\n\t\t\t\t\tcategory: item.category,\n\t\t\t\t\tcontributesToDeflation: true\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\t// TODO: Implement USDT payments via CCPayment\n\t\t\treturn res.status(501).json({\n\t\t\t\terror: 'USDT payments not yet implemented',\n\t\t\t\tmessage: 'Please use DGT for now'\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn res.status(400).json({ error: 'Invalid request', details: error.errors });\n\t\t}\n\t\tlogger.error('ShopController', 'Error processing purchase', {\n\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\tuserId: userService.getUserFromRequest(req)?.id\n\t\t});\n\t\tres.status(500).json({ error: 'Failed to process purchase' });\n\t}\n});\n\n// GET /api/shop/inventory - Get user's purchased items with enhanced transformations\nrouter.get('/inventory', isAuthenticated, async (req, res) => {\n\ttry {\n\t\tconst requestingUser = userService.getUserFromRequest(req);\n\t\tif (!requestingUser) {\n\t\t\treturn res.status(401).json({ error: 'User not authenticated' });\n\t\t}\n\n\t\tconst userId = requestingUser.id;\n\t\tconst { category, equipped } = req.query;\n\n\t\t// Get user's inventory\n\t\tlet inventoryQuery = db.select().from(userInventory).where(eq(userInventory.userId, userId));\n\t\t\n\t\t// Filter by equipped status if specified\n\t\tif (equipped === 'true') {\n\t\t\tinventoryQuery = inventoryQuery.where(eq(userInventory.isEquipped, true));\n\t\t} else if (equipped === 'false') {\n\t\t\tinventoryQuery = inventoryQuery.where(eq(userInventory.isEquipped, false));\n\t\t}\n\n\t\tconst inventory = await inventoryQuery;\n\n\t\t// Transform inventory items using ShopTransformer\n\t\tconst transformedInventory = inventory\n\t\t\t.map((inv) => {\n\t\t\t\tconst item = shopItems.find((item) => item.id === inv.itemId);\n\t\t\t\tif (!item) return null;\n\n\t\t\t\t// Create enhanced inventory item data\n\t\t\t\tconst inventoryItem = {\n\t\t\t\t\t...inv,\n\t\t\t\t\tname: item.name,\n\t\t\t\t\tcategory: item.category,\n\t\t\t\t\trarity: item.rarity,\n\t\t\t\t\ttype: item.category,\n\t\t\t\t\tpurchasePrice: inv.purchasePrice ? inv.purchasePrice / 100 : undefined // Convert from cents\n\t\t\t\t};\n\n\t\t\t\treturn ShopTransformer.toUserInventoryItem(inventoryItem);\n\t\t\t})\n\t\t\t.filter(item => item !== null); // Filter out items that no longer exist\n\n\t\t// Filter by category if specified\n\t\tlet filteredInventory = transformedInventory;\n\t\tif (category && category !== 'all') {\n\t\t\tfilteredInventory = transformedInventory.filter(item => item.category === category);\n\t\t}\n\n\t\t// Group by category for better organization\n\t\tconst inventoryByCategory = filteredInventory.reduce((acc, item) => {\n\t\t\tif (!acc[item.category]) {\n\t\t\t\tacc[item.category] = [];\n\t\t\t}\n\t\t\tacc[item.category].push(item);\n\t\t\treturn acc;\n\t\t}, {} as Record<string, any[]>);\n\n\t\t// Calculate stats\n\t\tconst stats = {\n\t\t\ttotalItems: filteredInventory.length,\n\t\t\tequippedItems: filteredInventory.filter(item => item.isEquipped).length,\n\t\t\ttotalValue: filteredInventory.reduce((sum, item) => sum + (item.purchasePrice || 0), 0),\n\t\t\trareItems: filteredInventory.filter(item => ['epic', 'legendary', 'mythic'].includes(item.rarity)).length\n\t\t};\n\n\t\tres.json({\n\t\t\tinventory: filteredInventory,\n\t\t\tinventoryByCategory,\n\t\t\tstats,\n\t\t\tfilters: {\n\t\t\t\tcategory: category || 'all',\n\t\t\t\tequipped: equipped || 'all'\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('ShopController', 'Error getting inventory', {\n\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\tuserId: userService.getUserFromRequest(req)?.id\n\t\t});\n\t\tres.status(500).json({ error: 'Failed to get inventory' });\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shop/transformers/cosmetics.transformer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'user' is defined but never used.","line":322,"column":61,"nodeType":"Identifier","messageId":"unusedVar","endLine":322,"endColumn":70}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cosmetics Transformer\n * \n * Specialized transformer for cosmetic items with equipment tracking\n * Handles avatar frames, username colors, titles, badges, effects, and themes\n * Follows security-first pattern with role-based data exposure\n */\n\nimport type { UserId } from '@shared/types/ids';\nimport type { PublicCosmetic, OwnedCosmetic, AdminCosmetic } from '../types';\n\nimport type { \n  ItemId,\n  DgtAmount, \n  ItemRarity\n} from '@shared/types';\n\nimport { ShopTransformer } from './shop.transformer';\n\nexport class CosmeticsTransformer {\n  \n  // ==========================================\n  // COSMETIC ITEM TRANSFORMERS\n  // ==========================================\n\n  /**\n   * Transform cosmetic for public view (browsing, social proof)\n   * Shows basic cosmetic info without user-specific data\n   */\n  static toPublicCosmetic(dbCosmetic: any): PublicCosmetic {\n    return {\n      id: dbCosmetic.id as ItemId,\n      name: dbCosmetic.name,\n      description: dbCosmetic.description || '',\n      type: this.normalizeCosmeticType(dbCosmetic.type),\n      rarity: dbCosmetic.rarity as ItemRarity,\n      \n      // Visual data\n      previewUrl: this.generatePreviewUrl(dbCosmetic),\n      thumbnailUrl: this.generateThumbnailUrl(dbCosmetic),\n      colorHex: dbCosmetic.colorHex || this.extractColorFromMetadata(dbCosmetic),\n      effectType: this.determineEffectType(dbCosmetic),\n      \n      // Metadata\n      tags: dbCosmetic.tags || [],\n      isAnimated: this.isAnimatedCosmetic(dbCosmetic),\n      isLimited: dbCosmetic.isLimited === true,\n      \n      // Social proof metrics\n      popularityScore: this.calculateCosmeticPopularity(dbCosmetic),\n      equippedByCount: dbCosmetic.equippedByCount || 0\n    };\n  }\n\n  /**\n   * Transform cosmetic for owned view (equipment management)\n   * Adds ownership status and equipment permissions\n   */\n  static toOwnedCosmetic(dbCosmetic: any, requestingUser: any, userInventory?: any[]): OwnedCosmetic {\n    const publicData = this.toPublicCosmetic(dbCosmetic);\n    \n    // Check user ownership and equipment status\n    const inventoryItem = this.findUserInventoryItem(dbCosmetic.id, userInventory);\n    const isOwned = !!inventoryItem;\n    const isEquipped = inventoryItem?.isEquipped === true;\n    \n    return {\n      ...publicData,\n      \n      // Ownership status\n      isOwned,\n      isEquipped,\n      acquiredAt: inventoryItem?.acquiredAt,\n      \n      // Equipment permissions\n      canEquip: this.canUserEquipCosmetic(dbCosmetic, requestingUser, inventoryItem),\n      canUnequip: this.canUserUnequipCosmetic(dbCosmetic, requestingUser, inventoryItem),\n      conflictsWith: this.getCosmeticConflicts(dbCosmetic, userInventory),\n      \n      // Purchase info (if not owned)\n      shopItemId: isOwned ? undefined : this.getShopItemId(dbCosmetic),\n      price: isOwned ? undefined : this.getCosmeticPrice(dbCosmetic),\n      canAfford: isOwned ? undefined : this.canUserAffordCosmetic(dbCosmetic, requestingUser),\n      \n      // Customization options\n      customizations: this.getCosmeticCustomizations(dbCosmetic, requestingUser)\n    };\n  }\n\n  /**\n   * Transform cosmetic for admin view\n   * Includes comprehensive analytics and management data\n   */\n  static toAdminCosmetic(dbCosmetic: any, analytics?: any): AdminCosmetic {\n    // Get owned data with admin permissions\n    const ownedData = this.toOwnedCosmetic(dbCosmetic, { role: 'admin', id: 'admin' });\n    \n    return {\n      ...ownedData,\n      \n      // Usage analytics\n      totalOwners: analytics?.totalOwners || 0,\n      totalEquipped: analytics?.totalEquipped || 0,\n      equipmentRate: this.calculateEquipmentRate(analytics),\n      \n      // Revenue data\n      totalRevenue: this.sanitizeDgtAmount(analytics?.totalRevenue || 0),\n      totalSales: analytics?.totalSales || 0,\n      averageSalePrice: this.calculateAverageSalePrice(analytics),\n      \n      // Content management\n      createdAt: dbCosmetic.createdAt.toISOString(),\n      updatedAt: dbCosmetic.updatedAt.toISOString(),\n      createdBy: dbCosmetic.createdBy as UserId,\n      \n      // File management\n      assetUrl: dbCosmetic.assetUrl || '',\n      assetSize: dbCosmetic.assetSize || 0,\n      assetType: dbCosmetic.assetType || 'image/png',\n      \n      // Status\n      isActive: dbCosmetic.isActive !== false,\n      moderationStatus: dbCosmetic.moderationStatus || 'approved',\n      \n      // Performance metrics\n      engagementScore: this.calculateEngagementScore(analytics),\n      retentionRate: this.calculateRetentionRate(analytics),\n      \n      // System data\n      version: dbCosmetic.version || 1,\n      compatibilityFlags: dbCosmetic.compatibilityFlags || []\n    };\n  }\n\n  // ==========================================\n  // COSMETIC-SPECIFIC UTILITY METHODS\n  // ==========================================\n\n  private static normalizeCosmeticType(type: string): 'avatar_frame' | 'username_color' | 'title' | 'badge' | 'signature_effect' | 'emoji_pack' | 'theme' {\n    const typeMap = {\n      'frame': 'avatar_frame',\n      'avatar_frame': 'avatar_frame',\n      'color': 'username_color',\n      'username_color': 'username_color',\n      'title': 'title',\n      'badge': 'badge',\n      'effect': 'signature_effect',\n      'signature_effect': 'signature_effect',\n      'emoji': 'emoji_pack',\n      'emoji_pack': 'emoji_pack',\n      'theme': 'theme'\n    };\n    return typeMap[type as keyof typeof typeMap] || 'badge';\n  }\n\n  private static generatePreviewUrl(dbCosmetic: any): string {\n    // Generate preview URLs based on cosmetic type\n    const baseUrl = '/api/cosmetics/preview';\n    const type = this.normalizeCosmeticType(dbCosmetic.type);\n    \n    switch (type) {\n      case 'avatar_frame':\n        return `${baseUrl}/frame/${dbCosmetic.id}`;\n      case 'username_color':\n        return `${baseUrl}/color/${dbCosmetic.id}`;\n      case 'title':\n        return `${baseUrl}/title/${dbCosmetic.id}`;\n      case 'badge':\n        return `${baseUrl}/badge/${dbCosmetic.id}`;\n      case 'signature_effect':\n        return `${baseUrl}/signature/${dbCosmetic.id}`;\n      case 'emoji_pack':\n        return `${baseUrl}/emoji/${dbCosmetic.id}`;\n      case 'theme':\n        return `${baseUrl}/theme/${dbCosmetic.id}`;\n      default:\n        return `${baseUrl}/generic/${dbCosmetic.id}`;\n    }\n  }\n\n  private static generateThumbnailUrl(dbCosmetic: any): string | undefined {\n    if (!dbCosmetic.thumbnailUrl && !dbCosmetic.id) return undefined;\n    return dbCosmetic.thumbnailUrl || `/api/cosmetics/thumbnail/${dbCosmetic.id}`;\n  }\n\n  private static extractColorFromMetadata(dbCosmetic: any): string | undefined {\n    // Extract primary color from cosmetic metadata\n    if (dbCosmetic.metadata?.primaryColor) return dbCosmetic.metadata.primaryColor;\n    if (dbCosmetic.metadata?.colors?.primary) return dbCosmetic.metadata.colors.primary;\n    \n    // Type-specific color extraction\n    const type = this.normalizeCosmeticType(dbCosmetic.type);\n    if (type === 'username_color' && dbCosmetic.metadata?.hex) {\n      return dbCosmetic.metadata.hex;\n    }\n    \n    return undefined;\n  }\n\n  private static determineEffectType(dbCosmetic: any): 'glow' | 'particle' | 'animation' | 'gradient' | undefined {\n    if (dbCosmetic.effectType) return dbCosmetic.effectType;\n    \n    // Infer from metadata\n    if (dbCosmetic.metadata?.hasGlow) return 'glow';\n    if (dbCosmetic.metadata?.hasParticles) return 'particle';\n    if (dbCosmetic.metadata?.isAnimated) return 'animation';\n    if (dbCosmetic.metadata?.hasGradient) return 'gradient';\n    \n    // Infer from cosmetic type\n    const type = this.normalizeCosmeticType(dbCosmetic.type);\n    if (type === 'signature_effect') return 'particle';\n    if (type === 'avatar_frame' && dbCosmetic.rarity !== 'common') return 'glow';\n    \n    return undefined;\n  }\n\n  private static isAnimatedCosmetic(dbCosmetic: any): boolean {\n    if (dbCosmetic.isAnimated !== undefined) return dbCosmetic.isAnimated;\n    if (dbCosmetic.metadata?.isAnimated) return true;\n    if (dbCosmetic.assetType?.includes('gif')) return true;\n    if (dbCosmetic.effectType === 'animation') return true;\n    return false;\n  }\n\n  private static calculateCosmeticPopularity(dbCosmetic: any): number {\n    // Different weighting for cosmetics vs general shop items\n    const equipped = dbCosmetic.equippedByCount || 0;\n    const owned = dbCosmetic.ownedByCount || 0;\n    const views = dbCosmetic.viewCount || 0;\n    \n    // Cosmetics are about being equipped and shown off\n    const equipScore = Math.min(equipped / 100, 0.5) * 100;\n    const ownedScore = Math.min(owned / 200, 0.3) * 100;\n    const viewScore = Math.min(views / 1000, 0.2) * 100;\n    \n    return Math.round(equipScore + ownedScore + viewScore);\n  }\n\n  private static findUserInventoryItem(cosmeticId: any, userInventory?: any[]): any | undefined {\n    if (!userInventory) return undefined;\n    return userInventory.find(item => item.itemId === cosmeticId);\n  }\n\n  private static canUserEquipCosmetic(dbCosmetic: any, user: any, inventoryItem?: any): boolean {\n    // Must own the cosmetic\n    if (!inventoryItem) return false;\n    \n    // Already equipped\n    if (inventoryItem.isEquipped) return false;\n    \n    // Check level requirements\n    if (dbCosmetic.requiredLevel && user.level < dbCosmetic.requiredLevel) return false;\n    \n    // Check for equipment conflicts\n    const type = this.normalizeCosmeticType(dbCosmetic.type);\n    if (this.hasEquipmentConflict(type, user.currentEquipment)) return false;\n    \n    return true;\n  }\n\n  private static canUserUnequipCosmetic(dbCosmetic: any, user: any, inventoryItem?: any): boolean {\n    // Must be equipped to unequip\n    return inventoryItem?.isEquipped === true;\n  }\n\n  private static getCosmeticConflicts(dbCosmetic: any, userInventory?: any[]): ItemId[] {\n    const type = this.normalizeCosmeticType(dbCosmetic.type);\n    const conflicts: ItemId[] = [];\n    \n    if (!userInventory) return conflicts;\n    \n    // Find conflicting equipped items\n    for (const item of userInventory) {\n      if (item.isEquipped && this.typesConflict(type, this.normalizeCosmeticType(item.type))) {\n        conflicts.push(item.itemId as ItemId);\n      }\n    }\n    \n    return conflicts;\n  }\n\n  private static typesConflict(type1: string, type2: string): boolean {\n    // Define which cosmetic types conflict with each other\n    const conflicts = {\n      'avatar_frame': ['avatar_frame'], // Only one frame at a time\n      'username_color': ['username_color'], // Only one color at a time\n      'title': ['title'], // Only one title at a time\n      'signature_effect': ['signature_effect'], // Only one signature effect\n      'theme': ['theme'] // Only one theme at a time\n    };\n    \n    return conflicts[type1 as keyof typeof conflicts]?.includes(type2) || false;\n  }\n\n  private static hasEquipmentConflict(type: string, currentEquipment: any): boolean {\n    if (!currentEquipment) return false;\n    \n    // Check if user already has this type equipped\n    return currentEquipment[type] !== undefined;\n  }\n\n  private static getShopItemId(dbCosmetic: any): ItemId | undefined {\n    // In a real system, cosmetics might be linked to shop items\n    return dbCosmetic.shopItemId as ItemId || undefined;\n  }\n\n  private static getCosmeticPrice(dbCosmetic: any): DgtAmount | undefined {\n    // Get price from linked shop item or cosmetic metadata\n    if (dbCosmetic.price) return this.sanitizeDgtAmount(dbCosmetic.price);\n    if (dbCosmetic.shopItem?.price) return this.sanitizeDgtAmount(dbCosmetic.shopItem.price);\n    return undefined;\n  }\n\n  private static canUserAffordCosmetic(dbCosmetic: any, user: any): boolean | undefined {\n    const price = this.getCosmeticPrice(dbCosmetic);\n    if (!price) return undefined;\n    \n    const userBalance = this.sanitizeDgtAmount(user.dgtBalance || 0);\n    return userBalance >= price;\n  }\n\n  private static getCosmeticCustomizations(dbCosmetic: any, user: any): any | undefined {\n    const type = this.normalizeCosmeticType(dbCosmetic.type);\n    \n    // Return type-specific customization options\n    switch (type) {\n      case 'username_color':\n        return {\n          colorOptions: dbCosmetic.metadata?.availableColors || [dbCosmetic.colorHex],\n          gradientOptions: dbCosmetic.metadata?.gradientOptions\n        };\n      \n      case 'avatar_frame':\n        return {\n          sizeOptions: ['small', 'medium', 'large'],\n          animationSpeed: dbCosmetic.isAnimated ? 1.0 : undefined\n        };\n      \n      case 'signature_effect':\n        return {\n          intensityOptions: ['low', 'medium', 'high'],\n          colorOptions: dbCosmetic.metadata?.effectColors\n        };\n      \n      default:\n        return undefined;\n    }\n  }\n\n  private static calculateEquipmentRate(analytics: any): number {\n    if (!analytics?.totalOwners || analytics.totalOwners === 0) return 0;\n    return Math.round((analytics.totalEquipped / analytics.totalOwners) * 100 * 100) / 100;\n  }\n\n  private static calculateEngagementScore(analytics: any): number {\n    // Complex engagement calculation for cosmetics\n    const equipmentRate = this.calculateEquipmentRate(analytics);\n    const retentionRate = this.calculateRetentionRate(analytics);\n    const popularityScore = analytics?.popularityScore || 0;\n    \n    // Weighted average\n    return Math.round((equipmentRate * 0.4 + retentionRate * 0.4 + popularityScore * 0.2));\n  }\n\n  private static calculateRetentionRate(analytics: any): number {\n    // Percentage of users who keep cosmetic equipped after 7 days\n    if (!analytics?.retentionData) return 0;\n    return Math.round(analytics.retentionData.sevenDayRetention * 100) / 100;\n  }\n\n  private static sanitizeDgtAmount(amount: any): DgtAmount {\n    const parsed = parseFloat(amount?.toString() || '0');\n    return (isNaN(parsed) ? 0 : Math.max(0, parsed)) as DgtAmount;\n  }\n\n  private static calculateAverageSalePrice(analytics: any): DgtAmount {\n    if (!analytics?.totalSales || analytics.totalSales === 0) return 0 as DgtAmount;\n    return this.sanitizeDgtAmount(analytics.totalRevenue / analytics.totalSales);\n  }\n\n  // ==========================================\n  // EQUIPMENT MANAGEMENT UTILITIES\n  // ==========================================\n\n  /**\n   * Get user's currently equipped cosmetics by type\n   */\n  static getUserEquippedCosmetics(userInventory: any[]): Record<string, any> {\n    const equipped: Record<string, any> = {};\n    \n    for (const item of userInventory) {\n      if (item.isEquipped) {\n        const type = this.normalizeCosmeticType(item.type);\n        equipped[type] = item;\n      }\n    }\n    \n    return equipped;\n  }\n\n  /**\n   * Validate equipment change for conflicts\n   */\n  static validateEquipmentChange(\n    cosmeticToEquip: any, \n    userInventory: any[]\n  ): { canEquip: boolean; conflicts: ItemId[]; reason?: string } {\n    const type = this.normalizeCosmeticType(cosmeticToEquip.type);\n    const equipped = this.getUserEquippedCosmetics(userInventory);\n    const conflicts: ItemId[] = [];\n    \n    // Check for type conflicts\n    if (equipped[type]) {\n      conflicts.push(equipped[type].itemId as ItemId);\n    }\n    \n    // Special conflict rules (e.g., certain combinations don't work)\n    // This would be expanded based on game design requirements\n    \n    return {\n      canEquip: conflicts.length === 0,\n      conflicts,\n      reason: conflicts.length > 0 ? `Conflicts with equipped ${type}` : undefined\n    };\n  }\n\n  /**\n   * Generate cosmetic preview with current user equipment\n   */\n  static generateEquipmentPreview(\n    targetCosmetic: any,\n    currentEquipment: any[]\n  ): {\n    previewUrl: string;\n    equipmentSet: Array<{ type: string; itemId: ItemId; name: string; }>;\n  } {\n    const type = this.normalizeCosmeticType(targetCosmetic.type);\n    const equipmentSet = currentEquipment\n      .filter(item => item.isEquipped && this.normalizeCosmeticType(item.type) !== type)\n      .map(item => ({\n        type: this.normalizeCosmeticType(item.type),\n        itemId: item.itemId as ItemId,\n        name: item.name\n      }));\n    \n    // Add the target cosmetic\n    equipmentSet.push({\n      type,\n      itemId: targetCosmetic.id as ItemId,\n      name: targetCosmetic.name\n    });\n    \n    // Generate preview URL with equipment set\n    const equipmentIds = equipmentSet.map(e => e.itemId).join(',');\n    const previewUrl = `/api/cosmetics/preview/composite/${equipmentIds}`;\n    \n    return { previewUrl, equipmentSet };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shop/transformers/shop.transformer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createHash' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dbItem' is defined but never used.","line":452,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":452,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'user' is defined but never used.","line":452,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":452,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dbItem' is defined but never used.","line":457,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":457,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userInventory' is defined but never used.","line":457,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":457,"endColumn":75},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'analytics' is defined but never used.","line":497,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":497,"endColumn":57}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Shop Transformer\n * \n * Security-first data transformation for shop and cosmetics\n * Implements three-tier access: Public → Authenticated → Admin\n * Follows established patterns from Users, Forums, and Economy domains\n */\n\nimport type { UserId } from '@shared/types/ids';\nimport type { PublicShopItem, AuthenticatedShopItem, AdminShopItem, UserOrder, AdminOrder, UserInventoryItem, AdminInventoryItem, VanitySinkMetrics, VanitySinkEvent } from '../types';\n\nimport type { \n  ItemId,\n  DgtAmount, \n  UsdAmount,\n  ItemRarity,\n  ItemCategory,\n  OrderId,\n  InventoryItemId\n} from '@shared/types';\n\nimport { UserTransformer } from '../../users/transformers/user.transformer';\nimport { createHash } from 'crypto';\n\nexport class ShopTransformer {\n  \n  // ==========================================\n  // SHOP ITEM TRANSFORMERS\n  // ==========================================\n\n  /**\n   * Transform shop item for public view (catalog browsing)\n   * Shows basic product information without user-specific data\n   */\n  static toPublicShopItem(dbItem: any): PublicShopItem {\n    return {\n      id: dbItem.id as ItemId,\n      name: dbItem.name,\n      description: dbItem.description || '',\n      category: dbItem.category as ItemCategory,\n      rarity: dbItem.rarity as ItemRarity,\n      \n      // Pricing information\n      price: this.sanitizeDgtAmount(dbItem.price),\n      originalPrice: dbItem.originalPrice ? this.sanitizeDgtAmount(dbItem.originalPrice) : undefined,\n      discountPercentage: this.calculateDiscountPercentage(dbItem.price, dbItem.originalPrice),\n      \n      // Visual metadata\n      previewUrl: dbItem.previewUrl || this.generatePreviewUrl(dbItem),\n      thumbnailUrl: dbItem.thumbnailUrl || this.generateThumbnailUrl(dbItem),\n      rarityColor: this.getRarityColor(dbItem.rarity),\n      rarityGlow: this.getRarityGlow(dbItem.rarity),\n      \n      // Availability\n      isAvailable: this.isItemAvailable(dbItem),\n      isLimited: dbItem.isLimited === true,\n      stockRemaining: dbItem.isLimited ? (dbItem.stockRemaining || 0) : undefined,\n      releaseDate: dbItem.releaseDate?.toISOString(),\n      expiryDate: dbItem.expiryDate?.toISOString(),\n      \n      // Public metrics\n      popularityScore: this.calculatePopularityScore(dbItem),\n      tags: dbItem.tags || []\n    };\n  }\n\n  /**\n   * Transform shop item for authenticated users\n   * Adds purchase permissions and user-specific context\n   */\n  static toAuthenticatedShopItem(dbItem: any, requestingUser: any, userInventory?: any[]): AuthenticatedShopItem {\n    const publicData = this.toPublicShopItem(dbItem);\n    \n    // Calculate user-specific purchase context\n    const userDgtBalance = this.sanitizeDgtAmount(requestingUser.dgtBalance || 0);\n    const requiredDgt = publicData.price;\n    const canAfford = userDgtBalance >= requiredDgt;\n    const alreadyOwned = this.checkUserOwnership(dbItem.id, userInventory);\n    const ownedQuantity = this.getUserItemQuantity(dbItem.id, userInventory);\n    \n    return {\n      ...publicData,\n      \n      // User-specific purchase data\n      canPurchase: this.canUserPurchase(dbItem, requestingUser, alreadyOwned),\n      canAfford,\n      alreadyOwned,\n      \n      // Purchase context\n      userDgtBalance,\n      requiredDgt,\n      dgtShortfall: canAfford ? undefined : (requiredDgt - userDgtBalance) as DgtAmount,\n      \n      // Ownership tracking\n      ownedQuantity,\n      maxQuantity: dbItem.maxQuantityPerUser || undefined,\n      \n      // Enhanced user experience\n      similarItems: this.getSimilarItems(dbItem, requestingUser),\n      bundleOpportunities: this.getBundleOpportunities(dbItem, userInventory),\n      \n      // Preview permissions\n      canPreview: this.canUserPreview(dbItem, requestingUser),\n      previewUrl: this.getEnhancedPreviewUrl(dbItem, requestingUser)\n    };\n  }\n\n  /**\n   * Transform shop item for admin view\n   * Includes comprehensive analytics and management data\n   */\n  static toAdminShopItem(dbItem: any, analytics?: any): AdminShopItem {\n    // Get authenticated data with admin permissions\n    const authenticatedData = this.toAuthenticatedShopItem(dbItem, { role: 'admin', id: 'admin' });\n    \n    return {\n      ...authenticatedData,\n      \n      // Financial metrics\n      totalRevenue: this.sanitizeDgtAmount(analytics?.totalRevenue || 0),\n      totalSales: analytics?.totalSales || 0,\n      revenueUsd: this.calculateUsdValue(analytics?.totalRevenue || 0),\n      averageSalePrice: this.calculateAverageSalePrice(analytics),\n      \n      // Analytics\n      viewCount: analytics?.viewCount || 0,\n      conversionRate: this.calculateConversionRate(analytics),\n      popularityTrend: this.determinePopularityTrend(analytics),\n      lastPurchaseAt: analytics?.lastPurchaseAt?.toISOString(),\n      \n      // Inventory management\n      totalStock: dbItem.totalStock || undefined,\n      stockAlerts: this.shouldShowStockAlerts(dbItem),\n      replenishmentNeeded: this.isReplenishmentNeeded(dbItem),\n      \n      // Content management\n      createdAt: dbItem.createdAt.toISOString(),\n      updatedAt: dbItem.updatedAt.toISOString(),\n      createdBy: dbItem.createdBy as UserId,\n      lastModifiedBy: dbItem.lastModifiedBy as UserId || undefined,\n      \n      // Status tracking\n      isActive: dbItem.isActive !== false,\n      isFeatured: dbItem.isFeatured === true,\n      isPromoted: dbItem.isPromoted === true,\n      moderationStatus: dbItem.moderationStatus || 'approved',\n      \n      // Performance insights\n      topBuyers: this.getTopBuyers(analytics),\n      \n      // A/B testing\n      experimentId: dbItem.experimentId || undefined,\n      conversionVariant: dbItem.conversionVariant || undefined\n    };\n  }\n\n  // ==========================================\n  // ORDER TRANSFORMERS\n  // ==========================================\n\n  /**\n   * Transform order for user view\n   */\n  static toUserOrder(dbOrder: any, orderItems?: any[]): UserOrder {\n    return {\n      id: dbOrder.id as OrderId,\n      userId: dbOrder.userId as UserId,\n      \n      // Order details\n      status: dbOrder.status,\n      totalAmount: this.sanitizeDgtAmount(dbOrder.totalAmount),\n      totalUsd: dbOrder.totalUsd ? this.sanitizeUsdAmount(dbOrder.totalUsd) : undefined,\n      paymentMethod: dbOrder.paymentMethod || 'dgt',\n      \n      // Items\n      items: (orderItems || []).map(item => ({\n        itemId: item.itemId as ItemId,\n        name: item.name,\n        quantity: item.quantity,\n        unitPrice: this.sanitizeDgtAmount(item.unitPrice),\n        totalPrice: this.sanitizeDgtAmount(item.totalPrice)\n      })),\n      \n      // Timestamps\n      createdAt: dbOrder.createdAt.toISOString(),\n      completedAt: dbOrder.completedAt?.toISOString(),\n      \n      // Transaction tracking\n      transactionId: dbOrder.transactionId || undefined,\n      \n      // Refund permissions\n      canRefund: this.canOrderBeRefunded(dbOrder),\n      refundDeadline: this.getRefundDeadline(dbOrder)?.toISOString()\n    };\n  }\n\n  /**\n   * Transform order for admin view\n   */\n  static toAdminOrder(dbOrder: any, user?: any, analytics?: any): AdminOrder {\n    const userData = this.toUserOrder(dbOrder);\n    \n    return {\n      ...userData,\n      \n      // User context\n      user: {\n        id: user?.id as UserId,\n        username: user?.username,\n        email: this.anonymizeEmail(user?.email),\n        totalLifetimeValue: this.sanitizeDgtAmount(user?.totalLifetimeValue || 0),\n        orderCount: user?.orderCount || 0\n      },\n      \n      // Financial analysis\n      revenueImpact: this.sanitizeDgtAmount(analytics?.revenueImpact || dbOrder.totalAmount),\n      marginAnalysis: analytics?.marginAnalysis ? {\n        cost: this.sanitizeDgtAmount(analytics.marginAnalysis.cost),\n        margin: this.sanitizeDgtAmount(analytics.marginAnalysis.margin),\n        marginPercent: analytics.marginAnalysis.marginPercent\n      } : undefined,\n      \n      // System data (anonymized for GDPR)\n      ipAddress: this.anonymizeIP(dbOrder.ipAddress),\n      userAgent: dbOrder.userAgent,\n      processingTime: dbOrder.processingTime,\n      \n      // Marketing analytics\n      conversionSource: dbOrder.conversionSource,\n      campaignId: dbOrder.campaignId,\n      referrer: dbOrder.referrer,\n      \n      // Risk management\n      riskScore: this.calculateOrderRiskScore(dbOrder),\n      flaggedForReview: dbOrder.flaggedForReview === true,\n      fraudScore: analytics?.fraudScore,\n      \n      // Administration\n      notes: dbOrder.notes,\n      lastReviewedBy: dbOrder.lastReviewedBy as UserId || undefined,\n      lastReviewedAt: dbOrder.lastReviewedAt?.toISOString()\n    };\n  }\n\n  // ==========================================\n  // INVENTORY TRANSFORMERS\n  // ==========================================\n\n  /**\n   * Transform inventory item for user view\n   */\n  static toUserInventoryItem(dbInventoryItem: any): UserInventoryItem {\n    return {\n      id: dbInventoryItem.id as InventoryItemId,\n      itemId: dbInventoryItem.itemId as ItemId,\n      userId: dbInventoryItem.userId as UserId,\n      \n      // Item details\n      name: dbInventoryItem.name,\n      category: dbInventoryItem.category as ItemCategory,\n      rarity: dbInventoryItem.rarity as ItemRarity,\n      type: dbInventoryItem.type,\n      \n      // Ownership data\n      quantity: dbInventoryItem.quantity || 1,\n      acquiredAt: dbInventoryItem.acquiredAt.toISOString(),\n      purchasePrice: dbInventoryItem.purchasePrice ? this.sanitizeDgtAmount(dbInventoryItem.purchasePrice) : undefined,\n      source: dbInventoryItem.source || 'purchase',\n      \n      // Equipment status\n      isEquipped: dbInventoryItem.isEquipped === true,\n      equippedAt: dbInventoryItem.equippedAt?.toISOString(),\n      equipSlot: dbInventoryItem.equipSlot,\n      \n      // Item state\n      condition: dbInventoryItem.condition || 'new',\n      usageCount: dbInventoryItem.usageCount || 0,\n      \n      // Metadata\n      metadata: dbInventoryItem.metadata || {},\n      customizations: dbInventoryItem.customizations || {}\n    };\n  }\n\n  /**\n   * Transform inventory item for admin view\n   */\n  static toAdminInventoryItem(dbInventoryItem: any, user?: any, analytics?: any): AdminInventoryItem {\n    const userItem = this.toUserInventoryItem(dbInventoryItem);\n    \n    return {\n      ...userItem,\n      \n      // User context\n      user: {\n        id: user?.id as UserId,\n        username: user?.username,\n        level: user?.level || 1,\n        totalSpent: this.sanitizeDgtAmount(user?.totalSpent || 0)\n      },\n      \n      // Analytics\n      lastUsed: analytics?.lastUsed?.toISOString(),\n      usageFrequency: analytics?.usageFrequency || 0,\n      \n      // Value tracking\n      currentMarketValue: analytics?.currentMarketValue ? this.sanitizeDgtAmount(analytics.currentMarketValue) : undefined,\n      valueAppreciation: analytics?.valueAppreciation,\n      \n      // System tracking\n      grantedBy: dbInventoryItem.grantedBy as UserId || undefined,\n      grantReason: dbInventoryItem.grantReason,\n      \n      // Status\n      isFlagged: dbInventoryItem.isFlagged === true,\n      flagReason: dbInventoryItem.flagReason\n    };\n  }\n\n  // ==========================================\n  // VANITY SINK ANALYTICS\n  // ==========================================\n\n  /**\n   * Transform vanity sink metrics for admin dashboard\n   */\n  static toVanitySinkMetrics(analyticsData: any): VanitySinkMetrics {\n    return {\n      periodStart: analyticsData.periodStart.toISOString(),\n      periodEnd: analyticsData.periodEnd.toISOString(),\n      \n      // Burn statistics\n      totalDgtBurned: this.sanitizeDgtAmount(analyticsData.totalDgtBurned),\n      totalTransactions: analyticsData.totalTransactions,\n      averageBurnPerTransaction: this.sanitizeDgtAmount(analyticsData.averageBurnPerTransaction),\n      \n      // Category breakdown\n      burnByCategory: this.transformBurnByCategory(analyticsData.burnByCategory),\n      \n      // User behavior\n      topSpenders: analyticsData.topSpenders.map((spender: any) => ({\n        userId: spender.userId as UserId,\n        username: spender.username,\n        totalBurned: this.sanitizeDgtAmount(spender.totalBurned),\n        transactionCount: spender.transactionCount,\n        favoriteCategory: spender.favoriteCategory as ItemCategory\n      })),\n      \n      // Trends\n      burnTrend: analyticsData.burnTrend,\n      projectedMonthlyBurn: this.sanitizeDgtAmount(analyticsData.projectedMonthlyBurn),\n      burnVelocity: analyticsData.burnVelocity,\n      \n      // Economic impact\n      burnUsdValue: this.calculateUsdValue(analyticsData.totalDgtBurned),\n      economicMultiplier: analyticsData.economicMultiplier || 1.0,\n      deflationaryPressure: analyticsData.deflationaryPressure || 0\n    };\n  }\n\n  // ==========================================\n  // UTILITY METHODS\n  // ==========================================\n\n  private static sanitizeDgtAmount(amount: any): DgtAmount {\n    const parsed = parseFloat(amount?.toString() || '0');\n    return (isNaN(parsed) ? 0 : Math.max(0, parsed)) as DgtAmount;\n  }\n\n  private static sanitizeUsdAmount(amount: any): UsdAmount {\n    const parsed = parseFloat(amount?.toString() || '0');\n    return (isNaN(parsed) ? 0 : Math.max(0, parsed)) as UsdAmount;\n  }\n\n  private static calculateDiscountPercentage(currentPrice: any, originalPrice: any): number | undefined {\n    if (!originalPrice || !currentPrice) return undefined;\n    const current = parseFloat(currentPrice.toString());\n    const original = parseFloat(originalPrice.toString());\n    if (original <= current) return undefined;\n    return Math.round(((original - current) / original) * 100);\n  }\n\n  private static getRarityColor(rarity: ItemRarity): string {\n    const colors = {\n      common: '#9ca3af',    // gray-400\n      rare: '#3b82f6',      // blue-500\n      epic: '#8b5cf6',      // violet-500\n      legendary: '#f59e0b', // amber-500\n      mythic: '#ef4444'     // red-500\n    };\n    return colors[rarity] || colors.common;\n  }\n\n  private static getRarityGlow(rarity: ItemRarity): string | undefined {\n    const glows = {\n      epic: '0 0 20px rgba(139, 92, 246, 0.5)',\n      legendary: '0 0 20px rgba(245, 158, 11, 0.5)',\n      mythic: '0 0 20px rgba(239, 68, 68, 0.7)'\n    };\n    return glows[rarity as keyof typeof glows];\n  }\n\n  private static isItemAvailable(dbItem: any): boolean {\n    const now = new Date();\n    if (dbItem.releaseDate && dbItem.releaseDate > now) return false;\n    if (dbItem.expiryDate && dbItem.expiryDate < now) return false;\n    if (dbItem.isLimited && dbItem.stockRemaining <= 0) return false;\n    return dbItem.isActive !== false;\n  }\n\n  private static calculatePopularityScore(dbItem: any): number {\n    // Combine view count, purchase count, and equipment rate\n    const views = dbItem.viewCount || 0;\n    const purchases = dbItem.purchaseCount || 0;\n    const equipped = dbItem.equippedCount || 0;\n    \n    // Weighted scoring\n    const viewScore = Math.min(views / 1000, 0.3) * 100;\n    const purchaseScore = Math.min(purchases / 100, 0.4) * 100;\n    const equipScore = Math.min(equipped / 50, 0.3) * 100;\n    \n    return Math.round(viewScore + purchaseScore + equipScore);\n  }\n\n  private static checkUserOwnership(itemId: any, userInventory?: any[]): boolean {\n    if (!userInventory) return false;\n    return userInventory.some(item => item.itemId === itemId);\n  }\n\n  private static getUserItemQuantity(itemId: any, userInventory?: any[]): number {\n    if (!userInventory) return 0;\n    const item = userInventory.find(inv => inv.itemId === itemId);\n    return item?.quantity || 0;\n  }\n\n  private static canUserPurchase(dbItem: any, user: any, alreadyOwned: boolean): boolean {\n    // Basic availability check\n    if (!this.isItemAvailable(dbItem)) return false;\n    \n    // User level requirements\n    if (dbItem.requiredLevel && user.level < dbItem.requiredLevel) return false;\n    \n    // Purchase limits\n    if (dbItem.maxQuantityPerUser && alreadyOwned) {\n      // Check if user has reached purchase limit\n      return false; // Simplified - would need actual quantity check\n    }\n    \n    return true;\n  }\n\n  private static getSimilarItems(dbItem: any, user: any): ItemId[] {\n    // This would be implemented with actual recommendation logic\n    return [];\n  }\n\n  private static getBundleOpportunities(dbItem: any, userInventory?: any[]): ItemId[] {\n    // This would be implemented with actual bundle logic\n    return [];\n  }\n\n  private static canUserPreview(dbItem: any, user: any): boolean {\n    return user?.level >= 1; // Basic level requirement for previews\n  }\n\n  private static getEnhancedPreviewUrl(dbItem: any, user: any): string | undefined {\n    if (!this.canUserPreview(dbItem, user)) return undefined;\n    return dbItem.enhancedPreviewUrl || dbItem.previewUrl;\n  }\n\n  private static generatePreviewUrl(dbItem: any): string | undefined {\n    if (!dbItem.id) return undefined;\n    return `/api/shop/preview/${dbItem.id}`;\n  }\n\n  private static generateThumbnailUrl(dbItem: any): string | undefined {\n    if (!dbItem.id) return undefined;\n    return `/api/shop/thumbnail/${dbItem.id}`;\n  }\n\n  private static calculateUsdValue(dgtAmount: any): UsdAmount {\n    const dgt = parseFloat(dgtAmount?.toString() || '0');\n    const rate = parseFloat(process.env.DGT_USD_RATE || '0.01');\n    return (dgt * rate) as UsdAmount;\n  }\n\n  private static calculateAverageSalePrice(analytics: any): DgtAmount {\n    if (!analytics?.totalSales || analytics.totalSales === 0) return 0 as DgtAmount;\n    return this.sanitizeDgtAmount(analytics.totalRevenue / analytics.totalSales);\n  }\n\n  private static calculateConversionRate(analytics: any): number {\n    if (!analytics?.viewCount || analytics.viewCount === 0) return 0;\n    return Math.round((analytics.totalSales / analytics.viewCount) * 100 * 100) / 100;\n  }\n\n  private static determinePopularityTrend(analytics: any): 'rising' | 'stable' | 'falling' {\n    // This would analyze historical data\n    return 'stable';\n  }\n\n  private static shouldShowStockAlerts(dbItem: any): boolean {\n    if (!dbItem.isLimited) return false;\n    return dbItem.stockRemaining <= (dbItem.stockAlertThreshold || 10);\n  }\n\n  private static isReplenishmentNeeded(dbItem: any): boolean {\n    if (!dbItem.isLimited) return false;\n    return dbItem.stockRemaining <= (dbItem.replenishmentThreshold || 5);\n  }\n\n  private static getTopBuyers(analytics: any): any[] {\n    return (analytics?.topBuyers || []).map((buyer: any) => ({\n      userId: buyer.userId as UserId,\n      username: buyer.username,\n      totalSpent: this.sanitizeDgtAmount(buyer.totalSpent),\n      purchaseCount: buyer.purchaseCount\n    }));\n  }\n\n  private static canOrderBeRefunded(dbOrder: any): boolean {\n    if (dbOrder.status !== 'completed') return false;\n    const refundWindow = 24 * 60 * 60 * 1000; // 24 hours\n    const completedAt = new Date(dbOrder.completedAt);\n    return (Date.now() - completedAt.getTime()) < refundWindow;\n  }\n\n  private static getRefundDeadline(dbOrder: any): Date | undefined {\n    if (!this.canOrderBeRefunded(dbOrder)) return undefined;\n    const completedAt = new Date(dbOrder.completedAt);\n    return new Date(completedAt.getTime() + (24 * 60 * 60 * 1000));\n  }\n\n  private static anonymizeEmail(email?: string): string | undefined {\n    if (!email) return undefined;\n    const [local, domain] = email.split('@');\n    if (!local || !domain) return undefined;\n    const masked = local.substring(0, 2) + '***';\n    return `${masked}@${domain}`;\n  }\n\n  private static anonymizeIP(ip?: string): string | undefined {\n    if (!ip) return undefined;\n    if (ip.includes(':')) {\n      // IPv6\n      const parts = ip.split(':');\n      return parts.slice(0, 4).join(':') + '::***';\n    } else {\n      // IPv4\n      const parts = ip.split('.');\n      return parts.slice(0, 3).join('.') + '.***';\n    }\n  }\n\n  private static calculateOrderRiskScore(dbOrder: any): number {\n    let score = 0;\n    \n    // Large order amounts\n    if (dbOrder.totalAmount > 10000) score += 2;\n    else if (dbOrder.totalAmount > 5000) score += 1;\n    \n    // Fast consecutive orders\n    if (dbOrder.consecutiveOrdersInHour > 5) score += 3;\n    else if (dbOrder.consecutiveOrdersInHour > 2) score += 1;\n    \n    // New user behavior\n    if (dbOrder.userAccountAge < 7) score += 2; // Account less than 7 days\n    \n    // Suspicious patterns\n    if (dbOrder.flaggedPatterns) score += 3;\n    \n    return Math.min(10, score);\n  }\n\n  private static transformBurnByCategory(burnData: any): any {\n    const result: any = {};\n    \n    for (const [category, data] of Object.entries(burnData)) {\n      result[category] = {\n        amount: this.sanitizeDgtAmount((data as any).amount),\n        transactions: (data as any).transactions,\n        topItems: ((data as any).topItems || []).map((item: any) => ({\n          itemId: item.itemId as ItemId,\n          name: item.name,\n          burned: this.sanitizeDgtAmount(item.burned)\n        }))\n      };\n    }\n    \n    return result;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shop/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shoutbox/enhanced-shoutbox.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shoutboxConfig' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":21,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shoutboxUserIgnores' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":22,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":27,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'or' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":27,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gt' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":27,"column":61,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":35,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":19},{"ruleId":"@typescript-eslint/ban-types","severity":1,"message":"Don't use `Function` as a type. The `Function` type accepts any function-like value.\nIt provides no type safety when calling the function, which can be a common source of bugs.\nIt also accepts things like class declarations, which will throw at runtime as they will not be called with `new`.\nIf you are expecting the function to accept certain arguments, you should explicitly define the function shape.","line":367,"column":70,"nodeType":"Identifier","messageId":"bannedTypeMessage","endLine":367,"endColumn":78}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { UserId } from '@shared/types/ids';\n/**\n * Enhanced Shoutbox Routes\n *\n * Complete implementation with:\n * - Command processing (/tip, /rain, /airdrop, moderation)\n * - Admin configuration management\n * - User ignore system\n * - Enhanced message filtering and caching\n * - Analytics tracking\n * - Room management\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport type { MessageId, RoomId, UserId } from '@shared/types';\nimport { db } from '@db';\nimport {\n\tshoutboxMessages,\n\tshoutboxConfig,\n\tshoutboxUserIgnores,\n\tshoutboxAnalytics,\n\tchatRooms,\n\tusers\n} from '@schema';\nimport { sql, desc, eq, and, isNull, inArray, asc, not, or, gt } from 'drizzle-orm';\nimport { z } from 'zod';\nimport {\n\tisAuthenticated,\n\tisAuthenticatedOptional,\n\tisAdminOrModerator,\n\tisAdmin\n} from '../auth/middleware/auth.middleware';\nimport { getUserId } from '../auth/services/auth.service';\nimport { logger } from '@server/src/core/logger';\nimport { ShoutboxService } from './services/shoutbox.service';\nimport { RoomService } from './services/room.service';\nimport { MessageHistoryService } from './services/history.service';\nimport { ShoutboxCacheService } from './services/cache.service';\nimport { messageQueue, MessageQueueService } from './services/queue.service';\nimport { PerformanceService } from './services/performance.service';\nimport { createCustomRateLimiter } from '@server/src/core/services/rate-limit.service';\nimport { isValidId } from '@shared/utils/id';\n\nconst router = Router();\n\n// Enhanced rate limiting for different user types\nconst userRateLimiters = {\n\t// VIP users get reduced cooldown\n\tvip: createCustomRateLimiter({\n\t\twindowMs: 5 * 1000, // 5 seconds\n\t\tmax: 1,\n\t\tmessage: { error: 'Please wait 5 seconds between messages (VIP)' }\n\t}),\n\n\t// Regular users\n\tregular: createCustomRateLimiter({\n\t\twindowMs: 10 * 1000, // 10 seconds\n\t\tmax: 1,\n\t\tmessage: { error: 'Please wait 10 seconds between messages' }\n\t}),\n\n\t// New users (level < 5) get longer cooldown\n\tnewUser: createCustomRateLimiter({\n\t\twindowMs: 15 * 1000, // 15 seconds\n\t\tmax: 1,\n\t\tmessage: { error: 'Please wait 15 seconds between messages (new user)' }\n\t})\n};\n\n// Message validation schema\nconst messageSchema = z.object({\n\tcontent: z.string().min(1).max(500),\n\troomId: z.string().uuid().optional(),\n\treplyTo: z.string().uuid().optional(),\n\tmentions: z.array(z.string()).optional()\n});\n\n// Room creation schema\nconst createRoomSchema = z.object({\n\tname: z.string().min(3).max(50),\n\tdescription: z.string().max(200).optional(),\n\tisPrivate: z.boolean().default(false),\n\tminXpRequired: z.number().min(0).optional(),\n\tminGroupIdRequired: z.number().min(1).optional(),\n\taccessRoles: z.array(z.string()).optional(),\n\tthemeConfig: z.record(z.any()).optional(),\n\tmaxUsers: z.number().min(1).max(10000).optional()\n});\n\n/**\n * Get shoutbox configuration for admin panel\n */\nrouter.get('/config', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) : undefined;\n\t\tconst config = await ShoutboxService.getConfig(roomId);\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: config\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error fetching config', { error });\n\t\tres.status(500).json({ error: 'Failed to fetch configuration' });\n\t}\n});\n\n/**\n * Update shoutbox configuration (admin only)\n */\nrouter.patch('/config', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) : undefined;\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\tconst updatedConfig = await ShoutboxService.updateConfig(\n\t\t\t{\n\t\t\t\t...req.body,\n\t\t\t\tupdatedBy: userId?.toString()\n\t\t\t},\n\t\t\troomId\n\t\t);\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: updatedConfig,\n\t\t\tmessage: 'Configuration updated successfully'\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error updating config', { error });\n\t\tres.status(500).json({ error: 'Failed to update configuration' });\n\t}\n});\n\n/**\n * Get rooms with comprehensive statistics\n */\nrouter.get('/rooms', isAuthenticatedOptional, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst includeStats = req.query.includeStats === 'true';\n\n\t\tif (includeStats) {\n\t\t\tconst roomsWithStats = await RoomService.getRoomsWithStats(userId);\n\t\t\tres.json({ success: true, data: roomsWithStats });\n\t\t} else {\n\t\t\t// Use existing simplified logic for backwards compatibility\n\t\t\tconst rooms = await db\n\t\t\t\t.select()\n\t\t\t\t.from(chatRooms)\n\t\t\t\t.where(eq(chatRooms.isDeleted, false))\n\t\t\t\t.orderBy(asc(chatRooms.order));\n\n\t\t\tres.json(rooms);\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error fetching rooms', { error });\n\t\tres.status(500).json({ error: 'Failed to fetch rooms' });\n\t}\n});\n\n/**\n * Create new chat room (admin only)\n */\nrouter.post('/rooms', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst roomData = createRoomSchema.parse({\n\t\t\t...req.body,\n\t\t\tcreatedBy: userId\n\t\t});\n\n\t\tconst result = await RoomService.createRoom(roomData);\n\n\t\tif (result.success) {\n\t\t\tres.status(201).json(result);\n\t\t} else {\n\t\t\tres.status(400).json(result);\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof z.ZodError) {\n\t\t\treturn res.status(400).json({\n\t\t\t\terror: 'Invalid room data',\n\t\t\t\tdetails: error.errors\n\t\t\t});\n\t\t}\n\n\t\tlogger.error('Enhanced Shoutbox', 'Error creating room', { error });\n\t\tres.status(500).json({ error: 'Failed to create room' });\n\t}\n});\n\n/**\n * Update chat room (admin only)\n */\nrouter.patch('/rooms/:roomId', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst roomId = req.params.roomId as RoomId;\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\tconst result = await RoomService.updateRoom(roomId, req.body, userId);\n\n\t\tif (result.success) {\n\t\t\tres.json(result);\n\t\t} else {\n\t\t\tres.status(400).json(result);\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error updating room', { error });\n\t\tres.status(500).json({ error: 'Failed to update room' });\n\t}\n});\n\n/**\n * Delete chat room (admin only)\n */\nrouter.delete('/rooms/:roomId', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst roomId = req.params.roomId as RoomId;\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\tconst result = await RoomService.deleteRoom(roomId, userId);\n\n\t\tif (result.success) {\n\t\t\tres.json(result);\n\t\t} else {\n\t\t\tres.status(400).json(result);\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error deleting room', { error });\n\t\tres.status(500).json({ error: 'Failed to delete room' });\n\t}\n});\n\n/**\n * Reorder rooms (admin only)\n */\nrouter.patch('/rooms/reorder', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst { roomOrders } = req.body;\n\n\t\tif (!Array.isArray(roomOrders)) {\n\t\t\treturn res.status(400).json({ error: 'roomOrders must be an array' });\n\t\t}\n\n\t\tconst result = await RoomService.reorderRooms(roomOrders);\n\n\t\tif (result.success) {\n\t\t\tres.json(result);\n\t\t} else {\n\t\t\tres.status(400).json(result);\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error reordering rooms', { error });\n\t\tres.status(500).json({ error: 'Failed to reorder rooms' });\n\t}\n});\n\n/**\n * Get messages with enhanced filtering and pagination\n */\nrouter.get('/messages', isAuthenticatedOptional, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) : null;\n\t\tconst limit = Math.min(parseInt(req.query.limit as string) || 50, 100);\n\t\tconst before = req.query.before ? parseInt(req.query.before as string) : null;\n\t\tconst after = req.query.after ? parseInt(req.query.after as string) : null;\n\t\tconst includeDeleted = req.query.includeDeleted === 'true';\n\n\t\t// Check room access if specified\n\t\tif (roomId && userId) {\n\t\t\tconst accessCheck = await RoomService.checkRoomAccess(userId, roomId);\n\t\t\tif (!accessCheck.hasAccess) {\n\t\t\t\treturn res.status(403).json({\n\t\t\t\t\terror: 'Access denied',\n\t\t\t\t\treason: accessCheck.reason\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Get user's ignore list\n\t\tconst ignoredUsers = userId\n\t\t\t? await RoomService.getUserIgnoreList(userId, roomId || undefined)\n\t\t\t: [];\n\n\t\t// Build query conditions\n\t\tconst conditions = [\n\t\t\troomId ? eq(shoutboxMessages.roomId, roomId) : undefined,\n\t\t\t!includeDeleted ? eq(shoutboxMessages.isDeleted, false) : undefined,\n\t\t\tbefore ? sql`${shoutboxMessages.id} < ${before}` : undefined,\n\t\t\tafter ? sql`${shoutboxMessages.id} > ${after}` : undefined,\n\t\t\tignoredUsers.length > 0 ? not(inArray(shoutboxMessages.userId, ignoredUsers)) : undefined\n\t\t].filter(Boolean);\n\n\t\tconst whereCondition = conditions.length > 0 ? and(...conditions) : undefined;\n\n\t\t// Get messages with user data\n\t\tconst messages = await db\n\t\t\t.select({\n\t\t\t\tid: shoutboxMessages.id,\n\t\t\t\tuserId: shoutboxMessages.userId,\n\t\t\t\troomId: shoutboxMessages.roomId,\n\t\t\t\tcontent: shoutboxMessages.content,\n\t\t\t\tcreatedAt: shoutboxMessages.createdAt,\n\t\t\t\teditedAt: shoutboxMessages.editedAt,\n\t\t\t\tisDeleted: shoutboxMessages.isDeleted,\n\t\t\t\tisPinned: shoutboxMessages.isPinned,\n\t\t\t\ttipAmount: shoutboxMessages.tipAmount,\n\t\t\t\t// User data\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\tlevel: users.level,\n\t\t\t\tgroupId: users.groupId,\n\t\t\t\troles: users.roles,\n\t\t\t\tusernameColor: users.usernameColor\n\t\t\t})\n\t\t\t.from(shoutboxMessages)\n\t\t\t.leftJoin(users, eq(shoutboxMessages.userId, users.id))\n\t\t\t.where(whereCondition)\n\t\t\t.orderBy(desc(shoutboxMessages.createdAt))\n\t\t\t.limit(limit);\n\n\t\t// Format response\n\t\tconst formattedMessages = messages.map((msg) => ({\n\t\t\tid: msg.id,\n\t\t\troomId: msg.roomId,\n\t\t\tcontent: msg.content,\n\t\t\tcreatedAt: msg.createdAt,\n\t\t\teditedAt: msg.editedAt,\n\t\t\tisDeleted: msg.isDeleted,\n\t\t\tisPinned: msg.isPinned,\n\t\t\ttipAmount: msg.tipAmount,\n\t\t\tuser: msg.userId\n\t\t\t\t? {\n\t\t\t\t\t\tid: msg.userId,\n\t\t\t\t\t\tusername: msg.username,\n\t\t\t\t\t\tavatarUrl: msg.avatarUrl || msg.activeAvatarUrl,\n\t\t\t\t\t\tlevel: msg.level,\n\t\t\t\t\t\tgroupId: msg.groupId,\n\t\t\t\t\t\troles: msg.roles || [],\n\t\t\t\t\t\tusernameColor: msg.usernameColor\n\t\t\t\t\t}\n\t\t\t\t: null\n\t\t}));\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: formattedMessages,\n\t\t\tmeta: {\n\t\t\t\tcount: messages.length,\n\t\t\t\thasMore: messages.length === limit,\n\t\t\t\toldestId: messages.length > 0 ? messages[messages.length - 1].id : null,\n\t\t\t\tnewestId: messages.length > 0 ? messages[0].id : null\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error fetching messages', { error });\n\t\tres.status(500).json({ error: 'Failed to fetch messages' });\n\t}\n});\n\n// Dynamic rate-limiter middleware that picks limiter based on user role/level\nasync function dynamicRateLimiter(req: Request, res: Response, next: Function) {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tif (!userId) return res.status(401).json({ error: 'Unauthorized' });\n\n\t\tconst user = await db.query.users.findFirst({\n\t\t\twhere: eq(users.id, userId),\n\t\t\tcolumns: {\n\t\t\t\tid: true,\n\t\t\t\tusername: true,\n\t\t\t\tlevel: true,\n\t\t\t\troles: true,\n\t\t\t\tgroupId: true\n\t\t\t}\n\t\t});\n\n\t\tif (!user) return res.status(401).json({ error: 'User not found' });\n\n\t\tlet rateLimiter = userRateLimiters.regular;\n\t\tif (\n\t\t\tuser.roles?.includes('vip') ||\n\t\t\tuser.roles?.includes('admin') ||\n\t\t\tuser.roles?.includes('moderator')\n\t\t) {\n\t\t\trateLimiter = userRateLimiters.vip;\n\t\t} else if (user.level && user.level < 5) {\n\t\t\trateLimiter = userRateLimiters.newUser;\n\t\t}\n\n\t\t// Attach user to request for downstream handlers\n\t\t(req as any).currentUser = user;\n\t\treturn rateLimiter(req, res, next);\n\t} catch (err) {\n\t\tlogger.error('Enhanced Shoutbox', 'Rate-limit middleware failed', { err });\n\t\treturn res.status(429).json({ error: 'Rate limit exceeded' });\n\t}\n}\n\n// Revised POST /messages endpoint: middleware chain enforces rate limiting before handler\n\nrouter.post(\n\t'/messages',\n\tisAuthenticated,\n\tdynamicRateLimiter,\n\tasync (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst userId = userService.getUserFromRequest(req);\n\t\t\tconst user = (req as any).currentUser;\n\t\t\tconst messageData = messageSchema.parse(req.body);\n\n\t\t\t// Determine room ID\n\t\t\tlet roomId = messageData.roomId;\n\t\t\tif (!roomId) {\n\t\t\t\tconst defaultRoom = await db.query.chatRooms.findFirst({\n\t\t\t\t\twhere: and(eq(chatRooms.name, 'degen-lounge'), eq(chatRooms.isDeleted, false))\n\t\t\t\t});\n\t\t\t\troomId = defaultRoom?.id || 1;\n\t\t\t}\n\n\t\t\tconst accessCheck = await RoomService.checkRoomAccess(userId, roomId);\n\n\t\t\tif (!accessCheck.hasAccess) {\n\t\t\t\treturn res.status(403).json({\n\t\t\t\t\terror: 'Access denied',\n\t\t\t\t\treason: accessCheck.reason\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Process message through enhanced service\n\t\t\tconst context = {\n\t\t\t\tuserId,\n\t\t\t\tusername: user.username,\n\t\t\t\troomId,\n\t\t\t\tcontent: messageData.content,\n\t\t\t\tuserRoles: user.roles || [],\n\t\t\t\tuserLevel: user.level || 1,\n\t\t\t\tipAddress: req.ip,\n\t\t\t\tsessionId: req.sessionID\n\t\t\t};\n\n\t\t\tconst result = await ShoutboxService.processMessage(context);\n\n\t\t\tif (result.success) {\n\t\t\t\t// Broadcast to WebSocket clients if available\n\t\t\t\tif (result.broadcastData && req.app && (req.app as any).wss) {\n\t\t\t\t\tconst clients = (req.app as any).wss.clients;\n\t\t\t\t\tfor (const client of clients) {\n\t\t\t\t\t\tif (client.readyState === 1) {\n\t\t\t\t\t\t\tclient.send(JSON.stringify(result.broadcastData));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tres.status(201).json({\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tmessage: result.message,\n\t\t\t\t\tdata: result.data\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tres.status(400).json({\n\t\t\t\t\terror: result.message,\n\t\t\t\t\tcode: result.error\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\terror: 'Invalid message data',\n\t\t\t\t\tdetails: error.errors\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlogger.error('Enhanced Shoutbox', 'Error in message endpoint', { error });\n\t\t\tres.status(500).json({ error: 'Failed to send message' });\n\t\t}\n\t}\n);\n\n/**\n * Pin/Unpin message (moderator+)\n */\nrouter.patch(\n\t'/messages/:messageId/pin',\n\tisAdminOrModerator,\n\tasync (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst messageId = req.params.messageId as MessageId;\n\t\t\tconst { isPinned } = req.body;\n\t\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\t\tif (typeof isPinned !== 'boolean') {\n\t\t\t\treturn res.status(400).json({ error: 'Invalid parameters' });\n\t\t\t}\n\n\t\t\t// Check if message exists\n\t\t\tconst message = await db.query.shoutboxMessages.findFirst({\n\t\t\t\twhere: eq(shoutboxMessages.id, messageId)\n\t\t\t});\n\n\t\t\tif (!message) {\n\t\t\t\treturn res.status(404).json({ error: 'Message not found' });\n\t\t\t}\n\n\t\t\t// Check room configuration for pinning limits\n\t\t\tconst config = await ShoutboxService.getConfig(message.roomId);\n\n\t\t\tif (isPinned && config.maxPinnedMessages) {\n\t\t\t\tconst pinnedCount = await db\n\t\t\t\t\t.select({ count: sql<number>`COUNT(*)` })\n\t\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(shoutboxMessages.roomId, message.roomId),\n\t\t\t\t\t\t\teq(shoutboxMessages.isPinned, true),\n\t\t\t\t\t\t\teq(shoutboxMessages.isDeleted, false)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\tif (pinnedCount[0].count >= config.maxPinnedMessages) {\n\t\t\t\t\treturn res.status(400).json({\n\t\t\t\t\t\terror: `Maximum ${config.maxPinnedMessages} pinned messages allowed`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update message\n\t\t\tconst [updatedMessage] = await db\n\t\t\t\t.update(shoutboxMessages)\n\t\t\t\t.set({\n\t\t\t\t\tisPinned,\n\t\t\t\t\teditedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(shoutboxMessages.id, messageId))\n\t\t\t\t.returning();\n\n\t\t\t// Log action\n\t\t\tlogger.info('Enhanced Shoutbox', `Message ${isPinned ? 'pinned' : 'unpinned'}`, {\n\t\t\t\tmessageId,\n\t\t\t\tuserId,\n\t\t\t\troomId: message.roomId\n\t\t\t});\n\n\t\t\t// Broadcast update\n\t\t\tif (req.app && (req.app as any).wss) {\n\t\t\t\tconst broadcastData = {\n\t\t\t\t\ttype: 'chat_update',\n\t\t\t\t\taction: isPinned ? 'message_pinned' : 'message_unpinned',\n\t\t\t\t\tmessageId,\n\t\t\t\t\troomId: message.roomId,\n\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t};\n\n\t\t\t\tconst clients = (req.app as any).wss.clients;\n\t\t\t\tfor (const client of clients) {\n\t\t\t\t\tif (client.readyState === 1) {\n\t\t\t\t\t\tclient.send(JSON.stringify(broadcastData));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Message ${isPinned ? 'pinned' : 'unpinned'} successfully`,\n\t\t\t\tdata: updatedMessage\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('Enhanced Shoutbox', 'Error pinning/unpinning message', { error });\n\t\t\tres.status(500).json({ error: 'Failed to update message' });\n\t\t}\n\t}\n);\n\n/**\n * Delete message (moderator+)\n */\nrouter.delete('/messages/:messageId', isAdminOrModerator, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst messageId = req.params.messageId as MessageId;\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\t// Soft delete message\n\t\tconst [deletedMessage] = await db\n\t\t\t.update(shoutboxMessages)\n\t\t\t.set({\n\t\t\t\tisDeleted: true,\n\t\t\t\teditedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(shoutboxMessages.id, messageId))\n\t\t\t.returning();\n\n\t\tif (!deletedMessage) {\n\t\t\treturn res.status(404).json({ error: 'Message not found' });\n\t\t}\n\n\t\t// Log action\n\t\tlogger.info('Enhanced Shoutbox', 'Message deleted', {\n\t\t\tmessageId,\n\t\t\tuserId,\n\t\t\troomId: deletedMessage.roomId\n\t\t});\n\n\t\t// Broadcast update\n\t\tif (req.app && (req.app as any).wss) {\n\t\t\tconst broadcastData = {\n\t\t\t\ttype: 'chat_update',\n\t\t\t\taction: 'message_deleted',\n\t\t\t\tmessageId,\n\t\t\t\troomId: deletedMessage.roomId,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\n\t\t\tconst clients = (req.app as any).wss.clients;\n\t\t\tfor (const client of clients) {\n\t\t\t\tif (client.readyState === 1) {\n\t\t\t\t\tclient.send(JSON.stringify(broadcastData));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: 'Message deleted successfully'\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error deleting message', { error });\n\t\tres.status(500).json({ error: 'Failed to delete message' });\n\t}\n});\n\n/**\n * User ignore system\n */\nrouter.post('/ignore', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { targetUserId, roomId, options } = req.body;\n\n\t\tif (!targetUserId || !isValidId(targetUserId)) {\n\t\t\treturn res.status(400).json({ error: 'Invalid target user ID' });\n\t\t}\n\n\t\tconst result = await RoomService.ignoreUser(\n\t\t\tuserId,\n\t\t\ttargetUserId as UserId,\n\t\t\troomId ? (roomId as RoomId) : undefined,\n\t\t\toptions\n\t\t);\n\n\t\tres.json(result);\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error ignoring user', { error });\n\t\tres.status(500).json({ error: 'Failed to ignore user' });\n\t}\n});\n\nrouter.delete('/ignore/:targetUserId', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst targetUserId = req.params.targetUserId as UserId;\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) : undefined;\n\n\t\tif (typeof targetUserId !== 'string') {\n\t\t\treturn res.status(400).json({ error: 'Invalid target user ID' });\n\t\t}\n\n\t\tconst result = await RoomService.unignoreUser(userId, targetUserId, roomId);\n\n\t\tres.json(result);\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error unignoring user', { error });\n\t\tres.status(500).json({ error: 'Failed to unignore user' });\n\t}\n});\n\n/**\n * Get shoutbox analytics (admin only)\n */\nrouter.get('/analytics', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst period = (req.query.period as string) || '24h';\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) : undefined;\n\n\t\tlet timeFilter: any;\n\t\tswitch (period) {\n\t\t\tcase '1h':\n\t\t\t\ttimeFilter = sql`${shoutboxAnalytics.timestamp} >= NOW() - INTERVAL '1 hour'`;\n\t\t\t\tbreak;\n\t\t\tcase '24h':\n\t\t\t\ttimeFilter = sql`${shoutboxAnalytics.timestamp} >= NOW() - INTERVAL '24 hours'`;\n\t\t\t\tbreak;\n\t\t\tcase '7d':\n\t\t\t\ttimeFilter = sql`${shoutboxAnalytics.timestamp} >= NOW() - INTERVAL '7 days'`;\n\t\t\t\tbreak;\n\t\t\tcase '30d':\n\t\t\t\ttimeFilter = sql`${shoutboxAnalytics.timestamp} >= NOW() - INTERVAL '30 days'`;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttimeFilter = sql`${shoutboxAnalytics.timestamp} >= NOW() - INTERVAL '24 hours'`;\n\t\t}\n\n\t\tconst conditions = [\n\t\t\ttimeFilter,\n\t\t\troomId ? eq(shoutboxAnalytics.roomId, roomId) : undefined\n\t\t].filter(Boolean);\n\n\t\t// Get event counts by type\n\t\tconst eventCounts = await db\n\t\t\t.select({\n\t\t\t\teventType: shoutboxAnalytics.eventType,\n\t\t\t\tcount: sql<number>`COUNT(*)`\n\t\t\t})\n\t\t\t.from(shoutboxAnalytics)\n\t\t\t.where(and(...conditions))\n\t\t\t.groupBy(shoutboxAnalytics.eventType);\n\n\t\t// Get hourly activity\n\t\tconst hourlyActivity = await db\n\t\t\t.select({\n\t\t\t\thour: sql<number>`EXTRACT(hour FROM ${shoutboxAnalytics.timestamp})`,\n\t\t\t\tcount: sql<number>`COUNT(*)`\n\t\t\t})\n\t\t\t.from(shoutboxAnalytics)\n\t\t\t.where(and(...conditions))\n\t\t\t.groupBy(sql`EXTRACT(hour FROM ${shoutboxAnalytics.timestamp})`)\n\t\t\t.orderBy(sql`EXTRACT(hour FROM ${shoutboxAnalytics.timestamp})`);\n\n\t\t// Get top users by activity\n\t\tconst topUsers = await db\n\t\t\t.select({\n\t\t\t\tuserId: shoutboxAnalytics.userId,\n\t\t\t\tusername: users.username,\n\t\t\t\tcount: sql<number>`COUNT(*)`\n\t\t\t})\n\t\t\t.from(shoutboxAnalytics)\n\t\t\t.leftJoin(users, eq(shoutboxAnalytics.userId, users.id))\n\t\t\t.where(and(...conditions))\n\t\t\t.groupBy(shoutboxAnalytics.userId, users.username)\n\t\t\t.orderBy(desc(sql`COUNT(*)`))\n\t\t\t.limit(10);\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tperiod,\n\t\t\t\troomId,\n\t\t\t\teventCounts,\n\t\t\t\thourlyActivity,\n\t\t\t\ttopUsers\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error fetching analytics', { error });\n\t\tres.status(500).json({ error: 'Failed to fetch analytics' });\n\t}\n});\n\n/**\n * Export message history (admin only)\n */\nrouter.get('/export', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst format = (req.query.format as string) || 'json';\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) : undefined;\n\t\tconst dateFrom = req.query.dateFrom as string;\n\t\tconst dateTo = req.query.dateTo as string;\n\n\t\t// Build query conditions\n\t\tconst conditions = [\n\t\t\troomId ? eq(shoutboxMessages.roomId, roomId) : undefined,\n\t\t\tdateFrom ? sql`${shoutboxMessages.createdAt} >= ${dateFrom}` : undefined,\n\t\t\tdateTo ? sql`${shoutboxMessages.createdAt} <= ${dateTo}` : undefined\n\t\t].filter(Boolean);\n\n\t\t// Get messages\n\t\tconst messages = await db\n\t\t\t.select({\n\t\t\t\tid: shoutboxMessages.id,\n\t\t\t\tuserId: shoutboxMessages.userId,\n\t\t\t\tusername: users.username,\n\t\t\t\troomId: shoutboxMessages.roomId,\n\t\t\t\troomName: chatRooms.name,\n\t\t\t\tcontent: shoutboxMessages.content,\n\t\t\t\tcreatedAt: shoutboxMessages.createdAt,\n\t\t\t\tisDeleted: shoutboxMessages.isDeleted,\n\t\t\t\tisPinned: shoutboxMessages.isPinned\n\t\t\t})\n\t\t\t.from(shoutboxMessages)\n\t\t\t.leftJoin(users, eq(shoutboxMessages.userId, users.id))\n\t\t\t.leftJoin(chatRooms, eq(shoutboxMessages.roomId, chatRooms.id))\n\t\t\t.where(conditions.length > 0 ? and(...conditions) : undefined)\n\t\t\t.orderBy(asc(shoutboxMessages.createdAt));\n\n\t\t// Format based on requested format\n\t\tif (format === 'csv') {\n\t\t\tconst csv = [\n\t\t\t\t'ID,User ID,Username,Room ID,Room Name,Content,Created At,Is Deleted,Is Pinned',\n\t\t\t\t...messages.map(\n\t\t\t\t\t(msg) =>\n\t\t\t\t\t\t`${msg.id},\"${msg.userId}\",\"${msg.username}\",\"${msg.roomId}\",\"${msg.roomName}\",\"${msg.content?.replace(/\"/g, '\"\"')}\",\"${msg.createdAt}\",\"${msg.isDeleted}\",\"${msg.isPinned}\"`\n\t\t\t\t)\n\t\t\t].join('\\n');\n\n\t\t\tres.setHeader('Content-Type', 'text/csv');\n\t\t\tres.setHeader(\n\t\t\t\t'Content-Disposition',\n\t\t\t\t`attachment; filename=\"shoutbox-export-${Date.now()}.csv\"`\n\t\t\t);\n\t\t\tres.send(csv);\n\t\t} else {\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: {\n\t\t\t\t\texportedAt: new Date().toISOString(),\n\t\t\t\t\ttotalMessages: messages.length,\n\t\t\t\t\tfilters: { roomId, dateFrom, dateTo },\n\t\t\t\t\tmessages\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error exporting messages', { error });\n\t\tres.status(500).json({ error: 'Failed to export messages' });\n\t}\n});\n\n/**\n * Performance monitoring endpoints\n */\n\n// Get performance statistics (admin only)\nrouter.get('/performance/stats', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst stats = PerformanceService.getPerformanceStats();\n\t\tconst cacheStats = ShoutboxCacheService.getCacheStats();\n\t\tconst queueStats = messageQueue.getStats();\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tperformance: stats,\n\t\t\t\tcache: cacheStats,\n\t\t\t\tqueue: queueStats,\n\t\t\t\tgeneratedAt: new Date().toISOString()\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error fetching performance stats', { error });\n\t\tres.status(500).json({ error: 'Failed to fetch performance statistics' });\n\t}\n});\n\n// Get optimization suggestions (admin only)\nrouter.get('/performance/analyze', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst suggestions = PerformanceService.analyzeQueryPerformance();\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tsuggestions,\n\t\t\t\tanalyzedAt: new Date().toISOString()\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error analyzing performance', { error });\n\t\tres.status(500).json({ error: 'Failed to analyze performance' });\n\t}\n});\n\n// Get optimized messages with caching\nrouter.get('/messages/optimized', isAuthenticatedOptional, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) : undefined;\n\t\tconst limit = req.query.limit ? parseInt(req.query.limit as string) : 50;\n\t\tconst cursor = req.query.cursor ? parseInt(req.query.cursor as string) : undefined;\n\t\tconst direction = (req.query.direction as 'before' | 'after') || 'before';\n\t\tconst userId = userService.getUserFromRequest(req);\n\n\t\tif (!roomId) {\n\t\t\treturn res.status(400).json({ error: 'Room ID is required' });\n\t\t}\n\n\t\tconst result = await PerformanceService.getOptimizedMessages({\n\t\t\troomId,\n\t\t\tlimit,\n\t\t\tcursor,\n\t\t\tdirection,\n\t\t\tuserId: userId || undefined\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\t...result\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error fetching optimized messages', { error });\n\t\tres.status(500).json({ error: 'Failed to fetch messages' });\n\t}\n});\n\n// Queue management endpoints (admin only)\nrouter.get('/queue/status', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = req.query.userId ? (req.query.userId as string) : undefined;\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) : undefined;\n\n\t\tconst queuedMessages = messageQueue.getQueuedMessages(userId, roomId);\n\t\tconst stats = messageQueue.getStats();\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: {\n\t\t\t\tstats,\n\t\t\t\tqueuedMessages: queuedMessages.slice(0, 50), // Limit for performance\n\t\t\t\ttotalQueued: queuedMessages.length\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error fetching queue status', { error });\n\t\tres.status(500).json({ error: 'Failed to fetch queue status' });\n\t}\n});\n\n// Remove message from queue (admin only)\nrouter.delete('/queue/:messageId', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst messageId = req.params.messageId;\n\t\tconst removed = await messageQueue.removeMessage(messageId);\n\n\t\tif (removed) {\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Message removed from queue'\n\t\t\t});\n\t\t} else {\n\t\t\tres.status(404).json({ error: 'Message not found in queue' });\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error removing message from queue', { error });\n\t\tres.status(500).json({ error: 'Failed to remove message from queue' });\n\t}\n});\n\n// Cache management endpoints (admin only)\nrouter.post('/cache/clear', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst { type, roomId } = req.body;\n\n\t\tswitch (type) {\n\t\t\tcase 'messages':\n\t\t\t\tif (roomId) {\n\t\t\t\t\tShoutboxCacheService.invalidateMessages(roomId);\n\t\t\t\t} else {\n\t\t\t\t\t// Clear all message caches\n\t\t\t\t\tShoutboxCacheService.clearAll();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'config':\n\t\t\t\tShoutboxCacheService.invalidateRoomConfig(roomId);\n\t\t\t\tbreak;\n\t\t\tcase 'all':\n\t\t\t\tShoutboxCacheService.clearAll();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn res.status(400).json({ error: 'Invalid cache type' });\n\t\t}\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: `Cache cleared for type: ${type}`\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error clearing cache', { error });\n\t\tres.status(500).json({ error: 'Failed to clear cache' });\n\t}\n});\n\n// Enhanced message history with performance optimization\nrouter.get('/history/advanced', isAdminOrModerator, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) : undefined;\n\t\tconst userId = req.query.userId ? (req.query.userId as string) : undefined;\n\t\tconst limit = req.query.limit ? parseInt(req.query.limit as string) : 50;\n\t\tconst cursor = req.query.cursor ? parseInt(req.query.cursor as string) : undefined;\n\t\tconst direction = (req.query.direction as 'before' | 'after') || 'before';\n\t\tconst includeDeleted = req.query.includeDeleted === 'true';\n\n\t\tconst result = await MessageHistoryService.getMessageHistory({\n\t\t\troomId,\n\t\t\tuserId,\n\t\t\tlimit,\n\t\t\tcursor,\n\t\t\tdirection,\n\t\t\tincludeDeleted\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: result\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error fetching message history', { error });\n\t\tres.status(500).json({ error: 'Failed to fetch message history' });\n\t}\n});\n\n// Message statistics for analytics\nrouter.get('/stats/messages', isAdminOrModerator, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) : undefined;\n\t\tconst dateFrom = req.query.dateFrom ? new Date(req.query.dateFrom as string) : undefined;\n\t\tconst dateTo = req.query.dateTo ? new Date(req.query.dateTo as string) : undefined;\n\t\tconst groupBy = (req.query.groupBy as 'hour' | 'day' | 'week' | 'month') || 'day';\n\n\t\tconst stats = await MessageHistoryService.getMessageStatistics({\n\t\t\troomId,\n\t\t\tdateFrom,\n\t\t\tdateTo,\n\t\t\tgroupBy\n\t\t});\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tdata: stats\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Enhanced Shoutbox', 'Error fetching message statistics', { error });\n\t\tres.status(500).json({ error: 'Failed to fetch message statistics' });\n\t}\n});\n\n// Active users in room with performance optimization\nrouter.get(\n\t'/users/active/:roomId',\n\tisAuthenticatedOptional,\n\tasync (req: Request, res: Response) => {\n\t\ttry {\n\t\t\tconst roomId = req.params.roomId as RoomId;\n\n\t\t\tif (!roomId) {\n\t\t\t\treturn res.status(400).json({ error: 'Invalid room ID' });\n\t\t\t}\n\n\t\t\tconst activeUsers = await PerformanceService.getActiveUsersInRoom(roomId);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: activeUsers\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('Enhanced Shoutbox', 'Error fetching active users', { error });\n\t\t\tres.status(500).json({ error: 'Failed to fetch active users' });\n\t\t}\n\t}\n);\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shoutbox/services/cache.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is defined but never used.","line":292,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":292,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is defined but never used.","line":329,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":329,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { UserId } from '@shared/types';\n/**\n * Shoutbox Cache Service\n *\n * High-performance caching layer for:\n * - Recent messages with real-time invalidation\n * - User session data and permissions\n * - Room configurations and access controls\n * - Rate limiting state\n * - Typing indicators\n */\n\nimport { logger } from '@server/src/core/logger';\nimport { createHash } from 'crypto';\nimport type { RoomId, MessageId } from '@shared/types';\nimport { MessageId, EntityId } from \"@shared/types\";\n\ninterface CacheItem<T> {\n\tdata: T;\n\texpiry: number;\n\tversion: string;\n}\n\ninterface MessageCacheEntry {\n\tid: MessageId;\n\tuserId: UserId | null;\n\troomId: RoomId;\n\tcontent: string;\n\tcreatedAt: Date;\n\tisPinned: boolean;\n\tisDeleted: boolean;\n\tuser?: {\n\t\tusername: string;\n\t\tlevel: number;\n\t\troles?: string[];\n\t\tusernameColor?: string;\n\t};\n}\n\ninterface UserSessionCache {\n\tuserId: UserId;\n\tusername: string;\n\troles: string[];\n\tlevel: number;\n\tpermissions: Record<string, boolean>;\n\tlastSeen: Date;\n\trateLimitState: {\n\t\tmessageCount: number;\n\t\tresetTime: number;\n\t\tcooldownUntil?: number;\n\t};\n}\n\ninterface RoomCache {\n\tid: EntityId;\n\tname: string;\n\tconfig: any;\n\taccessibleUsers: Set<UserId>;\n\tonlineUsers: Set<UserId>;\n\tpinnedMessages: number[];\n}\n\nexport class ShoutboxCacheService {\n\tprivate static cache = new Map<string, CacheItem<any>>();\n\tprivate static readonly DEFAULT_TTL = 5 * 60 * 1000; // 5 minutes\n\tprivate static readonly MESSAGE_CACHE_SIZE = 500;\n\tprivate static readonly USER_SESSION_TTL = 30 * 60 * 1000; // 30 minutes\n\tprivate static readonly ROOM_CONFIG_TTL = 60 * 60 * 1000; // 1 hour\n\n\t/**\n\t * Message caching with LRU eviction\n\t */\n\tstatic async cacheMessages(roomId: RoomId, messages: MessageCacheEntry[]): Promise<void> {\n\t\tconst key = `messages:${roomId}`;\n\t\tconst version = this.generateVersion();\n\n\t\tthis.setCache(key, messages, this.DEFAULT_TTL, version);\n\n\t\t// Track message IDs for invalidation\n\t\tconst messageIds = messages.map((m) => m.id);\n\t\tthis.setCache(`message_ids:${roomId}`, messageIds, this.DEFAULT_TTL, version);\n\n\t\tlogger.debug('ShoutboxCacheService', 'Cached messages', { roomId, count: messages.length });\n\t}\n\n\tstatic getCachedMessages(roomId: RoomId): MessageCacheEntry[] | null {\n\t\tconst key = `messages:${roomId}`;\n\t\tconst cached = this.getCache<MessageCacheEntry[]>(key);\n\n\t\tif (cached) {\n\t\t\tlogger.debug('ShoutboxCacheService', 'Cache hit for messages', {\n\t\t\t\troomId,\n\t\t\t\tcount: cached.length\n\t\t\t});\n\t\t}\n\n\t\treturn cached;\n\t}\n\n\tstatic invalidateMessages(roomId: RoomId, messageId?: MessageId): void {\n\t\tconst key = `messages:${roomId}`;\n\n\t\tif (messageId) {\n\t\t\t// Partial invalidation - remove specific message\n\t\t\tconst cached = this.getCache<MessageCacheEntry[]>(key);\n\t\t\tif (cached) {\n\t\t\t\tconst filtered = cached.filter((m) => m.id !== messageId);\n\t\t\t\tconst version = this.generateVersion();\n\t\t\t\tthis.setCache(key, filtered, this.DEFAULT_TTL, version);\n\t\t\t\tlogger.debug('ShoutboxCacheService', 'Invalidated specific message', { roomId, messageId });\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Full invalidation\n\t\tthis.deleteCache(key);\n\t\tthis.deleteCache(`message_ids:${roomId}`);\n\t\tlogger.debug('ShoutboxCacheService', 'Invalidated all messages', { roomId });\n\t}\n\n\t/**\n\t * User session caching\n\t */\n\tstatic cacheUserSession(userId: UserId, session: UserSessionCache): void {\n\t\tconst key = `user_session:${userId}`;\n\t\tconst version = this.generateVersion();\n\n\t\tthis.setCache(key, session, this.USER_SESSION_TTL, version);\n\t\tlogger.debug('ShoutboxCacheService', 'Cached user session', { userId });\n\t}\n\n\tstatic getCachedUserSession(userId: UserId): UserSessionCache | null {\n\t\tconst key = `user_session:${userId}`;\n\t\treturn this.getCache<UserSessionCache>(key);\n\t}\n\n\tstatic updateUserLastSeen(userId: UserId): void {\n\t\tconst key = `user_session:${userId}`;\n\t\tconst cached = this.getCache<UserSessionCache>(key);\n\n\t\tif (cached) {\n\t\t\tcached.lastSeen = new Date();\n\t\t\tconst version = this.generateVersion();\n\t\t\tthis.setCache(key, cached, this.USER_SESSION_TTL, version);\n\t\t}\n\t}\n\n\tstatic invalidateUserSession(userId: UserId): void {\n\t\tconst key = `user_session:${userId}`;\n\t\tthis.deleteCache(key);\n\t\tlogger.debug('ShoutboxCacheService', 'Invalidated user session', { userId });\n\t}\n\n\t/**\n\t * Rate limiting cache\n\t */\n\tstatic getRateLimitState(\n\t\tuserId: UserId\n\t): { messageCount: number; resetTime: number; cooldownUntil?: number } | null {\n\t\tconst session = this.getCachedUserSession(userId);\n\t\treturn session?.rateLimitState || null;\n\t}\n\n\tstatic updateRateLimitState(\n\t\tuserId: UserId,\n\t\tstate: { messageCount: number; resetTime: number; cooldownUntil?: number }\n\t): void {\n\t\tconst key = `user_session:${userId}`;\n\t\tconst cached = this.getCache<UserSessionCache>(key);\n\n\t\tif (cached) {\n\t\t\tcached.rateLimitState = state;\n\t\t\tconst version = this.generateVersion();\n\t\t\tthis.setCache(key, cached, this.USER_SESSION_TTL, version);\n\t\t}\n\t}\n\n\t/**\n\t * Room configuration caching\n\t */\n\tstatic cacheRoomConfig(roomId: RoomId, config: any): void {\n\t\tconst key = `room_config:${roomId}`;\n\t\tconst version = this.generateVersion();\n\n\t\tthis.setCache(key, config, this.ROOM_CONFIG_TTL, version);\n\t\tlogger.debug('ShoutboxCacheService', 'Cached room config', { roomId });\n\t}\n\n\tstatic getCachedRoomConfig(roomId: RoomId): any | null {\n\t\tconst key = `room_config:${roomId}`;\n\t\treturn this.getCache(key);\n\t}\n\n\tstatic invalidateRoomConfig(roomId?: RoomId): void {\n\t\tif (roomId) {\n\t\t\tconst key = `room_config:${roomId}`;\n\t\t\tthis.deleteCache(key);\n\t\t\tlogger.debug('ShoutboxCacheService', 'Invalidated room config', { roomId });\n\t\t} else {\n\t\t\t// Invalidate all room configs\n\t\t\tconst keys = Array.from(this.cache.keys()).filter((k) => k.startsWith('room_config:'));\n\t\t\tkeys.forEach((key) => this.deleteCache(key));\n\t\t\tlogger.debug('ShoutboxCacheService', 'Invalidated all room configs');\n\t\t}\n\t}\n\n\t/**\n\t * Room access and online users\n\t */\n\tstatic cacheRoom(room: RoomCache): void {\n\t\tconst key = `room:${room.id}`;\n\t\tconst version = this.generateVersion();\n\n\t\tthis.setCache(key, room, this.DEFAULT_TTL, version);\n\t\tlogger.debug('ShoutboxCacheService', 'Cached room data', { roomId: room.id });\n\t}\n\n\tstatic getCachedRoom(roomId: RoomId): RoomCache | null {\n\t\tconst key = `room:${roomId}`;\n\t\treturn this.getCache<RoomCache>(key);\n\t}\n\n\tstatic addUserToRoom(roomId: RoomId, userId: UserId): void {\n\t\tconst key = `room:${roomId}`;\n\t\tconst cached = this.getCache<RoomCache>(key);\n\n\t\tif (cached) {\n\t\t\tcached.onlineUsers.add(userId);\n\t\t\tconst version = this.generateVersion();\n\t\t\tthis.setCache(key, cached, this.DEFAULT_TTL, version);\n\t\t}\n\t}\n\n\tstatic removeUserFromRoom(roomId: RoomId, userId: UserId): void {\n\t\tconst key = `room:${roomId}`;\n\t\tconst cached = this.getCache<RoomCache>(key);\n\n\t\tif (cached) {\n\t\t\tcached.onlineUsers.delete(userId);\n\t\t\tconst version = this.generateVersion();\n\t\t\tthis.setCache(key, cached, this.DEFAULT_TTL, version);\n\t\t}\n\t}\n\n\t/**\n\t * Typing indicators\n\t */\n\tstatic setTypingIndicator(roomId: RoomId, userId: UserId, username: string): void {\n\t\tconst key = `typing:${roomId}`;\n\t\tconst cached =\n\t\t\tthis.getCache<Map<UserId, { username: string; timestamp: number }>>(key) || new Map();\n\n\t\tcached.set(userId, { username, timestamp: Date.now() });\n\t\tconst version = this.generateVersion();\n\t\tthis.setCache(key, cached, 10000, version); // 10 seconds\n\n\t\t// Clean up expired typing indicators\n\t\tthis.cleanupTypingIndicators(roomId);\n\t}\n\n\tstatic removeTypingIndicator(roomId: RoomId, userId: UserId): void {\n\t\tconst key = `typing:${roomId}`;\n\t\tconst cached = this.getCache<Map<UserId, { username: string; timestamp: number }>>(key);\n\n\t\tif (cached) {\n\t\t\tcached.delete(userId);\n\t\t\tconst version = this.generateVersion();\n\t\t\tthis.setCache(key, cached, 10000, version);\n\t\t}\n\t}\n\n\tstatic getTypingIndicators(roomId: RoomId): string[] {\n\t\tconst key = `typing:${roomId}`;\n\t\tconst cached = this.getCache<Map<UserId, { username: string; timestamp: number }>>(key);\n\n\t\tif (!cached) return [];\n\n\t\t// Clean up expired indicators\n\t\tthis.cleanupTypingIndicators(roomId);\n\n\t\t// Return active usernames\n\t\treturn Array.from(cached.values()).map((t) => t.username);\n\t}\n\n\tprivate static cleanupTypingIndicators(roomId: RoomId): void {\n\t\tconst key = `typing:${roomId}`;\n\t\tconst cached = this.getCache<Map<UserId, { username: string; timestamp: number }>>(key);\n\n\t\tif (cached) {\n\t\t\tconst now = Date.now();\n\t\t\tconst expired = Array.from(cached.entries()).filter(\n\t\t\t\t([_, data]) => now - data.timestamp > 5000\n\t\t\t);\n\n\t\t\tif (expired.length > 0) {\n\t\t\t\texpired.forEach(([userId]) => cached.delete(userId));\n\t\t\t\tconst version = this.generateVersion();\n\t\t\t\tthis.setCache(key, cached, 10000, version);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Performance monitoring\n\t */\n\tstatic getCacheStats(): {\n\t\tsize: number;\n\t\thitRate: number;\n\t\tmemoryUsage: string;\n\t\ttopKeys: string[];\n\t} {\n\t\tconst size = this.cache.size;\n\t\tconst memoryUsage = this.estimateMemoryUsage();\n\n\t\t// Get most accessed keys (would need hit tracking in production)\n\t\tconst topKeys = Array.from(this.cache.keys()).slice(0, 10);\n\n\t\treturn {\n\t\t\tsize,\n\t\t\thitRate: 0, // Would need hit/miss tracking\n\t\t\tmemoryUsage,\n\t\t\ttopKeys\n\t\t};\n\t}\n\n\tstatic clearExpiredEntries(): number {\n\t\tconst now = Date.now();\n\t\tconst expired = Array.from(this.cache.entries())\n\t\t\t.filter(([_, item]) => item.expiry < now)\n\t\t\t.map(([key]) => key);\n\n\t\texpired.forEach((key) => this.cache.delete(key));\n\n\t\tif (expired.length > 0) {\n\t\t\tlogger.debug('ShoutboxCacheService', 'Cleared expired entries', { count: expired.length });\n\t\t}\n\n\t\treturn expired.length;\n\t}\n\n\tstatic clearAll(): void {\n\t\tthis.cache.clear();\n\t\tlogger.info('ShoutboxCacheService', 'Cleared all cache entries');\n\t}\n\n\t/**\n\t * Core cache operations\n\t */\n\tprivate static setCache<T>(key: string, data: T, ttl: number, version: string): void {\n\t\tconst expiry = Date.now() + ttl;\n\t\tthis.cache.set(key, { data, expiry, version });\n\n\t\t// LRU eviction if cache gets too large\n\t\tif (this.cache.size > 10000) {\n\t\t\tthis.evictLRU();\n\t\t}\n\t}\n\n\tprivate static getCache<T>(key: string): T | null {\n\t\tconst item = this.cache.get(key);\n\n\t\tif (!item) return null;\n\n\t\tif (Date.now() > item.expiry) {\n\t\t\tthis.cache.delete(key);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn item.data as T;\n\t}\n\n\tprivate static deleteCache(key: string): void {\n\t\tthis.cache.delete(key);\n\t}\n\n\tprivate static generateVersion(): string {\n\t\treturn createHash('md5').update(Date.now().toString()).digest('hex').substring(0, 8);\n\t}\n\n\tprivate static evictLRU(): void {\n\t\t// Simple eviction - remove oldest entries\n\t\tconst entries = Array.from(this.cache.entries());\n\t\tconst toRemove = entries.sort((a, b) => a[1].expiry - b[1].expiry).slice(0, 1000);\n\n\t\ttoRemove.forEach(([key]) => this.cache.delete(key));\n\n\t\tlogger.debug('ShoutboxCacheService', 'Evicted LRU entries', { count: toRemove.length });\n\t}\n\n\tprivate static estimateMemoryUsage(): string {\n\t\tconst approxSize = JSON.stringify(Array.from(this.cache.entries())).length;\n\t\tconst mb = approxSize / (1024 * 1024);\n\t\treturn `${mb.toFixed(2)} MB`;\n\t}\n}\n\n// Cleanup interval\nsetInterval(() => {\n\tShoutboxCacheService.clearExpiredEntries();\n}, 60000); // Every minute\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shoutbox/services/history.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shoutboxAnalytics' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":62,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":79},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'or' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'not' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":74,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":77},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pipeline' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'compressedPath' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":431,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":431,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'compressedPath' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":537,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":537,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'compressedPath' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":621,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":621,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'compressedPath' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":757,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":757,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { UserId } from '@shared/types';\n/**\n * Message History Service\n *\n * Handles:\n * - Scalable message history with pagination\n * - Configurable retention policies\n * - Message archiving and cleanup\n * - Export functionality in multiple formats\n * - Performance-optimized queries\n */\n\nimport { db } from '@db';\nimport { shoutboxMessages, shoutboxConfig, chatRooms, users, shoutboxAnalytics } from '@schema';\nimport { eq, and, or, desc, asc, sql, gt, lt, gte, lte, isNull, inArray, not } from 'drizzle-orm';\nimport { logger } from '@server/src/core/logger';\nimport { createWriteStream } from 'fs';\nimport { pipeline } from 'stream/promises';\nimport { Transform } from 'stream';\nimport archiver from 'archiver';\nimport { format } from 'date-fns';\nimport type { RoomId } from '@shared/types';\nimport { UserId } from \"@shared/types\";\n\ninterface MessageHistoryOptions {\n\troomId?: RoomId;\n\tuserId?: UserId;\n\tdateFrom?: Date;\n\tdateTo?: Date;\n\tincludeDeleted?: boolean;\n\tlimit?: number;\n\toffset?: number;\n\tcursor?: number;\n\tdirection?: 'before' | 'after';\n\tsortOrder?: 'asc' | 'desc';\n}\n\ninterface ExportOptions {\n\tformat: 'json' | 'csv' | 'txt' | 'html';\n\troomId?: RoomId;\n\tdateFrom?: Date;\n\tdateTo?: Date;\n\tincludeDeleted?: boolean;\n\tincludeUserData?: boolean;\n\tcompress?: boolean;\n}\n\ninterface MessageWithUser {\n\tid: UserId;\n\tuserId: UserId | null;\n\troomId: RoomId;\n\tcontent: string;\n\tcreatedAt: Date;\n\teditedAt: Date | null;\n\tisDeleted: boolean;\n\tisPinned: boolean;\n\ttipAmount: number | null;\n\tuser?: {\n\t\tusername: string;\n\t\tlevel: number;\n\t\troles?: string[];\n\t};\n\troom?: {\n\t\tname: string;\n\t};\n}\n\nexport class MessageHistoryService {\n\tprivate static readonly BATCH_SIZE = 1000;\n\tprivate static readonly MAX_EXPORT_SIZE = 1000000; // 1M messages max\n\n\t/**\n\t * Get paginated message history with cursor-based pagination\n\t */\n\tstatic async getMessageHistory(options: MessageHistoryOptions): Promise<{\n\t\tmessages: MessageWithUser[];\n\t\thasMore: boolean;\n\t\tnextCursor?: number;\n\t\tpreviousCursor?: number;\n\t\ttotalCount?: number;\n\t}> {\n\t\ttry {\n\t\t\tconst {\n\t\t\t\troomId,\n\t\t\t\tuserId,\n\t\t\t\tdateFrom,\n\t\t\t\tdateTo,\n\t\t\t\tincludeDeleted = false,\n\t\t\t\tlimit = 50,\n\t\t\t\tcursor,\n\t\t\t\tdirection = 'before',\n\t\t\t\tsortOrder = 'desc'\n\t\t\t} = options;\n\n\t\t\t// Build query conditions\n\t\t\tconst conditions = [];\n\n\t\t\tif (roomId) {\n\t\t\t\tconditions.push(eq(shoutboxMessages.roomId, roomId));\n\t\t\t}\n\n\t\t\tif (userId) {\n\t\t\t\tconditions.push(eq(shoutboxMessages.userId, userId));\n\t\t\t}\n\n\t\t\tif (!includeDeleted) {\n\t\t\t\tconditions.push(eq(shoutboxMessages.isDeleted, false));\n\t\t\t}\n\n\t\t\tif (dateFrom) {\n\t\t\t\tconditions.push(gte(shoutboxMessages.createdAt, dateFrom));\n\t\t\t}\n\n\t\t\tif (dateTo) {\n\t\t\t\tconditions.push(lte(shoutboxMessages.createdAt, dateTo));\n\t\t\t}\n\n\t\t\t// Cursor-based pagination\n\t\t\tif (cursor) {\n\t\t\t\tif (direction === 'before') {\n\t\t\t\t\tconditions.push(lt(shoutboxMessages.id, cursor));\n\t\t\t\t} else {\n\t\t\t\t\tconditions.push(gt(shoutboxMessages.id, cursor));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst whereClause = conditions.length > 0 ? and(...conditions) : undefined;\n\n\t\t\t// Execute query with limit + 1 to check if there are more results\n\t\t\tconst messages = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: shoutboxMessages.id,\n\t\t\t\t\tuserId: shoutboxMessages.userId,\n\t\t\t\t\troomId: shoutboxMessages.roomId,\n\t\t\t\t\tcontent: shoutboxMessages.content,\n\t\t\t\t\tcreatedAt: shoutboxMessages.createdAt,\n\t\t\t\t\teditedAt: shoutboxMessages.editedAt,\n\t\t\t\t\tisDeleted: shoutboxMessages.isDeleted,\n\t\t\t\t\tisPinned: shoutboxMessages.isPinned,\n\t\t\t\t\ttipAmount: shoutboxMessages.tipAmount,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tuserLevel: users.level,\n\t\t\t\t\tuserRoles: users.roles,\n\t\t\t\t\troomName: chatRooms.name\n\t\t\t\t})\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.leftJoin(users, eq(shoutboxMessages.userId, users.id))\n\t\t\t\t.leftJoin(chatRooms, eq(shoutboxMessages.roomId, chatRooms.id))\n\t\t\t\t.where(whereClause)\n\t\t\t\t.orderBy(sortOrder === 'desc' ? desc(shoutboxMessages.id) : asc(shoutboxMessages.id))\n\t\t\t\t.limit(limit + 1);\n\n\t\t\t// Check if there are more results\n\t\t\tconst hasMore = messages.length > limit;\n\t\t\tconst resultMessages = hasMore ? messages.slice(0, limit) : messages;\n\n\t\t\t// Format messages\n\t\t\tconst formattedMessages: MessageWithUser[] = resultMessages.map((msg) => ({\n\t\t\t\tid: msg.id,\n\t\t\t\tuserId: msg.userId,\n\t\t\t\troomId: msg.roomId,\n\t\t\t\tcontent: msg.content,\n\t\t\t\tcreatedAt: msg.createdAt,\n\t\t\t\teditedAt: msg.editedAt,\n\t\t\t\tisDeleted: msg.isDeleted,\n\t\t\t\tisPinned: msg.isPinned,\n\t\t\t\ttipAmount: msg.tipAmount,\n\t\t\t\tuser: msg.userId\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tusername: msg.username || 'Unknown',\n\t\t\t\t\t\t\tlevel: msg.userLevel || 1,\n\t\t\t\t\t\t\troles: msg.userRoles\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t\troom: {\n\t\t\t\t\tname: msg.roomName || 'Unknown Room'\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\t// Determine cursors\n\t\t\tconst nextCursor =\n\t\t\t\thasMore && resultMessages.length > 0\n\t\t\t\t\t? resultMessages[resultMessages.length - 1].id\n\t\t\t\t\t: undefined;\n\n\t\t\tconst previousCursor = cursor && resultMessages.length > 0 ? resultMessages[0].id : undefined;\n\n\t\t\treturn {\n\t\t\t\tmessages: formattedMessages,\n\t\t\t\thasMore,\n\t\t\t\tnextCursor,\n\t\t\t\tpreviousCursor\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('MessageHistoryService', 'Error fetching message history', { error, options });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Clean up old messages based on retention policy\n\t */\n\tstatic async cleanupOldMessages(): Promise<{\n\t\tdeletedCount: number;\n\t\tarchivedCount: number;\n\t}> {\n\t\ttry {\n\t\t\t// Get retention settings for each room\n\t\t\tconst configs = await db.query.shoutboxConfig.findMany({\n\t\t\t\twhere: eq(shoutboxConfig.enabled, true)\n\t\t\t});\n\n\t\t\tlet totalDeleted = 0;\n\t\t\tlet totalArchived = 0;\n\n\t\t\tfor (const config of configs) {\n\t\t\t\tconst retentionDays = config.messageRetentionDays || 365;\n\t\t\t\tconst cutoffDate = new Date();\n\t\t\t\tcutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n\n\t\t\t\t// Archive messages before deletion (optional - could write to separate archive table)\n\t\t\t\tconst messagesToDelete = await db\n\t\t\t\t\t.select({\n\t\t\t\t\t\tid: shoutboxMessages.id,\n\t\t\t\t\t\tcontent: shoutboxMessages.content,\n\t\t\t\t\t\tuserId: shoutboxMessages.userId,\n\t\t\t\t\t\troomId: shoutboxMessages.roomId,\n\t\t\t\t\t\tcreatedAt: shoutboxMessages.createdAt\n\t\t\t\t\t})\n\t\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\tconfig.roomId ? eq(shoutboxMessages.roomId, config.roomId) : undefined,\n\t\t\t\t\t\t\tlt(shoutboxMessages.createdAt, cutoffDate),\n\t\t\t\t\t\t\teq(shoutboxMessages.isDeleted, false)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t.limit(this.BATCH_SIZE);\n\n\t\t\t\tif (messagesToDelete.length > 0) {\n\t\t\t\t\t// Archive messages (implement actual archiving logic here)\n\t\t\t\t\ttotalArchived += messagesToDelete.length;\n\n\t\t\t\t\t// Soft delete old messages\n\t\t\t\t\tawait db\n\t\t\t\t\t\t.update(shoutboxMessages)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tisDeleted: true,\n\t\t\t\t\t\t\teditedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(\n\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\tinArray(\n\t\t\t\t\t\t\t\t\tshoutboxMessages.id,\n\t\t\t\t\t\t\t\t\tmessagesToDelete.map((m) => m.id)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\ttotalDeleted += messagesToDelete.length;\n\n\t\t\t\t\tlogger.info('MessageHistoryService', 'Cleaned up old messages', {\n\t\t\t\t\t\troomId: config.roomId,\n\t\t\t\t\t\tretentionDays,\n\t\t\t\t\t\tdeletedCount: messagesToDelete.length\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdeletedCount: totalDeleted,\n\t\t\t\tarchivedCount: totalArchived\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('MessageHistoryService', 'Error cleaning up old messages', { error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Export message history in various formats\n\t */\n\tstatic async exportMessageHistory(options: ExportOptions): Promise<{\n\t\tfilename: string;\n\t\tsize: number;\n\t\tformat: string;\n\t}> {\n\t\ttry {\n\t\t\tconst {\n\t\t\t\tformat,\n\t\t\t\troomId,\n\t\t\t\tdateFrom,\n\t\t\t\tdateTo,\n\t\t\t\tincludeDeleted = false,\n\t\t\t\tincludeUserData = true,\n\t\t\t\tcompress = false\n\t\t\t} = options;\n\n\t\t\t// Build query conditions\n\t\t\tconst conditions = [];\n\n\t\t\tif (roomId) {\n\t\t\t\tconditions.push(eq(shoutboxMessages.roomId, roomId));\n\t\t\t}\n\n\t\t\tif (!includeDeleted) {\n\t\t\t\tconditions.push(eq(shoutboxMessages.isDeleted, false));\n\t\t\t}\n\n\t\t\tif (dateFrom) {\n\t\t\t\tconditions.push(gte(shoutboxMessages.createdAt, dateFrom));\n\t\t\t}\n\n\t\t\tif (dateTo) {\n\t\t\t\tconditions.push(lte(shoutboxMessages.createdAt, dateTo));\n\t\t\t}\n\n\t\t\tconst whereClause = conditions.length > 0 ? and(...conditions) : undefined;\n\n\t\t\t// Generate filename\n\t\t\tconst timestamp = format(new Date(), 'yyyy-MM-dd-HHmmss');\n\t\t\tconst baseFilename = `shoutbox-export-${timestamp}`;\n\t\t\tconst extension = compress ? 'zip' : format;\n\t\t\tconst filename = `${baseFilename}.${extension}`;\n\n\t\t\tswitch (format) {\n\t\t\t\tcase 'json':\n\t\t\t\t\treturn await this.exportAsJSON(whereClause, filename, includeUserData, compress);\n\n\t\t\t\tcase 'csv':\n\t\t\t\t\treturn await this.exportAsCSV(whereClause, filename, includeUserData, compress);\n\n\t\t\t\tcase 'txt':\n\t\t\t\t\treturn await this.exportAsText(whereClause, filename, includeUserData, compress);\n\n\t\t\t\tcase 'html':\n\t\t\t\t\treturn await this.exportAsHTML(whereClause, filename, includeUserData, compress);\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unsupported export format: ${format}`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('MessageHistoryService', 'Error exporting message history', { error, options });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Export as JSON format\n\t */\n\tprivate static async exportAsJSON(\n\t\twhereClause: any,\n\t\tfilename: string,\n\t\tincludeUserData: boolean,\n\t\tcompress: boolean\n\t): Promise<{ filename: string; size: number; format: string }> {\n\t\tconst outputPath = `/tmp/${filename}`;\n\t\tconst writeStream = createWriteStream(outputPath);\n\n\t\t// Start JSON array\n\t\twriteStream.write('[\\n');\n\n\t\tlet offset = 0;\n\t\tlet isFirst = true;\n\t\tlet totalSize = 2; // For [ and ]\n\n\t\twhile (offset < this.MAX_EXPORT_SIZE) {\n\t\t\tconst batch = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: shoutboxMessages.id,\n\t\t\t\t\tuserId: shoutboxMessages.userId,\n\t\t\t\t\troomId: shoutboxMessages.roomId,\n\t\t\t\t\tcontent: shoutboxMessages.content,\n\t\t\t\t\tcreatedAt: shoutboxMessages.createdAt,\n\t\t\t\t\teditedAt: shoutboxMessages.editedAt,\n\t\t\t\t\tisDeleted: shoutboxMessages.isDeleted,\n\t\t\t\t\tisPinned: shoutboxMessages.isPinned,\n\t\t\t\t\ttipAmount: shoutboxMessages.tipAmount,\n\t\t\t\t\tusername: includeUserData ? users.username : sql<null>`NULL`,\n\t\t\t\t\tuserLevel: includeUserData ? users.level : sql<null>`NULL`,\n\t\t\t\t\troomName: chatRooms.name\n\t\t\t\t})\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.leftJoin(users, eq(shoutboxMessages.userId, users.id))\n\t\t\t\t.leftJoin(chatRooms, eq(shoutboxMessages.roomId, chatRooms.id))\n\t\t\t\t.where(whereClause)\n\t\t\t\t.orderBy(asc(shoutboxMessages.createdAt))\n\t\t\t\t.limit(this.BATCH_SIZE)\n\t\t\t\t.offset(offset);\n\n\t\t\tif (batch.length === 0) break;\n\n\t\t\tfor (const message of batch) {\n\t\t\t\tconst messageObj = {\n\t\t\t\t\tid: message.id,\n\t\t\t\t\tuserId: message.userId,\n\t\t\t\t\troomId: message.roomId,\n\t\t\t\t\troomName: message.roomName,\n\t\t\t\t\tcontent: message.content,\n\t\t\t\t\tcreatedAt: message.createdAt,\n\t\t\t\t\teditedAt: message.editedAt,\n\t\t\t\t\tisDeleted: message.isDeleted,\n\t\t\t\t\tisPinned: message.isPinned,\n\t\t\t\t\ttipAmount: message.tipAmount\n\t\t\t\t};\n\n\t\t\t\tif (includeUserData && message.userId) {\n\t\t\t\t\t(messageObj as any).user = {\n\t\t\t\t\t\tusername: message.username,\n\t\t\t\t\t\tlevel: message.userLevel\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tconst json = JSON.stringify(messageObj, null, 2);\n\t\t\t\tconst entry = isFirst ? json : `,\\n${json}`;\n\t\t\t\twriteStream.write(entry);\n\t\t\t\ttotalSize += entry.length;\n\t\t\t\tisFirst = false;\n\t\t\t}\n\n\t\t\toffset += batch.length;\n\n\t\t\tif (batch.length < this.BATCH_SIZE) break;\n\t\t}\n\n\t\t// End JSON array\n\t\twriteStream.write('\\n]');\n\t\tawait new Promise((resolve) => writeStream.end(resolve));\n\n\t\tif (compress) {\n\t\t\tconst compressedPath = await this.compressFile(outputPath, 'json');\n\t\t\treturn {\n\t\t\t\tfilename: `${filename}.zip`,\n\t\t\t\tsize: totalSize,\n\t\t\t\tformat: 'json'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tfilename,\n\t\t\tsize: totalSize,\n\t\t\tformat: 'json'\n\t\t};\n\t}\n\n\t/**\n\t * Export as CSV format\n\t */\n\tprivate static async exportAsCSV(\n\t\twhereClause: any,\n\t\tfilename: string,\n\t\tincludeUserData: boolean,\n\t\tcompress: boolean\n\t): Promise<{ filename: string; size: number; format: string }> {\n\t\tconst outputPath = `/tmp/${filename}`;\n\t\tconst writeStream = createWriteStream(outputPath);\n\n\t\t// Write CSV header\n\t\tconst headers = [\n\t\t\t'ID',\n\t\t\t'Room ID',\n\t\t\t'Room Name',\n\t\t\t'Content',\n\t\t\t'Created At',\n\t\t\t'Is Deleted',\n\t\t\t'Is Pinned',\n\t\t\t'Tip Amount'\n\t\t];\n\n\t\tif (includeUserData) {\n\t\t\theaders.push('User ID', 'Username', 'User Level');\n\t\t}\n\n\t\twriteStream.write(headers.join(',') + '\\n');\n\t\tlet totalSize = headers.join(',').length + 1;\n\n\t\tlet offset = 0;\n\n\t\twhile (offset < this.MAX_EXPORT_SIZE) {\n\t\t\tconst batch = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: shoutboxMessages.id,\n\t\t\t\t\tuserId: shoutboxMessages.userId,\n\t\t\t\t\troomId: shoutboxMessages.roomId,\n\t\t\t\t\tcontent: shoutboxMessages.content,\n\t\t\t\t\tcreatedAt: shoutboxMessages.createdAt,\n\t\t\t\t\tisDeleted: shoutboxMessages.isDeleted,\n\t\t\t\t\tisPinned: shoutboxMessages.isPinned,\n\t\t\t\t\ttipAmount: shoutboxMessages.tipAmount,\n\t\t\t\t\tusername: includeUserData ? users.username : sql<null>`NULL`,\n\t\t\t\t\tuserLevel: includeUserData ? users.level : sql<null>`NULL`,\n\t\t\t\t\troomName: chatRooms.name\n\t\t\t\t})\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.leftJoin(users, eq(shoutboxMessages.userId, users.id))\n\t\t\t\t.leftJoin(chatRooms, eq(shoutboxMessages.roomId, chatRooms.id))\n\t\t\t\t.where(whereClause)\n\t\t\t\t.orderBy(asc(shoutboxMessages.createdAt))\n\t\t\t\t.limit(this.BATCH_SIZE)\n\t\t\t\t.offset(offset);\n\n\t\t\tif (batch.length === 0) break;\n\n\t\t\tfor (const message of batch) {\n\t\t\t\tconst row = [\n\t\t\t\t\tmessage.id,\n\t\t\t\t\tmessage.roomId,\n\t\t\t\t\tmessage.roomName || '',\n\t\t\t\t\t`\"${(message.content || '').replace(/\"/g, '\"\"')}\"`,\n\t\t\t\t\tmessage.createdAt.toISOString(),\n\t\t\t\t\tmessage.isDeleted,\n\t\t\t\t\tmessage.isPinned,\n\t\t\t\t\tmessage.tipAmount || ''\n\t\t\t\t];\n\n\t\t\t\tif (includeUserData) {\n\t\t\t\t\trow.push(\n\t\t\t\t\t\tmessage.userId?.toString() || '',\n\t\t\t\t\t\tmessage.username || '',\n\t\t\t\t\t\tmessage.userLevel?.toString() || ''\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst line = row.join(',') + '\\n';\n\t\t\t\twriteStream.write(line);\n\t\t\t\ttotalSize += line.length;\n\t\t\t}\n\n\t\t\toffset += batch.length;\n\n\t\t\tif (batch.length < this.BATCH_SIZE) break;\n\t\t}\n\n\t\tawait new Promise((resolve) => writeStream.end(resolve));\n\n\t\tif (compress) {\n\t\t\tconst compressedPath = await this.compressFile(outputPath, 'csv');\n\t\t\treturn {\n\t\t\t\tfilename: `${filename}.zip`,\n\t\t\t\tsize: totalSize,\n\t\t\t\tformat: 'csv'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tfilename,\n\t\t\tsize: totalSize,\n\t\t\tformat: 'csv'\n\t\t};\n\t}\n\n\t/**\n\t * Export as plain text format\n\t */\n\tprivate static async exportAsText(\n\t\twhereClause: any,\n\t\tfilename: string,\n\t\tincludeUserData: boolean,\n\t\tcompress: boolean\n\t): Promise<{ filename: string; size: number; format: string }> {\n\t\tconst outputPath = `/tmp/${filename}`;\n\t\tconst writeStream = createWriteStream(outputPath);\n\n\t\t// Write header\n\t\tconst header =\n\t\t\t'DEGENTALK SHOUTBOX EXPORT\\n' +\n\t\t\t'========================\\n' +\n\t\t\t`Generated: ${new Date().toISOString()}\\n\\n`;\n\t\twriteStream.write(header);\n\t\tlet totalSize = header.length;\n\n\t\tlet offset = 0;\n\t\tlet currentRoom = '';\n\n\t\twhile (offset < this.MAX_EXPORT_SIZE) {\n\t\t\tconst batch = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: shoutboxMessages.id,\n\t\t\t\t\tuserId: shoutboxMessages.userId,\n\t\t\t\t\troomId: shoutboxMessages.roomId,\n\t\t\t\t\tcontent: shoutboxMessages.content,\n\t\t\t\t\tcreatedAt: shoutboxMessages.createdAt,\n\t\t\t\t\tusername: includeUserData ? users.username : sql<null>`NULL`,\n\t\t\t\t\troomName: chatRooms.name\n\t\t\t\t})\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.leftJoin(users, eq(shoutboxMessages.userId, users.id))\n\t\t\t\t.leftJoin(chatRooms, eq(shoutboxMessages.roomId, chatRooms.id))\n\t\t\t\t.where(whereClause)\n\t\t\t\t.orderBy(asc(shoutboxMessages.roomId), asc(shoutboxMessages.createdAt))\n\t\t\t\t.limit(this.BATCH_SIZE)\n\t\t\t\t.offset(offset);\n\n\t\t\tif (batch.length === 0) break;\n\n\t\t\tfor (const message of batch) {\n\t\t\t\t// Add room header if room changed\n\t\t\t\tif (message.roomName && message.roomName !== currentRoom) {\n\t\t\t\t\tcurrentRoom = message.roomName;\n\t\t\t\t\tconst roomHeader = `\\n--- ${currentRoom} ---\\n\\n`;\n\t\t\t\t\twriteStream.write(roomHeader);\n\t\t\t\t\ttotalSize += roomHeader.length;\n\t\t\t\t}\n\n\t\t\t\tconst timestamp = format(message.createdAt, 'yyyy-MM-dd HH:mm:ss');\n\t\t\t\tconst username = message.username || 'Unknown';\n\t\t\t\tconst line = `[${timestamp}] ${username}: ${message.content}\\n`;\n\n\t\t\t\twriteStream.write(line);\n\t\t\t\ttotalSize += line.length;\n\t\t\t}\n\n\t\t\toffset += batch.length;\n\n\t\t\tif (batch.length < this.BATCH_SIZE) break;\n\t\t}\n\n\t\tawait new Promise((resolve) => writeStream.end(resolve));\n\n\t\tif (compress) {\n\t\t\tconst compressedPath = await this.compressFile(outputPath, 'txt');\n\t\t\treturn {\n\t\t\t\tfilename: `${filename}.zip`,\n\t\t\t\tsize: totalSize,\n\t\t\t\tformat: 'txt'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tfilename,\n\t\t\tsize: totalSize,\n\t\t\tformat: 'txt'\n\t\t};\n\t}\n\n\t/**\n\t * Export as HTML format\n\t */\n\tprivate static async exportAsHTML(\n\t\twhereClause: any,\n\t\tfilename: string,\n\t\tincludeUserData: boolean,\n\t\tcompress: boolean\n\t): Promise<{ filename: string; size: number; format: string }> {\n\t\tconst outputPath = `/tmp/${filename}`;\n\t\tconst writeStream = createWriteStream(outputPath);\n\n\t\t// Write HTML header\n\t\tconst htmlHeader = `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Degentalk Shoutbox Export - ${new Date().toISOString()}</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 20px; }\n    .room { margin-bottom: 40px; }\n    .room-header { background: #f0f0f0; padding: 10px; font-weight: bold; }\n    .message { margin: 10px 0; padding: 10px; border-left: 3px solid #ddd; }\n    .message.pinned { background: #fffacd; border-left-color: #ffd700; }\n    .message.deleted { opacity: 0.5; }\n    .meta { color: #666; font-size: 0.9em; }\n    .content { margin-top: 5px; }\n  </style>\n</head>\n<body>\n<h1>Degentalk Shoutbox Export</h1>\n<p>Generated: ${new Date().toISOString()}</p>\n`;\n\n\t\twriteStream.write(htmlHeader);\n\t\tlet totalSize = htmlHeader.length;\n\n\t\tlet offset = 0;\n\t\tlet currentRoom = '';\n\t\tlet roomOpen = false;\n\n\t\twhile (offset < this.MAX_EXPORT_SIZE) {\n\t\t\tconst batch = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: shoutboxMessages.id,\n\t\t\t\t\tuserId: shoutboxMessages.userId,\n\t\t\t\t\troomId: shoutboxMessages.roomId,\n\t\t\t\t\tcontent: shoutboxMessages.content,\n\t\t\t\t\tcreatedAt: shoutboxMessages.createdAt,\n\t\t\t\t\tisDeleted: shoutboxMessages.isDeleted,\n\t\t\t\t\tisPinned: shoutboxMessages.isPinned,\n\t\t\t\t\tusername: includeUserData ? users.username : sql<null>`NULL`,\n\t\t\t\t\tuserLevel: includeUserData ? users.level : sql<null>`NULL`,\n\t\t\t\t\troomName: chatRooms.name\n\t\t\t\t})\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.leftJoin(users, eq(shoutboxMessages.userId, users.id))\n\t\t\t\t.leftJoin(chatRooms, eq(shoutboxMessages.roomId, chatRooms.id))\n\t\t\t\t.where(whereClause)\n\t\t\t\t.orderBy(asc(shoutboxMessages.roomId), asc(shoutboxMessages.createdAt))\n\t\t\t\t.limit(this.BATCH_SIZE)\n\t\t\t\t.offset(offset);\n\n\t\t\tif (batch.length === 0) break;\n\n\t\t\tfor (const message of batch) {\n\t\t\t\t// Add room section if room changed\n\t\t\t\tif (message.roomName && message.roomName !== currentRoom) {\n\t\t\t\t\tif (roomOpen) {\n\t\t\t\t\t\twriteStream.write('</div>\\n');\n\t\t\t\t\t\ttotalSize += 7;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentRoom = message.roomName;\n\t\t\t\t\tconst roomSection = `<div class=\"room\">\n<div class=\"room-header\">${currentRoom}</div>\\n`;\n\t\t\t\t\twriteStream.write(roomSection);\n\t\t\t\t\ttotalSize += roomSection.length;\n\t\t\t\t\troomOpen = true;\n\t\t\t\t}\n\n\t\t\t\tconst timestamp = format(message.createdAt, 'yyyy-MM-dd HH:mm:ss');\n\t\t\t\tconst username = message.username || 'Unknown';\n\t\t\t\tconst level = message.userLevel || 1;\n\n\t\t\t\tlet messageClass = 'message';\n\t\t\t\tif (message.isPinned) messageClass += ' pinned';\n\t\t\t\tif (message.isDeleted) messageClass += ' deleted';\n\n\t\t\t\tconst messageHtml = `<div class=\"${messageClass}\">\n  <div class=\"meta\">\n    <strong>${this.escapeHtml(username)}</strong> (Level ${level})\n    - ${timestamp}\n    ${message.isPinned ? '<span style=\"color: gold;\">📌 Pinned</span>' : ''}\n  </div>\n  <div class=\"content\">${this.escapeHtml(message.content)}</div>\n</div>\\n`;\n\n\t\t\t\twriteStream.write(messageHtml);\n\t\t\t\ttotalSize += messageHtml.length;\n\t\t\t}\n\n\t\t\toffset += batch.length;\n\n\t\t\tif (batch.length < this.BATCH_SIZE) break;\n\t\t}\n\n\t\t// Close open room div\n\t\tif (roomOpen) {\n\t\t\twriteStream.write('</div>\\n');\n\t\t\ttotalSize += 7;\n\t\t}\n\n\t\t// Write HTML footer\n\t\tconst htmlFooter = '</body>\\n</html>';\n\t\twriteStream.write(htmlFooter);\n\t\ttotalSize += htmlFooter.length;\n\n\t\tawait new Promise((resolve) => writeStream.end(resolve));\n\n\t\tif (compress) {\n\t\t\tconst compressedPath = await this.compressFile(outputPath, 'html');\n\t\t\treturn {\n\t\t\t\tfilename: `${filename}.zip`,\n\t\t\t\tsize: totalSize,\n\t\t\t\tformat: 'html'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tfilename,\n\t\t\tsize: totalSize,\n\t\t\tformat: 'html'\n\t\t};\n\t}\n\n\t/**\n\t * Compress file using archiver\n\t */\n\tprivate static async compressFile(filePath: string, format: string): Promise<string> {\n\t\tconst archive = archiver('zip', { zlib: { level: 9 } });\n\t\tconst outputPath = `${filePath}.zip`;\n\t\tconst output = createWriteStream(outputPath);\n\n\t\tarchive.pipe(output);\n\t\tarchive.file(filePath, { name: `shoutbox-export.${format}` });\n\n\t\tawait archive.finalize();\n\n\t\treturn outputPath;\n\t}\n\n\t/**\n\t * Escape HTML special characters\n\t */\n\tprivate static escapeHtml(text: string): string {\n\t\tconst map: Record<string, string> = {\n\t\t\t'&': '&amp;',\n\t\t\t'<': '&lt;',\n\t\t\t'>': '&gt;',\n\t\t\t'\"': '&quot;',\n\t\t\t\"'\": '&#039;'\n\t\t};\n\n\t\treturn text.replace(/[&<>\"']/g, (m) => map[m]);\n\t}\n\n\t/**\n\t * Get message statistics for analytics\n\t */\n\tstatic async getMessageStatistics(options: {\n\t\troomId?: RoomId;\n\t\tdateFrom?: Date;\n\t\tdateTo?: Date;\n\t\tgroupBy?: 'hour' | 'day' | 'week' | 'month';\n\t}): Promise<any> {\n\t\ttry {\n\t\t\tconst { roomId, dateFrom, dateTo, groupBy = 'day' } = options;\n\n\t\t\tconst conditions = [];\n\n\t\t\tif (roomId) {\n\t\t\t\tconditions.push(eq(shoutboxMessages.roomId, roomId));\n\t\t\t}\n\n\t\t\tif (dateFrom) {\n\t\t\t\tconditions.push(gte(shoutboxMessages.createdAt, dateFrom));\n\t\t\t}\n\n\t\t\tif (dateTo) {\n\t\t\t\tconditions.push(lte(shoutboxMessages.createdAt, dateTo));\n\t\t\t}\n\n\t\t\tconditions.push(eq(shoutboxMessages.isDeleted, false));\n\n\t\t\tconst whereClause = conditions.length > 0 ? and(...conditions) : undefined;\n\n\t\t\t// Group by time period\n\t\t\tlet dateFormat: any;\n\t\t\tswitch (groupBy) {\n\t\t\t\tcase 'hour':\n\t\t\t\t\tdateFormat = sql`to_char(${shoutboxMessages.createdAt}, 'YYYY-MM-DD HH24:00')`;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'week':\n\t\t\t\t\tdateFormat = sql`to_char(date_trunc('week', ${shoutboxMessages.createdAt}), 'YYYY-MM-DD')`;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'month':\n\t\t\t\t\tdateFormat = sql`to_char(${shoutboxMessages.createdAt}, 'YYYY-MM')`;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdateFormat = sql`to_char(${shoutboxMessages.createdAt}, 'YYYY-MM-DD')`;\n\t\t\t}\n\n\t\t\tconst stats = await db\n\t\t\t\t.select({\n\t\t\t\t\tperiod: dateFormat,\n\t\t\t\t\tmessageCount: sql<number>`COUNT(*)`,\n\t\t\t\t\tuniqueUsers: sql<number>`COUNT(DISTINCT ${shoutboxMessages.userId})`,\n\t\t\t\t\tavgMessagesPerUser: sql<number>`COUNT(*)::float / NULLIF(COUNT(DISTINCT ${shoutboxMessages.userId}), 0)`\n\t\t\t\t})\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.where(whereClause)\n\t\t\t\t.groupBy(dateFormat)\n\t\t\t\t.orderBy(asc(dateFormat));\n\n\t\t\treturn stats;\n\t\t} catch (error) {\n\t\t\tlogger.error('MessageHistoryService', 'Error getting message statistics', { error, options });\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shoutbox/services/performance.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chatRooms' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":17,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shoutboxConfig' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":17,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cacheKey' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":65,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":65,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cacheKey' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":291,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":291,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Optimization Service\n *\n * Provides:\n * - Database query optimization\n * - Connection pooling management\n * - Real-time performance monitoring\n * - Query caching and invalidation\n * - Performance metrics collection\n */\n\nimport { db } from '@db';\nimport type { UserId } from '@shared/types';\nimport { logger } from '@server/src/core/logger';\nimport { ShoutboxCacheService } from './cache.service';\nimport { eq, and, desc, asc, sql, gte, lte, inArray } from 'drizzle-orm';\nimport { shoutboxMessages, chatRooms, users, shoutboxConfig } from '@schema';\nimport type { RoomId } from '@shared/types';\nimport { UserId, EntityId } from \"@shared/types\";\n\ninterface QueryMetrics {\n\tqueryType: string;\n\texecutionTime: number;\n\trowsReturned: number;\n\tcacheHit: boolean;\n\ttimestamp: Date;\n}\n\ninterface PerformanceStats {\n\tavgQueryTime: number;\n\tcacheHitRate: number;\n\tqueriesPerSecond: number;\n\tactiveConnections: number;\n\tmemoryUsage: number;\n\ttopSlowQueries: Array<{\n\t\tquery: string;\n\t\tavgTime: number;\n\t\tcount: number;\n\t}>;\n}\n\ninterface OptimizedMessageQuery {\n\troomId: RoomId;\n\tlimit?: number;\n\tcursor?: number;\n\tdirection?: 'before' | 'after';\n\tincludeDeleted?: boolean;\n\tuserId?: UserId;\n}\n\nexport class PerformanceService {\n\tprivate static queryMetrics: QueryMetrics[] = [];\n\tprivate static readonly MAX_METRICS = 10000;\n\tprivate static connectionPool: any = null;\n\n\t/**\n\t * Optimized message retrieval with intelligent caching\n\t */\n\tstatic async getOptimizedMessages(options: OptimizedMessageQuery): Promise<{\n\t\tdata: any[];\n\t\tmeta: { count: number; hasMore: boolean; nextCursor?: number };\n\t\tfromCache: boolean;\n\t}> {\n\t\tconst startTime = Date.now();\n\t\tconst cacheKey = this.generateCacheKey('messages', options);\n\n\t\t// Try cache first\n\t\tconst cached = ShoutboxCacheService.getCachedMessages(options.roomId);\n\t\tif (cached && this.isCacheValid(options, cached)) {\n\t\t\tconst filtered = this.applyFiltersToCache(cached, options);\n\n\t\t\tthis.recordQueryMetric({\n\t\t\t\tqueryType: 'messages_cached',\n\t\t\t\texecutionTime: Date.now() - startTime,\n\t\t\t\trowsReturned: filtered.length,\n\t\t\t\tcacheHit: true,\n\t\t\t\ttimestamp: new Date()\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tdata: filtered,\n\t\t\t\tmeta: {\n\t\t\t\t\tcount: filtered.length,\n\t\t\t\t\thasMore: filtered.length >= (options.limit || 50),\n\t\t\t\t\tnextCursor: filtered.length > 0 ? filtered[filtered.length - 1].id : undefined\n\t\t\t\t},\n\t\t\t\tfromCache: true\n\t\t\t};\n\t\t}\n\n\t\t// Database query with optimizations\n\t\tconst result = await this.executeOptimizedQuery(options);\n\n\t\t// Cache the result\n\t\tawait ShoutboxCacheService.cacheMessages(options.roomId, result.data);\n\n\t\tthis.recordQueryMetric({\n\t\t\tqueryType: 'messages_db',\n\t\t\texecutionTime: Date.now() - startTime,\n\t\t\trowsReturned: result.data.length,\n\t\t\tcacheHit: false,\n\t\t\ttimestamp: new Date()\n\t\t});\n\n\t\treturn {\n\t\t\t...result,\n\t\t\tfromCache: false\n\t\t};\n\t}\n\n\t/**\n\t * Execute optimized database query\n\t */\n\tprivate static async executeOptimizedQuery(options: OptimizedMessageQuery): Promise<{\n\t\tdata: any[];\n\t\tmeta: { count: number; hasMore: boolean; nextCursor?: number };\n\t}> {\n\t\tconst {\n\t\t\troomId,\n\t\t\tlimit = 50,\n\t\t\tcursor,\n\t\t\tdirection = 'before',\n\t\t\tincludeDeleted = false,\n\t\t\tuserId\n\t\t} = options;\n\n\t\t// Build optimized query conditions\n\t\tconst conditions = [eq(shoutboxMessages.roomId, roomId)];\n\n\t\tif (!includeDeleted) {\n\t\t\tconditions.push(eq(shoutboxMessages.isDeleted, false));\n\t\t}\n\n\t\tif (userId) {\n\t\t\tconditions.push(eq(shoutboxMessages.userId, userId));\n\t\t}\n\n\t\tif (cursor) {\n\t\t\tconditions.push(\n\t\t\t\tdirection === 'before'\n\t\t\t\t\t? sql`${shoutboxMessages.id} < ${cursor}`\n\t\t\t\t\t: sql`${shoutboxMessages.id} > ${cursor}`\n\t\t\t);\n\t\t}\n\n\t\t// Use prepared statement for better performance\n\t\tconst query = db\n\t\t\t.select({\n\t\t\t\tid: shoutboxMessages.id,\n\t\t\t\tuserId: shoutboxMessages.userId,\n\t\t\t\troomId: shoutboxMessages.roomId,\n\t\t\t\tcontent: shoutboxMessages.content,\n\t\t\t\tcreatedAt: shoutboxMessages.createdAt,\n\t\t\t\teditedAt: shoutboxMessages.editedAt,\n\t\t\t\tisDeleted: shoutboxMessages.isDeleted,\n\t\t\t\tisPinned: shoutboxMessages.isPinned,\n\t\t\t\ttipAmount: shoutboxMessages.tipAmount,\n\t\t\t\tusername: users.username,\n\t\t\t\tuserLevel: users.level,\n\t\t\t\tuserRoles: users.roles,\n\t\t\t\tusernameColor: users.usernameColor,\n\t\t\t\tavatarUrl: users.avatarUrl\n\t\t\t})\n\t\t\t.from(shoutboxMessages)\n\t\t\t.leftJoin(users, eq(shoutboxMessages.userId, users.id))\n\t\t\t.where(and(...conditions))\n\t\t\t.orderBy(desc(shoutboxMessages.id))\n\t\t\t.limit(limit + 1); // +1 to check for more results\n\n\t\tconst results = await query;\n\n\t\t// Check if there are more results\n\t\tconst hasMore = results.length > limit;\n\t\tconst data = hasMore ? results.slice(0, limit) : results;\n\n\t\t// Transform to expected format\n\t\tconst transformedData = data.map((row) => ({\n\t\t\tid: row.id,\n\t\t\tuserId: row.userId,\n\t\t\troomId: row.roomId,\n\t\t\tcontent: row.content,\n\t\t\tcreatedAt: row.createdAt,\n\t\t\teditedAt: row.editedAt,\n\t\t\tisDeleted: row.isDeleted,\n\t\t\tisPinned: row.isPinned,\n\t\t\ttipAmount: row.tipAmount,\n\t\t\tuser: row.userId\n\t\t\t\t? {\n\t\t\t\t\t\tusername: row.username || 'Unknown',\n\t\t\t\t\t\tlevel: row.userLevel || 1,\n\t\t\t\t\t\troles: row.userRoles || [],\n\t\t\t\t\t\tusernameColor: row.usernameColor,\n\t\t\t\t\t\tavatarUrl: row.avatarUrl\n\t\t\t\t\t}\n\t\t\t\t: null\n\t\t}));\n\n\t\treturn {\n\t\t\tdata: transformedData,\n\t\t\tmeta: {\n\t\t\t\tcount: data.length,\n\t\t\t\thasMore,\n\t\t\t\tnextCursor: data.length > 0 ? data[data.length - 1].id : undefined\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Batch message operations for efficiency\n\t */\n\tstatic async batchInsertMessages(\n\t\tmessages: Array<{\n\t\t\tuserId: UserId;\n\t\t\troomId: RoomId;\n\t\t\tcontent: string;\n\t\t\ttype?: string;\n\t\t\tmetadata?: any;\n\t\t}>\n\t): Promise<{ insertedIds: number[]; errors: any[] }> {\n\t\tconst startTime = Date.now();\n\t\tconst insertedIds: number[] = [];\n\t\tconst errors: any[] = [];\n\n\t\ttry {\n\t\t\t// Use database transaction for consistency\n\t\t\tconst result = await db.transaction(async (tx) => {\n\t\t\t\tconst insertPromises = messages.map(async (message) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst [inserted] = await tx\n\t\t\t\t\t\t\t.insert(shoutboxMessages)\n\t\t\t\t\t\t\t.values({\n\t\t\t\t\t\t\t\tuserId: message.userId,\n\t\t\t\t\t\t\t\troomId: message.roomId,\n\t\t\t\t\t\t\t\tcontent: message.content,\n\t\t\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\t\t\tisDeleted: false,\n\t\t\t\t\t\t\t\tisPinned: false\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.returning({ id: shoutboxMessages.id });\n\n\t\t\t\t\t\treturn inserted.id;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\terrors.push({ message, error });\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconst results = await Promise.all(insertPromises);\n\t\t\t\treturn results.filter((id) => id !== null) as number[];\n\t\t\t});\n\n\t\t\tinsertedIds.push(...result);\n\n\t\t\t// Invalidate cache for affected rooms\n\t\t\tconst affectedRooms = new Set(messages.map((m) => m.roomId));\n\t\t\taffectedRooms.forEach((roomId) => {\n\t\t\t\tShoutboxCacheService.invalidateMessages(roomId);\n\t\t\t});\n\n\t\t\tthis.recordQueryMetric({\n\t\t\t\tqueryType: 'batch_insert',\n\t\t\t\texecutionTime: Date.now() - startTime,\n\t\t\t\trowsReturned: insertedIds.length,\n\t\t\t\tcacheHit: false,\n\t\t\t\ttimestamp: new Date()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('PerformanceService', 'Batch insert failed', {\n\t\t\t\terror,\n\t\t\t\tmessageCount: messages.length\n\t\t\t});\n\t\t\terrors.push({ error, messages });\n\t\t}\n\n\t\treturn { insertedIds, errors };\n\t}\n\n\t/**\n\t * Optimized user session management\n\t */\n\tstatic async getActiveUsersInRoom(roomId: RoomId): Promise<\n\t\tArray<{\n\t\t\tid: EntityId;\n\t\t\tusername: string;\n\t\t\tlevel: number;\n\t\t\troles: string[];\n\t\t\tlastSeen: Date;\n\t\t}>\n\t> {\n\t\tconst startTime = Date.now();\n\t\tconst cacheKey = `active_users:${roomId}`;\n\n\t\t// Try cache first\n\t\tconst cached = ShoutboxCacheService.getCachedRoom(roomId);\n\t\tif (cached && cached.onlineUsers.size > 0) {\n\t\t\t// Get user details for online users\n\t\t\tconst userIds = Array.from(cached.onlineUsers);\n\n\t\t\tconst users = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\troles: users.roles,\n\t\t\t\t\tlastSeen: users.lastActiveAt\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(inArray(users.id, userIds));\n\n\t\t\tthis.recordQueryMetric({\n\t\t\t\tqueryType: 'active_users_optimized',\n\t\t\t\texecutionTime: Date.now() - startTime,\n\t\t\t\trowsReturned: users.length,\n\t\t\t\tcacheHit: true,\n\t\t\t\ttimestamp: new Date()\n\t\t\t});\n\n\t\t\treturn users.map((user) => ({\n\t\t\t\tid: user.id,\n\t\t\t\tusername: user.username,\n\t\t\t\tlevel: user.level || 1,\n\t\t\t\troles: user.roles || [],\n\t\t\t\tlastSeen: user.lastSeen || new Date()\n\t\t\t}));\n\t\t}\n\n\t\t// Fallback to recent activity query\n\t\tconst recentActiveTime = new Date(Date.now() - 5 * 60 * 1000); // 5 minutes\n\n\t\tconst activeUsers = await db\n\t\t\t.select({\n\t\t\t\tid: users.id,\n\t\t\t\tusername: users.username,\n\t\t\t\tlevel: users.level,\n\t\t\t\troles: users.roles,\n\t\t\t\tlastSeen: users.lastActiveAt\n\t\t\t})\n\t\t\t.from(users)\n\t\t\t.innerJoin(shoutboxMessages, eq(users.id, shoutboxMessages.userId))\n\t\t\t.where(\n\t\t\t\tand(eq(shoutboxMessages.roomId, roomId), gte(shoutboxMessages.createdAt, recentActiveTime))\n\t\t\t)\n\t\t\t.groupBy(users.id, users.username, users.level, users.roles, users.lastActiveAt);\n\n\t\tthis.recordQueryMetric({\n\t\t\tqueryType: 'active_users_db',\n\t\t\texecutionTime: Date.now() - startTime,\n\t\t\trowsReturned: activeUsers.length,\n\t\t\tcacheHit: false,\n\t\t\ttimestamp: new Date()\n\t\t});\n\n\t\treturn activeUsers.map((user) => ({\n\t\t\tid: user.id,\n\t\t\tusername: user.username,\n\t\t\tlevel: user.level || 1,\n\t\t\troles: user.roles || [],\n\t\t\tlastSeen: user.lastSeen || new Date()\n\t\t}));\n\t}\n\n\t/**\n\t * Performance monitoring and metrics\n\t */\n\tstatic getPerformanceStats(): PerformanceStats {\n\t\tconst now = Date.now();\n\t\tconst oneMinuteAgo = now - 60000;\n\n\t\t// Filter recent metrics\n\t\tconst recentMetrics = this.queryMetrics.filter((m) => m.timestamp.getTime() > oneMinuteAgo);\n\n\t\t// Calculate statistics\n\t\tconst totalQueries = recentMetrics.length;\n\t\tconst avgQueryTime =\n\t\t\ttotalQueries > 0\n\t\t\t\t? recentMetrics.reduce((sum, m) => sum + m.executionTime, 0) / totalQueries\n\t\t\t\t: 0;\n\n\t\tconst cacheHits = recentMetrics.filter((m) => m.cacheHit).length;\n\t\tconst cacheHitRate = totalQueries > 0 ? (cacheHits / totalQueries) * 100 : 0;\n\n\t\tconst queriesPerSecond = totalQueries / 60;\n\n\t\t// Top slow queries\n\t\tconst queryGroups = new Map<string, { totalTime: number; count: number }>();\n\t\trecentMetrics.forEach((metric) => {\n\t\t\tconst existing = queryGroups.get(metric.queryType) || { totalTime: 0, count: 0 };\n\t\t\tqueryGroups.set(metric.queryType, {\n\t\t\t\ttotalTime: existing.totalTime + metric.executionTime,\n\t\t\t\tcount: existing.count + 1\n\t\t\t});\n\t\t});\n\n\t\tconst topSlowQueries = Array.from(queryGroups.entries())\n\t\t\t.map(([query, stats]) => ({\n\t\t\t\tquery,\n\t\t\t\tavgTime: stats.totalTime / stats.count,\n\t\t\t\tcount: stats.count\n\t\t\t}))\n\t\t\t.sort((a, b) => b.avgTime - a.avgTime)\n\t\t\t.slice(0, 5);\n\n\t\treturn {\n\t\t\tavgQueryTime,\n\t\t\tcacheHitRate,\n\t\t\tqueriesPerSecond,\n\t\t\tactiveConnections: this.getActiveConnections(),\n\t\t\tmemoryUsage: this.getMemoryUsage(),\n\t\t\ttopSlowQueries\n\t\t};\n\t}\n\n\t/**\n\t * Query optimization suggestions\n\t */\n\tstatic analyzeQueryPerformance(): Array<{\n\t\tissue: string;\n\t\tsuggestion: string;\n\t\timpact: 'low' | 'medium' | 'high';\n\t}> {\n\t\tconst suggestions: Array<{\n\t\t\tissue: string;\n\t\t\tsuggestion: string;\n\t\t\timpact: 'low' | 'medium' | 'high';\n\t\t}> = [];\n\n\t\tconst stats = this.getPerformanceStats();\n\n\t\t// Check cache hit rate\n\t\tif (stats.cacheHitRate < 70) {\n\t\t\tsuggestions.push({\n\t\t\t\tissue: `Low cache hit rate: ${stats.cacheHitRate.toFixed(1)}%`,\n\t\t\t\tsuggestion: 'Increase cache TTL or improve cache key strategy',\n\t\t\t\timpact: 'high'\n\t\t\t});\n\t\t}\n\n\t\t// Check average query time\n\t\tif (stats.avgQueryTime > 100) {\n\t\t\tsuggestions.push({\n\t\t\t\tissue: `High average query time: ${stats.avgQueryTime.toFixed(1)}ms`,\n\t\t\t\tsuggestion: 'Optimize slow queries or add database indexes',\n\t\t\t\timpact: 'high'\n\t\t\t});\n\t\t}\n\n\t\t// Check queries per second\n\t\tif (stats.queriesPerSecond > 100) {\n\t\t\tsuggestions.push({\n\t\t\t\tissue: `High query rate: ${stats.queriesPerSecond.toFixed(1)} QPS`,\n\t\t\t\tsuggestion: 'Implement connection pooling or query batching',\n\t\t\t\timpact: 'medium'\n\t\t\t});\n\t\t}\n\n\t\treturn suggestions;\n\t}\n\n\t/**\n\t * Helper methods\n\t */\n\tprivate static generateCacheKey(type: string, options: any): string {\n\t\treturn `${type}:${JSON.stringify(options)}`;\n\t}\n\n\tprivate static isCacheValid(options: OptimizedMessageQuery, cached: any[]): boolean {\n\t\t// Simple validation - in production, implement more sophisticated logic\n\t\treturn cached.length > 0 && (!options.limit || cached.length >= options.limit);\n\t}\n\n\tprivate static applyFiltersToCache(cached: any[], options: OptimizedMessageQuery): any[] {\n\t\tlet filtered = [...cached];\n\n\t\tif (options.userId) {\n\t\t\tfiltered = filtered.filter((m) => m.userId === options.userId);\n\t\t}\n\n\t\tif (!options.includeDeleted) {\n\t\t\tfiltered = filtered.filter((m) => !m.isDeleted);\n\t\t}\n\n\t\tif (options.cursor) {\n\t\t\tfiltered = filtered.filter((m) =>\n\t\t\t\toptions.direction === 'before' ? m.id < options.cursor! : m.id > options.cursor!\n\t\t\t);\n\t\t}\n\n\t\tif (options.limit) {\n\t\t\tfiltered = filtered.slice(0, options.limit);\n\t\t}\n\n\t\treturn filtered;\n\t}\n\n\tprivate static recordQueryMetric(metric: QueryMetrics): void {\n\t\tthis.queryMetrics.push(metric);\n\n\t\t// Keep only recent metrics\n\t\tif (this.queryMetrics.length > this.MAX_METRICS) {\n\t\t\tthis.queryMetrics = this.queryMetrics.slice(-Math.floor(this.MAX_METRICS * 0.8));\n\t\t}\n\t}\n\n\tprivate static getActiveConnections(): number {\n\t\t// In production, get actual connection pool stats\n\t\treturn Math.floor(Math.random() * 20) + 5;\n\t}\n\n\tprivate static getMemoryUsage(): number {\n\t\t// In production, get actual memory usage\n\t\tconst used = process.memoryUsage();\n\t\treturn Math.round(used.heapUsed / 1024 / 1024); // MB\n\t}\n\n\t/**\n\t * Cleanup and maintenance\n\t */\n\tstatic cleanup(): void {\n\t\t// Clean old metrics\n\t\tconst oneHourAgo = Date.now() - 3600000;\n\t\tthis.queryMetrics = this.queryMetrics.filter((m) => m.timestamp.getTime() > oneHourAgo);\n\n\t\t// Clear expired cache entries\n\t\tShoutboxCacheService.clearExpiredEntries();\n\n\t\tlogger.debug('PerformanceService', 'Cleanup completed', {\n\t\t\tmetricsCount: this.queryMetrics.length\n\t\t});\n\t}\n}\n\n// Cleanup interval\nsetInterval(() => {\n\tPerformanceService.cleanup();\n}, 300000); // Every 5 minutes\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shoutbox/services/queue.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shoutbox/services/room.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lt' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":635,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":635,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced Chat Room Service\n *\n * Handles chat room creation, management, and access control\n * with admin configuration and multi-room support\n */\n\nimport { db } from '@db';\nimport type { UserId } from '@shared/types';\nimport { chatRooms, users, shoutboxConfig, shoutboxMessages, shoutboxUserIgnores } from '@schema';\nimport { eq, and, or, desc, asc, sql, gt, lt, isNull, inArray, not, count } from 'drizzle-orm';\nimport { logger } from '@server/src/core/logger';\nimport { createId } from '@paralleldrive/cuid2';\nimport type { RoomId, GroupId } from '@shared/types';\nimport { EntityId } from \"@shared/types\";\n\nexport interface CreateRoomData {\n\tname: string;\n\tdescription?: string;\n\tisPrivate?: boolean;\n\tminXpRequired?: number;\n\tminGroupIdRequired?: GroupId;\n\torder?: number;\n\tcreatedBy: number;\n\taccessRoles?: string[];\n\tthemeConfig?: any;\n\tmaxUsers?: number;\n}\n\nexport interface RoomWithStats {\n\tid: EntityId;\n\tname: string;\n\tdescription: string | null;\n\tisPrivate: boolean;\n\tminXpRequired: number | null;\n\tminGroupIdRequired: GroupId | null;\n\torder: number | null;\n\tcreatedAt: Date;\n\tcreatedBy: number;\n\tisDeleted: boolean;\n\taccessRoles: string[] | null;\n\tthemeConfig: any;\n\tmaxUsers: number | null;\n\n\t// Stats\n\tmessageCount: number;\n\tactiveUsers: number;\n\tonlineUsers: number;\n\tlastActivity: Date | null;\n\tpinnedMessageCount: number;\n}\n\nexport class RoomService {\n\tprivate static cache = new Map<string, any>();\n\tprivate static readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\n\t/**\n\t * Create a new chat room (admin only)\n\t */\n\tstatic async createRoom(roomData: CreateRoomData): Promise<{\n\t\tsuccess: boolean;\n\t\troom?: any;\n\t\tmessage: string;\n\t\terror?: string;\n\t}> {\n\t\ttry {\n\t\t\t// Validate room name\n\t\t\tif (!roomData.name || roomData.name.length < 3 || roomData.name.length > 50) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Room name must be between 3 and 50 characters',\n\t\t\t\t\terror: 'INVALID_ROOM_NAME'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check if room name already exists\n\t\t\tconst existingRoom = await db.query.chatRooms.findFirst({\n\t\t\t\twhere: and(eq(chatRooms.name, roomData.name), eq(chatRooms.isDeleted, false))\n\t\t\t});\n\n\t\t\tif (existingRoom) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'A room with this name already exists',\n\t\t\t\t\terror: 'ROOM_NAME_EXISTS'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Get next order if not specified\n\t\t\tlet order = roomData.order;\n\t\t\tif (!order) {\n\t\t\t\tconst maxOrderResult = await db\n\t\t\t\t\t.select({\n\t\t\t\t\t\tmaxOrder: sql<number>`COALESCE(MAX(${chatRooms.order}), 0)`\n\t\t\t\t\t})\n\t\t\t\t\t.from(chatRooms)\n\t\t\t\t\t.where(eq(chatRooms.isDeleted, false));\n\n\t\t\t\torder = (maxOrderResult[0]?.maxOrder || 0) + 1;\n\t\t\t}\n\n\t\t\t// Create the room\n\t\t\tconst [newRoom] = await db\n\t\t\t\t.insert(chatRooms)\n\t\t\t\t.values({\n\t\t\t\t\tname: roomData.name,\n\t\t\t\t\tdescription: roomData.description || null,\n\t\t\t\t\tisPrivate: roomData.isPrivate || false,\n\t\t\t\t\tminXpRequired: roomData.minXpRequired || null,\n\t\t\t\t\tminGroupIdRequired: roomData.minGroupIdRequired || null,\n\t\t\t\t\torder: order,\n\t\t\t\t\tcreatedBy: roomData.createdBy,\n\t\t\t\t\taccessRoles: roomData.accessRoles || null,\n\t\t\t\t\tthemeConfig: roomData.themeConfig || {},\n\t\t\t\t\tmaxUsers: roomData.maxUsers || null\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Create room-specific configuration if provided\n\t\t\tif (roomData.themeConfig || roomData.maxUsers) {\n\t\t\t\tawait this.createRoomConfig(newRoom.id, roomData);\n\t\t\t}\n\n\t\t\tlogger.info('RoomService', 'Chat room created', {\n\t\t\t\troomId: newRoom.id,\n\t\t\t\troomName: newRoom.name,\n\t\t\t\tcreatedBy: roomData.createdBy\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\troom: newRoom,\n\t\t\t\tmessage: 'Chat room created successfully'\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error creating chat room', { error, roomData });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Failed to create chat room',\n\t\t\t\terror: 'ROOM_CREATION_FAILED'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Update an existing chat room\n\t */\n\tstatic async updateRoom(\n\t\troomId: RoomId,\n\t\tupdateData: Partial<CreateRoomData>,\n\t\tupdatedBy: UserId\n\t): Promise<{\n\t\tsuccess: boolean;\n\t\troom?: any;\n\t\tmessage: string;\n\t\terror?: string;\n\t}> {\n\t\ttry {\n\t\t\t// Check if room exists\n\t\t\tconst existingRoom = await db.query.chatRooms.findFirst({\n\t\t\t\twhere: and(eq(chatRooms.id, roomId), eq(chatRooms.isDeleted, false))\n\t\t\t});\n\n\t\t\tif (!existingRoom) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Chat room not found',\n\t\t\t\t\terror: 'ROOM_NOT_FOUND'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If updating name, check for conflicts\n\t\t\tif (updateData.name && updateData.name !== existingRoom.name) {\n\t\t\t\tconst nameConflict = await db.query.chatRooms.findFirst({\n\t\t\t\t\twhere: and(\n\t\t\t\t\t\teq(chatRooms.name, updateData.name),\n\t\t\t\t\t\teq(chatRooms.isDeleted, false),\n\t\t\t\t\t\tnot(eq(chatRooms.id, roomId))\n\t\t\t\t\t)\n\t\t\t\t});\n\n\t\t\t\tif (nameConflict) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: 'A room with this name already exists',\n\t\t\t\t\t\terror: 'ROOM_NAME_EXISTS'\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update the room\n\t\t\tconst [updatedRoom] = await db\n\t\t\t\t.update(chatRooms)\n\t\t\t\t.set({\n\t\t\t\t\tname: updateData.name || existingRoom.name,\n\t\t\t\t\tdescription:\n\t\t\t\t\t\tupdateData.description !== undefined\n\t\t\t\t\t\t\t? updateData.description\n\t\t\t\t\t\t\t: existingRoom.description,\n\t\t\t\t\tisPrivate:\n\t\t\t\t\t\tupdateData.isPrivate !== undefined ? updateData.isPrivate : existingRoom.isPrivate,\n\t\t\t\t\tminXpRequired:\n\t\t\t\t\t\tupdateData.minXpRequired !== undefined\n\t\t\t\t\t\t\t? updateData.minXpRequired\n\t\t\t\t\t\t\t: existingRoom.minXpRequired,\n\t\t\t\t\tminGroupIdRequired:\n\t\t\t\t\t\tupdateData.minGroupIdRequired !== undefined\n\t\t\t\t\t\t\t? updateData.minGroupIdRequired\n\t\t\t\t\t\t\t: existingRoom.minGroupIdRequired,\n\t\t\t\t\torder: updateData.order !== undefined ? updateData.order : existingRoom.order,\n\t\t\t\t\taccessRoles:\n\t\t\t\t\t\tupdateData.accessRoles !== undefined\n\t\t\t\t\t\t\t? updateData.accessRoles\n\t\t\t\t\t\t\t: existingRoom.accessRoles,\n\t\t\t\t\tthemeConfig:\n\t\t\t\t\t\tupdateData.themeConfig !== undefined\n\t\t\t\t\t\t\t? updateData.themeConfig\n\t\t\t\t\t\t\t: existingRoom.themeConfig,\n\t\t\t\t\tmaxUsers: updateData.maxUsers !== undefined ? updateData.maxUsers : existingRoom.maxUsers\n\t\t\t\t})\n\t\t\t\t.where(eq(chatRooms.id, roomId))\n\t\t\t\t.returning();\n\n\t\t\t// Update room-specific configuration\n\t\t\tif (updateData.themeConfig || updateData.maxUsers !== undefined) {\n\t\t\t\tawait this.updateRoomConfig(roomId, updateData);\n\t\t\t}\n\n\t\t\t// Clear cache\n\t\t\tthis.clearRoomCache(roomId);\n\n\t\t\tlogger.info('RoomService', 'Chat room updated', {\n\t\t\t\troomId,\n\t\t\t\tupdatedBy,\n\t\t\t\tchanges: Object.keys(updateData)\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\troom: updatedRoom,\n\t\t\t\tmessage: 'Chat room updated successfully'\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error updating chat room', { error, roomId, updateData });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Failed to update chat room',\n\t\t\t\terror: 'ROOM_UPDATE_FAILED'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Delete a chat room (soft delete)\n\t */\n\tstatic async deleteRoom(\n\t\troomId: RoomId,\n\t\tdeletedBy: UserId\n\t): Promise<{\n\t\tsuccess: boolean;\n\t\tmessage: string;\n\t\terror?: string;\n\t}> {\n\t\ttry {\n\t\t\t// Check if room exists and is not already deleted\n\t\t\tconst existingRoom = await db.query.chatRooms.findFirst({\n\t\t\t\twhere: and(eq(chatRooms.id, roomId), eq(chatRooms.isDeleted, false))\n\t\t\t});\n\n\t\t\tif (!existingRoom) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Chat room not found',\n\t\t\t\t\terror: 'ROOM_NOT_FOUND'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Prevent deletion of default room\n\t\t\tif (existingRoom.name === 'degen-lounge') {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Cannot delete the default chat room',\n\t\t\t\t\terror: 'CANNOT_DELETE_DEFAULT'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Soft delete the room\n\t\t\tawait db\n\t\t\t\t.update(chatRooms)\n\t\t\t\t.set({\n\t\t\t\t\tisDeleted: true,\n\t\t\t\t\tdeletedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(chatRooms.id, roomId));\n\n\t\t\t// Also soft delete all messages in the room\n\t\t\tawait db\n\t\t\t\t.update(shoutboxMessages)\n\t\t\t\t.set({\n\t\t\t\t\tisDeleted: true,\n\t\t\t\t\teditedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(shoutboxMessages.roomId, roomId));\n\n\t\t\t// Clear cache\n\t\t\tthis.clearRoomCache(roomId);\n\t\t\tthis.clearRoomCache(); // Clear general room list cache\n\n\t\t\tlogger.info('RoomService', 'Chat room deleted', {\n\t\t\t\troomId,\n\t\t\t\troomName: existingRoom.name,\n\t\t\t\tdeletedBy\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Chat room deleted successfully'\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error deleting chat room', { error, roomId });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Failed to delete chat room',\n\t\t\t\terror: 'ROOM_DELETION_FAILED'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Get all chat rooms with statistics\n\t */\n\tstatic async getRoomsWithStats(userId?: UserId): Promise<RoomWithStats[]> {\n\t\tconst cacheKey = `rooms-with-stats:${userId || 'guest'}`;\n\n\t\tif (this.cache.has(cacheKey)) {\n\t\t\treturn this.cache.get(cacheKey);\n\t\t}\n\n\t\ttry {\n\t\t\t// Base query for rooms\n\t\t\tlet roomsQuery = db\n\t\t\t\t.select({\n\t\t\t\t\tid: chatRooms.id,\n\t\t\t\t\tname: chatRooms.name,\n\t\t\t\t\tdescription: chatRooms.description,\n\t\t\t\t\tisPrivate: chatRooms.isPrivate,\n\t\t\t\t\tminXpRequired: chatRooms.minXpRequired,\n\t\t\t\t\tminGroupIdRequired: chatRooms.minGroupIdRequired,\n\t\t\t\t\torder: chatRooms.order,\n\t\t\t\t\tcreatedAt: chatRooms.createdAt,\n\t\t\t\t\tcreatedBy: chatRooms.createdBy,\n\t\t\t\t\tisDeleted: chatRooms.isDeleted,\n\t\t\t\t\taccessRoles: chatRooms.accessRoles,\n\t\t\t\t\tthemeConfig: chatRooms.themeConfig,\n\t\t\t\t\tmaxUsers: chatRooms.maxUsers\n\t\t\t\t})\n\t\t\t\t.from(chatRooms)\n\t\t\t\t.where(eq(chatRooms.isDeleted, false));\n\n\t\t\t// If user is specified, filter rooms they can access\n\t\t\tif (userId) {\n\t\t\t\tconst userInfo = await db.query.users.findFirst({\n\t\t\t\t\twhere: eq(users.id, userId),\n\t\t\t\t\tcolumns: { groupId: true, xp: true }\n\t\t\t\t});\n\n\t\t\t\tif (userInfo) {\n\t\t\t\t\troomsQuery = roomsQuery.where(\n\t\t\t\t\t\tor(\n\t\t\t\t\t\t\teq(chatRooms.isPrivate, false),\n\t\t\t\t\t\t\teq(chatRooms.createdBy, userId),\n\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\teq(chatRooms.isPrivate, true),\n\t\t\t\t\t\t\t\tor(\n\t\t\t\t\t\t\t\t\tisNull(chatRooms.minGroupIdRequired),\n\t\t\t\t\t\t\t\t\tsql`${userInfo.groupId} <= ${chatRooms.minGroupIdRequired}`\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tor(\n\t\t\t\t\t\t\t\t\tisNull(chatRooms.minXpRequired),\n\t\t\t\t\t\t\t\t\tsql`${userInfo.xp} >= ${chatRooms.minXpRequired}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Guest users can only see public rooms\n\t\t\t\troomsQuery = roomsQuery.where(eq(chatRooms.isPrivate, false));\n\t\t\t}\n\n\t\t\tconst rooms = await roomsQuery.orderBy(asc(chatRooms.order));\n\n\t\t\t// Get statistics for each room\n\t\t\tconst roomsWithStats: RoomWithStats[] = await Promise.all(\n\t\t\t\trooms.map(async (room) => {\n\t\t\t\t\tconst stats = await this.getRoomStats(room.id);\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...room,\n\t\t\t\t\t\t...stats\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Cache the result\n\t\t\tthis.cache.set(cacheKey, roomsWithStats);\n\t\t\tsetTimeout(() => this.cache.delete(cacheKey), this.CACHE_TTL);\n\n\t\t\treturn roomsWithStats;\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error getting rooms with stats', { error, userId });\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Get statistics for a specific room\n\t */\n\tstatic async getRoomStats(roomId: RoomId): Promise<{\n\t\tmessageCount: number;\n\t\tactiveUsers: number;\n\t\tonlineUsers: number;\n\t\tlastActivity: Date | null;\n\t\tpinnedMessageCount: number;\n\t}> {\n\t\ttry {\n\t\t\t// Get message count\n\t\t\tconst messageCountResult = await db\n\t\t\t\t.select({\n\t\t\t\t\tcount: count(shoutboxMessages.id)\n\t\t\t\t})\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.where(and(eq(shoutboxMessages.roomId, roomId), eq(shoutboxMessages.isDeleted, false)));\n\n\t\t\t// Get pinned message count\n\t\t\tconst pinnedCountResult = await db\n\t\t\t\t.select({\n\t\t\t\t\tcount: count(shoutboxMessages.id)\n\t\t\t\t})\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(shoutboxMessages.roomId, roomId),\n\t\t\t\t\t\teq(shoutboxMessages.isDeleted, false),\n\t\t\t\t\t\teq(shoutboxMessages.isPinned, true)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t// Get last activity\n\t\t\tconst lastActivityResult = await db\n\t\t\t\t.select({\n\t\t\t\t\tlastActivity: sql<Date>`MAX(${shoutboxMessages.createdAt})`\n\t\t\t\t})\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.where(and(eq(shoutboxMessages.roomId, roomId), eq(shoutboxMessages.isDeleted, false)));\n\n\t\t\t// Get active users (users who posted in last 24 hours)\n\t\t\tconst activeUsersResult = await db\n\t\t\t\t.select({\n\t\t\t\t\tcount: sql<number>`COUNT(DISTINCT ${shoutboxMessages.userId})`\n\t\t\t\t})\n\t\t\t\t.from(shoutboxMessages)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(shoutboxMessages.roomId, roomId),\n\t\t\t\t\t\teq(shoutboxMessages.isDeleted, false),\n\t\t\t\t\t\tgt(shoutboxMessages.createdAt, sql`NOW() - INTERVAL '24 hours'`)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tmessageCount: messageCountResult[0]?.count || 0,\n\t\t\t\tactiveUsers: activeUsersResult[0]?.count || 0,\n\t\t\t\tonlineUsers: 0, // Would need WebSocket connection tracking\n\t\t\t\tlastActivity: lastActivityResult[0]?.lastActivity || null,\n\t\t\t\tpinnedMessageCount: pinnedCountResult[0]?.count || 0\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error getting room stats', { error, roomId });\n\t\t\treturn {\n\t\t\t\tmessageCount: 0,\n\t\t\t\tactiveUsers: 0,\n\t\t\t\tonlineUsers: 0,\n\t\t\t\tlastActivity: null,\n\t\t\t\tpinnedMessageCount: 0\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Check if user has access to a room\n\t */\n\tstatic async checkRoomAccess(\n\t\tuserId: UserId,\n\t\troomId: RoomId\n\t): Promise<{\n\t\thasAccess: boolean;\n\t\treason?: string;\n\t}> {\n\t\ttry {\n\t\t\tconst room = await db.query.chatRooms.findFirst({\n\t\t\t\twhere: and(eq(chatRooms.id, roomId), eq(chatRooms.isDeleted, false))\n\t\t\t});\n\n\t\t\tif (!room) {\n\t\t\t\treturn { hasAccess: false, reason: 'Room not found' };\n\t\t\t}\n\n\t\t\t// Public rooms are accessible to all authenticated users\n\t\t\tif (!room.isPrivate) {\n\t\t\t\treturn { hasAccess: true };\n\t\t\t}\n\n\t\t\t// Room creator always has access\n\t\t\tif (room.createdBy === userId) {\n\t\t\t\treturn { hasAccess: true };\n\t\t\t}\n\n\t\t\t// Check user requirements\n\t\t\tconst user = await db.query.users.findFirst({\n\t\t\t\twhere: eq(users.id, userId),\n\t\t\t\tcolumns: { groupId: true, xp: true, roles: true }\n\t\t\t});\n\n\t\t\tif (!user) {\n\t\t\t\treturn { hasAccess: false, reason: 'User not found' };\n\t\t\t}\n\n\t\t\t// Check XP requirement\n\t\t\tif (room.minXpRequired && user.xp && user.xp < room.minXpRequired) {\n\t\t\t\treturn { hasAccess: false, reason: `Requires ${room.minXpRequired} XP` };\n\t\t\t}\n\n\t\t\t// Check group requirement (lower groupId = higher permission)\n\t\t\tif (room.minGroupIdRequired && user.groupId && user.groupId > room.minGroupIdRequired) {\n\t\t\t\treturn { hasAccess: false, reason: 'Insufficient permissions' };\n\t\t\t}\n\n\t\t\t// Check role requirements\n\t\t\tif (room.accessRoles && room.accessRoles.length > 0) {\n\t\t\t\tconst userRoles = user.roles || [];\n\t\t\t\tconst hasRequiredRole = room.accessRoles.some((role) => userRoles.includes(role));\n\t\t\t\tif (!hasRequiredRole) {\n\t\t\t\t\treturn { hasAccess: false, reason: 'Role requirements not met' };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { hasAccess: true };\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error checking room access', { error, userId, roomId });\n\t\t\treturn { hasAccess: false, reason: 'Access check failed' };\n\t\t}\n\t}\n\n\t/**\n\t * Get user's ignored users for a room\n\t */\n\tstatic async getUserIgnoreList(userId: UserId, roomId?: RoomId): Promise<UserId[]> {\n\t\ttry {\n\t\t\tconst ignoreList = await db\n\t\t\t\t.select({\n\t\t\t\t\tignoredUserId: shoutboxUserIgnores.ignoredUserId\n\t\t\t\t})\n\t\t\t\t.from(shoutboxUserIgnores)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(shoutboxUserIgnores.userId, userId.toString()),\n\t\t\t\t\t\troomId\n\t\t\t\t\t\t\t? eq(shoutboxUserIgnores.roomId, roomId.toString())\n\t\t\t\t\t\t\t: isNull(shoutboxUserIgnores.roomId)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\treturn ignoreList.map((item) => item.ignoredUserId as UserId);\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error getting ignore list', { error, userId, roomId });\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Add user to ignore list\n\t */\n\tstatic async ignoreUser(\n\t\tuserId: UserId,\n\t\tignoredUserId: UserId,\n\t\troomId?: RoomId,\n\t\toptions?: {\n\t\t\thideMessages?: boolean;\n\t\t\thideCommands?: boolean;\n\t\t\thideMentions?: boolean;\n\t\t}\n\t): Promise<{ success: boolean; message: string }> {\n\t\ttry {\n\t\t\t// Check if already ignoring\n\t\t\tconst existing = await db.query.shoutboxUserIgnores.findFirst({\n\t\t\t\twhere: and(\n\t\t\t\t\teq(shoutboxUserIgnores.userId, userId.toString()),\n\t\t\t\t\teq(shoutboxUserIgnores.ignoredUserId, ignoredUserId.toString()),\n\t\t\t\t\troomId\n\t\t\t\t\t\t? eq(shoutboxUserIgnores.roomId, roomId.toString())\n\t\t\t\t\t\t: isNull(shoutboxUserIgnores.roomId)\n\t\t\t\t)\n\t\t\t});\n\n\t\t\tif (existing) {\n\t\t\t\treturn { success: false, message: 'User is already ignored' };\n\t\t\t}\n\n\t\t\t// Add to ignore list\n\t\t\tawait db.insert(shoutboxUserIgnores).values({\n\t\t\t\tuserId: userId.toString(),\n\t\t\t\tignoredUserId: ignoredUserId.toString(),\n\t\t\t\troomId: roomId?.toString() || null,\n\t\t\t\thideMessages: options?.hideMessages ?? true,\n\t\t\t\thideCommands: options?.hideCommands ?? true,\n\t\t\t\thideMentions: options?.hideMentions ?? true\n\t\t\t});\n\n\t\t\treturn { success: true, message: 'User added to ignore list' };\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error ignoring user', { error, userId, ignoredUserId, roomId });\n\t\t\treturn { success: false, message: 'Failed to ignore user' };\n\t\t}\n\t}\n\n\t/**\n\t * Remove user from ignore list\n\t */\n\tstatic async unignoreUser(\n\t\tuserId: UserId,\n\t\tignoredUserId: UserId,\n\t\troomId?: RoomId\n\t): Promise<{ success: boolean; message: string }> {\n\t\ttry {\n\t\t\tconst result = await db\n\t\t\t\t.delete(shoutboxUserIgnores)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(shoutboxUserIgnores.userId, userId.toString()),\n\t\t\t\t\t\teq(shoutboxUserIgnores.ignoredUserId, ignoredUserId.toString()),\n\t\t\t\t\t\troomId\n\t\t\t\t\t\t\t? eq(shoutboxUserIgnores.roomId, roomId.toString())\n\t\t\t\t\t\t\t: isNull(shoutboxUserIgnores.roomId)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\treturn { success: true, message: 'User removed from ignore list' };\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error unignoring user', {\n\t\t\t\terror,\n\t\t\t\tuserId,\n\t\t\t\tignoredUserId,\n\t\t\t\troomId\n\t\t\t});\n\t\t\treturn { success: false, message: 'Failed to unignore user' };\n\t\t}\n\t}\n\n\t/**\n\t * Create room-specific configuration\n\t */\n\tprivate static async createRoomConfig(roomId: RoomId, roomData: CreateRoomData): Promise<void> {\n\t\ttry {\n\t\t\tawait db.insert(shoutboxConfig).values({\n\t\t\t\tscope: 'room',\n\t\t\t\troomId: roomId.toString(),\n\t\t\t\tthemeConfig: roomData.themeConfig || {},\n\t\t\t\tmaxConcurrentUsers: roomData.maxUsers || 1000,\n\t\t\t\tcreatedBy: roomData.createdBy.toString()\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error creating room config', { error, roomId });\n\t\t}\n\t}\n\n\t/**\n\t * Update room-specific configuration\n\t */\n\tprivate static async updateRoomConfig(\n\t\troomId: RoomId,\n\t\tupdateData: Partial<CreateRoomData>\n\t): Promise<void> {\n\t\ttry {\n\t\t\tconst updateValues: any = {};\n\n\t\t\tif (updateData.themeConfig !== undefined) {\n\t\t\t\tupdateValues.themeConfig = updateData.themeConfig;\n\t\t\t}\n\n\t\t\tif (updateData.maxUsers !== undefined) {\n\t\t\t\tupdateValues.maxConcurrentUsers = updateData.maxUsers;\n\t\t\t}\n\n\t\t\tif (Object.keys(updateValues).length > 0) {\n\t\t\t\tupdateValues.updatedAt = new Date();\n\n\t\t\t\tawait db\n\t\t\t\t\t.update(shoutboxConfig)\n\t\t\t\t\t.set(updateValues)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(eq(shoutboxConfig.scope, 'room'), eq(shoutboxConfig.roomId, roomId.toString()))\n\t\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error updating room config', { error, roomId });\n\t\t}\n\t}\n\n\t/**\n\t * Clear room cache\n\t */\n\tprivate static clearRoomCache(roomId?: RoomId): void {\n\t\tif (roomId) {\n\t\t\tthis.cache.delete(`room:${roomId}`);\n\t\t\tthis.cache.delete(`room-stats:${roomId}`);\n\t\t}\n\n\t\t// Clear rooms list cache for all users\n\t\tfor (const key of this.cache.keys()) {\n\t\t\tif (key.startsWith('rooms-with-stats:')) {\n\t\t\t\tthis.cache.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Reorder rooms\n\t */\n\tstatic async reorderRooms(roomOrders: { roomId: RoomId; order: number }[]): Promise<{\n\t\tsuccess: boolean;\n\t\tmessage: string;\n\t}> {\n\t\ttry {\n\t\t\t// Update all room orders in a transaction\n\t\t\tawait db.transaction(async (tx) => {\n\t\t\t\tfor (const { roomId, order } of roomOrders) {\n\t\t\t\t\tawait tx.update(chatRooms).set({ order }).where(eq(chatRooms.id, roomId));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Clear cache\n\t\t\tthis.clearRoomCache();\n\n\t\t\treturn { success: true, message: 'Room order updated successfully' };\n\t\t} catch (error) {\n\t\t\tlogger.error('RoomService', 'Error reordering rooms', { error, roomOrders });\n\t\t\treturn { success: false, message: 'Failed to update room order' };\n\t\t}\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shoutbox/services/shoutbox.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chatRooms' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shoutboxUserIgnores' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":19,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'customEmojis' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":22,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":24,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asc' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":24,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":24,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gt' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":24,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lt' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":24,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":24,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'not' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":24,"column":64,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":26,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'roomId' is defined but never used.","line":872,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":872,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'scope' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":927,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":927,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced Shoutbox Service\n *\n * Comprehensive shoutbox system with:\n * - Command processing (/tip, /rain, /airdrop, /moderation commands)\n * - Admin configuration management\n * - User ignore system\n * - Message queuing and caching\n * - Analytics tracking\n */\n\nimport { db } from '@db';\nimport type { UserId } from '@shared/types';\nimport {\n\tshoutboxMessages,\n\tchatRooms,\n\tusers,\n\tshoutboxConfig,\n\tshoutboxUserIgnores,\n\tshoutboxAnalytics,\n\tshoutboxBannedWords,\n\tcustomEmojis\n} from '@schema';\nimport { eq, and, or, desc, asc, sql, gt, lt, isNull, inArray, not } from 'drizzle-orm';\nimport { logger } from '@server/src/core/logger';\nimport { createId } from '@paralleldrive/cuid2';\nimport type { NewShoutboxConfig, ShoutboxConfig } from '@schema/admin/shoutboxConfig';\nimport type { RoomId } from '@shared/types';\n\ninterface MessageContext {\n\tuserId: UserId;\n\tusername: string;\n\troomId: RoomId;\n\tcontent: string;\n\tuserRoles: string[];\n\tuserLevel: number;\n\tipAddress?: string;\n\tsessionId?: string;\n}\n\ninterface CommandResult {\n\tsuccess: boolean;\n\tmessage: string;\n\tdata?: any;\n\terror?: string;\n\tbroadcastData?: any;\n}\n\nexport class ShoutboxService {\n\tprivate static cache = new Map<string, any>();\n\tprivate static configCache = new Map<string, ShoutboxConfig>();\n\tprivate static readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\n\t/**\n\t * Get shoutbox configuration with hierarchical override system\n\t * Global config can be overridden by room-specific config\n\t */\n\tstatic async getConfig(roomId?: RoomId): Promise<ShoutboxConfig> {\n\t\tconst cacheKey = `config:${roomId || 'global'}`;\n\n\t\tif (this.configCache.has(cacheKey)) {\n\t\t\treturn this.configCache.get(cacheKey)!;\n\t\t}\n\n\t\ttry {\n\t\t\t// Get global config first\n\t\t\tlet globalConfig = await db.query.shoutboxConfig.findFirst({\n\t\t\t\twhere: and(eq(shoutboxConfig.scope, 'global'), isNull(shoutboxConfig.roomId))\n\t\t\t});\n\n\t\t\t// Create default global config if none exists\n\t\t\tif (!globalConfig) {\n\t\t\t\tglobalConfig = await this.createDefaultConfig();\n\t\t\t}\n\n\t\t\tlet finalConfig = globalConfig;\n\n\t\t\t// If room-specific config is requested, merge with global\n\t\t\tif (roomId) {\n\t\t\t\tconst roomConfig = await db.query.shoutboxConfig.findFirst({\n\t\t\t\t\twhere: and(eq(shoutboxConfig.scope, 'room'), eq(shoutboxConfig.roomId, roomId.toString()))\n\t\t\t\t});\n\n\t\t\t\tif (roomConfig) {\n\t\t\t\t\t// Merge room config over global config\n\t\t\t\t\tfinalConfig = { ...globalConfig, ...roomConfig };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.configCache.set(cacheKey, finalConfig);\n\n\t\t\t// Auto-expire cache\n\t\t\tsetTimeout(() => this.configCache.delete(cacheKey), this.CACHE_TTL);\n\n\t\t\treturn finalConfig;\n\t\t} catch (error) {\n\t\t\tlogger.error('ShoutboxService', 'Error loading config', { error, roomId });\n\t\t\treturn await this.createDefaultConfig();\n\t\t}\n\t}\n\n\t/**\n\t * Create default shoutbox configuration\n\t */\n\tprivate static async createDefaultConfig(): Promise<ShoutboxConfig> {\n\t\tconst defaultConfig: NewShoutboxConfig = {\n\t\t\tscope: 'global',\n\t\t\tenabled: true,\n\t\t\tmaxMessageLength: 500,\n\t\t\tmessageRetentionDays: 365,\n\t\t\trateLimitSeconds: 10,\n\t\t\tautoModerationEnabled: true,\n\t\t\tprofanityFilterEnabled: true,\n\t\t\tspamDetectionEnabled: true,\n\t\t\tallowUserAvatars: true,\n\t\t\tallowUsernameColors: true,\n\t\t\tallowCustomEmojis: true,\n\t\t\tallowMentions: true,\n\t\t\tallowReactions: true,\n\t\t\tcommandsEnabled: true,\n\t\t\tallowTippingCommands: true,\n\t\t\tallowRainCommands: true,\n\t\t\tallowAirdropCommands: true,\n\t\t\tallowModerationCommands: true,\n\t\t\tallowPinnedMessages: true,\n\t\t\tmaxPinnedMessages: 3,\n\t\t\tanalyticsEnabled: true,\n\t\t\tlogMessageHistory: true,\n\t\t\tlogModerationActions: true,\n\t\t\tlogCommandUsage: true,\n\t\t\tallowMessageExport: true,\n\t\t\tuserIgnoreSystemEnabled: true,\n\t\t\ttypingIndicatorsEnabled: true,\n\t\t\tmessageQueueEnabled: true,\n\t\t\tmaxConcurrentUsers: 1000,\n\t\t\tmessagePreloadCount: 50,\n\t\t\tcacheEnabled: true,\n\t\t\tcacheTtlSeconds: 300,\n\t\t\tcreatedBy: 'system',\n\t\t\tthemeConfig: {\n\t\t\t\tprimaryColor: '#3b82f6',\n\t\t\t\tbackgroundColor: '#1f2937',\n\t\t\t\ttextColor: '#f9fafb',\n\t\t\t\tshowTimestamps: true,\n\t\t\t\tcompactMode: false,\n\t\t\t\tshowAvatars: true,\n\t\t\t\tavatarSize: 'medium'\n\t\t\t},\n\t\t\trolePermissions: {\n\t\t\t\tadmin: {\n\t\t\t\t\tcanPost: true,\n\t\t\t\t\tcanPin: true,\n\t\t\t\t\tcanDelete: true,\n\t\t\t\t\tcanBan: true,\n\t\t\t\t\tcanUseCommands: true,\n\t\t\t\t\tcanUseCustomEmojis: true,\n\t\t\t\t\tcanBypassRateLimit: true,\n\t\t\t\t\tcanSeeDeletedMessages: true\n\t\t\t\t},\n\t\t\t\tmoderator: {\n\t\t\t\t\tcanPost: true,\n\t\t\t\t\tcanPin: true,\n\t\t\t\t\tcanDelete: true,\n\t\t\t\t\tcanBan: true,\n\t\t\t\t\tcanUseCommands: true,\n\t\t\t\t\tcanUseCustomEmojis: true,\n\t\t\t\t\tcanBypassRateLimit: true,\n\t\t\t\t\tcanSeeDeletedMessages: true\n\t\t\t\t},\n\t\t\t\tuser: {\n\t\t\t\t\tcanPost: true,\n\t\t\t\t\tcanPin: false,\n\t\t\t\t\tcanDelete: false,\n\t\t\t\t\tcanBan: false,\n\t\t\t\t\tcanUseCommands: true,\n\t\t\t\t\tcanUseCustomEmojis: false,\n\t\t\t\t\tcanBypassRateLimit: false,\n\t\t\t\t\tcanSeeDeletedMessages: false\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst [created] = await db.insert(shoutboxConfig).values(defaultConfig).returning();\n\t\treturn created;\n\t}\n\n\t/**\n\t * Process shoutbox message with command detection and filtering\n\t */\n\tstatic async processMessage(context: MessageContext): Promise<CommandResult> {\n\t\tconst config = await this.getConfig(context.roomId);\n\n\t\t// Check if shoutbox is enabled\n\t\tif (!config.enabled) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Shoutbox is currently disabled',\n\t\t\t\terror: 'SHOUTBOX_DISABLED'\n\t\t\t};\n\t\t}\n\n\t\t// Check message length\n\t\tif (context.content.length > config.maxMessageLength) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Message too long. Maximum ${config.maxMessageLength} characters allowed.`,\n\t\t\t\terror: 'MESSAGE_TOO_LONG'\n\t\t\t};\n\t\t}\n\n\t\t// Check for commands\n\t\tif (context.content.startsWith('/') && config.commandsEnabled) {\n\t\t\treturn await this.processCommand(context, config);\n\t\t}\n\n\t\t// Apply content filters\n\t\tconst filterResult = await this.applyContentFilters(context.content, config);\n\t\tif (!filterResult.allowed) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: filterResult.reason || 'Message contains inappropriate content',\n\t\t\t\terror: 'CONTENT_FILTERED'\n\t\t\t};\n\t\t}\n\n\t\t// Process regular message\n\t\treturn await this.createMessage(context, config);\n\t}\n\n\t/**\n\t * Process chat commands (/tip, /rain, /airdrop, moderation commands)\n\t */\n\tprivate static async processCommand(\n\t\tcontext: MessageContext,\n\t\tconfig: ShoutboxConfig\n\t): Promise<CommandResult> {\n\t\tconst { content, userId, roomId } = context;\n\t\tconst commandMatch = content.match(/^\\/(\\w+)(.*)$/);\n\n\t\tif (!commandMatch) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Invalid command format',\n\t\t\t\terror: 'INVALID_COMMAND'\n\t\t\t};\n\t\t}\n\n\t\tconst [, command, args] = commandMatch;\n\t\tconst commandLower = command.toLowerCase();\n\n\t\t// Log command usage\n\t\tif (config.logCommandUsage) {\n\t\t\tawait this.logAnalytics({\n\t\t\t\teventType: 'command',\n\t\t\t\tuserId: userId.toString(),\n\t\t\t\troomId: roomId.toString(),\n\t\t\t\teventData: { command: commandLower, args: args.trim() },\n\t\t\t\tsessionId: context.sessionId,\n\t\t\t\tipAddress: context.ipAddress\n\t\t\t});\n\t\t}\n\n\t\tswitch (commandLower) {\n\t\t\tcase 'tip':\n\t\t\t\treturn await this.processTipCommand(context, args.trim(), config);\n\n\t\t\tcase 'rain':\n\t\t\t\treturn await this.processRainCommand(context, args.trim(), config);\n\n\t\t\tcase 'airdrop':\n\t\t\t\treturn await this.processAirdropCommand(context, args.trim(), config);\n\n\t\t\tcase 'mute':\n\t\t\tcase 'unmute':\n\t\t\tcase 'ban':\n\t\t\tcase 'unban':\n\t\t\tcase 'timeout':\n\t\t\t\treturn await this.processModerationCommand(context, commandLower, args.trim(), config);\n\n\t\t\tcase 'clear':\n\t\t\t\treturn await this.processClearCommand(context, config);\n\n\t\t\tcase 'help':\n\t\t\t\treturn await this.processHelpCommand(context, config);\n\n\t\t\tdefault:\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: `Unknown command: /${command}`,\n\t\t\t\t\terror: 'UNKNOWN_COMMAND'\n\t\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Process /tip command\n\t */\n\tprivate static async processTipCommand(\n\t\tcontext: MessageContext,\n\t\targs: string,\n\t\tconfig: ShoutboxConfig\n\t): Promise<CommandResult> {\n\t\tif (!config.allowTippingCommands) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Tipping commands are disabled in this room',\n\t\t\t\terror: 'TIPPING_DISABLED'\n\t\t\t};\n\t\t}\n\n\t\tconst tipMatch = args.match(/^@?(\\w+)\\s+(\\d+(?:\\.\\d{1,2})?)(?:\\s+(.*))?$/);\n\t\tif (!tipMatch) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Usage: /tip @username amount [message]',\n\t\t\t\terror: 'INVALID_TIP_FORMAT'\n\t\t\t};\n\t\t}\n\n\t\tconst [, targetUsername, amountStr, tipMessage] = tipMatch;\n\t\tconst amount = parseFloat(amountStr);\n\n\t\tif (amount <= 0 || amount > 10000) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Tip amount must be between 0.01 and 10,000 DGT',\n\t\t\t\terror: 'INVALID_TIP_AMOUNT'\n\t\t\t};\n\t\t}\n\n\t\ttry {\n\t\t\t// Import tip service dynamically to avoid circular dependencies\n\t\t\tconst { TipService } = await import('../../engagement/tip/tip.service');\n\n\t\t\tconst tipResult = await TipService.createTip({\n\t\t\t\tfromUserId: context.userId,\n\t\t\t\ttoUsername: targetUsername,\n\t\t\t\tamount,\n\t\t\t\tnote: tipMessage || `Tip from ${context.username} in shoutbox`,\n\t\t\t\tcontext: 'shoutbox'\n\t\t\t});\n\n\t\t\tif (tipResult.success) {\n\t\t\t\t// Create system message about the tip\n\t\t\t\tconst systemMessage = `💰 ${context.username} tipped @${targetUsername} ${amount} DGT${tipMessage ? `: ${tipMessage}` : ''}`;\n\n\t\t\t\tawait this.createSystemMessage(context.roomId, systemMessage);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tmessage: `Successfully tipped @${targetUsername} ${amount} DGT`,\n\t\t\t\t\tdata: tipResult.data,\n\t\t\t\t\tbroadcastData: {\n\t\t\t\t\t\ttype: 'chat_update',\n\t\t\t\t\t\taction: 'system_message',\n\t\t\t\t\t\tcontent: systemMessage,\n\t\t\t\t\t\troomId: context.roomId\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: tipResult.message || 'Failed to process tip',\n\t\t\t\t\terror: 'TIP_FAILED'\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('ShoutboxService', 'Error processing tip command', { error, context });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Failed to process tip command',\n\t\t\t\terror: 'TIP_ERROR'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Process /rain command\n\t */\n\tprivate static async processRainCommand(\n\t\tcontext: MessageContext,\n\t\targs: string,\n\t\tconfig: ShoutboxConfig\n\t): Promise<CommandResult> {\n\t\tif (!config.allowRainCommands) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Rain commands are disabled in this room',\n\t\t\t\terror: 'RAIN_DISABLED'\n\t\t\t};\n\t\t}\n\n\t\tconst rainMatch = args.match(/^(\\d+(?:\\.\\d{1,2})?)\\s+(\\d+)(?:\\s+(.*))?$/);\n\t\tif (!rainMatch) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Usage: /rain amount userCount [message]',\n\t\t\t\terror: 'INVALID_RAIN_FORMAT'\n\t\t\t};\n\t\t}\n\n\t\tconst [, amountStr, userCountStr, rainMessage] = rainMatch;\n\t\tconst totalAmount = parseFloat(amountStr);\n\t\tconst userCount = parseInt(userCountStr);\n\n\t\tif (totalAmount <= 0 || totalAmount > 50000) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Rain amount must be between 0.01 and 50,000 DGT',\n\t\t\t\terror: 'INVALID_RAIN_AMOUNT'\n\t\t\t};\n\t\t}\n\n\t\tif (userCount < 2 || userCount > 50) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'User count must be between 2 and 50',\n\t\t\t\terror: 'INVALID_RAIN_COUNT'\n\t\t\t};\n\t\t}\n\n\t\ttry {\n\t\t\t// Import rain service dynamically\n\t\t\tconst { RainService } = await import('../../engagement/rain/rain.service');\n\n\t\t\tconst rainResult = await RainService.createRain({\n\t\t\t\tuserId: context.userId,\n\t\t\t\tamount: totalAmount,\n\t\t\t\trecipientCount: userCount,\n\t\t\t\tmessage: rainMessage || `Rain from ${context.username}`,\n\t\t\t\troomId: context.roomId\n\t\t\t});\n\n\t\t\tif (rainResult.success) {\n\t\t\t\tconst systemMessage = `🌧️ ${context.username} started a rain of ${totalAmount} DGT for ${userCount} users! ${rainMessage || ''}`;\n\n\t\t\t\tawait this.createSystemMessage(context.roomId, systemMessage);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tmessage: `Successfully started rain of ${totalAmount} DGT for ${userCount} users`,\n\t\t\t\t\tdata: rainResult.data,\n\t\t\t\t\tbroadcastData: {\n\t\t\t\t\t\ttype: 'chat_update',\n\t\t\t\t\t\taction: 'rain_started',\n\t\t\t\t\t\tcontent: systemMessage,\n\t\t\t\t\t\troomId: context.roomId,\n\t\t\t\t\t\trainData: rainResult.data\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: rainResult.message || 'Failed to start rain',\n\t\t\t\t\terror: 'RAIN_FAILED'\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('ShoutboxService', 'Error processing rain command', { error, context });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Failed to process rain command',\n\t\t\t\terror: 'RAIN_ERROR'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Process /airdrop command (admin only)\n\t */\n\tprivate static async processAirdropCommand(\n\t\tcontext: MessageContext,\n\t\targs: string,\n\t\tconfig: ShoutboxConfig\n\t): Promise<CommandResult> {\n\t\tif (!config.allowAirdropCommands) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Airdrop commands are disabled',\n\t\t\t\terror: 'AIRDROP_DISABLED'\n\t\t\t};\n\t\t}\n\n\t\t// Check if user has admin permissions\n\t\tconst rolePermissions = config.rolePermissions;\n\t\tconst userRole = this.getUserRole(context.userRoles);\n\n\t\tif (!rolePermissions[userRole]?.canUseCommands || !context.userRoles.includes('admin')) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Only administrators can use the airdrop command',\n\t\t\t\terror: 'INSUFFICIENT_PERMISSIONS'\n\t\t\t};\n\t\t}\n\n\t\tconst airdropMatch = args.match(/^(\\d+(?:\\.\\d{1,2})?)(?:\\s+(.*))?$/);\n\t\tif (!airdropMatch) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Usage: /airdrop amount [message]',\n\t\t\t\terror: 'INVALID_AIRDROP_FORMAT'\n\t\t\t};\n\t\t}\n\n\t\tconst [, amountStr, airdropMessage] = airdropMatch;\n\t\tconst amount = parseFloat(amountStr);\n\n\t\tif (amount <= 0 || amount > 100000) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Airdrop amount must be between 0.01 and 100,000 DGT',\n\t\t\t\terror: 'INVALID_AIRDROP_AMOUNT'\n\t\t\t};\n\t\t}\n\n\t\ttry {\n\t\t\t// Get all active users in the room\n\t\t\tconst activeUsers = await this.getActiveRoomUsers(context.roomId);\n\n\t\t\tif (activeUsers.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'No active users found for airdrop',\n\t\t\t\t\terror: 'NO_ACTIVE_USERS'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst perUserAmount = amount / activeUsers.length;\n\n\t\t\t// Process airdrop (implementation would depend on wallet service)\n\t\t\tconst systemMessage = `🪂 Administrator ${context.username} sent an airdrop of ${amount} DGT (${perUserAmount.toFixed(2)} per user) to ${activeUsers.length} users! ${airdropMessage || ''}`;\n\n\t\t\tawait this.createSystemMessage(context.roomId, systemMessage);\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Successfully sent airdrop of ${amount} DGT to ${activeUsers.length} users`,\n\t\t\t\tdata: { totalAmount: amount, perUserAmount, recipientCount: activeUsers.length },\n\t\t\t\tbroadcastData: {\n\t\t\t\t\ttype: 'chat_update',\n\t\t\t\t\taction: 'airdrop_sent',\n\t\t\t\t\tcontent: systemMessage,\n\t\t\t\t\troomId: context.roomId\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ShoutboxService', 'Error processing airdrop command', { error, context });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Failed to process airdrop command',\n\t\t\t\terror: 'AIRDROP_ERROR'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Process moderation commands\n\t */\n\tprivate static async processModerationCommand(\n\t\tcontext: MessageContext,\n\t\tcommand: string,\n\t\targs: string,\n\t\tconfig: ShoutboxConfig\n\t): Promise<CommandResult> {\n\t\tif (!config.allowModerationCommands) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Moderation commands are disabled',\n\t\t\t\terror: 'MODERATION_DISABLED'\n\t\t\t};\n\t\t}\n\n\t\tconst userRole = this.getUserRole(context.userRoles);\n\t\tconst rolePermissions = config.rolePermissions[userRole];\n\n\t\tif (!rolePermissions?.canBan && !rolePermissions?.canDelete) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Insufficient permissions for moderation commands',\n\t\t\t\terror: 'INSUFFICIENT_PERMISSIONS'\n\t\t\t};\n\t\t}\n\n\t\tconst targetMatch = args.match(/^@?(\\w+)(?:\\s+(\\d+[smhd]?))?(?:\\s+(.*))?$/);\n\t\tif (!targetMatch) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Usage: /${command} @username [duration] [reason]`,\n\t\t\t\terror: 'INVALID_MODERATION_FORMAT'\n\t\t\t};\n\t\t}\n\n\t\tconst [, targetUsername, duration, reason] = targetMatch;\n\n\t\t// Find target user\n\t\tconst targetUser = await db.query.users.findFirst({\n\t\t\twhere: eq(users.username, targetUsername)\n\t\t});\n\n\t\tif (!targetUser) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `User @${targetUsername} not found`,\n\t\t\t\terror: 'USER_NOT_FOUND'\n\t\t\t};\n\t\t}\n\n\t\t// Process the moderation action\n\t\tlet actionMessage = '';\n\n\t\tswitch (command) {\n\t\t\tcase 'mute':\n\t\t\t\tactionMessage = `🔇 ${targetUsername} has been muted by ${context.username}`;\n\t\t\t\tbreak;\n\t\t\tcase 'unmute':\n\t\t\t\tactionMessage = `🔊 ${targetUsername} has been unmuted by ${context.username}`;\n\t\t\t\tbreak;\n\t\t\tcase 'ban':\n\t\t\t\tactionMessage = `🚫 ${targetUsername} has been banned by ${context.username}`;\n\t\t\t\tbreak;\n\t\t\tcase 'unban':\n\t\t\t\tactionMessage = `✅ ${targetUsername} has been unbanned by ${context.username}`;\n\t\t\t\tbreak;\n\t\t\tcase 'timeout':\n\t\t\t\tactionMessage = `⏰ ${targetUsername} has been timed out by ${context.username}`;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (duration) {\n\t\t\tactionMessage += ` for ${duration}`;\n\t\t}\n\t\tif (reason) {\n\t\t\tactionMessage += ` - Reason: ${reason}`;\n\t\t}\n\n\t\tawait this.createSystemMessage(context.roomId, actionMessage);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: `Successfully ${command}ed @${targetUsername}`,\n\t\t\tdata: { action: command, target: targetUsername, duration, reason },\n\t\t\tbroadcastData: {\n\t\t\t\ttype: 'chat_update',\n\t\t\t\taction: 'moderation_action',\n\t\t\t\tcontent: actionMessage,\n\t\t\t\troomId: context.roomId\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Process /clear command\n\t */\n\tprivate static async processClearCommand(\n\t\tcontext: MessageContext,\n\t\tconfig: ShoutboxConfig\n\t): Promise<CommandResult> {\n\t\tconst userRole = this.getUserRole(context.userRoles);\n\t\tconst rolePermissions = config.rolePermissions[userRole];\n\n\t\tif (!rolePermissions?.canDelete) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Insufficient permissions to clear chat',\n\t\t\t\terror: 'INSUFFICIENT_PERMISSIONS'\n\t\t\t};\n\t\t}\n\n\t\ttry {\n\t\t\t// Soft delete all messages in the room\n\t\t\tawait db\n\t\t\t\t.update(shoutboxMessages)\n\t\t\t\t.set({ isDeleted: true, editedAt: new Date() })\n\t\t\t\t.where(\n\t\t\t\t\tand(eq(shoutboxMessages.roomId, context.roomId), eq(shoutboxMessages.isDeleted, false))\n\t\t\t\t);\n\n\t\t\tconst systemMessage = `🧹 Chat cleared by ${context.username}`;\n\t\t\tawait this.createSystemMessage(context.roomId, systemMessage);\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Chat cleared successfully',\n\t\t\t\tbroadcastData: {\n\t\t\t\t\ttype: 'chat_update',\n\t\t\t\t\taction: 'chat_cleared',\n\t\t\t\t\troomId: context.roomId\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ShoutboxService', 'Error clearing chat', { error, context });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Failed to clear chat',\n\t\t\t\terror: 'CLEAR_FAILED'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Process /help command\n\t */\n\tprivate static async processHelpCommand(\n\t\tcontext: MessageContext,\n\t\tconfig: ShoutboxConfig\n\t): Promise<CommandResult> {\n\t\tconst userRole = this.getUserRole(context.userRoles);\n\t\tconst rolePermissions = config.rolePermissions[userRole];\n\n\t\tconst commands = [];\n\n\t\tif (config.allowTippingCommands) {\n\t\t\tcommands.push('/tip @username amount [message] - Tip another user');\n\t\t}\n\n\t\tif (config.allowRainCommands) {\n\t\t\tcommands.push('/rain amount userCount [message] - Start a rain for multiple users');\n\t\t}\n\n\t\tif (config.allowAirdropCommands && context.userRoles.includes('admin')) {\n\t\t\tcommands.push('/airdrop amount [message] - Send airdrop to all active users (admin only)');\n\t\t}\n\n\t\tif (rolePermissions?.canBan || rolePermissions?.canDelete) {\n\t\t\tcommands.push('/mute @username [duration] [reason] - Mute a user');\n\t\t\tcommands.push('/ban @username [duration] [reason] - Ban a user');\n\t\t\tcommands.push('/timeout @username [duration] [reason] - Timeout a user');\n\t\t\tcommands.push('/clear - Clear all messages in the room');\n\t\t}\n\n\t\tconst helpMessage =\n\t\t\tcommands.length > 0\n\t\t\t\t? `Available commands:\\n${commands.join('\\n')}`\n\t\t\t\t: 'No commands available in this room';\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: helpMessage\n\t\t};\n\t}\n\n\t/**\n\t * Apply content filters (profanity, spam detection, etc.)\n\t */\n\tprivate static async applyContentFilters(\n\t\tcontent: string,\n\t\tconfig: ShoutboxConfig\n\t): Promise<{\n\t\tallowed: boolean;\n\t\treason?: string;\n\t\taction?: string;\n\t}> {\n\t\tif (!config.profanityFilterEnabled && !config.spamDetectionEnabled) {\n\t\t\treturn { allowed: true };\n\t\t}\n\n\t\ttry {\n\t\t\t// Check banned words\n\t\t\tconst bannedWords = await db.query.shoutboxBannedWords.findMany({\n\t\t\t\twhere: and(\n\t\t\t\t\teq(shoutboxBannedWords.enabled, true),\n\t\t\t\t\tor(\n\t\t\t\t\t\tisNull(shoutboxBannedWords.roomId),\n\t\t\t\t\t\teq(shoutboxBannedWords.roomId, config.roomId || '')\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t});\n\n\t\t\tfor (const bannedWord of bannedWords) {\n\t\t\t\tconst pattern = bannedWord.isRegex\n\t\t\t\t\t? new RegExp(bannedWord.pattern, 'i')\n\t\t\t\t\t: new RegExp(bannedWord.pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i');\n\n\t\t\t\tif (pattern.test(content)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tallowed: bannedWord.action === 'warn',\n\t\t\t\t\t\treason: bannedWord.warningMessage || 'Content contains inappropriate language',\n\t\t\t\t\t\taction: bannedWord.action\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Basic spam detection (repeated characters, excessive caps, etc.)\n\t\t\tif (config.spamDetectionEnabled) {\n\t\t\t\tconst repeatedCharsMatch = content.match(/(.)\\1{5,}/);\n\t\t\t\tif (repeatedCharsMatch) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tallowed: false,\n\t\t\t\t\t\treason: 'Message contains too many repeated characters'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tconst capsRatio = (content.match(/[A-Z]/g) || []).length / content.length;\n\t\t\t\tif (content.length > 10 && capsRatio > 0.7) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tallowed: false,\n\t\t\t\t\t\treason: 'Message contains too many capital letters'\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { allowed: true };\n\t\t} catch (error) {\n\t\t\tlogger.error('ShoutboxService', 'Error in content filtering', { error, content });\n\t\t\treturn { allowed: true }; // Allow message if filtering fails\n\t\t}\n\t}\n\n\t/**\n\t * Create a regular message\n\t */\n\tprivate static async createMessage(\n\t\tcontext: MessageContext,\n\t\tconfig: ShoutboxConfig\n\t): Promise<CommandResult> {\n\t\ttry {\n\t\t\tconst [message] = await db\n\t\t\t\t.insert(shoutboxMessages)\n\t\t\t\t.values({\n\t\t\t\t\tuserId: context.userId,\n\t\t\t\t\troomId: context.roomId,\n\t\t\t\t\tcontent: context.content\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Log analytics\n\t\t\tif (config.analyticsEnabled) {\n\t\t\t\tawait this.logAnalytics({\n\t\t\t\t\teventType: 'message',\n\t\t\t\t\tuserId: context.userId.toString(),\n\t\t\t\t\troomId: context.roomId.toString(),\n\t\t\t\t\teventData: { messageId: message.id.toString() },\n\t\t\t\t\tsessionId: context.sessionId,\n\t\t\t\t\tipAddress: context.ipAddress\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Message sent successfully',\n\t\t\t\tdata: message\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('ShoutboxService', 'Error creating message', { error, context });\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Failed to send message',\n\t\t\t\terror: 'MESSAGE_CREATION_FAILED'\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Create a system message\n\t */\n\tprivate static async createSystemMessage(roomId: RoomId, content: string): Promise<void> {\n\t\ttry {\n\t\t\tawait db.insert(shoutboxMessages).values({\n\t\t\t\tuserId: null, // System message\n\t\t\t\troomId,\n\t\t\t\tcontent,\n\t\t\t\tisDeleted: false\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ShoutboxService', 'Error creating system message', { error, roomId, content });\n\t\t}\n\t}\n\n\t/**\n\t * Get active users in a room\n\t */\n\tprivate static async getActiveRoomUsers(roomId: RoomId): Promise<any[]> {\n\t\t// This would typically query online users or recent message senders\n\t\t// For now, return mock data\n\t\treturn [];\n\t}\n\n\t/**\n\t * Get user role from roles array\n\t */\n\tprivate static getUserRole(userRoles: string[]): string {\n\t\tif (userRoles.includes('admin')) return 'admin';\n\t\tif (userRoles.includes('moderator')) return 'moderator';\n\t\treturn 'user';\n\t}\n\n\t/**\n\t * Log analytics event\n\t */\n\tprivate static async logAnalytics(event: {\n\t\teventType: string;\n\t\tuserId: string;\n\t\troomId: string;\n\t\teventData?: any;\n\t\tsessionId?: string;\n\t\tipAddress?: string;\n\t}): Promise<void> {\n\t\ttry {\n\t\t\tawait db.insert(shoutboxAnalytics).values({\n\t\t\t\teventType: event.eventType,\n\t\t\t\tuserId: event.userId,\n\t\t\t\troomId: event.roomId,\n\t\t\t\teventData: event.eventData || {},\n\t\t\t\tsessionId: event.sessionId,\n\t\t\t\tipAddress: event.ipAddress\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('ShoutboxService', 'Error logging analytics', { error, event });\n\t\t}\n\t}\n\n\t/**\n\t * Clear configuration cache\n\t */\n\tstatic clearConfigCache(roomId?: RoomId): void {\n\t\tconst cacheKey = `config:${roomId || 'global'}`;\n\t\tthis.configCache.delete(cacheKey);\n\t}\n\n\t/**\n\t * Update configuration\n\t */\n\tstatic async updateConfig(\n\t\tconfigData: Partial<NewShoutboxConfig>,\n\t\troomId?: RoomId\n\t): Promise<ShoutboxConfig> {\n\t\tconst scope = roomId ? 'room' : 'global';\n\t\tconst whereClause = roomId\n\t\t\t? and(eq(shoutboxConfig.scope, 'room'), eq(shoutboxConfig.roomId, roomId.toString()))\n\t\t\t: and(eq(shoutboxConfig.scope, 'global'), isNull(shoutboxConfig.roomId));\n\n\t\tconst [updated] = await db\n\t\t\t.update(shoutboxConfig)\n\t\t\t.set({\n\t\t\t\t...configData,\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\tupdatedBy: configData.updatedBy || 'system'\n\t\t\t})\n\t\t\t.where(whereClause)\n\t\t\t.returning();\n\n\t\t// Clear cache\n\t\tthis.clearConfigCache(roomId);\n\n\t\treturn updated;\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/shoutbox/shoutbox.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'customEmojis' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":17,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":19,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":19,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'not' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":19,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAuthenticatedOptional' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":23,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":26,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":19},{"ruleId":"prefer-const","severity":1,"message":"'whereCondition' is never reassigned. Use 'const' instead.","line":328,"column":3,"nodeType":"Identifier","messageId":"useConst","endLine":328,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Shoutbox Routes\n *\n * Defines API routes for the shoutbox messaging system.\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport type { MessageId, UserId } from '@shared/types';\nimport { db } from '@db';\nimport {\n\tshoutboxMessages,\n\tinsertShoutboxMessageSchema,\n\tusers,\n\tchatRooms,\n\tcustomEmojis\n} from '@schema';\nimport { sql, desc, eq, and, isNull, inArray, asc, not, or } from 'drizzle-orm';\nimport { ZodError } from 'zod';\nimport {\n\tisAuthenticated,\n\tisAuthenticatedOptional,\n\tisAdminOrModerator\n} from '../auth/middleware/auth.middleware';\nimport { getUserId } from '../auth/services/auth.service';\nimport { canUser } from '@lib/auth/canUser.ts';\nimport { logger } from '@server/src/core/logger';\nimport { MentionsService } from '../social/mentions.service';\nimport type { RoomId, GroupId } from '@shared/types';\n\n// Rate limiting for shoutbox messages (10 seconds cooldown)\nconst userLastMessageTime = new Map<UserId, number>();\nconst COOLDOWN_MS = 10000; // 10 seconds\n\n// Check if user has access to a specific chat room\nasync function userHasRoomAccess(userId: UserId, roomId: RoomId): Promise<boolean> {\n\ttry {\n\t\t// Get the room info\n\t\tconst roomInfo = await db.select().from(chatRooms).where(eq(chatRooms.id, roomId)).limit(1);\n\n\t\tif (roomInfo.length === 0 || roomInfo[0].isDeleted) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst room = roomInfo[0];\n\n\t\t// If the room is not private, or if the user created the room, they have access\n\t\tif (!room.isPrivate || room.createdBy === userId) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check if the user meets the minimum XP requirement\n\t\tif (room.minXpRequired && room.minXpRequired > 0) {\n\t\t\tconst userInfo = await db\n\t\t\t\t.select({ xp: users.xp })\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userInfo.length === 0 || !userInfo[0].xp || userInfo[0].xp < room.minXpRequired) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if the user meets the minimum group requirement\n\t\tif (room.minGroupIdRequired) {\n\t\t\tconst userInfo = await db\n\t\t\t\t.select({ groupId: users.groupId })\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userInfo.length === 0 || !userInfo[0].groupId) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Lower group IDs typically have higher permissions\n\t\t\t// Admin = 1, Moderator = 2, Regular user = 3+\n\t\t\tif (userInfo[0].groupId > room.minGroupIdRequired) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t} catch (error) {\n\t\tlogger.error('ShoutboxRoutes', 'Error checking room access', { err: error, roomId, userId });\n\t\treturn false;\n\t}\n}\n\nconst router = Router();\n\n// Get available chat rooms\nrouter.get('/rooms', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst isAdminOrMod = userService.getUserFromRequest(req)\n\t\t\t? await canUser(\n\t\t\t\t\t{\n\t\t\t\t\t\tid: (userService.getUserFromRequest(req) as any).id,\n\t\t\t\t\t\tprimaryRoleId: (userService.getUserFromRequest(req) as any).primaryRoleId,\n\t\t\t\t\t\tsecondaryRoleIds: (userService.getUserFromRequest(req) as any).secondaryRoleIds\n\t\t\t\t\t},\n\t\t\t\t\t'canModerateChat'\n\t\t\t\t)\n\t\t\t: false;\n\n\t\t// Base query - get non-deleted rooms\n\t\tlet query = db\n\t\t\t.select({\n\t\t\t\tid: chatRooms.id,\n\t\t\t\tname: chatRooms.name,\n\t\t\t\tdescription: chatRooms.description,\n\t\t\t\tisPrivate: chatRooms.isPrivate,\n\t\t\t\tminXpRequired: chatRooms.minXpRequired,\n\t\t\t\tcreatedAt: chatRooms.createdAt,\n\t\t\t\tcreatedBy: chatRooms.createdBy,\n\t\t\t\torder: chatRooms.order\n\t\t\t})\n\t\t\t.from(chatRooms)\n\t\t\t.where(eq(chatRooms.isDeleted, false))\n\t\t\t.orderBy(asc(chatRooms.order));\n\n\t\t// If user is not admin/mod, exclude private rooms they don't have access to\n\t\tif (!isAdminOrMod && userId) {\n\t\t\t// For logged-in regular users, filter rooms they can access:\n\t\t\t// 1. Public rooms (not private)\n\t\t\t// 2. Private rooms where they meet the group requirement\n\t\t\tquery = db\n\t\t\t\t.select({\n\t\t\t\t\tid: chatRooms.id,\n\t\t\t\t\tname: chatRooms.name,\n\t\t\t\t\tdescription: chatRooms.description,\n\t\t\t\t\tisPrivate: chatRooms.isPrivate,\n\t\t\t\t\tminXpRequired: chatRooms.minXpRequired,\n\t\t\t\t\tcreatedAt: chatRooms.createdAt,\n\t\t\t\t\tcreatedBy: chatRooms.createdBy,\n\t\t\t\t\torder: chatRooms.order\n\t\t\t\t})\n\t\t\t\t.from(chatRooms)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(chatRooms.isDeleted, false),\n\t\t\t\t\t\tor(\n\t\t\t\t\t\t\teq(chatRooms.isPrivate, false),\n\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\teq(chatRooms.isPrivate, true),\n\t\t\t\t\t\t\t\tor(\n\t\t\t\t\t\t\t\t\t// User created the room\n\t\t\t\t\t\t\t\t\teq(chatRooms.createdBy, userId),\n\t\t\t\t\t\t\t\t\t// User meets minimum group requirement (lower groupId = higher permission)\n\t\t\t\t\t\t\t\t\tsql`(\n                  SELECT ${users.groupId} FROM ${users} \n                  WHERE ${users.id} = ${userId}\n                ) <= ${chatRooms.minGroupIdRequired}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.orderBy(asc(chatRooms.order));\n\t\t} else if (!userId) {\n\t\t\t// For guests, only show public rooms\n\t\t\tquery = db\n\t\t\t\t.select({\n\t\t\t\t\tid: chatRooms.id,\n\t\t\t\t\tname: chatRooms.name,\n\t\t\t\t\tdescription: chatRooms.description,\n\t\t\t\t\tisPrivate: chatRooms.isPrivate,\n\t\t\t\t\tminXpRequired: chatRooms.minXpRequired,\n\t\t\t\t\tcreatedAt: chatRooms.createdAt,\n\t\t\t\t\tcreatedBy: chatRooms.createdBy,\n\t\t\t\t\torder: chatRooms.order\n\t\t\t\t})\n\t\t\t\t.from(chatRooms)\n\t\t\t\t.where(and(eq(chatRooms.isDeleted, false), eq(chatRooms.isPrivate, false)))\n\t\t\t\t.orderBy(asc(chatRooms.order));\n\t\t}\n\n\t\tconst rooms = await query;\n\n\t\t// Add accessibility information for the current user\n\t\tconst roomsWithAccess = rooms.map((room) => {\n\t\t\tconst accessible = !room.isPrivate || isAdminOrMod || (userId && room.createdBy === userId);\n\n\t\t\treturn {\n\t\t\t\t...room,\n\t\t\t\taccessible,\n\t\t\t\tlocked: !accessible\n\t\t\t};\n\t\t});\n\n\t\tres.json(roomsWithAccess);\n\t} catch (error) {\n\t\tlogger.error('ShoutboxRoutes', 'Error fetching chat rooms', { err: error });\n\t\tres.status(500).json({ error: 'Failed to fetch chat rooms' });\n\t}\n});\n\n// Moderation endpoint: Delete (soft delete) a shoutbox message with WebSocket notification\nrouter.delete('/messages/:id', isAdminOrModerator, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst messageId = req.params.id as MessageId;\n\n\t\t// Check if message exists\n\t\tconst existingMessage = await db\n\t\t\t.select()\n\t\t\t.from(shoutboxMessages)\n\t\t\t.where(eq(shoutboxMessages.id, messageId))\n\t\t\t.limit(1);\n\n\t\tif (existingMessage.length === 0) {\n\t\t\treturn res.status(404).json({ error: 'Message not found' });\n\t\t}\n\n\t\t// Soft delete the message (mark as deleted)\n\t\tconst result = await db\n\t\t\t.update(shoutboxMessages)\n\t\t\t.set({\n\t\t\t\tisDeleted: true,\n\t\t\t\teditedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(shoutboxMessages.id, messageId))\n\t\t\t.returning();\n\n\t\t// Log the moderation action\n\t\tconst moderatorId = userService.getUserFromRequest(req);\n\t\tlogger.info('ShoutboxRoutes', `User ${moderatorId} deleted shoutbox message ${messageId}`, {\n\t\t\tmoderatorId,\n\t\t\tmessageId,\n\t\t\taction: 'delete_shoutbox_message'\n\t\t});\n\n\t\tconst deletedMessage = result[0];\n\n\t\t// Notify connected clients about the deletion\n\t\tif (req.app && (req.app as any).wss && (req.app as any).wss.clients) {\n\t\t\tconst clients = (req.app as any).wss.clients;\n\t\t\tconst broadcastData = {\n\t\t\t\ttype: 'chat_update',\n\t\t\t\taction: 'message_deleted',\n\t\t\t\tmessageId: messageId,\n\t\t\t\troomId: deletedMessage.roomId,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\n\t\t\tfor (const client of clients) {\n\t\t\t\tif (client.readyState === 1) {\n\t\t\t\t\t// WebSocket.OPEN\n\t\t\t\t\tclient.send(JSON.stringify(broadcastData));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: 'Message deleted successfully',\n\t\t\tdeletedMessage: deletedMessage\n\t\t});\n\t} catch (error) {\n\t\t// console.error('Error deleting shoutbox message:', error); // Original console.error removed\n\t\tconst messageIdForLog = req.params.id as MessageId; // Ensure messageId is available for logging\n\t\tlogger.error('ShoutboxRoutes', 'Error deleting shoutbox message', {\n\t\t\terr: error,\n\t\t\tmessageId: messageIdForLog\n\t\t});\n\t\tres.status(500).json({ error: 'Failed to delete message' });\n\t}\n});\n\n// Get latest shoutbox messages - now with room support\nrouter.get('/messages', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst limit = req.query.limit ? parseInt(req.query.limit as string) : 50;\n\t\tconst roomId = req.query.roomId ? (req.query.roomId as string) as RoomId : null;\n\t\tconst currentUserId = userService.getUserFromRequest(req);\n\n\t\t// Check if the user has access to the specified room\n\t\tif (roomId && currentUserId) {\n\t\t\tconst hasAccess = await userHasRoomAccess(currentUserId, roomId);\n\t\t\tif (!hasAccess) {\n\t\t\t\treturn res.status(403).json({ error: 'You do not have access to this room' });\n\t\t\t}\n\t\t} else if (roomId && !currentUserId) {\n\t\t\t// If guest tries to access a specific room, check if it's public\n\t\t\tconst roomInfo = await db\n\t\t\t\t.select({ isPrivate: chatRooms.isPrivate })\n\t\t\t\t.from(chatRooms)\n\t\t\t\t.where(eq(chatRooms.id, roomId))\n\t\t\t\t.limit(1);\n\t\t\tif (roomInfo.length === 0 || roomInfo[0].isPrivate) {\n\t\t\t\treturn res.status(403).json({ error: 'You do not have access to this room' });\n\t\t\t}\n\t\t}\n\n\t\t// Variable to hold our where condition\n\t\tlet whereCondition;\n\t\tlet targetRoomId: RoomId | null = roomId;\n\n\t\t// Determine the target room ID if not explicitly provided\n\t\tif (!targetRoomId) {\n\t\t\ttry {\n\t\t\t\tconst defaultRoom = await db\n\t\t\t\t\t.select({ id: chatRooms.id })\n\t\t\t\t\t.from(chatRooms)\n\t\t\t\t\t.where(and(eq(chatRooms.name, 'degen-lounge'), eq(chatRooms.isDeleted, false)))\n\t\t\t\t\t.limit(1);\n\t\t\t\tif (defaultRoom.length > 0) {\n\t\t\t\t\ttargetRoomId = defaultRoom[0].id;\n\t\t\t\t} else {\n\t\t\t\t\t// If no default room, maybe return empty or fetch from all public rooms?\n\t\t\t\t\t// For now, let's return empty if no room is specified and default doesn't exist.\n\t\t\t\t\treturn res.json([]);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.warn('ShoutboxRoutes', 'Error fetching default room', { err: error });\n\t\t\t\treturn res.status(500).json({ error: 'Failed to determine chat room' });\n\t\t\t}\n\t\t}\n\n\t\t// Ensure we have a target room ID to filter by\n\t\tif (!targetRoomId) {\n\t\t\t// This case should ideally not be reached if the logic above is sound\n\t\t\treturn res.status(400).json({ error: 'Could not determine the target chat room.' });\n\t\t}\n\n\t\twhereCondition = eq(shoutboxMessages.roomId, targetRoomId);\n\n\t\t// Perform a single query with LEFT JOIN\n\t\tconst messagesWithUsers = await db\n\t\t\t.select({\n\t\t\t\t// Message fields\n\t\t\t\tid: shoutboxMessages.id,\n\t\t\t\tuserId: shoutboxMessages.userId,\n\t\t\t\troomId: shoutboxMessages.roomId,\n\t\t\t\tcontent: shoutboxMessages.content,\n\t\t\t\tcreatedAt: shoutboxMessages.createdAt,\n\t\t\t\teditedAt: shoutboxMessages.editedAt,\n\t\t\t\tisDeleted: shoutboxMessages.isDeleted,\n\t\t\t\tisPinned: shoutboxMessages.isPinned,\n\t\t\t\ttipAmount: shoutboxMessages.tipAmount,\n\t\t\t\t// User fields (prefixed)\n\t\t\t\tu_id: users.id,\n\t\t\t\tu_username: users.username,\n\t\t\t\tu_avatarUrl: users.avatarUrl,\n\t\t\t\tu_activeAvatarUrl: users.activeAvatarUrl,\n\t\t\t\tu_level: users.level,\n\t\t\t\tu_groupId: users.groupId,\n\t\t\t\tu_isActive: users.isActive, // Include flags to check status\n\t\t\t\tu_isBanned: users.isBanned\n\t\t\t})\n\t\t\t.from(shoutboxMessages)\n\t\t\t.leftJoin(users, eq(shoutboxMessages.userId, users.id))\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\twhereCondition // Filter by the target room\n\t\t\t\t\t// Optionally hide deleted messages unless requested?\n\t\t\t\t\t// For now, include deleted messages and let frontend handle visibility\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(desc(shoutboxMessages.createdAt))\n\t\t\t.limit(limit);\n\n\t\t// Process the results\n\t\tconst messages = messagesWithUsers.map((row) => {\n\t\t\tlet user = null;\n\t\t\t// Check if user exists and is active/not banned\n\t\t\tif (row.u_id && row.u_isActive && !row.u_isBanned) {\n\t\t\t\tuser = {\n\t\t\t\t\tid: row.u_id,\n\t\t\t\t\tusername: row.u_username,\n\t\t\t\t\tavatarUrl: row.u_avatarUrl,\n\t\t\t\t\tactiveAvatarUrl: row.u_activeAvatarUrl,\n\t\t\t\t\tlevel: row.u_level,\n\t\t\t\t\tgroupId: row.u_groupId\n\t\t\t\t};\n\t\t\t} else if (row.u_id) {\n\t\t\t\t// User exists but is inactive or banned\n\t\t\t\tuser = {\n\t\t\t\t\tid: row.u_id,\n\t\t\t\t\tusername: row.u_username || '[Inactive User]',\n\t\t\t\t\tavatarUrl: null,\n\t\t\t\t\tactiveAvatarUrl: null,\n\t\t\t\t\tlevel: 1,\n\t\t\t\t\tgroupId: null, // Indicate inactive/banned status\n\t\t\t\t\tisInactiveOrBanned: true\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// User ID was likely null in the message, or user truly deleted\n\t\t\t\tuser = {\n\t\t\t\t\tid: row.userId, // Keep original ID if available\n\t\t\t\t\tusername: '[Deleted User]',\n\t\t\t\t\tavatarUrl: null,\n\t\t\t\t\tactiveAvatarUrl: null,\n\t\t\t\t\tlevel: 1,\n\t\t\t\t\tgroupId: null,\n\t\t\t\t\tisDeleted: true\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tid: row.id,\n\t\t\t\troomId: row.roomId,\n\t\t\t\tcontent: row.content,\n\t\t\t\tcreatedAt: row.createdAt,\n\t\t\t\teditedAt: row.editedAt,\n\t\t\t\tisDeleted: row.isDeleted,\n\t\t\t\tisPinned: row.isPinned,\n\t\t\t\ttipAmount: row.tipAmount,\n\t\t\t\tuser // Attach the processed user object\n\t\t\t};\n\t\t});\n\n\t\tres.json(messages);\n\t} catch (error) {\n\t\tconst roomIdForLog = req.query.roomId ? (req.query.roomId as string) as RoomId : null;\n\t\tconst limitForLog = req.query.limit ? parseInt(req.query.limit as string) : 50;\n\t\tlogger.error('ShoutboxRoutes', 'Error fetching shoutbox messages', {\n\t\t\terr: error,\n\t\t\troomId: roomIdForLog,\n\t\t\tlimit: limitForLog\n\t\t});\n\t\tres.status(500).json({ error: 'Failed to fetch shoutbox messages' });\n\t}\n});\n\n// Post a new shoutbox message - now with room support and WebSocket broadcast\nrouter.post('/messages', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req);\n\t\tconst { roomId } = req.body;\n\n\t\t// Check rate limiting\n\t\tconst lastMessageTime = userLastMessageTime.get(userId) || 0;\n\t\tconst now = Date.now();\n\n\t\tif (now - lastMessageTime < COOLDOWN_MS) {\n\t\t\tconst waitTime = Math.ceil((COOLDOWN_MS - (now - lastMessageTime)) / 1000);\n\t\t\treturn res.status(429).json({\n\t\t\t\terror: `Please wait ${waitTime} seconds before sending another message`\n\t\t\t});\n\t\t}\n\n\t\t// If roomId is provided, check if user has access to this room\n\t\tif (roomId) {\n\t\t\tconst hasAccess = await userHasRoomAccess(userId, roomId);\n\t\t\tif (!hasAccess) {\n\t\t\t\treturn res.status(403).json({ error: 'You do not have access to this room' });\n\t\t\t}\n\t\t} else {\n\t\t\t// If no roomId specified, get the default room (degen-lounge)\n\t\t\tconst defaultRoom = await db\n\t\t\t\t.select()\n\t\t\t\t.from(chatRooms)\n\t\t\t\t.where(eq(chatRooms.name, 'degen-lounge'))\n\t\t\t\t.limit(1);\n\n\t\t\tif (defaultRoom.length > 0) {\n\t\t\t\treq.body.roomId = defaultRoom[0].id;\n\t\t\t}\n\t\t}\n\n\t\t// Validate message data\n\t\tconst messageData = insertShoutboxMessageSchema.parse({\n\t\t\t...req.body,\n\t\t\tuserId\n\t\t});\n\n\t\t// Insert message\n\t\tconst result = await db.insert(shoutboxMessages).values(messageData).returning();\n\t\tconst newMessage = result[0];\n\n\t\t// Update rate limit tracking\n\t\tuserLastMessageTime.set(userId, now);\n\n\t\t// Process mentions in the shoutbox message\n\t\ttry {\n\t\t\tawait MentionsService.processMentions({\n\t\t\t\tcontent: messageData.content,\n\t\t\t\tmentioningUserId: userId.toString(),\n\t\t\t\ttype: 'shoutbox',\n\t\t\t\tmessageId: newMessage.id.toString(),\n\t\t\t\tcontext: `Shoutbox message in room ${newMessage.roomId}`\n\t\t\t});\n\t\t} catch (mentionError) {\n\t\t\tlogger.error('ShoutboxRoutes', 'Error processing mentions for shoutbox message', {\n\t\t\t\terr: mentionError,\n\t\t\t\tmessageId: newMessage.id,\n\t\t\t\tuserId\n\t\t\t});\n\t\t\t// Don't fail the message creation if mentions fail\n\t\t}\n\n\t\t// Get user data to return with the message\n\t\tconst userData = await db\n\t\t\t.select({\n\t\t\t\tid: users.id,\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\tlevel: users.level,\n\t\t\t\tgroupId: users.groupId\n\t\t\t})\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, userId))\n\t\t\t.limit(1);\n\n\t\tconst responseData = {\n\t\t\t...newMessage,\n\t\t\tuser: userData[0]\n\t\t};\n\n\t\t// Broadcast the message to all connected WebSocket clients\n\t\tif (req.app && (req.app as any).wss && (req.app as any).wss.clients) {\n\t\t\tconst clients = (req.app as any).wss.clients;\n\t\t\tconst broadcastData = {\n\t\t\t\ttype: 'chat_update',\n\t\t\t\taction: 'new_message',\n\t\t\t\tmessage: responseData,\n\t\t\t\troomId: newMessage.roomId,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\n\t\t\tfor (const client of clients) {\n\t\t\t\tif (client.readyState === 1) {\n\t\t\t\t\t// WebSocket.OPEN\n\t\t\t\t\tclient.send(JSON.stringify(broadcastData));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tres.status(201).json(responseData);\n\t} catch (error) {\n\t\tif (error instanceof ZodError) {\n\t\t\treturn res.status(400).json({\n\t\t\t\terror: 'Invalid message data',\n\t\t\t\tdetails: error.errors\n\t\t\t});\n\t\t}\n\n\t\tconst userIdForLog = userService.getUserFromRequest(req); // Ensure userId is available\n\t\tconst roomIdForLog = req.body.roomId; // Get roomId from request body for logging context\n\t\tlogger.error('ShoutboxRoutes', 'Error creating shoutbox message', {\n\t\t\terr: error,\n\t\t\tuserId: userIdForLog,\n\t\t\troomId: roomIdForLog\n\t\t});\n\t\tres.status(500).json({ error: 'Failed to create shoutbox message' });\n\t}\n});\n\n// Update a shoutbox message (for pinning/unpinning) - admin/mod only with WebSocket notification\nrouter.patch('/messages/:id', isAdminOrModerator, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst messageId = req.params.id as MessageId;\n\n\t\t// Check if message exists\n\t\tconst existingMessage = await db\n\t\t\t.select()\n\t\t\t.from(shoutboxMessages)\n\t\t\t.where(eq(shoutboxMessages.id, messageId))\n\t\t\t.limit(1);\n\n\t\tif (existingMessage.length === 0) {\n\t\t\treturn res.status(404).json({ error: 'Message not found' });\n\t\t}\n\n\t\t// Validate update data - currently only supporting isPinned\n\t\tconst { isPinned } = req.body;\n\n\t\t// Check if isPinned is a boolean\n\t\tif (typeof isPinned !== 'boolean') {\n\t\t\treturn res.status(400).json({ error: 'isPinned must be a boolean value' });\n\t\t}\n\n\t\t// Update the message\n\t\tconst result = await db\n\t\t\t.update(shoutboxMessages)\n\t\t\t.set({\n\t\t\t\tisPinned,\n\t\t\t\teditedAt: new Date() // Update the edited timestamp\n\t\t\t})\n\t\t\t.where(eq(shoutboxMessages.id, messageId))\n\t\t\t.returning();\n\n\t\t// Log the moderation action\n\t\tconst moderatorId = userService.getUserFromRequest(req);\n\t\tlogger.info(\n\t\t\t'ShoutboxRoutes',\n\t\t\t`User ${moderatorId} ${isPinned ? 'pinned' : 'unpinned'} shoutbox message ${messageId}`,\n\t\t\t{\n\t\t\t\tmoderatorId,\n\t\t\t\tmessageId,\n\t\t\t\taction: isPinned ? 'pin_shoutbox_message' : 'unpin_shoutbox_message',\n\t\t\t\tisPinned\n\t\t\t}\n\t\t);\n\n\t\tconst updatedMessage = result[0];\n\n\t\t// Notify connected clients about the pin/unpin action\n\t\tif (req.app && (req.app as any).wss && (req.app as any).wss.clients) {\n\t\t\tconst clients = (req.app as any).wss.clients;\n\t\t\tconst broadcastData = {\n\t\t\t\ttype: 'chat_update',\n\t\t\t\taction: isPinned ? 'message_pinned' : 'message_unpinned',\n\t\t\t\tmessageId: messageId,\n\t\t\t\troomId: updatedMessage.roomId,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\n\t\t\tfor (const client of clients) {\n\t\t\t\tif (client.readyState === 1) {\n\t\t\t\t\t// WebSocket.OPEN\n\t\t\t\t\tclient.send(JSON.stringify(broadcastData));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tres.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: isPinned ? 'Message pinned successfully' : 'Message unpinned successfully',\n\t\t\tupdatedMessage: updatedMessage\n\t\t});\n\t} catch (error) {\n\t\t// console.error('Error updating shoutbox message:', error); // Original console.error removed\n\t\tconst messageIdForLog = req.params.id as MessageId; // Ensure messageId is available\n\t\tconst isPinnedForLog = req.body.isPinned; // Ensure isPinned is available\n\t\tlogger.error('ShoutboxRoutes', 'Error updating shoutbox message', {\n\t\t\terr: error,\n\t\t\tmessageId: messageIdForLog,\n\t\t\tisPinned: isPinnedForLog\n\t\t});\n\t\tres.status(500).json({ error: 'Failed to update message' });\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/follows.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/follows.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { userFollows, userFollowPreferences, followRequests, users } from '@schema';\nimport { eq, and, desc, sql, count, inArray } from 'drizzle-orm';\nimport type { FollowNotificationSettings, UserStats } from './follows.types';\nimport type { RequestId } from '@shared/types';\n\nexport class FollowsService {\n\t/**\n\t * Follow a user\n\t */\n\tstatic async followUser({\n\t\tfollowerId,\n\t\tfollowedId,\n\t\tnotificationSettings = {}\n\t}: {\n\t\tfollowerId: string;\n\t\tfollowedId: string;\n\t\tnotificationSettings?: Partial<FollowNotificationSettings>;\n\t}) {\n\t\t// Prevent self-following\n\t\tif (followerId === followedId) {\n\t\t\tthrow new Error('Cannot follow yourself');\n\t\t}\n\n\t\t// Check if already following\n\t\tconst existingFollow = await db\n\t\t\t.select()\n\t\t\t.from(userFollows)\n\t\t\t.where(and(eq(userFollows.followerId, followerId), eq(userFollows.followedId, followedId)))\n\t\t\t.limit(1);\n\n\t\tif (existingFollow.length > 0) {\n\t\t\tthrow new Error('Already following this user');\n\t\t}\n\n\t\t// Check if follow approval is required\n\t\tconst followedUserPrefs = await this.getUserFollowPreferences(followedId);\n\n\t\tif (followedUserPrefs.requireFollowApproval) {\n\t\t\t// Create follow request instead of direct follow\n\t\t\tconst request = await db\n\t\t\t\t.insert(followRequests)\n\t\t\t\t.values({\n\t\t\t\t\trequesterId: followerId,\n\t\t\t\t\ttargetId: followedId,\n\t\t\t\t\tmessage: '', // Could be extended to include a message\n\t\t\t\t\tisPending: true,\n\t\t\t\t\tisApproved: false,\n\t\t\t\t\tisRejected: false\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\treturn { type: 'request', data: request[0] };\n\t\t}\n\n\t\t// Create direct follow\n\t\tconst follow = await db\n\t\t\t.insert(userFollows)\n\t\t\t.values({\n\t\t\t\tfollowerId,\n\t\t\t\tfollowedId,\n\t\t\t\tnotifyOnPosts: notificationSettings.notifyOnPosts ?? true,\n\t\t\t\tnotifyOnThreads: notificationSettings.notifyOnThreads ?? true,\n\t\t\t\tnotifyOnTrades: notificationSettings.notifyOnTrades ?? false,\n\t\t\t\tnotifyOnLargeStakes: notificationSettings.notifyOnLargeStakes ?? true,\n\t\t\t\tminStakeNotification: notificationSettings.minStakeNotification ?? 1000\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn { type: 'follow', data: follow[0] };\n\t}\n\n\t/**\n\t * Unfollow a user\n\t */\n\tstatic async unfollowUser(followerId: string, followedId: string) {\n\t\tconst result = await db\n\t\t\t.delete(userFollows)\n\t\t\t.where(and(eq(userFollows.followerId, followerId), eq(userFollows.followedId, followedId)))\n\t\t\t.returning();\n\n\t\tif (result.length === 0) {\n\t\t\tthrow new Error('Follow relationship not found');\n\t\t}\n\n\t\treturn result[0];\n\t}\n\n\t/**\n\t * Check if user A is following user B\n\t */\n\tstatic async isFollowing(followerId: string, followedId: string): Promise<boolean> {\n\t\tconst result = await db\n\t\t\t.select({ id: userFollows.id })\n\t\t\t.from(userFollows)\n\t\t\t.where(and(eq(userFollows.followerId, followerId), eq(userFollows.followedId, followedId)))\n\t\t\t.limit(1);\n\n\t\treturn result.length > 0;\n\t}\n\n\t/**\n\t * Get user's following list\n\t */\n\tstatic async getUserFollowing(userId: string, page = 1, limit = 20) {\n\t\tconst offset = (page - 1) * limit;\n\n\t\tconst following = await db\n\t\t\t.select({\n\t\t\t\tid: userFollows.id,\n\t\t\t\tfollowedAt: userFollows.createdAt,\n\t\t\t\tnotificationSettings: {\n\t\t\t\t\tnotifyOnPosts: userFollows.notifyOnPosts,\n\t\t\t\t\tnotifyOnThreads: userFollows.notifyOnThreads,\n\t\t\t\t\tnotifyOnTrades: userFollows.notifyOnTrades,\n\t\t\t\t\tnotifyOnLargeStakes: userFollows.notifyOnLargeStakes,\n\t\t\t\t\tminStakeNotification: userFollows.minStakeNotification\n\t\t\t\t},\n\t\t\t\tuser: {\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\trole: users.role,\n\t\t\t\t\tclout: users.clout\n\t\t\t\t}\n\t\t\t})\n\t\t\t.from(userFollows)\n\t\t\t.leftJoin(users, eq(userFollows.followedId, users.id))\n\t\t\t.where(eq(userFollows.followerId, userId))\n\t\t\t.orderBy(desc(userFollows.createdAt))\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\n\t\treturn following;\n\t}\n\n\t/**\n\t * Get user's followers list\n\t */\n\tstatic async getUserFollowers(userId: string, page = 1, limit = 20) {\n\t\tconst offset = (page - 1) * limit;\n\n\t\tconst followers = await db\n\t\t\t.select({\n\t\t\t\tid: userFollows.id,\n\t\t\t\tfollowedAt: userFollows.createdAt,\n\t\t\t\tuser: {\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\trole: users.role,\n\t\t\t\t\tclout: users.clout\n\t\t\t\t}\n\t\t\t})\n\t\t\t.from(userFollows)\n\t\t\t.leftJoin(users, eq(userFollows.followerId, users.id))\n\t\t\t.where(eq(userFollows.followedId, userId))\n\t\t\t.orderBy(desc(userFollows.createdAt))\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\n\t\treturn followers;\n\t}\n\n\t/**\n\t * Get user follow counts\n\t */\n\tstatic async getUserFollowCounts(userId: string) {\n\t\tconst followingCount = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(userFollows)\n\t\t\t.where(eq(userFollows.followerId, userId));\n\n\t\tconst followersCount = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(userFollows)\n\t\t\t.where(eq(userFollows.followedId, userId));\n\n\t\treturn {\n\t\t\tfollowing: followingCount[0]?.count || 0,\n\t\t\tfollowers: followersCount[0]?.count || 0\n\t\t};\n\t}\n\n\t/**\n\t * Get user's follow preferences\n\t */\n\tstatic async getUserFollowPreferences(userId: string) {\n\t\tconst preferences = await db\n\t\t\t.select()\n\t\t\t.from(userFollowPreferences)\n\t\t\t.where(eq(userFollowPreferences.userId, userId))\n\t\t\t.limit(1);\n\n\t\t// Return default preferences if none exist\n\t\tif (preferences.length === 0) {\n\t\t\treturn {\n\t\t\t\tallowAllFollows: true,\n\t\t\t\tonlyFriendsCanFollow: false,\n\t\t\t\trequireFollowApproval: false,\n\t\t\t\thideFollowerCount: false,\n\t\t\t\thideFollowingCount: false,\n\t\t\t\thideFollowersList: false,\n\t\t\t\thideFollowingList: false,\n\t\t\t\tnotifyOnNewFollower: true,\n\t\t\t\temailOnNewFollower: false\n\t\t\t};\n\t\t}\n\n\t\treturn preferences[0];\n\t}\n\n\t/**\n\t * Update user's follow preferences\n\t */\n\tstatic async updateUserFollowPreferences(userId: string, preferences: Partial<any>) {\n\t\tconst existingPrefs = await db\n\t\t\t.select()\n\t\t\t.from(userFollowPreferences)\n\t\t\t.where(eq(userFollowPreferences.userId, userId))\n\t\t\t.limit(1);\n\n\t\tif (existingPrefs.length === 0) {\n\t\t\t// Create new preferences\n\t\t\treturn await db\n\t\t\t\t.insert(userFollowPreferences)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\t...preferences\n\t\t\t\t})\n\t\t\t\t.returning();\n\t\t} else {\n\t\t\t// Update existing preferences\n\t\t\treturn await db\n\t\t\t\t.update(userFollowPreferences)\n\t\t\t\t.set({\n\t\t\t\t\t...preferences,\n\t\t\t\t\tupdatedAt: sql`NOW()`\n\t\t\t\t})\n\t\t\t\t.where(eq(userFollowPreferences.userId, userId))\n\t\t\t\t.returning();\n\t\t}\n\t}\n\n\t/**\n\t * Get follow requests for a user\n\t */\n\tstatic async getFollowRequests(targetUserId: string) {\n\t\tconst requests = await db\n\t\t\t.select({\n\t\t\t\tid: followRequests.id,\n\t\t\t\tmessage: followRequests.message,\n\t\t\t\tcreatedAt: followRequests.createdAt,\n\t\t\t\trequester: {\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\trole: users.role\n\t\t\t\t}\n\t\t\t})\n\t\t\t.from(followRequests)\n\t\t\t.leftJoin(users, eq(followRequests.requesterId, users.id))\n\t\t\t.where(and(eq(followRequests.targetId, targetUserId), eq(followRequests.isPending, true)))\n\t\t\t.orderBy(desc(followRequests.createdAt));\n\n\t\treturn requests;\n\t}\n\n\t/**\n\t * Respond to a follow request\n\t */\n\tstatic async respondToFollowRequest(requestId: RequestId, approve: boolean) {\n\t\t// Get the request details\n\t\tconst request = await db\n\t\t\t.select()\n\t\t\t.from(followRequests)\n\t\t\t.where(eq(followRequests.id, requestId))\n\t\t\t.limit(1);\n\n\t\tif (request.length === 0) {\n\t\t\tthrow new Error('Follow request not found');\n\t\t}\n\n\t\tconst requestData = request[0];\n\n\t\tif (!requestData.isPending) {\n\t\t\tthrow new Error('Follow request already responded to');\n\t\t}\n\n\t\t// Update the request\n\t\tawait db\n\t\t\t.update(followRequests)\n\t\t\t.set({\n\t\t\t\tisPending: false,\n\t\t\t\tisApproved: approve,\n\t\t\t\tisRejected: !approve,\n\t\t\t\trespondedAt: sql`NOW()`\n\t\t\t})\n\t\t\t.where(eq(followRequests.id, requestId));\n\n\t\t// If approved, create the follow relationship\n\t\tif (approve) {\n\t\t\tawait db.insert(userFollows).values({\n\t\t\t\tfollowerId: requestData.requesterId,\n\t\t\t\tfollowedId: requestData.targetId,\n\t\t\t\tnotifyOnPosts: true,\n\t\t\t\tnotifyOnThreads: true,\n\t\t\t\tnotifyOnTrades: false,\n\t\t\t\tnotifyOnLargeStakes: true,\n\t\t\t\tminStakeNotification: 1000\n\t\t\t});\n\t\t}\n\n\t\treturn { approved: approve, requestData };\n\t}\n\n\t/**\n\t * Get whale candidates (users with high stats)\n\t */\n\tstatic async getWhaleCandidates(limit = 20) {\n\t\t// This would typically include complex logic to identify \"whales\"\n\t\t// For now, we'll use level and clout as indicators\n\t\tconst whales = await db\n\t\t\t.select({\n\t\t\t\tid: users.id,\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\tlevel: users.level,\n\t\t\t\tclout: users.clout,\n\t\t\t\trole: users.role,\n\t\t\t\tcreatedAt: users.createdAt\n\t\t\t})\n\t\t\t.from(users)\n\t\t\t.where(sql`${users.level} >= 25 OR ${users.clout} >= 10000`)\n\t\t\t.orderBy(desc(users.clout), desc(users.level))\n\t\t\t.limit(limit);\n\n\t\treturn whales;\n\t}\n\n\t/**\n\t * Get activity feed for followed users\n\t */\n\tstatic async getFollowingActivity(userId: string, page = 1, limit = 20) {\n\t\t// This would integrate with other systems to show activity from followed users\n\t\t// For now, return a placeholder structure\n\t\treturn {\n\t\t\tactivities: [],\n\t\t\tpagination: { page, limit, hasMore: false }\n\t\t};\n\t}\n\n\t/**\n\t * Search users for following\n\t */\n\tstatic async searchUsersToFollow(query: string, currentUserId: string, limit = 10) {\n\t\tif (query.length < 1) return [];\n\n\t\tconst searchResults = await db\n\t\t\t.select({\n\t\t\t\tid: users.id,\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\tlevel: users.level,\n\t\t\t\trole: users.role,\n\t\t\t\tclout: users.clout,\n\t\t\t\tisFollowing: sql<boolean>`EXISTS(\n\t\t\t\t\tSELECT 1 FROM ${userFollows} \n\t\t\t\t\tWHERE ${userFollows.followerId} = ${currentUserId} \n\t\t\t\t\tAND ${userFollows.followedId} = ${users.id}\n\t\t\t\t)`.as('isFollowing')\n\t\t\t})\n\t\t\t.from(users)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\tsql`LOWER(${users.username}) LIKE LOWER(${`%${query}%`})`,\n\t\t\t\t\tsql`${users.id} != ${currentUserId}` // Exclude current user\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(desc(users.level), users.username)\n\t\t\t.limit(limit);\n\n\t\treturn searchResults;\n\t}\n\n\t/**\n\t * Update follow notification preferences\n\t */\n\tstatic async updateFollowNotificationSettings(\n\t\tfollowerId: string,\n\t\tfollowedId: string,\n\t\tsettings: Partial<FollowNotificationSettings>\n\t) {\n\t\tconst result = await db\n\t\t\t.update(userFollows)\n\t\t\t.set({\n\t\t\t\t...settings,\n\t\t\t\tupdatedAt: sql`NOW()`\n\t\t\t})\n\t\t\t.where(and(eq(userFollows.followerId, followerId), eq(userFollows.followedId, followedId)))\n\t\t\t.returning();\n\n\t\tif (result.length === 0) {\n\t\t\tthrow new Error('Follow relationship not found');\n\t\t}\n\n\t\treturn result[0];\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/follows.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/friends.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/friends.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friendGroups' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friendGroupMembers' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":6,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'recipientPrefs' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":429,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":429,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport {\n\tfriendships,\n\tuserFriendPreferences,\n\tfriendGroups,\n\tfriendGroupMembers,\n\tusers\n} from '@schema';\nimport { eq, and, desc, sql, count, inArray, or } from 'drizzle-orm';\nimport type { RequestId } from '@shared/types';\n\nexport class FriendsService {\n\t/**\n\t * Send a friend request\n\t */\n\tstatic async sendFriendRequest({\n\t\trequesterId,\n\t\taddresseeId,\n\t\tmessage = ''\n\t}: {\n\t\trequesterId: string;\n\t\taddresseeId: string;\n\t\tmessage?: string;\n\t}) {\n\t\t// Prevent self-friending\n\t\tif (requesterId === addresseeId) {\n\t\t\tthrow new Error('Cannot send friend request to yourself');\n\t\t}\n\n\t\t// Check if friendship already exists\n\t\tconst existingFriendship = await db\n\t\t\t.select()\n\t\t\t.from(friendships)\n\t\t\t.where(\n\t\t\t\tor(\n\t\t\t\t\tand(eq(friendships.requesterId, requesterId), eq(friendships.addresseeId, addresseeId)),\n\t\t\t\t\tand(eq(friendships.requesterId, addresseeId), eq(friendships.addresseeId, requesterId))\n\t\t\t\t)\n\t\t\t)\n\t\t\t.limit(1);\n\n\t\tif (existingFriendship.length > 0) {\n\t\t\tconst existing = existingFriendship[0];\n\t\t\tif (existing.status === 'accepted') {\n\t\t\t\tthrow new Error('Already friends with this user');\n\t\t\t} else if (existing.status === 'pending') {\n\t\t\t\tthrow new Error('Friend request already pending');\n\t\t\t} else if (existing.status === 'blocked') {\n\t\t\t\tthrow new Error('Cannot send friend request to this user');\n\t\t\t}\n\t\t}\n\n\t\t// Check addressee's friend preferences\n\t\tconst addresseePrefs = await this.getUserFriendPreferences(addresseeId);\n\n\t\tif (!addresseePrefs.allowAllFriendRequests) {\n\t\t\tif (addresseePrefs.onlyMutualsCanRequest) {\n\t\t\t\t// Check if they follow each other (implement when follows service is available)\n\t\t\t\t// const areMutuals = await FollowsService.areMutualFollows(requesterId, addresseeId);\n\t\t\t\t// if (!areMutuals) throw new Error('Only mutual followers can send friend requests');\n\t\t\t}\n\t\t}\n\n\t\t// Create friend request\n\t\tconst request = await db\n\t\t\t.insert(friendships)\n\t\t\t.values({\n\t\t\t\trequesterId,\n\t\t\t\taddresseeId,\n\t\t\t\tstatus: 'pending',\n\t\t\t\trequestMessage: message,\n\t\t\t\tallowWhispers: addresseePrefs.defaultAllowWhispers,\n\t\t\t\tallowProfileView: addresseePrefs.defaultAllowProfileView,\n\t\t\t\tallowActivityView: addresseePrefs.defaultAllowActivityView\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn request[0];\n\t}\n\n\t/**\n\t * Respond to a friend request\n\t */\n\tstatic async respondToFriendRequest(\n\t\trequestId: RequestId,\n\t\tresponse: 'accept' | 'decline' | 'block'\n\t) {\n\t\t// Get the request\n\t\tconst request = await db\n\t\t\t.select()\n\t\t\t.from(friendships)\n\t\t\t.where(eq(friendships.id, requestId))\n\t\t\t.limit(1);\n\n\t\tif (request.length === 0) {\n\t\t\tthrow new Error('Friend request not found');\n\t\t}\n\n\t\tconst requestData = request[0];\n\n\t\tif (requestData.status !== 'pending') {\n\t\t\tthrow new Error('Friend request already responded to');\n\t\t}\n\n\t\tlet newStatus: 'accepted' | 'blocked';\n\t\tif (response === 'accept') {\n\t\t\tnewStatus = 'accepted';\n\t\t} else if (response === 'block') {\n\t\t\tnewStatus = 'blocked';\n\t\t} else {\n\t\t\t// Decline - delete the request\n\t\t\tawait db.delete(friendships).where(eq(friendships.id, requestId));\n\t\t\treturn { action: 'declined', requestData };\n\t\t}\n\n\t\t// Update the request\n\t\tconst updated = await db\n\t\t\t.update(friendships)\n\t\t\t.set({\n\t\t\t\tstatus: newStatus,\n\t\t\t\trespondedAt: sql`NOW()`,\n\t\t\t\tupdatedAt: sql`NOW()`\n\t\t\t})\n\t\t\t.where(eq(friendships.id, requestId))\n\t\t\t.returning();\n\n\t\treturn { action: response, friendship: updated[0] };\n\t}\n\n\t/**\n\t * Remove a friend (unfriend)\n\t */\n\tstatic async removeFriend(userId: string, friendId: string) {\n\t\tconst result = await db\n\t\t\t.delete(friendships)\n\t\t\t.where(\n\t\t\t\tor(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(friendships.requesterId, userId),\n\t\t\t\t\t\teq(friendships.addresseeId, friendId),\n\t\t\t\t\t\teq(friendships.status, 'accepted')\n\t\t\t\t\t),\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(friendships.requesterId, friendId),\n\t\t\t\t\t\teq(friendships.addresseeId, userId),\n\t\t\t\t\t\teq(friendships.status, 'accepted')\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.returning();\n\n\t\tif (result.length === 0) {\n\t\t\tthrow new Error('Friendship not found');\n\t\t}\n\n\t\treturn result[0];\n\t}\n\n\t/**\n\t * Check if two users are friends\n\t */\n\tstatic async areFriends(userId1: string, userId2: string): Promise<boolean> {\n\t\tconst result = await db\n\t\t\t.select({ id: friendships.id })\n\t\t\t.from(friendships)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\tor(\n\t\t\t\t\t\tand(eq(friendships.requesterId, userId1), eq(friendships.addresseeId, userId2)),\n\t\t\t\t\t\tand(eq(friendships.requesterId, userId2), eq(friendships.addresseeId, userId1))\n\t\t\t\t\t),\n\t\t\t\t\teq(friendships.status, 'accepted')\n\t\t\t\t)\n\t\t\t)\n\t\t\t.limit(1);\n\n\t\treturn result.length > 0;\n\t}\n\n\t/**\n\t * Get user's friends list\n\t */\n\tstatic async getUserFriends(userId: string, page = 1, limit = 20) {\n\t\tconst offset = (page - 1) * limit;\n\n\t\tconst friends = await db\n\t\t\t.select({\n\t\t\t\tid: friendships.id,\n\t\t\t\tfriendedAt: friendships.respondedAt,\n\t\t\t\tpermissions: {\n\t\t\t\t\tallowWhispers: friendships.allowWhispers,\n\t\t\t\t\tallowProfileView: friendships.allowProfileView,\n\t\t\t\t\tallowActivityView: friendships.allowActivityView\n\t\t\t\t},\n\t\t\t\tfriend: {\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\trole: users.role,\n\t\t\t\t\tclout: users.clout\n\t\t\t\t}\n\t\t\t})\n\t\t\t.from(friendships)\n\t\t\t.leftJoin(\n\t\t\t\tusers,\n\t\t\t\tor(\n\t\t\t\t\tand(eq(friendships.requesterId, userId), eq(users.id, friendships.addresseeId)),\n\t\t\t\t\tand(eq(friendships.addresseeId, userId), eq(users.id, friendships.requesterId))\n\t\t\t\t)\n\t\t\t)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\tor(eq(friendships.requesterId, userId), eq(friendships.addresseeId, userId)),\n\t\t\t\t\teq(friendships.status, 'accepted')\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(desc(friendships.respondedAt))\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\n\t\treturn friends;\n\t}\n\n\t/**\n\t * Get incoming friend requests\n\t */\n\tstatic async getIncomingFriendRequests(userId: string) {\n\t\tconst requests = await db\n\t\t\t.select({\n\t\t\t\tid: friendships.id,\n\t\t\t\trequestMessage: friendships.requestMessage,\n\t\t\t\tcreatedAt: friendships.createdAt,\n\t\t\t\trequester: {\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\trole: users.role\n\t\t\t\t}\n\t\t\t})\n\t\t\t.from(friendships)\n\t\t\t.leftJoin(users, eq(friendships.requesterId, users.id))\n\t\t\t.where(and(eq(friendships.addresseeId, userId), eq(friendships.status, 'pending')))\n\t\t\t.orderBy(desc(friendships.createdAt));\n\n\t\treturn requests;\n\t}\n\n\t/**\n\t * Get outgoing friend requests\n\t */\n\tstatic async getOutgoingFriendRequests(userId: string) {\n\t\tconst requests = await db\n\t\t\t.select({\n\t\t\t\tid: friendships.id,\n\t\t\t\trequestMessage: friendships.requestMessage,\n\t\t\t\tcreatedAt: friendships.createdAt,\n\t\t\t\taddressee: {\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\trole: users.role\n\t\t\t\t}\n\t\t\t})\n\t\t\t.from(friendships)\n\t\t\t.leftJoin(users, eq(friendships.addresseeId, users.id))\n\t\t\t.where(and(eq(friendships.requesterId, userId), eq(friendships.status, 'pending')))\n\t\t\t.orderBy(desc(friendships.createdAt));\n\n\t\treturn requests;\n\t}\n\n\t/**\n\t * Get friend counts\n\t */\n\tstatic async getFriendCounts(userId: string) {\n\t\tconst friendCount = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(friendships)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\tor(eq(friendships.requesterId, userId), eq(friendships.addresseeId, userId)),\n\t\t\t\t\teq(friendships.status, 'accepted')\n\t\t\t\t)\n\t\t\t);\n\n\t\tconst incomingRequestCount = await db\n\t\t\t.select({ count: count() })\n\t\t\t.from(friendships)\n\t\t\t.where(and(eq(friendships.addresseeId, userId), eq(friendships.status, 'pending')));\n\n\t\treturn {\n\t\t\tfriends: friendCount[0]?.count || 0,\n\t\t\tincomingRequests: incomingRequestCount[0]?.count || 0\n\t\t};\n\t}\n\n\t/**\n\t * Get user's friend preferences\n\t */\n\tstatic async getUserFriendPreferences(userId: string) {\n\t\tconst preferences = await db\n\t\t\t.select()\n\t\t\t.from(userFriendPreferences)\n\t\t\t.where(eq(userFriendPreferences.userId, userId))\n\t\t\t.limit(1);\n\n\t\t// Return default preferences if none exist\n\t\tif (preferences.length === 0) {\n\t\t\treturn {\n\t\t\t\tallowAllFriendRequests: true,\n\t\t\t\tonlyMutualsCanRequest: false,\n\t\t\t\trequireMinLevel: false,\n\t\t\t\tminLevelRequired: 1,\n\t\t\t\tautoAcceptFromFollowers: false,\n\t\t\t\tautoAcceptFromWhales: false,\n\t\t\t\thideFriendsList: false,\n\t\t\t\thideFriendCount: false,\n\t\t\t\tshowOnlineStatus: true,\n\t\t\t\tnotifyOnFriendRequest: true,\n\t\t\t\tnotifyOnFriendAccept: true,\n\t\t\t\temailOnFriendRequest: false,\n\t\t\t\tdefaultAllowWhispers: true,\n\t\t\t\tdefaultAllowProfileView: true,\n\t\t\t\tdefaultAllowActivityView: true\n\t\t\t};\n\t\t}\n\n\t\treturn preferences[0];\n\t}\n\n\t/**\n\t * Update user's friend preferences\n\t */\n\tstatic async updateUserFriendPreferences(userId: string, preferences: Partial<any>) {\n\t\tconst existingPrefs = await db\n\t\t\t.select()\n\t\t\t.from(userFriendPreferences)\n\t\t\t.where(eq(userFriendPreferences.userId, userId))\n\t\t\t.limit(1);\n\n\t\tif (existingPrefs.length === 0) {\n\t\t\t// Create new preferences\n\t\t\treturn await db\n\t\t\t\t.insert(userFriendPreferences)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\t...preferences\n\t\t\t\t})\n\t\t\t\t.returning();\n\t\t} else {\n\t\t\t// Update existing preferences\n\t\t\treturn await db\n\t\t\t\t.update(userFriendPreferences)\n\t\t\t\t.set({\n\t\t\t\t\t...preferences,\n\t\t\t\t\tupdatedAt: sql`NOW()`\n\t\t\t\t})\n\t\t\t\t.where(eq(userFriendPreferences.userId, userId))\n\t\t\t\t.returning();\n\t\t}\n\t}\n\n\t/**\n\t * Update friendship permissions\n\t */\n\tstatic async updateFriendshipPermissions(\n\t\tuserId: string,\n\t\tfriendId: string,\n\t\tpermissions: {\n\t\t\tallowWhispers?: boolean;\n\t\t\tallowProfileView?: boolean;\n\t\t\tallowActivityView?: boolean;\n\t\t}\n\t) {\n\t\tconst result = await db\n\t\t\t.update(friendships)\n\t\t\t.set({\n\t\t\t\t...permissions,\n\t\t\t\tupdatedAt: sql`NOW()`\n\t\t\t})\n\t\t\t.where(\n\t\t\t\tor(\n\t\t\t\t\tand(eq(friendships.requesterId, userId), eq(friendships.addresseeId, friendId)),\n\t\t\t\t\tand(eq(friendships.requesterId, friendId), eq(friendships.addresseeId, userId))\n\t\t\t\t)\n\t\t\t)\n\t\t\t.returning();\n\n\t\tif (result.length === 0) {\n\t\t\tthrow new Error('Friendship not found');\n\t\t}\n\n\t\treturn result[0];\n\t}\n\n\t/**\n\t * Check if user can send whisper to another user\n\t */\n\tstatic async canSendWhisper(senderId: string, recipientId: string): Promise<boolean> {\n\t\t// Check if they are friends\n\t\tconst friendship = await db\n\t\t\t.select({\n\t\t\t\tallowWhispers: friendships.allowWhispers\n\t\t\t})\n\t\t\t.from(friendships)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\tor(\n\t\t\t\t\t\tand(eq(friendships.requesterId, senderId), eq(friendships.addresseeId, recipientId)),\n\t\t\t\t\t\tand(eq(friendships.requesterId, recipientId), eq(friendships.addresseeId, senderId))\n\t\t\t\t\t),\n\t\t\t\t\teq(friendships.status, 'accepted')\n\t\t\t\t)\n\t\t\t)\n\t\t\t.limit(1);\n\n\t\t// If they're friends, check whisper permission\n\t\tif (friendship.length > 0) {\n\t\t\treturn friendship[0].allowWhispers;\n\t\t}\n\n\t\t// If not friends, check recipient's preferences\n\t\tconst recipientPrefs = await this.getUserFriendPreferences(recipientId);\n\n\t\t// For now, allow whispers from non-friends\n\t\t// This can be changed to enforce friends-only whispers\n\t\treturn true;\n\t}\n\n\t/**\n\t * Search users for friend requests\n\t */\n\tstatic async searchUsersForFriends(query: string, currentUserId: string, limit = 10) {\n\t\tif (query.length < 1) return [];\n\n\t\tconst searchResults = await db\n\t\t\t.select({\n\t\t\t\tid: users.id,\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\tlevel: users.level,\n\t\t\t\trole: users.role,\n\t\t\t\tclout: users.clout,\n\t\t\t\tfriendshipStatus: sql<string | null>`\n\t\t\t\t\tCASE \n\t\t\t\t\t\tWHEN ${friendships.status} = 'accepted' THEN 'friends'\n\t\t\t\t\t\tWHEN ${friendships.status} = 'pending' AND ${friendships.requesterId} = ${currentUserId} THEN 'request_sent'\n\t\t\t\t\t\tWHEN ${friendships.status} = 'pending' AND ${friendships.addresseeId} = ${currentUserId} THEN 'request_received'\n\t\t\t\t\t\tWHEN ${friendships.status} = 'blocked' THEN 'blocked'\n\t\t\t\t\t\tELSE NULL\n\t\t\t\t\tEND\n\t\t\t\t`.as('friendshipStatus')\n\t\t\t})\n\t\t\t.from(users)\n\t\t\t.leftJoin(\n\t\t\t\tfriendships,\n\t\t\t\tor(\n\t\t\t\t\tand(eq(friendships.requesterId, currentUserId), eq(friendships.addresseeId, users.id)),\n\t\t\t\t\tand(eq(friendships.requesterId, users.id), eq(friendships.addresseeId, currentUserId))\n\t\t\t\t)\n\t\t\t)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\tsql`LOWER(${users.username}) LIKE LOWER(${`%${query}%`})`,\n\t\t\t\t\tsql`${users.id} != ${currentUserId}` // Exclude current user\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(users.username)\n\t\t\t.limit(limit);\n\n\t\treturn searchResults;\n\t}\n\n\t/**\n\t * Get mutual friends between two users\n\t */\n\tstatic async getMutualFriends(userId1: string, userId2: string) {\n\t\t// This is a complex query that finds users who are friends with both userId1 and userId2\n\t\tconst mutualFriends = await db\n\t\t\t.select({\n\t\t\t\tid: users.id,\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\tactiveAvatarUrl: users.activeAvatarUrl,\n\t\t\t\tlevel: users.level\n\t\t\t})\n\t\t\t.from(users)\n\t\t\t.where(\n\t\t\t\tsql`\n\t\t\t\t\t${users.id} IN (\n\t\t\t\t\t\tSELECT CASE \n\t\t\t\t\t\t\tWHEN ${friendships.requesterId} = ${userId1} THEN ${friendships.addresseeId}\n\t\t\t\t\t\t\tELSE ${friendships.requesterId}\n\t\t\t\t\t\tEND as friend_id\n\t\t\t\t\t\tFROM ${friendships}\n\t\t\t\t\t\tWHERE (${friendships.requesterId} = ${userId1} OR ${friendships.addresseeId} = ${userId1})\n\t\t\t\t\t\tAND ${friendships.status} = 'accepted'\n\t\t\t\t\t)\n\t\t\t\t\tAND ${users.id} IN (\n\t\t\t\t\t\tSELECT CASE \n\t\t\t\t\t\t\tWHEN ${friendships.requesterId} = ${userId2} THEN ${friendships.addresseeId}\n\t\t\t\t\t\t\tELSE ${friendships.requesterId}\n\t\t\t\t\t\tEND as friend_id\n\t\t\t\t\t\tFROM ${friendships}\n\t\t\t\t\t\tWHERE (${friendships.requesterId} = ${userId2} OR ${friendships.addresseeId} = ${userId2})\n\t\t\t\t\t\tAND ${friendships.status} = 'accepted'\n\t\t\t\t\t)\n\t\t\t\t`\n\t\t\t)\n\t\t\t.orderBy(users.username);\n\n\t\treturn mutualFriends;\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/mentions.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/mentions.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/mentions.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/relationships.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'not' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'or' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gt' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNull' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdminOrModerator' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdmin' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Social Relationships Routes\n *\n * Defines API routes for user relationships including following, blocking, etc.\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport type { UserId } from '@shared/types';\nimport { db } from '@db';\nimport { users, userRelationships } from '@schema';\nimport { eq, and, sql, desc, not, or, count, gt, isNull } from 'drizzle-orm';\nimport { isValidId } from '@shared/utils/id';\n\nimport { isAuthenticated, isAdminOrModerator, isAdmin } from '../auth/middleware/auth.middleware';\nimport { getUserIdFromRequest } from '@server/src/utils/auth';\nimport { logger } from \"../../core/logger\";\n\nconst router = Router();\n\n// Get followers for a user\nrouter.get('/:userId/followers', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = req.params.userId as UserId;\n\n\t\tif (!userId || !isValidId(userId)) {\n\t\t\treturn res.status(400).json({ message: 'Valid user ID is required' });\n\t\t}\n\n\t\t// Get followers\n\t\tconst followers = await db\n\t\t\t.select({\n\t\t\t\tid: users.id,\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\tcreatedAt: userRelationships.createdAt\n\t\t\t})\n\t\t\t.from(userRelationships)\n\t\t\t.innerJoin(users, eq(users.id, userRelationships.followerId))\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(userRelationships.followingId, userId),\n\t\t\t\t\teq(userRelationships.relationshipType, 'follow')\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(desc(userRelationships.createdAt));\n\n\t\treturn res.status(200).json(followers);\n\t} catch (error) {\n\t\tlogger.error('Error fetching followers:', error);\n\t\treturn res.status(500).json({ message: 'Error fetching followers' });\n\t}\n});\n\n// Get following for a user\nrouter.get('/:userId/following', async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = req.params.userId as UserId;\n\n\t\tif (!userId || !isValidId(userId)) {\n\t\t\treturn res.status(400).json({ message: 'Valid user ID is required' });\n\t\t}\n\n\t\t// Get following\n\t\tconst following = await db\n\t\t\t.select({\n\t\t\t\tid: users.id,\n\t\t\t\tusername: users.username,\n\t\t\t\tavatarUrl: users.avatarUrl,\n\t\t\t\tcreatedAt: userRelationships.createdAt\n\t\t\t})\n\t\t\t.from(userRelationships)\n\t\t\t.innerJoin(users, eq(users.id, userRelationships.followingId))\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(userRelationships.followerId, userId),\n\t\t\t\t\teq(userRelationships.relationshipType, 'follow')\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(desc(userRelationships.createdAt));\n\n\t\treturn res.status(200).json(following);\n\t} catch (error) {\n\t\tlogger.error('Error fetching following:', error);\n\t\treturn res.status(500).json({ message: 'Error fetching following' });\n\t}\n});\n\n// Follow a user\nrouter.post('/follow/:userId', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = req.params.userId as UserId;\n\t\tconst followerId = getUserIdFromRequest(req);\n\n\t\tif (!userId || !isValidId(userId)) {\n\t\t\treturn res.status(400).json({ message: 'Valid user ID is required' });\n\t\t}\n\n\t\tif (followerId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'You must be logged in to follow users' });\n\t\t}\n\n\t\t// Check if already following\n\t\tconst existingRelationship = await db\n\t\t\t.select()\n\t\t\t.from(userRelationships)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(userRelationships.followerId, followerId),\n\t\t\t\t\teq(userRelationships.followingId, userId),\n\t\t\t\t\teq(userRelationships.relationshipType, 'follow')\n\t\t\t\t)\n\t\t\t);\n\n\t\tif (existingRelationship.length > 0) {\n\t\t\treturn res.status(400).json({ message: 'You are already following this user' });\n\t\t}\n\n\t\t// Check if user exists\n\t\tconst userExists = await db\n\t\t\t.select()\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, userId));\n\n\t\tif (userExists.length === 0) {\n\t\t\treturn res.status(404).json({ message: 'User not found' });\n\t\t}\n\n\t\t// Cannot follow yourself\n\t\tif (followerId === userId) {\n\t\t\treturn res.status(400).json({ message: 'You cannot follow yourself' });\n\t\t}\n\n\t\t// Create follow relationship\n\t\tconst newRelationship = await db\n\t\t\t.insert(userRelationships)\n\t\t\t.values({\n\t\t\t\tfollowerId: followerId,\n\t\t\t\tfollowingId: userId,\n\t\t\t\trelationshipType: 'follow',\n\t\t\t\tisAccepted: true, // follow doesn't need acceptance\n\t\t\t\tcreatedAt: new Date()\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn res.status(201).json({\n\t\t\tmessage: 'Successfully followed user',\n\t\t\trelationship: newRelationship[0]\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Error following user:', error);\n\t\treturn res.status(500).json({ message: 'Error following user' });\n\t}\n});\n\n// Unfollow a user\nrouter.delete('/unfollow/:userId', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = req.params.userId as UserId;\n\t\tconst followerId = getUserIdFromRequest(req);\n\n\t\tif (!userId || !isValidId(userId)) {\n\t\t\treturn res.status(400).json({ message: 'Valid user ID is required' });\n\t\t}\n\n\t\tif (followerId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'You must be logged in to unfollow users' });\n\t\t}\n\n\t\t// Check if relationship exists\n\t\tconst existingRelationship = await db\n\t\t\t.select()\n\t\t\t.from(userRelationships)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(userRelationships.followerId, followerId),\n\t\t\t\t\teq(userRelationships.followingId, userId),\n\t\t\t\t\teq(userRelationships.relationshipType, 'follow')\n\t\t\t\t)\n\t\t\t);\n\n\t\tif (existingRelationship.length === 0) {\n\t\t\treturn res.status(400).json({ message: 'You are not following this user' });\n\t\t}\n\n\t\t// Delete relationship\n\t\tawait db\n\t\t\t.delete(userRelationships)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(userRelationships.followerId, followerId),\n\t\t\t\t\teq(userRelationships.followingId, userId),\n\t\t\t\t\teq(userRelationships.relationshipType, 'follow')\n\t\t\t\t)\n\t\t\t);\n\n\t\treturn res.status(200).json({ message: 'Successfully unfollowed user' });\n\t} catch (error) {\n\t\tlogger.error('Error unfollowing user:', error);\n\t\treturn res.status(500).json({ message: 'Error unfollowing user' });\n\t}\n});\n\n// Check if current user is following a user\nrouter.get('/is-following/:userId', isAuthenticated, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst userId = req.params.userId as UserId;\n\t\tconst followerId = getUserIdFromRequest(req);\n\n\t\tif (!userId || !isValidId(userId)) {\n\t\t\treturn res.status(400).json({ message: 'Valid user ID is required' });\n\t\t}\n\n\t\tif (followerId === undefined) {\n\t\t\treturn res.status(401).json({ message: 'You must be logged in to check follow status' });\n\t\t}\n\n\t\t// Check if relationship exists\n\t\tconst existingRelationship = await db\n\t\t\t.select()\n\t\t\t.from(userRelationships)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(userRelationships.followerId, followerId),\n\t\t\t\t\teq(userRelationships.followingId, userId),\n\t\t\t\t\teq(userRelationships.relationshipType, 'follow')\n\t\t\t\t)\n\t\t\t);\n\n\t\treturn res.status(200).json({ isFollowing: existingRelationship.length > 0 });\n\t} catch (error) {\n\t\tlogger.error('Error checking follow status:', error);\n\t\treturn res.status(500).json({ message: 'Error checking follow status' });\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/social.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/whale-watch.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/social/whale-watch.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/subscriptions/subscription-permissions.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/subscriptions/subscription.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/subscriptions/subscription.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/subscriptions/subscription.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'subscriptionBenefits' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'gte' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":18,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Subscription Service\n *\n * Handles VIP Pass (lifetime) and Degen Pass (monthly) subscription management,\n * including purchases, renewals, cancellations, and benefit tracking.\n */\n\nimport { db } from '@db';\nimport {\n\tsubscriptions,\n\tsubscriptionBenefits,\n\tcosmeticDrops,\n\tusers,\n\tavatarFrames,\n\tbadges,\n\ttitles\n} from '@schema';\nimport { eq, and, sql, desc, gte, lt } from 'drizzle-orm';\nimport { dgtService } from '../wallet/dgt.service';\nimport { logger } from '../../core/logger';\nimport type { CosmeticId, ItemId, SubscriptionId } from '@shared/types';\nimport { EntityId } from \"@shared/types\";\n\nexport interface SubscriptionPurchaseRequest {\n\tuserId: string;\n\ttype: 'vip_pass' | 'degen_pass';\n}\n\nexport interface SubscriptionInfo {\n\tid: EntityId;\n\tuserId: string;\n\ttype: 'vip_pass' | 'degen_pass';\n\tstatus: 'active' | 'expired' | 'cancelled' | 'lifetime';\n\tstartDate: Date;\n\tendDate: Date | null;\n\tnextBillingDate: Date | null;\n\tautoRenew: boolean;\n\ttotalCosmeticValue: number;\n\tbenefits: Record<string, any>;\n}\n\nexport interface CosmeticDropInfo {\n\tcosmeticType: 'avatar_frame' | 'badge' | 'title' | 'sticker' | 'emoji_pack' | 'profile_theme';\n\tcosmeticId: CosmeticId;\n\tcosmeticName: string;\n\tcosmeticValue: number;\n}\n\n/**\n * Subscription Service Class\n */\nexport class SubscriptionService {\n\tprivate readonly VIP_PASS_PRICE = 500; // 500 DGT\n\tprivate readonly DEGEN_PASS_PRICE = 100; // 100 DGT per month\n\tprivate readonly COSMETIC_DROP_VALUE = 120; // 120 DGT worth of cosmetics per month\n\n\t/**\n\t * Purchase a subscription (VIP Pass or Degen Pass)\n\t */\n\tasync purchaseSubscription(request: SubscriptionPurchaseRequest): Promise<SubscriptionInfo> {\n\t\tconst { userId, type } = request;\n\n\t\ttry {\n\t\t\t// Check if user already has an active subscription of this type\n\t\t\tconst existingSubscription = await this.getUserActiveSubscription(userId, type);\n\t\t\tif (existingSubscription) {\n\t\t\t\tthrow new Error(`User already has an active ${type.replace('_', ' ')} subscription`);\n\t\t\t}\n\n\t\t\t// Determine pricing\n\t\t\tconst price = type === 'vip_pass' ? this.VIP_PASS_PRICE : this.DEGEN_PASS_PRICE;\n\n\t\t\t// Check user's DGT balance\n\t\t\tconst balance = await dgtService.getDGTBalance(userId);\n\t\t\tif (balance.balance < price) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Insufficient DGT balance. Required: ${price}, Available: ${balance.balance}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Process payment and create subscription\n\t\t\tconst result = await db.transaction(async (tx) => {\n\t\t\t\t// Debit DGT from user\n\t\t\t\tconst transaction = await dgtService.debitDGT(userId, price, {\n\t\t\t\t\tsource: 'shop_purchase',\n\t\t\t\t\tshopItemId: `subscription_${type}`,\n\t\t\t\t\treason: `${type.replace('_', ' ')} subscription purchase`\n\t\t\t\t});\n\n\t\t\t\t// Create subscription record\n\t\t\t\tconst endDate = type === 'vip_pass' ? null : this.getNextMonthDate();\n\t\t\t\tconst nextBillingDate = type === 'vip_pass' ? null : endDate;\n\t\t\t\tconst status = type === 'vip_pass' ? 'lifetime' : 'active';\n\n\t\t\t\tconst [subscription] = await tx\n\t\t\t\t\t.insert(subscriptions)\n\t\t\t\t\t.values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tstatus,\n\t\t\t\t\t\tpricePaid: price,\n\t\t\t\t\t\tcurrency: 'DGT',\n\t\t\t\t\t\tstartDate: new Date(),\n\t\t\t\t\t\tendDate,\n\t\t\t\t\t\tnextBillingDate,\n\t\t\t\t\t\tautoRenew: type === 'degen_pass',\n\t\t\t\t\t\tpurchaseTransactionId: transaction.id,\n\t\t\t\t\t\tbenefits: this.getDefaultBenefits(type),\n\t\t\t\t\t\tmetadata: { purchaseSource: 'web', transactionId: transaction.id }\n\t\t\t\t\t})\n\t\t\t\t\t.returning();\n\n\t\t\t\treturn subscription;\n\t\t\t});\n\n\t\t\tlogger.info('SUBSCRIPTION', `${type} purchased by user ${userId} for ${price} DGT`);\n\n\t\t\treturn this.mapToSubscriptionInfo(result);\n\t\t} catch (error) {\n\t\t\tlogger.error('SUBSCRIPTION', `Error purchasing ${type}:`, error);\n\t\t\tthrow new Error(`Failed to purchase subscription: ${error.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get user's active subscription\n\t */\n\tasync getUserActiveSubscription(\n\t\tuserId: string,\n\t\ttype?: 'vip_pass' | 'degen_pass'\n\t): Promise<SubscriptionInfo | null> {\n\t\ttry {\n\t\t\tlet query = db\n\t\t\t\t.select()\n\t\t\t\t.from(subscriptions)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(subscriptions.userId, userId),\n\t\t\t\t\t\tsql`${subscriptions.status} IN ('active', 'lifetime')`,\n\t\t\t\t\t\teq(subscriptions.isDeleted, false)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tif (type) {\n\t\t\t\tquery = query.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(subscriptions.userId, userId),\n\t\t\t\t\t\teq(subscriptions.type, type),\n\t\t\t\t\t\tsql`${subscriptions.status} IN ('active', 'lifetime')`,\n\t\t\t\t\t\teq(subscriptions.isDeleted, false)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst result = await query.orderBy(desc(subscriptions.createdAt)).limit(1);\n\n\t\t\tif (result.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn this.mapToSubscriptionInfo(result[0]);\n\t\t} catch (error) {\n\t\t\tlogger.error('SUBSCRIPTION', 'Error getting user subscription:', error);\n\t\t\tthrow new Error('Failed to retrieve subscription information');\n\t\t}\n\t}\n\n\t/**\n\t * Get all user subscriptions (active and historical)\n\t */\n\tasync getUserSubscriptions(userId: string): Promise<SubscriptionInfo[]> {\n\t\ttry {\n\t\t\tconst results = await db\n\t\t\t\t.select()\n\t\t\t\t.from(subscriptions)\n\t\t\t\t.where(and(eq(subscriptions.userId, userId), eq(subscriptions.isDeleted, false)))\n\t\t\t\t.orderBy(desc(subscriptions.createdAt));\n\n\t\t\treturn results.map((sub) => this.mapToSubscriptionInfo(sub));\n\t\t} catch (error) {\n\t\t\tlogger.error('SUBSCRIPTION', 'Error getting user subscriptions:', error);\n\t\t\tthrow new Error('Failed to retrieve subscription history');\n\t\t}\n\t}\n\n\t/**\n\t * Cancel a subscription\n\t */\n\tasync cancelSubscription(userId: string, subscriptionId: SubscriptionId): Promise<boolean> {\n\t\ttry {\n\t\t\t// Verify subscription belongs to user and is active\n\t\t\tconst subscription = await db\n\t\t\t\t.select()\n\t\t\t\t.from(subscriptions)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(subscriptions.id, subscriptionId),\n\t\t\t\t\t\teq(subscriptions.userId, userId),\n\t\t\t\t\t\tsql`${subscriptions.status} IN ('active', 'lifetime')`\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.limit(1);\n\n\t\t\tif (subscription.length === 0) {\n\t\t\t\tthrow new Error('Subscription not found or not active');\n\t\t\t}\n\n\t\t\t// VIP Pass cannot be cancelled (lifetime)\n\t\t\tif (subscription[0].type === 'vip_pass') {\n\t\t\t\tthrow new Error('VIP Pass subscriptions cannot be cancelled (lifetime access)');\n\t\t\t}\n\n\t\t\t// Cancel the subscription\n\t\t\tawait db\n\t\t\t\t.update(subscriptions)\n\t\t\t\t.set({\n\t\t\t\t\tstatus: 'cancelled',\n\t\t\t\t\tautoRenew: false,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(subscriptions.id, subscriptionId));\n\n\t\t\tlogger.info('SUBSCRIPTION', `Subscription ${subscriptionId} cancelled by user ${userId}`);\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tlogger.error('SUBSCRIPTION', 'Error cancelling subscription:', error);\n\t\t\tthrow new Error(`Failed to cancel subscription: ${error.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Renew monthly subscription\n\t */\n\tasync renewSubscription(subscriptionId: SubscriptionId): Promise<boolean> {\n\t\ttry {\n\t\t\tconst subscription = await db\n\t\t\t\t.select()\n\t\t\t\t.from(subscriptions)\n\t\t\t\t.where(eq(subscriptions.id, subscriptionId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (subscription.length === 0) {\n\t\t\t\tthrow new Error('Subscription not found');\n\t\t\t}\n\n\t\t\tconst sub = subscription[0];\n\n\t\t\t// Only monthly subscriptions can be renewed\n\t\t\tif (sub.type !== 'degen_pass') {\n\t\t\t\tthrow new Error('Only Degen Pass subscriptions can be renewed');\n\t\t\t}\n\n\t\t\t// Check if subscription is eligible for renewal\n\t\t\tif (sub.status === 'cancelled') {\n\t\t\t\tthrow new Error('Cancelled subscriptions cannot be renewed');\n\t\t\t}\n\n\t\t\t// Check user's DGT balance\n\t\t\tconst balance = await dgtService.getDGTBalance(sub.userId);\n\t\t\tif (balance.balance < this.DEGEN_PASS_PRICE) {\n\t\t\t\t// Mark subscription as expired\n\t\t\t\tawait db\n\t\t\t\t\t.update(subscriptions)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tstatus: 'expired',\n\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(subscriptions.id, subscriptionId));\n\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Insufficient DGT balance for renewal. Required: ${this.DEGEN_PASS_PRICE}, Available: ${balance.balance}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Process renewal payment\n\t\t\tawait db.transaction(async (tx) => {\n\t\t\t\t// Debit DGT from user\n\t\t\t\tawait dgtService.debitDGT(sub.userId, this.DEGEN_PASS_PRICE, {\n\t\t\t\t\tsource: 'shop_purchase',\n\t\t\t\t\tshopItemId: 'subscription_degen_pass_renewal',\n\t\t\t\t\treason: 'Degen Pass subscription renewal'\n\t\t\t\t});\n\n\t\t\t\t// Update subscription\n\t\t\t\tconst newEndDate = this.getNextMonthDate();\n\t\t\t\tconst newBillingDate = this.getNextMonthDate(newEndDate);\n\n\t\t\t\tawait tx\n\t\t\t\t\t.update(subscriptions)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tstatus: 'active',\n\t\t\t\t\t\tendDate: newEndDate,\n\t\t\t\t\t\tnextBillingDate: newBillingDate,\n\t\t\t\t\t\tlastPaymentDate: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(subscriptions.id, subscriptionId));\n\t\t\t});\n\n\t\t\tlogger.info('SUBSCRIPTION', `Subscription ${subscriptionId} renewed for user ${sub.userId}`);\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tlogger.error('SUBSCRIPTION', 'Error renewing subscription:', error);\n\t\t\tthrow new Error(`Failed to renew subscription: ${error.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Process monthly cosmetic drop for Degen Pass subscribers\n\t */\n\tasync processMonthlyCosmetics(): Promise<{\n\t\tprocessed: number;\n\t\tfailed: number;\n\t\tdetails: Array<{ userId: string; success: boolean; error?: string }>;\n\t}> {\n\t\ttry {\n\t\t\tconst currentDate = new Date();\n\t\t\tconst currentMonth = currentDate.getMonth() + 1;\n\t\t\tconst currentYear = currentDate.getFullYear();\n\n\t\t\t// Get all active Degen Pass subscriptions\n\t\t\tconst activeSubscriptions = await db\n\t\t\t\t.select()\n\t\t\t\t.from(subscriptions)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(subscriptions.type, 'degen_pass'),\n\t\t\t\t\t\teq(subscriptions.status, 'active'),\n\t\t\t\t\t\teq(subscriptions.isDeleted, false)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tconst results = {\n\t\t\t\tprocessed: 0,\n\t\t\t\tfailed: 0,\n\t\t\t\tdetails: [] as Array<{ userId: string; success: boolean; error?: string }>\n\t\t\t};\n\n\t\t\tfor (const subscription of activeSubscriptions) {\n\t\t\t\ttry {\n\t\t\t\t\t// Check if cosmetic drop already processed for this month\n\t\t\t\t\tconst existingDrop = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(cosmeticDrops)\n\t\t\t\t\t\t.where(\n\t\t\t\t\t\t\tand(\n\t\t\t\t\t\t\t\teq(cosmeticDrops.userId, subscription.userId),\n\t\t\t\t\t\t\t\teq(cosmeticDrops.subscriptionId, subscription.id),\n\t\t\t\t\t\t\t\teq(cosmeticDrops.dropMonth, currentMonth),\n\t\t\t\t\t\t\t\teq(cosmeticDrops.dropYear, currentYear)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.limit(1);\n\n\t\t\t\t\tif (existingDrop.length > 0) {\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t'COSMETIC_DROP',\n\t\t\t\t\t\t\t`Cosmetic already dropped for user ${subscription.userId} this month`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Generate random cosmetic drop\n\t\t\t\t\tconst cosmetic = await this.generateRandomCosmetic();\n\t\t\t\t\tif (!cosmetic) {\n\t\t\t\t\t\tthrow new Error('Failed to generate cosmetic item');\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create cosmetic drop record\n\t\t\t\t\tawait db.insert(cosmeticDrops).values({\n\t\t\t\t\t\tuserId: subscription.userId,\n\t\t\t\t\t\tsubscriptionId: subscription.id,\n\t\t\t\t\t\tdropMonth: currentMonth,\n\t\t\t\t\t\tdropYear: currentYear,\n\t\t\t\t\t\tcosmeticType: cosmetic.cosmeticType,\n\t\t\t\t\t\tcosmeticId: cosmetic.cosmeticId,\n\t\t\t\t\t\tcosmeticName: cosmetic.cosmeticName,\n\t\t\t\t\t\tcosmeticValue: cosmetic.cosmeticValue,\n\t\t\t\t\t\tclaimed: false,\n\t\t\t\t\t\tmetadata: { generatedAt: new Date(), dropReason: 'monthly_degen_pass' }\n\t\t\t\t\t});\n\n\t\t\t\t\t// Update subscription cosmetic value\n\t\t\t\t\tawait db\n\t\t\t\t\t\t.update(subscriptions)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tlastCosmeticDrop: new Date(),\n\t\t\t\t\t\t\ttotalCosmeticValue: sql`${subscriptions.totalCosmeticValue} + ${cosmetic.cosmeticValue}`,\n\t\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(eq(subscriptions.id, subscription.id));\n\n\t\t\t\t\tresults.processed++;\n\t\t\t\t\tresults.details.push({ userId: subscription.userId, success: true });\n\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t'COSMETIC_DROP',\n\t\t\t\t\t\t`Cosmetic dropped for user ${subscription.userId}: ${cosmetic.cosmeticName} (${cosmetic.cosmeticValue} DGT value)`\n\t\t\t\t\t);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tresults.failed++;\n\t\t\t\t\tresults.details.push({\n\t\t\t\t\t\tuserId: subscription.userId,\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: error.message\n\t\t\t\t\t});\n\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'COSMETIC_DROP',\n\t\t\t\t\t\t`Failed to process cosmetic drop for user ${subscription.userId}:`,\n\t\t\t\t\t\terror\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.info(\n\t\t\t\t'COSMETIC_DROP',\n\t\t\t\t`Monthly cosmetic drop completed: ${results.processed} processed, ${results.failed} failed`\n\t\t\t);\n\n\t\t\treturn results;\n\t\t} catch (error) {\n\t\t\tlogger.error('COSMETIC_DROP', 'Error processing monthly cosmetics:', error);\n\t\t\tthrow new Error(`Failed to process monthly cosmetic drops: ${error.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get user's cosmetic drop history\n\t */\n\tasync getUserCosmeticDrops(userId: string): Promise<any[]> {\n\t\ttry {\n\t\t\tconst drops = await db\n\t\t\t\t.select()\n\t\t\t\t.from(cosmeticDrops)\n\t\t\t\t.where(eq(cosmeticDrops.userId, userId))\n\t\t\t\t.orderBy(desc(cosmeticDrops.createdAt));\n\n\t\t\treturn drops;\n\t\t} catch (error) {\n\t\t\tlogger.error('SUBSCRIPTION', 'Error getting cosmetic drops:', error);\n\t\t\tthrow new Error('Failed to retrieve cosmetic drop history');\n\t\t}\n\t}\n\n\t/**\n\t * Check if user has specific subscription benefit\n\t */\n\tasync hasSubscriptionBenefit(userId: string, benefitKey: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst subscription = await this.getUserActiveSubscription(userId);\n\t\t\tif (!subscription) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Check if benefit exists in subscription benefits or default benefits\n\t\t\tconst benefits = subscription.benefits as Record<string, any>;\n\t\t\treturn benefits[benefitKey] === true || benefits[benefitKey] === 1;\n\t\t} catch (error) {\n\t\t\tlogger.error('SUBSCRIPTION', 'Error checking subscription benefit:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Get expired subscriptions that need renewal processing\n\t */\n\tasync getExpiredSubscriptions(): Promise<any[]> {\n\t\ttry {\n\t\t\tconst now = new Date();\n\n\t\t\tconst expired = await db\n\t\t\t\t.select()\n\t\t\t\t.from(subscriptions)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(subscriptions.type, 'degen_pass'),\n\t\t\t\t\t\teq(subscriptions.status, 'active'),\n\t\t\t\t\t\teq(subscriptions.autoRenew, true),\n\t\t\t\t\t\tlt(subscriptions.endDate, now),\n\t\t\t\t\t\teq(subscriptions.isDeleted, false)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\treturn expired;\n\t\t} catch (error) {\n\t\t\tlogger.error('SUBSCRIPTION', 'Error getting expired subscriptions:', error);\n\t\t\tthrow new Error('Failed to retrieve expired subscriptions');\n\t\t}\n\t}\n\n\t/**\n\t * Map database subscription to SubscriptionInfo interface\n\t */\n\tprivate mapToSubscriptionInfo(sub: any): SubscriptionInfo {\n\t\treturn {\n\t\t\tid: sub.id,\n\t\t\tuserId: sub.userId,\n\t\t\ttype: sub.type,\n\t\t\tstatus: sub.status,\n\t\t\tstartDate: sub.startDate,\n\t\t\tendDate: sub.endDate,\n\t\t\tnextBillingDate: sub.nextBillingDate,\n\t\t\tautoRenew: sub.autoRenew,\n\t\t\ttotalCosmeticValue: sub.totalCosmeticValue,\n\t\t\tbenefits: sub.benefits || {}\n\t\t};\n\t}\n\n\t/**\n\t * Get default benefits for subscription type\n\t */\n\tprivate getDefaultBenefits(type: 'vip_pass' | 'degen_pass'): Record<string, any> {\n\t\tconst benefits: Record<string, any> = {};\n\n\t\tif (type === 'vip_pass') {\n\t\t\tbenefits.lifetime_vip = true;\n\t\t\tbenefits.vip_badge = true;\n\t\t\tbenefits.priority_support = true;\n\t\t\tbenefits.advanced_forum_features = true;\n\t\t} else {\n\t\t\tbenefits.monthly_cosmetic_drop = true;\n\t\t\tbenefits.degen_badge = true;\n\t\t\tbenefits.exclusive_content = true;\n\t\t\tbenefits.enhanced_profile = true;\n\t\t}\n\n\t\treturn benefits;\n\t}\n\n\t/**\n\t * Generate random cosmetic item for monthly drop\n\t */\n\tprivate async generateRandomCosmetic(): Promise<CosmeticDropInfo | null> {\n\t\ttry {\n\t\t\t// Randomly select cosmetic type\n\t\t\tconst cosmeticTypes: Array<CosmeticDropInfo['cosmeticType']> = [\n\t\t\t\t'avatar_frame',\n\t\t\t\t'badge',\n\t\t\t\t'title'\n\t\t\t];\n\t\t\tconst randomType = cosmeticTypes[Math.floor(Math.random() * cosmeticTypes.length)];\n\n\t\t\t// Get available cosmetics of that type\n\t\t\tlet cosmetic: CosmeticDropInfo | null = null;\n\n\t\t\tswitch (randomType) {\n\t\t\t\tcase 'avatar_frame': {\n\t\t\t\t\tconst frames = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(avatarFrames)\n\t\t\t\t\t\t.where(eq(avatarFrames.isActive, true));\n\t\t\t\t\tif (frames.length > 0) {\n\t\t\t\t\t\tconst randomFrame = frames[Math.floor(Math.random() * frames.length)];\n\t\t\t\t\t\tcosmetic = {\n\t\t\t\t\t\t\tcosmeticType: 'avatar_frame',\n\t\t\t\t\t\t\tcosmeticId: randomFrame.id,\n\t\t\t\t\t\t\tcosmeticName: randomFrame.name || `Avatar Frame #${randomFrame.id}`,\n\t\t\t\t\t\t\tcosmeticValue: this.COSMETIC_DROP_VALUE\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'badge': {\n\t\t\t\t\tconst badgeList = await db.select().from(badges).where(eq(badges.isActive, true));\n\t\t\t\t\tif (badgeList.length > 0) {\n\t\t\t\t\t\tconst randomBadge = badgeList[Math.floor(Math.random() * badgeList.length)];\n\t\t\t\t\t\tcosmetic = {\n\t\t\t\t\t\t\tcosmeticType: 'badge',\n\t\t\t\t\t\t\tcosmeticId: randomBadge.id,\n\t\t\t\t\t\t\tcosmeticName: randomBadge.name,\n\t\t\t\t\t\t\tcosmeticValue: this.COSMETIC_DROP_VALUE\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'title': {\n\t\t\t\t\tconst titleList = await db.select().from(titles).where(eq(titles.isActive, true));\n\t\t\t\t\tif (titleList.length > 0) {\n\t\t\t\t\t\tconst randomTitle = titleList[Math.floor(Math.random() * titleList.length)];\n\t\t\t\t\t\tcosmetic = {\n\t\t\t\t\t\t\tcosmeticType: 'title',\n\t\t\t\t\t\t\tcosmeticId: randomTitle.id,\n\t\t\t\t\t\t\tcosmeticName: randomTitle.title,\n\t\t\t\t\t\t\tcosmeticValue: this.COSMETIC_DROP_VALUE\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn cosmetic;\n\t\t} catch (error) {\n\t\t\tlogger.error('COSMETIC_DROP', 'Error generating random cosmetic:', error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get date one month from now\n\t */\n\tprivate getNextMonthDate(fromDate?: Date): Date {\n\t\tconst date = fromDate ? new Date(fromDate) : new Date();\n\t\tdate.setMonth(date.getMonth() + 1);\n\t\treturn date;\n\t}\n}\n\n// Export singleton instance\nexport const subscriptionService = new SubscriptionService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/subscriptions/subscription.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/treasury/treasury.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eq' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserId' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":16,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactionResult' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":134,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":134,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mockUsdtVolume' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":270,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":270,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'formattedTransactions' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":290,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":290,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dailyDgtVolume' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":333,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":333,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * Treasury Routes\n *\n * Defines API routes for treasury operations including balance management,\n * adjustments, and settings.\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport { db } from '@db';\nimport { sql } from 'drizzle-orm';\nimport { users, transactions } from '@schema';\nimport { eq } from 'drizzle-orm';\nimport { isAdmin } from '../auth/middleware/auth.middleware';\nimport { getUserId } from '../auth/services/auth.service';\nimport { logger } from \"../../core/logger\";\n\n/**\n * Format DGT amount from storage format (BIGINT with 6 decimal precision) to display format\n */\nfunction formatDgtAmount(amount: number | bigint): number {\n\treturn Number(amount) / 1000000;\n}\n\n/**\n * Parse DGT amount from display format to storage format\n */\nfunction parseDgtAmount(displayAmount: number): number {\n\treturn Math.round(displayAmount * 1000000);\n}\n\n/**\n * Helper function to adjust treasury balance (used by both /adjust and /adjust-usdt endpoints)\n */\nasync function adjustTreasuryBalance(\n\treq: Request,\n\tres: Response,\n\tparams: {\n\t\tamount: number;\n\t\ttype: string;\n\t\treason?: string;\n\t\tcurrency: string;\n\t}\n): Promise<Response> {\n\ttry {\n\t\tconst adminId = userService.getUserFromRequest(req);\n\t\tconst { amount, type, reason, currency } = params;\n\n\t\tif (!amount || !type || !currency) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'Required fields: amount, type (credit/debit), currency (DGT/USDT)'\n\t\t\t});\n\t\t}\n\n\t\tif (type !== 'credit' && type !== 'debit') {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: \"Type must be 'credit' or 'debit'\"\n\t\t\t});\n\t\t}\n\n\t\tif (currency !== 'DGT' && currency !== 'USDT') {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: \"Currency must be 'DGT' or 'USDT'\"\n\t\t\t});\n\t\t}\n\n\t\t// Validate amount\n\t\tconst amountNumeric = parseFloat(amount.toString());\n\t\tif (isNaN(amountNumeric) || amountNumeric <= 0) {\n\t\t\treturn res.status(400).json({ message: 'Amount must be a positive number' });\n\t\t}\n\n\t\t// Begin transaction\n\t\tawait db.transaction(async (tx) => {\n\t\t\t// Fetch current treasury settings\n\t\t\tconst treasuryResult = await tx.execute(sql`\n        SELECT treasury_usdt_balance, dgt_treasury_balance FROM dgt_economy_parameters LIMIT 1\n      `);\n\n\t\t\tif (treasuryResult.rows.length === 0) {\n\t\t\t\tthrow new Error('Treasury settings not found');\n\t\t\t}\n\n\t\t\tconst treasurySettings = treasuryResult.rows[0];\n\n\t\t\t// Calculate new balance based on currency\n\t\t\tlet newBalance: number;\n\t\t\tlet previousBalance: number;\n\t\t\tlet dbField: string;\n\t\t\tlet amountToAdjust: number;\n\n\t\t\tif (currency === 'USDT') {\n\t\t\t\tpreviousBalance = Number(treasurySettings.treasury_usdt_balance) || 0;\n\t\t\t\tdbField = 'treasury_usdt_balance';\n\t\t\t\tamountToAdjust = amountNumeric;\n\t\t\t} else {\n\t\t\t\t// DGT\n\t\t\t\tpreviousBalance = Number(treasurySettings.dgt_treasury_balance) || 0;\n\t\t\t\tdbField = 'dgt_treasury_balance';\n\t\t\t\tamountToAdjust = parseDgtAmount(amountNumeric);\n\t\t\t}\n\n\t\t\tif (type === 'credit') {\n\t\t\t\tnewBalance = previousBalance + amountToAdjust;\n\t\t\t} else {\n\t\t\t\t// debit\n\t\t\t\tif (previousBalance < amountToAdjust) {\n\t\t\t\t\tthrow new Error(`Insufficient treasury ${currency} balance`);\n\t\t\t\t}\n\t\t\t\tnewBalance = previousBalance - amountToAdjust;\n\t\t\t}\n\n\t\t\t// Update treasury balance using standard SQL for improved parameter safety\n\t\t\tif (dbField === 'treasury_usdt_balance') {\n\t\t\t\tawait tx.execute(sql`\n          UPDATE dgt_economy_parameters\n          SET treasury_usdt_balance = ${newBalance}, \n              updated_at = NOW(),\n              updated_by = ${adminId}\n          WHERE setting_id = 1\n        `);\n\t\t\t} else {\n\t\t\t\tawait tx.execute(sql`\n          UPDATE dgt_economy_parameters\n          SET dgt_treasury_balance = ${newBalance}, \n              updated_at = NOW(),\n              updated_by = ${adminId}\n          WHERE setting_id = 1\n        `);\n\t\t\t}\n\n\t\t\t// Create transaction record\n\t\t\tconst transactionResult = await tx.execute(sql`\n        INSERT INTO transactions (\n          user_id,\n          amount,\n          type,\n          status,\n          description,\n          metadata,\n          is_treasury_transaction,\n          currency_type,\n          created_at,\n          updated_at,\n          confirmed_at\n        ) VALUES (\n          ${adminId},\n          ${amountToAdjust},\n          ${'TREASURY_ADJUST'},\n          ${'confirmed'},\n          ${type === 'credit' ? `Treasury ${currency} Credit: ${reason || 'No reason provided'}` : `Treasury ${currency} Debit: ${reason || 'No reason provided'}`},\n          ${JSON.stringify({\n\t\t\t\t\t\tadjustment_type: type,\n\t\t\t\t\t\treason: reason || 'No reason provided',\n\t\t\t\t\t\tcurrency,\n\t\t\t\t\t\tdisplay_amount: amountNumeric // Store original display amount for DGT\n\t\t\t\t\t})},\n          ${true},\n          ${currency},\n          NOW(),\n          NOW(),\n          NOW()\n        ) RETURNING transaction_id\n      `);\n\n\t\t\t// Create admin audit log\n\t\t\tawait tx.execute(sql`\n        INSERT INTO admin_audit_logs (\n          user_id,\n          action,\n          entity_type,\n          entity_id,\n          details,\n          created_at,\n          ip_address\n        ) VALUES (\n          ${adminId},\n          ${`TREASURY_${currency}_${type.toUpperCase()}`},\n          ${'dgt_economy_parameters'},\n          ${1},\n          ${JSON.stringify({\n\t\t\t\t\t\tamount: currency === 'DGT' ? amountNumeric : amountToAdjust, // Display amount for DGT\n\t\t\t\t\t\tprevious_balance:\n\t\t\t\t\t\t\tcurrency === 'DGT' ? formatDgtAmount(previousBalance) : previousBalance,\n\t\t\t\t\t\tnew_balance: currency === 'DGT' ? formatDgtAmount(newBalance) : newBalance,\n\t\t\t\t\t\treason\n\t\t\t\t\t})},\n          NOW(),\n          ${req.ip || '127.0.0.1'}\n        )\n      `);\n\t\t});\n\n\t\treturn res.status(200).json({\n\t\t\tsuccess: true,\n\t\t\tmessage: `Successfully ${type === 'credit' ? 'credited' : 'debited'} ${amountNumeric} ${currency} to treasury`\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('Error adjusting treasury balance:', error);\n\n\t\tif (\n\t\t\terror.message &&\n\t\t\t(error.message.includes('Insufficient treasury') ||\n\t\t\t\terror.message === 'Treasury settings not found')\n\t\t) {\n\t\t\treturn res.status(400).json({ message: error.message });\n\t\t}\n\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n}\n\nconst router = Router();\n\n// Get treasury overview (admin only)\nrouter.get('/overview', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\t// Get treasury settings\n\t\tconst treasuryResult = await db.execute(sql`\n      SELECT \n        dgt_treasury_balance as \"dgtTreasuryBalance\",\n        treasury_usdt_balance as \"treasuryUsdtBalance\",\n        treasury_wallet_address as \"treasuryWalletAddress\",\n        min_withdrawal_amount as \"minWithdrawalAmount\",\n        withdrawal_fee_percent as \"withdrawalFeePercent\",\n        dgt_usdt_exchange_rate as \"dgtUsdtExchangeRate\",\n        updated_at as \"lastUpdated\"\n      FROM dgt_economy_parameters\n      LIMIT 1\n    `);\n\n\t\tconst treasurySettings = treasuryResult.rows[0];\n\n\t\tif (!treasurySettings) {\n\t\t\treturn res.status(404).json({ message: 'Treasury settings not found' });\n\t\t}\n\n\t\t// Get total circulating supply\n\t\tconst supplyResult = await db.execute(sql`\n      SELECT SUM(dgt_wallet_balance) as \"circulatingSupply\"\n      FROM users\n    `);\n\n\t\tconst circulatingSupply = formatDgtAmount(Number(supplyResult.rows[0].circulatingSupply) || 0);\n\n\t\t// Get active wallet stats\n\t\tconst walletStats = await db.execute(sql`\n      SELECT \n        COUNT(*) as \"activeWallets\",\n        COUNT(CASE WHEN wallet_address IS NOT NULL AND is_deleted = false THEN 1 ELSE NULL END) as \"totalWalletCount\",\n        0 as \"pendingWithdrawalCount\",\n        0 as \"pendingWithdrawalTotal\"\n      FROM users\n    `);\n\n\t\t// Get daily transaction volume - for now, just get the total with mock split\n\t\tconst transactionVolumeResult = await db.execute(sql`\n      SELECT \n        COALESCE(SUM(amount::numeric), 0) as \"totalVolume\",\n        COUNT(*) as \"transactionCount\"\n      FROM transactions\n      WHERE created_at > NOW() - INTERVAL '24 hours'\n        AND status = 'confirmed'\n    `);\n\n\t\t// Simplify and split the volume temporarily until schema update\n\t\tconst totalVolume = Number(transactionVolumeResult.rows[0].totalVolume) || 0;\n\t\tconst mockDgtVolume = totalVolume * 0.7; // 70% DGT\n\t\tconst mockUsdtVolume = totalVolume * 0.3; // 30% USDT\n\n\t\t// Get recent treasury transactions\n\t\tconst recentTransactions = await db.execute(sql`\n      SELECT\n        transaction_id,\n        type,\n        amount,\n        status,\n        description,\n        metadata,\n        created_at,\n        user_id\n      FROM transactions\n      WHERE is_treasury_transaction = true\n      ORDER BY created_at DESC\n      LIMIT 15\n    `);\n\n\t\t// Format transactions for display\n\t\tconst formattedTransactions = recentTransactions.rows.map((tx: any) => {\n\t\t\tlet meta = {};\n\t\t\tlet currency = 'DGT'; // Default\n\n\t\t\ttry {\n\t\t\t\t// Handle different formats of metadata\n\t\t\t\tif (tx.metadata) {\n\t\t\t\t\tif (typeof tx.metadata === 'string') {\n\t\t\t\t\t\tmeta = JSON.parse(tx.metadata);\n\t\t\t\t\t\tif (meta.currency) {\n\t\t\t\t\t\t\tcurrency = meta.currency;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (typeof tx.metadata === 'object') {\n\t\t\t\t\t\tmeta = tx.metadata;\n\t\t\t\t\t\tif (meta.currency) {\n\t\t\t\t\t\t\tcurrency = meta.currency;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tlogger.warn('Error parsing transaction metadata:', e);\n\t\t\t}\n\n\t\t\t// Use DGT formatting for DGT, regular for USDT\n\t\t\tconst formattedAmount =\n\t\t\t\tcurrency === 'USDT' ? Number(tx.amount) : formatDgtAmount(Number(tx.amount));\n\n\t\t\treturn {\n\t\t\t\tid: tx.transaction_id,\n\t\t\t\ttype: tx.type,\n\t\t\t\tamount: formattedAmount,\n\t\t\t\tstatus: tx.status,\n\t\t\t\tcreated_at: tx.created_at,\n\t\t\t\tdescription: tx.description,\n\t\t\t\tcurrency,\n\t\t\t\tuser_id: tx.user_id,\n\t\t\t\tmeta\n\t\t\t};\n\t\t});\n\n\t\t// Calculate DGT supply stats\n\t\tconst totalSupply = 1000000000; // 1 billion DGT fixed supply\n\t\tconst treasuryBalance = formatDgtAmount(treasurySettings.dgtTreasuryBalance);\n\t\tconst dailyDgtVolume = formatDgtAmount(mockDgtVolume);\n\n\t\tconst overview = {\n\t\t\tdgt_stats: {\n\t\t\t\tcirculating_supply: circulatingSupply,\n\t\t\t\ttotal_supply: formatDgtAmount(totalSupply),\n\t\t\t\ttreasury_balance: treasuryBalance,\n\t\t\t\ttreasury_balance_usdt: Number(treasurySettings.treasuryUsdtBalance) || 0,\n\t\t\t\ttreasury_wallet_address: treasurySettings.treasuryWalletAddress\n\t\t\t},\n\t\t\tplatform_stats: {\n\t\t\t\tactive_wallets: Number(walletStats.rows[0].activeWallets) || 0,\n\t\t\t\tpending_withdrawal_count: Number(walletStats.rows[0].pendingWithdrawalCount) || 0,\n\t\t\t\tpending_withdrawal_total: Number(walletStats.rows[0].pendingWithdrawalTotal) || 0\n\t\t\t},\n\t\t\teconomy_settings: {\n\t\t\t\tmin_withdrawal_amount: formatDgtAmount(treasurySettings.minWithdrawalAmount),\n\t\t\t\twithdrawal_fee_percent: treasurySettings.withdrawalFeePercent,\n\t\t\t\tdgt_usdt_exchange_rate: treasurySettings.dgtUsdtExchangeRate || 1,\n\t\t\t\tlast_updated: treasurySettings.lastUpdated\n\t\t\t}\n\t\t};\n\n\t\treturn res.status(200).json(overview);\n\t} catch (error) {\n\t\tlogger.error('Error fetching treasury overview:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n});\n\n// Adjust user DGT balance (admin only)\nrouter.post('/adjust-balance', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst adminId = userService.getUserFromRequest(req);\n\t\tconst { user_id, amount, type, reason } = req.body;\n\n\t\tif (!user_id || !amount || !type) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'Required fields: user_id, amount, type (credit/debit)'\n\t\t\t});\n\t\t}\n\n\t\tif (type !== 'credit' && type !== 'debit') {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: \"Type must be 'credit' or 'debit'\"\n\t\t\t});\n\t\t}\n\n\t\t// Check if user exists\n\t\tconst userCheck = await db.execute(sql`\n      SELECT user_id, username, dgt_wallet_balance \n      FROM users \n      WHERE user_id = ${user_id}\n    `);\n\n\t\tif (userCheck.rows.length === 0) {\n\t\t\treturn res.status(404).json({ message: 'User not found' });\n\t\t}\n\n\t\tconst user = userCheck.rows[0];\n\t\tconst dgtAmountInStorage = parseDgtAmount(amount);\n\n\t\t// Begin transaction\n\t\tawait db.transaction(async (tx) => {\n\t\t\t// Update user's DGT balance\n\t\t\tif (type === 'credit') {\n\t\t\t\tawait tx.execute(sql`\n          UPDATE users\n          SET dgt_wallet_balance = dgt_wallet_balance + ${dgtAmountInStorage}\n          WHERE user_id = ${user_id}\n        `);\n\n\t\t\t\t// Reduce from treasury\n\t\t\t\tawait tx.execute(sql`\n          UPDATE dgt_economy_parameters\n          SET dgt_treasury_balance = dgt_treasury_balance - ${dgtAmountInStorage}\n        `);\n\t\t\t} else {\n\t\t\t\t// Check if user has enough balance for debit\n\t\t\t\tif (Number(user.dgt_wallet_balance) < dgtAmountInStorage) {\n\t\t\t\t\tthrow new Error('Insufficient user balance');\n\t\t\t\t}\n\n\t\t\t\tawait tx.execute(sql`\n          UPDATE users\n          SET dgt_wallet_balance = dgt_wallet_balance - ${dgtAmountInStorage}\n          WHERE user_id = ${user_id}\n        `);\n\n\t\t\t\t// Add to treasury\n\t\t\t\tawait tx.execute(sql`\n          UPDATE dgt_economy_parameters\n          SET dgt_treasury_balance = dgt_treasury_balance + ${dgtAmountInStorage}\n        `);\n\t\t\t}\n\n\t\t\t// Create transaction record\n\t\t\tconst transactionResult = await tx.execute(sql`\n        INSERT INTO transactions (\n          user_id,\n          amount,\n          type,\n          status,\n          description,\n          metadata,\n          is_treasury_transaction,\n          created_at,\n          updated_at\n        ) VALUES (\n          ${user_id},\n          ${dgtAmountInStorage},\n          ${'ADMIN_ADJUST'},\n          ${'confirmed'},\n          ${type === 'credit' ? `Admin Credit: ${reason || 'No reason provided'}` : `Admin Debit: ${reason || 'No reason provided'}`},\n          ${JSON.stringify({\n\t\t\t\t\t\tadjusted_by: adminId,\n\t\t\t\t\t\tadjustment_type: type,\n\t\t\t\t\t\treason: reason || 'No reason provided',\n\t\t\t\t\t\tdisplay_amount: amount\n\t\t\t\t\t})},\n          ${true},\n          NOW(),\n          NOW()\n        ) RETURNING *\n      `);\n\n\t\t\t// Create admin audit log\n\t\t\tawait tx.execute(sql`\n        INSERT INTO admin_audit_logs (\n          user_id,\n          action,\n          entity_type,\n          entity_id,\n          details,\n          created_at,\n          ip_address\n        ) VALUES (\n          ${adminId},\n          ${type === 'credit' ? 'TREASURY_CREDIT' : 'TREASURY_DEBIT'},\n          ${'user'},\n          ${user_id},\n          ${JSON.stringify({\n\t\t\t\t\t\tamount,\n\t\t\t\t\t\tusername: user.username,\n\t\t\t\t\t\treason,\n\t\t\t\t\t\ttransaction_id: transactionResult.rows[0].transaction_id\n\t\t\t\t\t})},\n          NOW(),\n          ${req.ip || '127.0.0.1'}\n        )\n      `);\n\t\t});\n\n\t\treturn res.status(200).json({\n\t\t\tsuccess: true,\n\t\t\tmessage: `Successfully ${type === 'credit' ? 'credited' : 'debited'} ${amount} DGT to user ID ${user_id}`,\n\t\t\tuser_id,\n\t\t\tamount,\n\t\t\ttype\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Error adjusting balance:', error);\n\n\t\tif (error.message === 'Insufficient user balance') {\n\t\t\treturn res.status(400).json({ message: 'Insufficient user balance for debit operation' });\n\t\t}\n\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n});\n\n// Adjust treasury balance (admin only)\nrouter.post('/adjust', isAdmin, async (req: Request, res: Response) => {\n\tconst { amount, type, reason, currency } = req.body;\n\treturn await adjustTreasuryBalance(req, res, { amount, type, reason, currency });\n});\n\n// Update treasury settings (admin only)\nrouter.put('/settings', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst adminId = userService.getUserFromRequest(req);\n\t\tconst {\n\t\t\ttreasury_wallet_address,\n\t\t\tmin_withdrawal_amount,\n\t\t\twithdrawal_fee_percent,\n\t\t\tdgt_usdt_exchange_rate,\n\t\t\tauto_approve_withdrawals,\n\t\t\tmax_daily_withdrawal_limit\n\t\t} = req.body;\n\n\t\t// Basic validation\n\t\tif (\n\t\t\tmin_withdrawal_amount &&\n\t\t\t(isNaN(parseFloat(min_withdrawal_amount)) || parseFloat(min_withdrawal_amount) < 0)\n\t\t) {\n\t\t\treturn res\n\t\t\t\t.status(400)\n\t\t\t\t.json({ message: 'Minimum withdrawal amount must be a non-negative number' });\n\t\t}\n\t\tif (\n\t\t\twithdrawal_fee_percent &&\n\t\t\t(isNaN(parseFloat(withdrawal_fee_percent)) ||\n\t\t\t\tparseFloat(withdrawal_fee_percent) < 0 ||\n\t\t\t\tparseFloat(withdrawal_fee_percent) > 100)\n\t\t) {\n\t\t\treturn res.status(400).json({ message: 'Withdrawal fee percent must be between 0 and 100' });\n\t\t}\n\t\t// Add more validation as needed\n\n\t\t// Construct the SET clause dynamically to only update provided fields\n\t\tconst setClauses: string[] = [];\n\t\tconst params: any[] = [];\n\t\tlet paramIndex = 1;\n\n\t\tif (treasury_wallet_address !== undefined) {\n\t\t\tsetClauses.push(`treasury_wallet_address = $${paramIndex++}`);\n\t\t\tparams.push(treasury_wallet_address);\n\t\t}\n\t\tif (min_withdrawal_amount !== undefined) {\n\t\t\tsetClauses.push(`min_withdrawal_amount = $${paramIndex++}`);\n\t\t\tparams.push(parseDgtAmount(parseFloat(min_withdrawal_amount)));\n\t\t}\n\t\tif (withdrawal_fee_percent !== undefined) {\n\t\t\tsetClauses.push(`withdrawal_fee_percent = $${paramIndex++}`);\n\t\t\tparams.push(parseFloat(withdrawal_fee_percent));\n\t\t}\n\t\tif (dgt_usdt_exchange_rate !== undefined) {\n\t\t\tsetClauses.push(`dgt_usdt_exchange_rate = $${paramIndex++}`);\n\t\t\tparams.push(parseFloat(dgt_usdt_exchange_rate));\n\t\t}\n\t\tif (auto_approve_withdrawals !== undefined) {\n\t\t\tsetClauses.push(`auto_approve_withdrawals = $${paramIndex++}`);\n\t\t\tparams.push(auto_approve_withdrawals);\n\t\t}\n\t\tif (max_daily_withdrawal_limit !== undefined) {\n\t\t\tsetClauses.push(`max_daily_withdrawal_limit = $${paramIndex++}`);\n\t\t\tparams.push(parseDgtAmount(parseFloat(max_daily_withdrawal_limit)));\n\t\t}\n\n\t\tif (setClauses.length === 0) {\n\t\t\treturn res.status(400).json({ message: 'No settings provided to update' });\n\t\t}\n\n\t\tsetClauses.push(`updated_at = NOW()`);\n\t\tsetClauses.push(`updated_by = $${paramIndex++}`);\n\t\tparams.push(adminId);\n\n\t\tconst query = `UPDATE dgt_economy_parameters SET ${setClauses.join(', ')} WHERE setting_id = 1`;\n\n\t\tawait db.execute(sql.raw(query), ...params.slice(0, params.length - 1)); // Pass params directly to execute\n\n\t\t// Admin Audit Log\n\t\tawait db.execute(sql`\n      INSERT INTO admin_audit_logs (\n        user_id,\n        action,\n        entity_type,\n        entity_id,\n        details,\n        created_at,\n        ip_address\n      ) VALUES (\n        ${adminId},\n        'TREASURY_SETTINGS_UPDATE',\n        'dgt_economy_parameters',\n        1, -- Assuming setting_id 1 for the single row\n        ${JSON.stringify(req.body)}, -- Log all changes sent in the request\n        NOW(),\n        ${req.ip || '127.0.0.1'}\n      )\n    `);\n\n\t\treturn res.status(200).json({\n\t\t\tsuccess: true,\n\t\t\tmessage: 'Treasury settings updated successfully'\n\t\t});\n\t} catch (error: any) {\n\t\tlogger.error('Error updating treasury settings:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n});\n\n// Adjust treasury USDT balance (admin only) - Legacy endpoint for backward compatibility\nrouter.post('/adjust-usdt', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\t// Modify the request to use the new unified endpoint format\n\t\tconst { amount, type, reason } = req.body;\n\n\t\t// Use the same logic as the main adjust endpoint\n\t\treturn await adjustTreasuryBalance(req, res, {\n\t\t\tamount,\n\t\t\ttype,\n\t\t\treason,\n\t\t\tcurrency: 'USDT'\n\t\t});\n\t} catch (error) {\n\t\tlogger.error('Error in adjust-usdt endpoint:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n});\n\n// Get treasury balance history (mocked for now, replace with actual query)\nrouter.get('/balance-history', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst historyResult = await db.execute(sql`\n      SELECT \n        created_at as date,\n        dgt_treasury_balance as \"dgtBalance\",\n        treasury_usdt_balance as \"usdtBalance\"\n      FROM dgt_economy_parameters_history -- MOCKED - THIS TABLE DOES NOT EXIST YET\n      ORDER BY created_at DESC\n      LIMIT 30\n    `);\n\n\t\tconst history = historyResult.rows.map((row) => ({\n\t\t\tdate: row.date,\n\t\t\tdgtBalance: formatDgtAmount(Number(row.dgtBalance) || 0),\n\t\t\tusdtBalance: Number(row.usdtBalance) || 0\n\t\t}));\n\n\t\treturn res.status(200).json(history);\n\t} catch (error: any) {\n\t\tlogger.error('Error fetching treasury balance history:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n});\n\n// Get treasury transaction history (admin only)\nrouter.get('/transaction-history', isAdmin, async (req: Request, res: Response) => {\n\ttry {\n\t\tconst historyResult = await db.execute(sql`\n      SELECT \n        created_at as date,\n        type,\n        amount,\n        status,\n        description,\n        metadata\n      FROM transactions\n      WHERE is_treasury_transaction = true\n      ORDER BY created_at DESC\n      LIMIT 30\n    `);\n\n\t\tconst history = historyResult.rows.map((row) => ({\n\t\t\tdate: row.date,\n\t\t\ttype: row.type,\n\t\t\tamount: formatDgtAmount(Number(row.amount) || 0),\n\t\t\tstatus: row.status,\n\t\t\tdescription: row.description,\n\t\t\tmetadata: row.metadata\n\t\t}));\n\n\t\treturn res.status(200).json(history);\n\t} catch (error: any) {\n\t\tlogger.error('Error fetching treasury transaction history:', error);\n\t\treturn res.status(500).json({ message: 'Internal server error' });\n\t}\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/uploads/upload.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/uploads/upload.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/uploads/upload.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/user/user-preferences.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/user/user-preferences.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/users/middleware/privacy.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/users/transformers/user.transformer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/users/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/ccpayment.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/crypto-wallet.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/dgt.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tx' is defined but never used.","line":318,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":318,"endColumn":49}],"suppressedMessages":[{"ruleId":"prefer-spread","severity":2,"message":"Use the spread operator instead of '.apply()'.","line":269,"column":10,"nodeType":"CallExpression","messageId":"preferSpread","endLine":269,"endColumn":48,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * DGT Service\n *\n * Handles all DGT (Degentalk Token) operations including crediting, debiting,\n * transfers, and balance management. Integrates with existing economy system.\n */\n\nimport { db } from '@db';\nimport { wallets, transactions, users } from '@schema';\nimport { eq, and, sql, desc } from 'drizzle-orm';\nimport { walletConfigService } from './wallet-config.service';\nimport { vanitySinkAnalyzer } from '../shop/services/vanity-sink.analyzer';\nimport type { ItemId, ActionId, WalletId, TransactionId, DgtAmount, UserId } from '@shared/types/ids';\nimport { logger } from \"../../core/logger\";\n\nexport interface DGTTransactionMetadata {\n\tsource:\n\t\t| 'crypto_deposit'\n\t\t| 'shop_purchase'\n\t\t| 'tip_send'\n\t\t| 'tip_receive'\n\t\t| 'rain_send'\n\t\t| 'rain_receive'\n\t\t| 'admin_credit'\n\t\t| 'admin_debit'\n\t\t| 'internal_transfer_send'\n\t\t| 'internal_transfer_receive'\n\t\t| 'xp_boost'\n\t\t| 'manual_credit';\n\toriginalToken?: string;\n\tusdtAmount?: string;\n\tdepositRecordId?: string;\n\ttipId?: string;\n\trainId?: string;\n\tshopItemId?: string;\n\ttransferId?: string;\n\tadminUserId?: string;\n\treason?: string;\n\tmetadata?: Record<string, any>;\n}\n\nexport interface DGTBalance {\n\tuserId: UserId;\n\tbalance: DgtAmount;\n\tlastTransactionAt: Date | null;\n\twalletId: WalletId;\n}\n\nexport interface DGTTransaction {\n\tid: TransactionId;\n\tuserId: UserId;\n\tamount: DgtAmount;\n\ttype: string;\n\tbalanceAfter: number;\n\tmetadata: DGTTransactionMetadata;\n\tcreatedAt: Date;\n}\n\nexport interface DGTTransferResult {\n\ttransactionId: ActionId;\n\tfromBalance: number;\n\ttoBalance: number;\n\ttransferId: string;\n}\n\n/**\n * DGT Service Class\n */\nexport class DGTService {\n\t/**\n\t * Get user's DGT balance\n\t */\n\tasync getDGTBalance(userId: string): Promise<DGTBalance> {\n\t\ttry {\n\t\t\t// Get user's DGT wallet\n\t\t\tconst wallet = await db.select().from(wallets).where(eq(wallets.userId, userId)).limit(1);\n\n\t\t\tif (wallet.length === 0) {\n\t\t\t\t// Create wallet if it doesn't exist\n\t\t\t\tawait this.createDGTWallet(userId);\n\t\t\t\treturn {\n\t\t\t\t\tuserId,\n\t\t\t\t\tbalance: 0,\n\t\t\t\t\tlastTransactionAt: null,\n\t\t\t\t\twalletId: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst userWallet = wallet[0];\n\t\t\treturn {\n\t\t\t\tuserId,\n\t\t\t\tbalance: userWallet.balance,\n\t\t\t\tlastTransactionAt: userWallet.lastTransaction,\n\t\t\t\twalletId: userWallet.id\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting DGT balance:', error);\n\t\t\tthrow new Error('Failed to retrieve DGT balance');\n\t\t}\n\t}\n\n\t/**\n\t * Credit DGT to user's account\n\t */\n\tasync creditDGT(\n\t\tuserId: string,\n\t\tamount: number,\n\t\tmetadata: DGTTransactionMetadata\n\t): Promise<DGTTransaction> {\n\t\tif (amount <= 0) {\n\t\t\tthrow new Error('Credit amount must be positive');\n\t\t}\n\n\t\ttry {\n\t\t\tconst config = await walletConfigService.getConfig();\n\n\t\t\t// Get or create user wallet\n\t\t\tawait this.ensureDGTWallet(userId);\n\t\t\tconst walletData = await this.getDGTBalance(userId);\n\n\t\t\t// Check max balance limit\n\t\t\tconst newBalance = walletData.balance + amount;\n\t\t\tif (newBalance > config.dgt.maxDGTBalance) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Transaction would exceed maximum DGT balance limit of ${config.dgt.maxDGTBalance}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Start transaction\n\t\t\tconst result = await db.transaction(async (tx) => {\n\t\t\t\t// Update wallet balance\n\t\t\t\tawait tx\n\t\t\t\t\t.update(wallets)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tbalance: newBalance,\n\t\t\t\t\t\tlastTransaction: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(wallets.userId, userId));\n\n\t\t\t\t// Create transaction record\n\t\t\t\tconst [transaction] = await tx\n\t\t\t\t\t.insert(transactions)\n\t\t\t\t\t.values({\n\t\t\t\t\t\tuserId: userId,\n\t\t\t\t\t\twalletId: walletData.walletId,\n\t\t\t\t\t\tamount: Math.round(amount * 100), // Store in cents for precision\n\t\t\t\t\t\ttype: this.getTransactionType(metadata.source),\n\t\t\t\t\t\tstatus: 'confirmed',\n\t\t\t\t\t\tdescription: this.getTransactionDescription(metadata),\n\t\t\t\t\t\tmetadata: metadata as any,\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.returning();\n\n\t\t\t\treturn transaction;\n\t\t\t});\n\n\t\t\tlogger.info(`DGT credited: ${amount} DGT to user ${userId} (${metadata.source})`);\n\n\t\t\treturn {\n\t\t\t\tid: result.id,\n\t\t\t\tuserId,\n\t\t\t\tamount,\n\t\t\t\ttype: result.type,\n\t\t\t\tbalanceAfter: newBalance,\n\t\t\t\tmetadata,\n\t\t\t\tcreatedAt: result.createdAt\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error crediting DGT:', error);\n\t\t\tconst err = error as Error;\n\t\t\tthrow new Error(`Failed to credit DGT: ${err.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Debit DGT from user's account\n\t */\n\tasync debitDGT(\n\t\tuserId: string,\n\t\tamount: number,\n\t\tmetadata: DGTTransactionMetadata\n\t): Promise<DGTTransaction> {\n\t\tif (amount <= 0) {\n\t\t\tthrow new Error('Debit amount must be positive');\n\t\t}\n\n\t\ttry {\n\t\t\t// Get user balance\n\t\t\tconst walletData = await this.getDGTBalance(userId);\n\n\t\t\t// Check sufficient balance\n\t\t\tif (walletData.balance < amount) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Insufficient DGT balance. Available: ${walletData.balance}, Required: ${amount}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst newBalance = walletData.balance - amount;\n\n\t\t\t// Start transaction\n\t\t\tconst result = await db.transaction(async (tx) => {\n\t\t\t\t// Update wallet balance\n\t\t\t\tawait tx\n\t\t\t\t\t.update(wallets)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tbalance: newBalance,\n\t\t\t\t\t\tlastTransaction: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(wallets.userId, userId));\n\n\t\t\t\t// Create transaction record\n\t\t\t\tconst [transaction] = await tx\n\t\t\t\t\t.insert(transactions)\n\t\t\t\t\t.values({\n\t\t\t\t\t\tuserId: userId,\n\t\t\t\t\t\twalletId: walletData.walletId,\n\t\t\t\t\t\tamount: -Math.round(amount * 100), // Negative for debit, store in cents\n\t\t\t\t\t\ttype: this.getTransactionType(metadata.source),\n\t\t\t\t\t\tstatus: 'confirmed',\n\t\t\t\t\t\tdescription: this.getTransactionDescription(metadata),\n\t\t\t\t\t\tmetadata: metadata as any,\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.returning();\n\n\t\t\t\treturn transaction;\n\t\t\t});\n\n\t\t\tlogger.info(`DGT debited: ${amount} DGT from user ${userId} (${metadata.source})`);\n\n\t\t\t// Track DGT burn for XP boost purchases\n\t\t\tif (metadata.source === 'xp_boost') {\n\t\t\t\tawait vanitySinkAnalyzer.trackBurn({\n\t\t\t\t\tuserId,\n\t\t\t\t\torderId: result.id,\n\t\t\t\t\tdgtBurned: amount,\n\t\t\t\t\tburnType: 'xp_boost',\n\t\t\t\t\tsource: 'gamification',\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tboostType: metadata.metadata?.boostType || 'personal_xp_multiplier',\n\t\t\t\t\t\tburnReason: 'xp_boost_purchase',\n\t\t\t\t\t\t...metadata.metadata\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tid: result.id,\n\t\t\t\tuserId,\n\t\t\t\tamount: -amount, // Return negative for debit\n\t\t\t\ttype: result.type,\n\t\t\t\tbalanceAfter: newBalance,\n\t\t\t\tmetadata,\n\t\t\t\tcreatedAt: result.createdAt\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error debiting DGT:', error);\n\t\t\tconst err = error as Error;\n\t\t\tthrow new Error(`Failed to debit DGT: ${err.message}`);\n\t\t}\n\t}\n\n\t/** @deprecated – use debitDGT */\n\tasync deductDGT(...args: Parameters<this['debitDGT']>): Promise<ReturnType<this['debitDGT']>> {\n\t\t// eslint-disable-next-line prefer-spread\n\t\treturn this.debitDGT.apply(this, args as any);\n\t}\n\n\t/**\n\t * Transfer DGT between users\n\t */\n\tasync transferDGT(\n\t\tfromUserId: string,\n\t\ttoUserId: string,\n\t\tamount: number,\n\t\tnote?: string\n\t): Promise<DGTTransferResult> {\n\t\tif (amount <= 0) {\n\t\t\tthrow new Error('Transfer amount must be positive');\n\t\t}\n\n\t\tif (fromUserId === toUserId) {\n\t\t\tthrow new Error('Cannot transfer DGT to yourself');\n\t\t}\n\n\t\ttry {\n\t\t\tconst config = await walletConfigService.getConfig();\n\n\t\t\t// Check if transfers are allowed\n\t\t\tif (!config.features.allowInternalTransfers) {\n\t\t\t\tthrow new Error('DGT transfers are currently disabled');\n\t\t\t}\n\n\t\t\t// Check transfer limits\n\t\t\tif (amount > config.limits.maxDGTTransfer) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Transfer amount exceeds maximum limit of ${config.limits.maxDGTTransfer} DGT`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Verify users exist\n\t\t\tconst usersData = await db\n\t\t\t\t.select()\n\t\t\t\t.from(users)\n\t\t\t\t.where(sql`${users.id} IN (${fromUserId}, ${toUserId})`);\n\n\t\t\tif (usersData.length !== 2) {\n\t\t\t\tthrow new Error('Invalid user(s) for transfer');\n\t\t\t}\n\n\t\t\t// Generate transfer ID\n\t\t\tconst transferId = `dgt_transfer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n\t\t\t// Start transaction\n\t\t\tconst result = await db.transaction(async (tx) => {\n\t\t\t\t// Debit from sender\n\t\t\t\tconst debitTransaction = await this.debitDGT(fromUserId, amount, {\n\t\t\t\t\tsource: 'internal_transfer_send',\n\t\t\t\t\ttransferId,\n\t\t\t\t\treason: note,\n\t\t\t\t\tmetadata: { toUserId, transferId }\n\t\t\t\t});\n\n\t\t\t\t// Credit to receiver\n\t\t\t\tconst creditTransaction = await this.creditDGT(toUserId, amount, {\n\t\t\t\t\tsource: 'internal_transfer_receive',\n\t\t\t\t\ttransferId,\n\t\t\t\t\treason: note,\n\t\t\t\t\tmetadata: { fromUserId, transferId }\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tdebit: debitTransaction,\n\t\t\t\t\tcredit: creditTransaction\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tlogger.info(`DGT transfer: ${amount} DGT from ${fromUserId} to ${toUserId} (${transferId})`);\n\n\t\t\treturn {\n\t\t\t\ttransactionId: result.debit.id,\n\t\t\t\tfromBalance: result.debit.balanceAfter,\n\t\t\t\ttoBalance: result.credit.balanceAfter,\n\t\t\t\ttransferId\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error transferring DGT:', error);\n\t\t\tconst err = error as Error;\n\t\t\tthrow new Error(`Failed to transfer DGT: ${err.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get user's DGT transaction history\n\t */\n\tasync getDGTHistory(\n\t\tuserId: string,\n\t\toptions?: {\n\t\t\tlimit?: number;\n\t\t\toffset?: number;\n\t\t\ttype?: string;\n\t\t}\n\t): Promise<DGTTransaction[]> {\n\t\ttry {\n\t\t\tconst limit = options?.limit || 50;\n\t\t\tconst offset = options?.offset || 0;\n\n\t\t\tconst userWallet = await this.getDGTBalance(userId);\n\n\t\t\tlet query = db\n\t\t\t\t.select()\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(eq(transactions.walletId, userWallet.walletId))\n\t\t\t\t.orderBy(desc(transactions.createdAt))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\tif (options?.type) {\n\t\t\t\tquery = query.where(\n\t\t\t\t\tand(eq(transactions.walletId, userWallet.walletId), eq(transactions.type, options.type))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst results = await query;\n\n\t\t\treturn results.map((tx) => ({\n\t\t\t\tid: tx.id,\n\t\t\t\tuserId,\n\t\t\t\tamount: tx.amount / 100, // Convert back from cents\n\t\t\t\ttype: tx.type,\n\t\t\t\tbalanceAfter: 0, // Would need to calculate or store separately\n\t\t\t\tmetadata: tx.metadata as DGTTransactionMetadata,\n\t\t\t\tcreatedAt: tx.createdAt\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting DGT history:', error);\n\t\t\tthrow new Error('Failed to retrieve DGT transaction history');\n\t\t}\n\t}\n\n\t/**\n\t * Get DGT analytics for admin\n\t */\n\tasync getDGTAnalytics(): Promise<{\n\t\ttotalSupply: number;\n\t\ttotalUsers: number;\n\t\ttotalTransactions: number;\n\t\tdailyVolume: number;\n\t\taverageBalance: number;\n\t}> {\n\t\ttry {\n\t\t\tconst [totalSupplyResult, totalUsersResult, totalTransactionsResult] = await Promise.all([\n\t\t\t\t// Total DGT in circulation\n\t\t\t\tdb\n\t\t\t\t\t.select({\n\t\t\t\t\t\ttotal: sql<number>`SUM(${wallets.balance})`\n\t\t\t\t\t})\n\t\t\t\t\t.from(wallets),\n\n\t\t\t\t// Total users with DGT\n\t\t\t\tdb\n\t\t\t\t\t.select({\n\t\t\t\t\t\tcount: sql<number>`COUNT(*)`\n\t\t\t\t\t})\n\t\t\t\t\t.from(wallets)\n\t\t\t\t\t.where(sql`${wallets.balance} > 0`),\n\n\t\t\t\t// Total transactions\n\t\t\t\tdb\n\t\t\t\t\t.select({\n\t\t\t\t\t\tcount: sql<number>`COUNT(*)`\n\t\t\t\t\t})\n\t\t\t\t\t.from(transactions)\n\t\t\t]);\n\n\t\t\t// Daily volume (last 24 hours)\n\t\t\tconst oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);\n\t\t\tconst [dailyVolumeResult] = await db\n\t\t\t\t.select({\n\t\t\t\t\tvolume: sql<number>`SUM(ABS(${transactions.amount}))`\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(sql`${transactions.createdAt} >= ${oneDayAgo}`);\n\n\t\t\tconst totalSupply = totalSupplyResult[0]?.total || 0;\n\t\t\tconst totalUsers = totalUsersResult[0]?.count || 0;\n\t\t\tconst totalTransactions = totalTransactionsResult[0]?.count || 0;\n\t\t\tconst dailyVolume = (dailyVolumeResult?.volume || 0) / 100; // Convert from cents\n\t\t\tconst averageBalance = totalUsers > 0 ? totalSupply / totalUsers : 0;\n\n\t\t\treturn {\n\t\t\t\ttotalSupply,\n\t\t\t\ttotalUsers,\n\t\t\t\ttotalTransactions,\n\t\t\t\tdailyVolume,\n\t\t\t\taverageBalance\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting DGT analytics:', error);\n\t\t\tthrow new Error('Failed to retrieve DGT analytics');\n\t\t}\n\t}\n\n\t/**\n\t * Ensure user has a DGT wallet\n\t */\n\tprivate async ensureDGTWallet(userId: string): Promise<void> {\n\t\tconst existing = await db.select().from(wallets).where(eq(wallets.userId, userId)).limit(1);\n\n\t\tif (existing.length === 0) {\n\t\t\tawait this.createDGTWallet(userId);\n\t\t}\n\t}\n\n\t/**\n\t * Create DGT wallet for user\n\t */\n\tprivate async createDGTWallet(userId: string): Promise<void> {\n\t\ttry {\n\t\t\tawait db.insert(wallets).values({\n\t\t\t\tuserId: userId,\n\t\t\t\tbalance: 0,\n\t\t\t\tisDeleted: false,\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t});\n\n\t\t\tlogger.info(`DGT wallet created for user: ${userId}`);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error creating DGT wallet:', error);\n\t\t\tthrow new Error('Failed to create DGT wallet');\n\t\t}\n\t}\n\n\t/**\n\t * Get transaction type from source\n\t */\n\tprivate getTransactionType(source: DGTTransactionMetadata['source']): string {\n\t\tconst typeMap: Record<DGTTransactionMetadata['source'], string> = {\n\t\t\tcrypto_deposit: 'DEPOSIT_CREDIT',\n\t\t\tshop_purchase: 'SHOP_SPEND',\n\t\t\ttip_send: 'TIP_SEND',\n\t\t\ttip_receive: 'TIP_RECEIVE',\n\t\t\train_send: 'RAIN_SEND',\n\t\t\train_receive: 'RAIN_RECEIVE',\n\t\t\tadmin_credit: 'ADMIN_CREDIT',\n\t\t\tadmin_debit: 'ADMIN_DEBIT',\n\t\t\tinternal_transfer_send: 'INTERNAL_TRANSFER_SEND',\n\t\t\tinternal_transfer_receive: 'INTERNAL_TRANSFER_RECEIVE',\n\t\t\txp_boost: 'XP_BOOST',\n\t\t\tmanual_credit: 'MANUAL_CREDIT'\n\t\t};\n\n\t\treturn typeMap[source] || 'OTHER';\n\t}\n\n\t/**\n\t * Get transaction description from metadata\n\t */\n\tprivate getTransactionDescription(metadata: DGTTransactionMetadata): string {\n\t\tswitch (metadata.source) {\n\t\t\tcase 'crypto_deposit':\n\t\t\t\treturn `DGT credit from ${metadata.originalToken} deposit (${metadata.usdtAmount} USDT)`;\n\t\t\tcase 'shop_purchase':\n\t\t\t\treturn `Shop purchase: ${metadata.shopItemId}`;\n\t\t\tcase 'tip_send':\n\t\t\t\treturn `Tip sent: ${metadata.reason || 'No message'}`;\n\t\t\tcase 'tip_receive':\n\t\t\t\treturn `Tip received: ${metadata.reason || 'No message'}`;\n\t\t\tcase 'rain_send':\n\t\t\t\treturn `Rain event participation`;\n\t\t\tcase 'rain_receive':\n\t\t\t\treturn `Rain reward received`;\n\t\t\tcase 'admin_credit':\n\t\t\t\treturn `Admin credit: ${metadata.reason || 'Manual adjustment'}`;\n\t\t\tcase 'admin_debit':\n\t\t\t\treturn `Admin debit: ${metadata.reason || 'Manual adjustment'}`;\n\t\t\tcase 'internal_transfer_send':\n\t\t\t\treturn `Transfer sent: ${metadata.reason || 'No note'}`;\n\t\t\tcase 'internal_transfer_receive':\n\t\t\t\treturn `Transfer received: ${metadata.reason || 'No note'}`;\n\t\t\tcase 'xp_boost':\n\t\t\t\treturn `XP boost purchase`;\n\t\t\tcase 'manual_credit':\n\t\t\t\treturn `Manual credit: ${metadata.reason || 'Administrator action'}`;\n\t\t\tdefault:\n\t\t\t\treturn 'DGT transaction';\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const dgtService = new DGTService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/middleware/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/middleware/security.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'wallets' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { Request, Response, NextFunction } from 'express';\nimport { db } from '@db';\nimport { wallets, users } from '@schema';\nimport { eq, and, sql } from 'drizzle-orm';\nimport { walletConfigService } from '../wallet-config.service';\nimport type { SecurityMiddleware, RateLimitResult } from './types';\nimport { logger } from \"../../../core/logger\";\n\n/**\n * Wallet Security Middleware\n *\n * Provides rate limiting, fraud detection, and security controls for wallet operations.\n */\n\n// In-memory rate limiting storage (in production, use Redis)\nconst rateLimitStore = new Map<string, { count: number; resetTime: number }>();\n\n/**\n * Check rate limit for a specific operation\n */\nconst checkRateLimit = async (\n\tuserId: string,\n\toperation: string,\n\tmaxAttempts: number,\n\twindowMinutes: number\n): Promise<RateLimitResult> => {\n\tconst key = `${userId}:${operation}`;\n\tconst now = Date.now();\n\tconst windowMs = windowMinutes * 60 * 1000;\n\n\tlet record = rateLimitStore.get(key);\n\n\tif (!record || now > record.resetTime) {\n\t\t// Create new record or reset expired one\n\t\trecord = {\n\t\t\tcount: 0,\n\t\t\tresetTime: now + windowMs\n\t\t};\n\t}\n\n\tif (record.count >= maxAttempts) {\n\t\treturn {\n\t\t\tallowed: false,\n\t\t\tremaining: 0,\n\t\t\tresetTime: record.resetTime\n\t\t};\n\t}\n\n\trecord.count++;\n\trateLimitStore.set(key, record);\n\n\treturn {\n\t\tallowed: true,\n\t\tremaining: maxAttempts - record.count,\n\t\tresetTime: record.resetTime\n\t};\n};\n\n/**\n * Rate limiting for deposits\n */\nconst depositRateLimit = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\tres.status(401).json({ success: false, message: 'Authentication required' });\n\t\t\treturn;\n\t\t}\n\n\t\tconst config = await walletConfigService.getConfig();\n\t\tconst rateCheck = await checkRateLimit(\n\t\t\tuserId,\n\t\t\t'deposit',\n\t\t\tconfig.limits.depositsPerHour,\n\t\t\t60 // 1 hour window\n\t\t);\n\n\t\tif (!rateCheck.allowed) {\n\t\t\tconst resetTime = new Date(rateCheck.resetTime);\n\t\t\tres.status(429).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Deposit rate limit exceeded',\n\t\t\t\terror: {\n\t\t\t\t\ttype: 'RATE_LIMIT_EXCEEDED',\n\t\t\t\t\tresetTime: resetTime.toISOString(),\n\t\t\t\t\tmaxAttempts: config.limits.depositsPerHour\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Add rate limit headers\n\t\tres.set({\n\t\t\t'X-RateLimit-Limit': config.limits.depositsPerHour.toString(),\n\t\t\t'X-RateLimit-Remaining': rateCheck.remaining.toString(),\n\t\t\t'X-RateLimit-Reset': rateCheck.resetTime.toString()\n\t\t});\n\n\t\tnext();\n\t} catch (error) {\n\t\tlogger.error('Error in deposit rate limit middleware:', error);\n\t\tres.status(500).json({ success: false, message: 'Internal server error' });\n\t}\n};\n\n/**\n * Rate limiting for transfers/tips\n */\nconst transferRateLimit = async (\n\treq: Request,\n\tres: Response,\n\tnext: NextFunction\n): Promise<void> => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\tres.status(401).json({ success: false, message: 'Authentication required' });\n\t\t\treturn;\n\t\t}\n\n\t\tconst config = await walletConfigService.getConfig();\n\t\tconst rateCheck = await checkRateLimit(\n\t\t\tuserId,\n\t\t\t'transfer',\n\t\t\tconfig.limits.tipsPerMinute,\n\t\t\t1 // 1 minute window\n\t\t);\n\n\t\tif (!rateCheck.allowed) {\n\t\t\tconst resetTime = new Date(rateCheck.resetTime);\n\t\t\tres.status(429).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Transfer rate limit exceeded',\n\t\t\t\terror: {\n\t\t\t\t\ttype: 'RATE_LIMIT_EXCEEDED',\n\t\t\t\t\tresetTime: resetTime.toISOString(),\n\t\t\t\t\tmaxAttempts: config.limits.tipsPerMinute\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Add rate limit headers\n\t\tres.set({\n\t\t\t'X-RateLimit-Limit': config.limits.tipsPerMinute.toString(),\n\t\t\t'X-RateLimit-Remaining': rateCheck.remaining.toString(),\n\t\t\t'X-RateLimit-Reset': rateCheck.resetTime.toString()\n\t\t});\n\n\t\tnext();\n\t} catch (error) {\n\t\tlogger.error('Error in transfer rate limit middleware:', error);\n\t\tres.status(500).json({ success: false, message: 'Internal server error' });\n\t}\n};\n\n/**\n * Security checks for withdrawals\n */\nconst withdrawalSecurityCheck = async (\n\treq: Request,\n\tres: Response,\n\tnext: NextFunction\n): Promise<void> => {\n\ttry {\n\t\tconst userId = userService.getUserFromRequest(req)?.id;\n\t\tif (!userId) {\n\t\t\tres.status(401).json({ success: false, message: 'Authentication required' });\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if withdrawals are enabled\n\t\tconst config = await walletConfigService.getConfig();\n\t\tif (!config.features.allowCryptoWithdrawals) {\n\t\t\tres.status(403).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Crypto withdrawals are currently disabled',\n\t\t\t\terror: { type: 'FEATURE_DISABLED' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Get user info for additional security checks\n\t\tconst user = await db.select().from(users).where(eq(users.id, userId)).limit(1);\n\n\t\tif (user.length === 0) {\n\t\t\tres.status(404).json({ success: false, message: 'User not found' });\n\t\t\treturn;\n\t\t}\n\n\t\tconst userData = user[0];\n\n\t\t// Additional security checks can be added here:\n\t\t// - Account age verification\n\t\t// - Email verification status\n\t\t// - Two-factor authentication status\n\t\t// - Suspicious activity detection\n\n\t\t// Example: Check if account is less than 24 hours old\n\t\tconst accountAge = Date.now() - new Date(userData.createdAt).getTime();\n\t\tconst minAccountAge = 24 * 60 * 60 * 1000; // 24 hours\n\n\t\tif (accountAge < minAccountAge) {\n\t\t\tres.status(403).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Account must be at least 24 hours old to withdraw',\n\t\t\t\terror: {\n\t\t\t\t\ttype: 'ACCOUNT_TOO_NEW',\n\t\t\t\t\taccountAge: Math.floor(accountAge / (60 * 60 * 1000)), // hours\n\t\t\t\t\trequiredAge: 24\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tnext();\n\t} catch (error) {\n\t\tlogger.error('Error in withdrawal security check:', error);\n\t\tres.status(500).json({ success: false, message: 'Internal server error' });\n\t}\n};\n\n/**\n * Validate DGT transfer amounts and limits\n */\nconst dgtTransferValidation = async (\n\treq: Request,\n\tres: Response,\n\tnext: NextFunction\n): Promise<void> => {\n\ttry {\n\t\tconst { amount, toUserId } = req.body;\n\t\tconst fromUserId = userService.getUserFromRequest(req)?.id;\n\n\t\tif (!fromUserId) {\n\t\t\tres.status(401).json({ success: false, message: 'Authentication required' });\n\t\t\treturn;\n\t\t}\n\n\t\t// Validate amount\n\t\tif (!amount || amount <= 0) {\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Invalid transfer amount',\n\t\t\t\terror: { type: 'INVALID_AMOUNT' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Check config limits\n\t\tconst config = await walletConfigService.getConfig();\n\t\tif (amount > config.limits.maxDGTTransfer) {\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Transfer amount exceeds maximum limit of ${config.limits.maxDGTTransfer} DGT`,\n\t\t\t\terror: {\n\t\t\t\t\ttype: 'AMOUNT_EXCEEDS_LIMIT',\n\t\t\t\t\tmaxAmount: config.limits.maxDGTTransfer\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Validate target user\n\t\tif (!toUserId || fromUserId === toUserId) {\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Invalid transfer recipient',\n\t\t\t\terror: { type: 'INVALID_RECIPIENT' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if target user exists\n\t\tconst targetUser = await db.select().from(users).where(eq(users.id, toUserId)).limit(1);\n\n\t\tif (targetUser.length === 0) {\n\t\t\tres.status(404).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Transfer recipient not found',\n\t\t\t\terror: { type: 'RECIPIENT_NOT_FOUND' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tnext();\n\t} catch (error) {\n\t\tlogger.error('Error in DGT transfer validation:', error);\n\t\tres.status(500).json({ success: false, message: 'Internal server error' });\n\t}\n};\n\n/**\n * Validate admin DGT operations (credit/debit)\n */\nconst adminDGTOperationValidation = async (\n\treq: Request,\n\tres: Response,\n\tnext: NextFunction\n): Promise<void> => {\n\ttry {\n\t\tconst { userId: targetUserId, amount } = req.body;\n\t\tconst adminUserId = userService.getUserFromRequest(req)?.id;\n\n\t\tif (!adminUserId) {\n\t\t\tres.status(401).json({ success: false, message: 'Admin authentication required' });\n\t\t\treturn;\n\t\t}\n\n\t\t// Validate amount\n\t\tif (!amount || amount <= 0) {\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Invalid operation amount',\n\t\t\t\terror: { type: 'INVALID_AMOUNT' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Check daily credit limit for admin operations\n\t\tconst config = await walletConfigService.getConfig();\n\t\tconst today = new Date();\n\t\ttoday.setHours(0, 0, 0, 0);\n\n\t\t// This could be implemented with more sophisticated tracking\n\t\t// For now, we'll just check the config limit\n\t\tif (amount > config.limits.maxDailyCreditAmount) {\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Operation amount exceeds daily limit of ${config.limits.maxDailyCreditAmount} DGT`,\n\t\t\t\terror: {\n\t\t\t\t\ttype: 'DAILY_LIMIT_EXCEEDED',\n\t\t\t\t\tmaxDailyAmount: config.limits.maxDailyCreditAmount\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Validate target user\n\t\tif (!targetUserId) {\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Target user ID required',\n\t\t\t\terror: { type: 'MISSING_TARGET_USER' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if target user exists\n\t\tconst targetUser = await db.select().from(users).where(eq(users.id, targetUserId)).limit(1);\n\n\t\tif (targetUser.length === 0) {\n\t\t\tres.status(404).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Target user not found',\n\t\t\t\terror: { type: 'TARGET_USER_NOT_FOUND' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tnext();\n\t} catch (error) {\n\t\tlogger.error('Error in admin DGT operation validation:', error);\n\t\tres.status(500).json({ success: false, message: 'Internal server error' });\n\t}\n};\n\nexport const securityMiddleware: SecurityMiddleware = {\n\tdepositRateLimit,\n\ttransferRateLimit,\n\twithdrawalSecurityCheck,\n\tdgtTransferValidation,\n\tadminDGTOperationValidation\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/middleware/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/middleware/webhook.middleware.ts","messages":[{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":77,"column":12,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":77,"endColumn":14},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":78,"column":12,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":78,"endColumn":14},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":79,"column":12,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":79,"endColumn":14},{"ruleId":"no-mixed-spaces-and-tabs","severity":1,"message":"Mixed spaces and tabs.","line":80,"column":12,"nodeType":"Program","messageId":"mixedSpacesAndTabs","endLine":80,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport crypto from 'crypto';\nimport type { WebhookMiddleware } from './types';\nimport { logger } from \"../../../core/logger\";\n\n/**\n * Webhook Validation Middleware\n *\n * Validates incoming webhooks from CCPayment to ensure authenticity and prevent tampering.\n */\n\n// In-memory store for webhook rate limiting (use Redis in production)\nconst webhookRateLimitStore = new Map<string, { count: number; resetTime: number }>();\n\n/**\n * Validate CCPayment webhook signature\n */\nconst validateCCPaymentWebhook = async (\n\treq: Request,\n\tres: Response,\n\tnext: NextFunction\n): Promise<void> => {\n\ttry {\n\t\tconst signature = req.headers['ccpayment-signature'] as string;\n\t\tconst timestamp = req.headers['ccpayment-timestamp'] as string;\n\n\t\tif (!signature || !timestamp) {\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Missing webhook signature or timestamp',\n\t\t\t\terror: { type: 'MISSING_WEBHOOK_HEADERS' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Get app secret from environment\n\t\tconst appSecret = process.env.CCPAYMENT_APP_SECRET;\n\t\tif (!appSecret) {\n\t\t\tlogger.error('CCPAYMENT_APP_SECRET not configured');\n\t\t\tres.status(500).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Webhook validation not configured',\n\t\t\t\terror: { type: 'CONFIGURATION_ERROR' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Verify timestamp is recent (within 5 minutes)\n\t\tconst webhookTime = parseInt(timestamp);\n\t\tconst currentTime = Math.floor(Date.now() / 1000);\n\t\tconst timeDiff = Math.abs(currentTime - webhookTime);\n\n\t\tif (timeDiff > 300) {\n\t\t\t// 5 minutes\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Webhook timestamp too old',\n\t\t\t\terror: {\n\t\t\t\t\ttype: 'TIMESTAMP_TOO_OLD',\n\t\t\t\t\tmaxAge: 300,\n\t\t\t\t\tactualAge: timeDiff\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Verify signature\n\t\tconst payloadString = JSON.stringify(req.body);\n\t\tconst stringToSign = timestamp + payloadString;\n\t\tconst expectedSignature = crypto\n\t\t\t.createHmac('sha256', appSecret)\n\t\t\t.update(stringToSign)\n\t\t\t.digest('hex');\n\n\t\tif (signature !== expectedSignature) {\n\t\t\tlogger.error('Webhook signature validation failed', {\n            \t\t\t\treceived: signature,\n            \t\t\t\texpected: expectedSignature,\n            \t\t\t\tpayload: payloadString.substring(0, 100) + '...'\n            \t\t\t});\n\n\t\t\tres.status(401).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Invalid webhook signature',\n\t\t\t\terror: { type: 'INVALID_SIGNATURE' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Signature is valid, proceed\n\t\tnext();\n\t} catch (error) {\n\t\tlogger.error('Error validating webhook:', error);\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\tmessage: 'Webhook validation error',\n\t\t\terror: { type: 'VALIDATION_ERROR' }\n\t\t});\n\t}\n};\n\n/**\n * Rate limit webhook requests to prevent spam/abuse\n */\nconst rateLimitWebhooks = async (\n\treq: Request,\n\tres: Response,\n\tnext: NextFunction\n): Promise<void> => {\n\ttry {\n\t\t// Use IP address for rate limiting\n\t\tconst clientIP = req.ip || req.connection.remoteAddress || 'unknown';\n\t\tconst key = `webhook:${clientIP}`;\n\t\tconst now = Date.now();\n\t\tconst windowMs = 60 * 1000; // 1 minute window\n\t\tconst maxRequests = 100; // Max 100 webhooks per minute per IP\n\n\t\tlet record = webhookRateLimitStore.get(key);\n\n\t\tif (!record || now > record.resetTime) {\n\t\t\t// Create new record or reset expired one\n\t\t\trecord = {\n\t\t\t\tcount: 0,\n\t\t\t\tresetTime: now + windowMs\n\t\t\t};\n\t\t}\n\n\t\tif (record.count >= maxRequests) {\n\t\t\tres.status(429).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Webhook rate limit exceeded',\n\t\t\t\terror: {\n\t\t\t\t\ttype: 'WEBHOOK_RATE_LIMIT_EXCEEDED',\n\t\t\t\t\tresetTime: new Date(record.resetTime).toISOString(),\n\t\t\t\t\tmaxRequests\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\trecord.count++;\n\t\twebhookRateLimitStore.set(key, record);\n\n\t\t// Add rate limit headers\n\t\tres.set({\n\t\t\t'X-Webhook-RateLimit-Limit': maxRequests.toString(),\n\t\t\t'X-Webhook-RateLimit-Remaining': (maxRequests - record.count).toString(),\n\t\t\t'X-Webhook-RateLimit-Reset': record.resetTime.toString()\n\t\t});\n\n\t\tnext();\n\t} catch (error) {\n\t\tlogger.error('Error in webhook rate limiting:', error);\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\tmessage: 'Webhook rate limiting error',\n\t\t\terror: { type: 'RATE_LIMIT_ERROR' }\n\t\t});\n\t}\n};\n\n/**\n * Validate webhook payload structure\n */\nconst validateWebhookPayload = (req: Request, res: Response, next: NextFunction): void => {\n\ttry {\n\t\tconst { eventType } = req.body;\n\n\t\tif (!eventType) {\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: 'Missing eventType in webhook payload',\n\t\t\t\terror: { type: 'MISSING_EVENT_TYPE' }\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst validEventTypes = ['deposit', 'withdraw', 'internal_transfer', 'swap'];\n\t\tif (!validEventTypes.includes(eventType)) {\n\t\t\tres.status(400).json({\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Invalid eventType: ${eventType}`,\n\t\t\t\terror: {\n\t\t\t\t\ttype: 'INVALID_EVENT_TYPE',\n\t\t\t\t\tvalidTypes: validEventTypes\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Additional validation based on event type\n\t\tswitch (eventType) {\n\t\t\tcase 'deposit':\n\t\t\t\tif (!req.body.recordId || !req.body.uid || !req.body.amount) {\n\t\t\t\t\tres.status(400).json({\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: 'Missing required fields for deposit webhook',\n\t\t\t\t\t\terror: { type: 'MISSING_DEPOSIT_FIELDS' }\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'withdraw':\n\t\t\t\tif (!req.body.recordId || !req.body.uid || !req.body.amount) {\n\t\t\t\t\tres.status(400).json({\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: 'Missing required fields for withdrawal webhook',\n\t\t\t\t\t\terror: { type: 'MISSING_WITHDRAWAL_FIELDS' }\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'internal_transfer':\n\t\t\t\tif (!req.body.recordId || !req.body.fromUid || !req.body.toUid || !req.body.amount) {\n\t\t\t\t\tres.status(400).json({\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: 'Missing required fields for transfer webhook',\n\t\t\t\t\t\terror: { type: 'MISSING_TRANSFER_FIELDS' }\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'swap':\n\t\t\t\tif (!req.body.recordId || !req.body.uid || !req.body.fromAmount || !req.body.toCoinId) {\n\t\t\t\t\tres.status(400).json({\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: 'Missing required fields for swap webhook',\n\t\t\t\t\t\terror: { type: 'MISSING_SWAP_FIELDS' }\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tnext();\n\t} catch (error) {\n\t\tlogger.error('Error validating webhook payload:', error);\n\t\tres.status(500).json({\n\t\t\tsuccess: false,\n\t\t\tmessage: 'Webhook payload validation error',\n\t\t\terror: { type: 'PAYLOAD_VALIDATION_ERROR' }\n\t\t});\n\t}\n};\n\nexport const webhookMiddleware: WebhookMiddleware = {\n\tvalidateCCPaymentWebhook,\n\trateLimitWebhooks\n};\n\n// Export individual middleware functions\nexport { validateCCPaymentWebhook, rateLimitWebhooks, validateWebhookPayload };\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/services/ccpayment-api.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/services/ccpayment-balance.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/services/ccpayment-deposit.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/services/ccpayment-token.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/treasury.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ccpaymentService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactionTypeEnum' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":20,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { UserId } from '@shared/types/ids';\n/**\n * Treasury Controller\n *\n * Admin interface for managing the platform's treasury and user balances\n */\n\nimport type { Request, Response, NextFunction } from 'express';\nimport { logger } from '../../core/logger';\nimport { dgtService } from './dgt.service';\nimport { walletService } from './wallet.service';\nimport { ccpaymentService } from './ccpayment.service';\nimport { db } from '@db';\nimport {\n\tusers,\n\ttransactions,\n\tdgtPurchaseOrders,\n\twithdrawalRequests,\n\ttransactionTypeEnum\n} from '@schema';\nimport { eq, desc, sql, and, gte, lt, count } from 'drizzle-orm';\nimport { z } from 'zod';\n\n// Validation schemas\nconst adjustBalanceSchema = z.object({\n\tuserId: z.string().uuid().positive(),\n\tamount: z.number(),\n\treason: z.string().min(1).max(500),\n\ttype: z.enum(['credit', 'debit'])\n});\n\nconst bulkAirdropSchema = z.object({\n\tamount: z.number().positive(),\n\treason: z.string().min(1).max(500),\n\ttargetUsers: z.enum(['all', 'active', 'specific']),\n\tuserIds: z.array(z.number()).optional(),\n\tminLevel: z.number().min(0).optional()\n});\n\nexport class TreasuryController {\n\t/**\n\t * Get treasury overview\n\t */\n\tasync getTreasuryOverview(req: Request, res: Response, next: NextFunction) {\n\t\ttry {\n\t\t\t// Get total DGT in circulation\n\t\t\tconst [circulationResult] = await db\n\t\t\t\t.select({\n\t\t\t\t\ttotalDGT: sql<number>`COALESCE(SUM(${transactions.amount}), 0)`\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(eq(transactions.type, 'MINT'));\n\n\t\t\tconst totalMinted = circulationResult?.totalDGT || 0;\n\n\t\t\t// Get total user balances\n\t\t\tconst userBalancePromises = await db\n\t\t\t\t.select({\n\t\t\t\t\tuserId: users.id,\n\t\t\t\t\tusername: users.username\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.isDeleted, false))\n\t\t\t\t.limit(1000); // Limit for performance\n\n\t\t\tlet totalUserBalances = 0;\n\t\t\tconst topHolders = [];\n\n\t\t\tfor (const user of userBalancePromises) {\n\t\t\t\tconst balance = await dgtService.getUserBalance(user.userId);\n\t\t\t\tconst balanceNumber = Number(balance) / 100000000;\n\t\t\t\ttotalUserBalances += balanceNumber;\n\n\t\t\t\tif (balanceNumber > 0) {\n\t\t\t\t\ttopHolders.push({\n\t\t\t\t\t\tuserId: user.userId,\n\t\t\t\t\t\tusername: user.username,\n\t\t\t\t\t\tbalance: balanceNumber\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sort top holders\n\t\t\ttopHolders.sort((a, b) => b.balance - a.balance);\n\t\t\tconst top10Holders = topHolders.slice(0, 10);\n\n\t\t\t// Get recent transactions summary\n\t\t\tconst twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);\n\t\t\tconst [dailyStats] = await db\n\t\t\t\t.select({\n\t\t\t\t\ttotalTransactions: count(),\n\t\t\t\t\ttotalVolume: sql<number>`COALESCE(SUM(${transactions.amount}), 0)`\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(gte(transactions.createdAt, twentyFourHoursAgo));\n\n\t\t\t// Get pending withdrawals\n\t\t\tconst [pendingWithdrawals] = await db\n\t\t\t\t.select({\n\t\t\t\t\tcount: count(),\n\t\t\t\t\ttotalAmount: sql<number>`COALESCE(SUM(${withdrawalRequests.amount}), 0)`\n\t\t\t\t})\n\t\t\t\t.from(withdrawalRequests)\n\t\t\t\t.where(eq(withdrawalRequests.status, 'pending'));\n\n\t\t\t// Get purchase orders stats\n\t\t\tconst [purchaseStats] = await db\n\t\t\t\t.select({\n\t\t\t\t\tpendingCount: count(),\n\t\t\t\t\tpendingValue: sql<number>`COALESCE(SUM(CAST(${dgtPurchaseOrders.cryptoAmount} AS DECIMAL)), 0)`\n\t\t\t\t})\n\t\t\t\t.from(dgtPurchaseOrders)\n\t\t\t\t.where(eq(dgtPurchaseOrders.status, 'pending'));\n\n\t\t\tres.json({\n\t\t\t\ttreasury: {\n\t\t\t\t\ttotalMinted: totalMinted / 100000000,\n\t\t\t\t\ttotalUserBalances,\n\t\t\t\t\tcirculatingSupply: totalUserBalances,\n\t\t\t\t\treserveBalance: Math.max(0, totalMinted / 100000000 - totalUserBalances)\n\t\t\t\t},\n\t\t\t\ttopHolders: top10Holders,\n\t\t\t\tdailyStats: {\n\t\t\t\t\ttransactions: dailyStats?.totalTransactions || 0,\n\t\t\t\t\tvolume: (dailyStats?.totalVolume || 0) / 100000000\n\t\t\t\t},\n\t\t\t\tpendingOperations: {\n\t\t\t\t\twithdrawals: {\n\t\t\t\t\t\tcount: pendingWithdrawals?.count || 0,\n\t\t\t\t\t\ttotalAmount: (pendingWithdrawals?.totalAmount || 0) / 100\n\t\t\t\t\t},\n\t\t\t\t\tpurchases: {\n\t\t\t\t\t\tcount: purchaseStats?.pendingCount || 0,\n\t\t\t\t\t\ttotalValue: purchaseStats?.pendingValue || 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('TreasuryController', 'Error getting treasury overview', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tnext(error);\n\t\t}\n\t}\n\n\t/**\n\t * Get user balance details\n\t */\n\tasync getUserBalanceDetails(req: Request, res: Response, next: NextFunction) {\n\t\ttry {\n\t\t\tconst userId = req.params.userId as UserId;\n\n\t\t\t// Get user info\n\t\t\tconst [user] = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\temail: users.email,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\tccpaymentAccountId: users.ccpaymentAccountId\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\tif (!user) {\n\t\t\t\treturn res.status(404).json({ error: 'User not found' });\n\t\t\t}\n\n\t\t\t// Get wallet details\n\t\t\tconst wallet = await walletService.getUserWallet(userId);\n\t\t\tconst transactionHistory = await walletService.getTransactionHistory(userId, 50);\n\n\t\t\t// Get transaction summary by type\n\t\t\tconst transactionSummary = await db\n\t\t\t\t.select({\n\t\t\t\t\ttype: transactions.type,\n\t\t\t\t\tcount: count(),\n\t\t\t\t\ttotalAmount: sql<number>`COALESCE(SUM(${transactions.amount}), 0)`\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(eq(transactions.userId, userId))\n\t\t\t\t.groupBy(transactions.type);\n\n\t\t\tres.json({\n\t\t\t\tuser: {\n\t\t\t\t\tid: user.id,\n\t\t\t\t\tusername: user.username,\n\t\t\t\t\temail: user.email,\n\t\t\t\t\tlevel: user.level,\n\t\t\t\t\thasCCPaymentAccount: !!user.ccpaymentAccountId\n\t\t\t\t},\n\t\t\t\twallet: {\n\t\t\t\t\tdgtBalance: Number(wallet.dgt) / 100000000,\n\t\t\t\t\tcryptoBalances: wallet.cryptoBalances\n\t\t\t\t},\n\t\t\t\ttransactionSummary: transactionSummary.map((summary) => ({\n\t\t\t\t\ttype: summary.type,\n\t\t\t\t\tcount: summary.count,\n\t\t\t\t\ttotalAmount: summary.totalAmount / 100000000\n\t\t\t\t})),\n\t\t\t\trecentTransactions: transactionHistory.slice(0, 20)\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('TreasuryController', 'Error getting user balance details', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tuserId: req.params.userId\n\t\t\t});\n\t\t\tnext(error);\n\t\t}\n\t}\n\n\t/**\n\t * Adjust user balance (admin only)\n\t */\n\tasync adjustUserBalance(req: Request, res: Response, next: NextFunction) {\n\t\ttry {\n\t\t\tconst adminId = (userService.getUserFromRequest(req) as { id: UserId }).id;\n\t\t\tconst { userId, amount, reason, type } = adjustBalanceSchema.parse(req.body);\n\n\t\t\t// Verify user exists\n\t\t\tconst [user] = await db\n\t\t\t\t.select({ username: users.username })\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\tif (!user) {\n\t\t\t\treturn res.status(404).json({ error: 'User not found' });\n\t\t\t}\n\n\t\t\tconst dgtAmount = BigInt(Math.floor(Math.abs(amount) * 100000000));\n\t\t\tconst adjustmentReason = `Admin adjustment: ${reason}`;\n\n\t\t\tif (type === 'credit') {\n\t\t\t\tawait dgtService.addDGT(userId, dgtAmount, 'ADMIN_CREDIT', adjustmentReason, {\n\t\t\t\t\tadminId,\n\t\t\t\t\toriginalAmount: amount\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tawait dgtService.deductDGT(userId, dgtAmount, 'ADMIN_DEBIT', adjustmentReason, {\n\t\t\t\t\tadminId,\n\t\t\t\t\toriginalAmount: amount\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlogger.info('TreasuryController', 'Balance adjusted by admin', {\n\t\t\t\tadminId,\n\t\t\t\tuserId,\n\t\t\t\tusername: user.username,\n\t\t\t\ttype,\n\t\t\t\tamount,\n\t\t\t\treason\n\t\t\t});\n\n\t\t\t// Get new balance\n\t\t\tconst newBalance = await dgtService.getUserBalance(userId);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Successfully ${type === 'credit' ? 'credited' : 'debited'} ${amount} DGT ${type === 'credit' ? 'to' : 'from'} ${user.username}`,\n\t\t\t\tnewBalance: Number(newBalance) / 100000000\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({ error: 'Invalid request', details: error.errors });\n\t\t\t}\n\t\t\tlogger.error('TreasuryController', 'Error adjusting user balance', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tnext(error);\n\t\t}\n\t}\n\n\t/**\n\t * Execute bulk airdrop (admin only)\n\t */\n\tasync executeBulkAirdrop(req: Request, res: Response, next: NextFunction) {\n\t\ttry {\n\t\t\tconst adminId = (userService.getUserFromRequest(req) as { id: UserId }).id;\n\t\t\tconst { amount, reason, targetUsers, userIds, minLevel } = bulkAirdropSchema.parse(req.body);\n\n\t\t\tlet targetUserList: { id: UserId; username: string }[] = [];\n\n\t\t\t// Determine target users\n\t\t\tif (targetUsers === 'specific' && userIds) {\n\t\t\t\tconst specificUsers = await db\n\t\t\t\t\t.select({ id: users.id, username: users.username })\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(and(eq(users.isDeleted, false), sql`${users.id} = ANY(${userIds})`));\n\t\t\t\ttargetUserList = specificUsers;\n\t\t\t} else if (targetUsers === 'active') {\n\t\t\t\t// Users who have been active in the last 30 days\n\t\t\t\tconst thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n\t\t\t\tconst activeUsers = await db\n\t\t\t\t\t.select({ id: users.id, username: users.username })\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(users.isDeleted, false),\n\t\t\t\t\t\t\tgte(users.lastActiveAt, thirtyDaysAgo),\n\t\t\t\t\t\t\tminLevel ? gte(users.level, minLevel) : sql`true`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\ttargetUserList = activeUsers;\n\t\t\t} else {\n\t\t\t\t// All users\n\t\t\t\tconst allUsers = await db\n\t\t\t\t\t.select({ id: users.id, username: users.username })\n\t\t\t\t\t.from(users)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(eq(users.isDeleted, false), minLevel ? gte(users.level, minLevel) : sql`true`)\n\t\t\t\t\t);\n\t\t\t\ttargetUserList = allUsers;\n\t\t\t}\n\n\t\t\tif (targetUserList.length === 0) {\n\t\t\t\treturn res.status(400).json({ error: 'No users match the criteria' });\n\t\t\t}\n\n\t\t\t// Execute airdrop\n\t\t\tconst dgtAmount = BigInt(Math.floor(amount * 100000000));\n\t\t\tconst airdropReason = `Airdrop: ${reason}`;\n\t\t\tconst results = [];\n\n\t\t\tfor (const user of targetUserList) {\n\t\t\t\ttry {\n\t\t\t\t\tawait dgtService.addDGT(user.id, dgtAmount, 'AIRDROP', airdropReason, {\n\t\t\t\t\t\tadminId,\n\t\t\t\t\t\tairdropReason: reason\n\t\t\t\t\t});\n\t\t\t\t\tresults.push({ userId: user.id, username: user.username, success: true });\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.error('TreasuryController', 'Failed to airdrop to user', {\n\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\tusername: user.username,\n\t\t\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t\t\t});\n\t\t\t\t\tresults.push({\n\t\t\t\t\t\tuserId: user.id,\n\t\t\t\t\t\tusername: user.username,\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst successCount = results.filter((r) => r.success).length;\n\t\t\tconst totalAmount = successCount * amount;\n\n\t\t\tlogger.info('TreasuryController', 'Bulk airdrop executed', {\n\t\t\t\tadminId,\n\t\t\t\ttargetUsers,\n\t\t\t\ttotalUsers: targetUserList.length,\n\t\t\t\tsuccessCount,\n\t\t\t\tamount,\n\t\t\t\ttotalAmount,\n\t\t\t\treason\n\t\t\t});\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Airdrop completed: ${successCount}/${targetUserList.length} users received ${amount} DGT`,\n\t\t\t\tsummary: {\n\t\t\t\t\ttotalUsers: targetUserList.length,\n\t\t\t\t\tsuccessCount,\n\t\t\t\t\tfailureCount: targetUserList.length - successCount,\n\t\t\t\t\tamountPerUser: amount,\n\t\t\t\t\ttotalDistributed: totalAmount\n\t\t\t\t},\n\t\t\t\tresults: results.slice(0, 50) // Limit results for response size\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({ error: 'Invalid request', details: error.errors });\n\t\t\t}\n\t\t\tlogger.error('TreasuryController', 'Error executing bulk airdrop', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tnext(error);\n\t\t}\n\t}\n\n\t/**\n\t * Get transaction analytics\n\t */\n\tasync getTransactionAnalytics(req: Request, res: Response, next: NextFunction) {\n\t\ttry {\n\t\t\tconst days = parseInt(req.query.days as string) || 7;\n\t\t\tconst startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n\n\t\t\t// Transaction volume by day\n\t\t\tconst dailyVolume = await db\n\t\t\t\t.select({\n\t\t\t\t\tdate: sql<string>`DATE(${transactions.createdAt})`,\n\t\t\t\t\tcount: count(),\n\t\t\t\t\tvolume: sql<number>`COALESCE(SUM(${transactions.amount}), 0)`\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(gte(transactions.createdAt, startDate))\n\t\t\t\t.groupBy(sql`DATE(${transactions.createdAt})`)\n\t\t\t\t.orderBy(sql`DATE(${transactions.createdAt})`);\n\n\t\t\t// Transaction volume by type\n\t\t\tconst volumeByType = await db\n\t\t\t\t.select({\n\t\t\t\t\ttype: transactions.type,\n\t\t\t\t\tcount: count(),\n\t\t\t\t\tvolume: sql<number>`COALESCE(SUM(${transactions.amount}), 0)`\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(gte(transactions.createdAt, startDate))\n\t\t\t\t.groupBy(transactions.type);\n\n\t\t\t// Top spenders\n\t\t\tconst topSpenders = await db\n\t\t\t\t.select({\n\t\t\t\t\tuserId: transactions.userId,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\ttotalSpent: sql<number>`COALESCE(SUM(CASE WHEN ${transactions.amount} < 0 THEN ABS(${transactions.amount}) ELSE 0 END), 0)`,\n\t\t\t\t\ttransactionCount: count()\n\t\t\t\t})\n\t\t\t\t.from(transactions)\n\t\t\t\t.leftJoin(users, eq(transactions.userId, users.id))\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\tgte(transactions.createdAt, startDate),\n\t\t\t\t\t\tlt(transactions.amount, 0) // Only debit transactions\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.groupBy(transactions.userId, users.username)\n\t\t\t\t.orderBy(desc(sql`totalSpent`))\n\t\t\t\t.limit(10);\n\n\t\t\tres.json({\n\t\t\t\tperiod: {\n\t\t\t\t\tdays,\n\t\t\t\t\tstartDate: startDate.toISOString(),\n\t\t\t\t\tendDate: new Date().toISOString()\n\t\t\t\t},\n\t\t\t\tdailyVolume: dailyVolume.map((day) => ({\n\t\t\t\t\tdate: day.date,\n\t\t\t\t\tcount: day.count,\n\t\t\t\t\tvolume: day.volume / 100000000\n\t\t\t\t})),\n\t\t\t\tvolumeByType: volumeByType.map((type) => ({\n\t\t\t\t\ttype: type.type,\n\t\t\t\t\tcount: type.count,\n\t\t\t\t\tvolume: type.volume / 100000000\n\t\t\t\t})),\n\t\t\t\ttopSpenders: topSpenders.map((spender) => ({\n\t\t\t\t\tuserId: spender.userId,\n\t\t\t\t\tusername: spender.username,\n\t\t\t\t\ttotalSpent: spender.totalSpent / 100000000,\n\t\t\t\t\ttransactionCount: spender.transactionCount\n\t\t\t\t}))\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('TreasuryController', 'Error getting transaction analytics', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tnext(error);\n\t\t}\n\t}\n}\n\nexport const treasuryController = new TreasuryController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/user-management.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { ccpaymentUsers, users, cryptoWallets } from '@schema';\nimport { eq, and } from 'drizzle-orm';\nimport { CCPaymentService } from './ccpayment.service';\nimport type { CoinId } from '@shared/types/ids';\nimport { logger } from \"../../core/logger\";\n\n/**\n * User Management Service for CCPayment Integration\n *\n * Handles the mapping between Degentalk users and CCPayment user accounts.\n * Ensures each Degentalk user has a corresponding CCPayment user for wallet operations.\n */\nexport class UserManagementService {\n\tprivate ccpaymentService: CCPaymentService;\n\n\tconstructor() {\n\t\tthis.ccpaymentService = new CCPaymentService();\n\t}\n\n\t/**\n\t * Get or create a CCPayment user for a Degentalk user\n\t */\n\tasync getOrCreateCCPaymentUser(userId: string): Promise<string> {\n\t\ttry {\n\t\t\t// First check if user already has a CCPayment mapping\n\t\t\tconst existingMapping = await db\n\t\t\t\t.select()\n\t\t\t\t.from(ccpaymentUsers)\n\t\t\t\t.where(eq(ccpaymentUsers.userId, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (existingMapping.length > 0) {\n\t\t\t\treturn existingMapping[0].ccpaymentUserId;\n\t\t\t}\n\n\t\t\t// Get user details from Degentalk\n\t\t\tconst userDetails = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\temail: users.email\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userDetails.length === 0) {\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\n\t\t\tconst user = userDetails[0];\n\n\t\t\t// Create CCPayment user\n\t\t\tconst ccpaymentUserId = await this.ccpaymentService.createUser({\n\t\t\t\tuid: user.id,\n\t\t\t\tname: user.username,\n\t\t\t\temail: user.email || `${user.username}@degentalk.com` // Fallback email\n\t\t\t});\n\n\t\t\t// Store the mapping\n\t\t\tawait db.insert(ccpaymentUsers).values({\n\t\t\t\tuserId: user.id,\n\t\t\t\tccpaymentUserId: ccpaymentUserId\n\t\t\t});\n\n\t\t\treturn ccpaymentUserId;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting/creating CCPayment user:', error);\n\t\t\tthrow new Error('Failed to initialize user wallet');\n\t\t}\n\t}\n\n\t/**\n\t * Get CCPayment user ID for a Degentalk user\n\t */\n\tasync getCCPaymentUserId(userId: string): Promise<string | null> {\n\t\ttry {\n\t\t\tconst mapping = await db\n\t\t\t\t.select()\n\t\t\t\t.from(ccpaymentUsers)\n\t\t\t\t.where(eq(ccpaymentUsers.userId, userId))\n\t\t\t\t.limit(1);\n\n\t\t\treturn mapping.length > 0 ? mapping[0].ccpaymentUserId : null;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting CCPayment user ID:', error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get Degentalk user ID from CCPayment user ID\n\t */\n\tasync getDegentalkUserId(ccpaymentUserId: string): Promise<string | null> {\n\t\ttry {\n\t\t\tconst mapping = await db\n\t\t\t\t.select()\n\t\t\t\t.from(ccpaymentUsers)\n\t\t\t\t.where(eq(ccpaymentUsers.ccpaymentUserId, ccpaymentUserId))\n\t\t\t\t.limit(1);\n\n\t\t\treturn mapping.length > 0 ? mapping[0].userId : null;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting Degentalk user ID:', error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Check if user has CCPayment account\n\t */\n\tasync hasCCPaymentAccount(userId: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst mapping = await db\n\t\t\t\t.select()\n\t\t\t\t.from(ccpaymentUsers)\n\t\t\t\t.where(eq(ccpaymentUsers.userId, userId))\n\t\t\t\t.limit(1);\n\n\t\t\treturn mapping.length > 0;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error checking CCPayment account:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Initialize wallet system for a user (creates CCPayment account and default wallets)\n\t */\n\tasync initializeUserWallet(userId: string): Promise<{\n\t\tccpaymentUserId: string;\n\t\twallets: Array<{\n\t\t\tcoinId: CoinId;\n\t\t\tcoinSymbol: string;\n\t\t\tchain: string;\n\t\t\taddress: string;\n\t\t}>;\n\t}> {\n\t\ttry {\n\t\t\t// Get or create CCPayment user\n\t\t\tconst ccpaymentUserId = await this.getOrCreateCCPaymentUser(userId);\n\n\t\t\t// Get supported coins for wallet creation\n\t\t\tconst supportedCoins = await this.ccpaymentService.getSupportedCoins();\n\n\t\t\t// Create wallets for major cryptocurrencies (ETH, BTC, USDT)\n\t\t\tconst primaryCoins = supportedCoins.filter((coin) =>\n\t\t\t\t['ETH', 'BTC', 'USDT'].includes(coin.coinSymbol.toUpperCase())\n\t\t\t);\n\n\t\t\tconst wallets = [];\n\t\t\tfor (const coin of primaryCoins) {\n\t\t\t\ttry {\n\t\t\t\t\tconst address = await this.ccpaymentService.createWallet({\n\t\t\t\t\t\tuid: ccpaymentUserId,\n\t\t\t\t\t\tcoinId: coin.coinId,\n\t\t\t\t\t\tchain: coin.chain\n\t\t\t\t\t});\n\n\t\t\t\t\t// Store wallet in database\n\t\t\t\t\tawait db.insert(cryptoWallets).values({\n\t\t\t\t\t\tuserId: userId,\n\t\t\t\t\t\tccpaymentUserId: ccpaymentUserId,\n\t\t\t\t\t\tcoinId: coin.coinId,\n\t\t\t\t\t\tcoinSymbol: coin.coinSymbol,\n\t\t\t\t\t\tchain: coin.chain,\n\t\t\t\t\t\taddress: address\n\t\t\t\t\t});\n\n\t\t\t\t\twallets.push({\n\t\t\t\t\t\tcoinId: coin.coinId,\n\t\t\t\t\t\tcoinSymbol: coin.coinSymbol,\n\t\t\t\t\t\tchain: coin.chain,\n\t\t\t\t\t\taddress: address\n\t\t\t\t\t});\n\t\t\t\t} catch (walletError) {\n\t\t\t\t\tlogger.error(`Error creating wallet for ${coin.coinSymbol}:`, walletError);\n\t\t\t\t\t// Continue with other wallets even if one fails\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tccpaymentUserId,\n\t\t\t\twallets\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error initializing user wallet:', error);\n\t\t\tthrow new Error('Failed to initialize wallet system');\n\t\t}\n\t}\n\n\t/**\n\t * Ensure user has all necessary wallets for supported coins\n\t */\n\tasync ensureUserWallets(userId: string, coinIds?: CoinId[]): Promise<void> {\n\t\ttry {\n\t\t\tconst ccpaymentUserId = await this.getOrCreateCCPaymentUser(userId);\n\n\t\t\t// Get all supported coins if no specific coins requested\n\t\t\tconst supportedCoins = await this.ccpaymentService.getSupportedCoins();\n\t\t\tconst targetCoins = coinIds\n\t\t\t\t? supportedCoins.filter((coin) => coinIds.includes(coin.coinId))\n\t\t\t\t: supportedCoins;\n\n\t\t\t// Check existing wallets\n\t\t\tconst existingWallets = await db\n\t\t\t\t.select()\n\t\t\t\t.from(cryptoWallets)\n\t\t\t\t.where(eq(cryptoWallets.userId, userId));\n\n\t\t\tconst existingCoinIds = existingWallets.map((w) => w.coinId);\n\n\t\t\t// Create missing wallets\n\t\t\tfor (const coin of targetCoins) {\n\t\t\t\tif (!existingCoinIds.includes(coin.coinId)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst address = await this.ccpaymentService.createWallet({\n\t\t\t\t\t\t\tuid: ccpaymentUserId,\n\t\t\t\t\t\t\tcoinId: coin.coinId,\n\t\t\t\t\t\t\tchain: coin.chain\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tawait db.insert(cryptoWallets).values({\n\t\t\t\t\t\t\tuserId: userId,\n\t\t\t\t\t\t\tccpaymentUserId: ccpaymentUserId,\n\t\t\t\t\t\t\tcoinId: coin.coinId,\n\t\t\t\t\t\t\tcoinSymbol: coin.coinSymbol,\n\t\t\t\t\t\t\tchain: coin.chain,\n\t\t\t\t\t\t\taddress: address\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (walletError) {\n\t\t\t\t\t\tlogger.error(`Error creating wallet for ${coin.coinSymbol}:`, walletError);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('Error ensuring user wallets:', error);\n\t\t\tthrow new Error('Failed to ensure user wallets');\n\t\t}\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/wallet-api-tests.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'wallet' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'z' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Wallet API Test Utility\n *\n * This file provides test functions to validate the wallet API endpoints.\n * It's intended for development use only.\n */\n\nimport axios from 'axios';\nimport { logger } from '../../core/logger';\nimport { wallet } from '../..';\nimport { z } from 'zod';\nimport { AxiosInstance } from 'axios';\n\n// Configuration\nconst API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000/api';\nconst TEST_USER_TOKEN = process.env.TEST_USER_TOKEN; // JWT token for authentication\n\n// Create axios instance with auth header\nconst api = axios.create({\n\tbaseURL: API_BASE_URL,\n\theaders: {\n\t\t'Content-Type': 'application/json',\n\t\t...(TEST_USER_TOKEN ? { Authorization: `Bearer ${TEST_USER_TOKEN}` } : {})\n\t}\n});\n\n/**\n * Colors for console output\n */\nconst colors = {\n\treset: '\\x1b[0m',\n\tbright: '\\x1b[1m',\n\tdim: '\\x1b[2m',\n\tunderscore: '\\x1b[4m',\n\tblink: '\\x1b[5m',\n\treverse: '\\x1b[7m',\n\thidden: '\\x1b[8m',\n\n\tfg: {\n\t\tblack: '\\x1b[30m',\n\t\tred: '\\x1b[31m',\n\t\tgreen: '\\x1b[32m',\n\t\tyellow: '\\x1b[33m',\n\t\tblue: '\\x1b[34m',\n\t\tmagenta: '\\x1b[35m',\n\t\tcyan: '\\x1b[36m',\n\t\twhite: '\\x1b[37m',\n\t\tcrimson: '\\x1b[38m'\n\t},\n\n\tbg: {\n\t\tblack: '\\x1b[40m',\n\t\tred: '\\x1b[41m',\n\t\tgreen: '\\x1b[42m',\n\t\tyellow: '\\x1b[43m',\n\t\tblue: '\\x1b[44m',\n\t\tmagenta: '\\x1b[45m',\n\t\tcyan: '\\x1b[46m',\n\t\twhite: '\\x1b[47m',\n\t\tcrimson: '\\x1b[48m'\n\t}\n};\n\n/**\n * Log a test step with color coding\n */\nfunction logStep(step: string, data?: any) {\n\tlogger.info(`${colors.fg.cyan}[TEST STEP]${colors.reset} ${step}`);\n\tif (data) {\n\t\tlogger.info(`${colors.dim}${JSON.stringify(data, null, 2)}${colors.reset}`);\n\t}\n}\n\n/**\n * Log a test result with color coding\n */\nfunction logResult(passed: boolean, message: string, data?: any) {\n\tconst color = passed ? colors.fg.green : colors.fg.red;\n\tconst status = passed ? 'PASSED' : 'FAILED';\n\tlogger.info(`${color}[${status}]${colors.reset} ${message}`);\n\tif (data) {\n\t\tlogger.info(`${colors.dim}${JSON.stringify(data, null, 2)}${colors.reset}`);\n\t}\n}\n\n/**\n * Test wallet balance endpoint\n */\nasync function testGetWalletBalance() {\n\ttry {\n\t\tlogStep('Testing GET /wallet/balance');\n\n\t\tconst response = await api.get('/wallet/balance');\n\t\tconst data = response.data;\n\n\t\tconst passed =\n\t\t\tresponse.status === 200 && data.success === true && typeof data.data.dgt === 'number';\n\n\t\tlogResult(passed, 'Get wallet balance', data);\n\t\treturn { passed, data };\n\t} catch (error) {\n\t\tlogResult(false, `Error: ${error.message}`, error.response?.data);\n\t\treturn { passed: false, error };\n\t}\n}\n\n/**\n * Test transaction history endpoint\n */\nasync function testGetTransactionHistory() {\n\ttry {\n\t\tlogStep('Testing GET /wallet/transactions');\n\n\t\tconst response = await api.get('/wallet/transactions?limit=5');\n\t\tconst data = response.data;\n\n\t\tconst passed =\n\t\t\tresponse.status === 200 && data.success === true && Array.isArray(data.data.transactions);\n\n\t\tlogResult(passed, 'Get transaction history', data);\n\t\treturn { passed, data };\n\t} catch (error) {\n\t\tlogResult(false, `Error: ${error.message}`, error.response?.data);\n\t\treturn { passed: false, error };\n\t}\n}\n\n/**\n * Test deposit address creation endpoint\n */\nasync function testCreateDepositAddress() {\n\ttry {\n\t\tlogStep('Testing POST /wallet/deposit-address for USDT');\n\n\t\tconst response = await api.post('/wallet/deposit-address', {\n\t\t\tcurrency: 'USDT'\n\t\t});\n\t\tconst data = response.data;\n\n\t\tconst passed =\n\t\t\tresponse.status === 200 && data.success === true && data.data.address && data.data.currency;\n\n\t\tlogResult(passed, 'Create deposit address', data);\n\t\treturn { passed, data };\n\t} catch (error) {\n\t\tlogResult(false, `Error: ${error.message}`, error.response?.data);\n\t\treturn { passed: false, error };\n\t}\n}\n\n/**\n * Test DGT purchase endpoint\n */\nasync function testProcessDgtPurchase() {\n\ttry {\n\t\tlogStep('Testing POST /wallet/purchase-dgt');\n\n\t\t// This would typically come from a completed CCPayment transaction\n\t\tconst mockPurchaseData = {\n\t\t\tcryptoAmount: 10,\n\t\t\tcryptoCurrency: 'USDT',\n\t\t\tdgtAmount: 1000, // 10 USDT = 1000 DGT at 1:100 rate\n\t\t\tccpaymentOrderId: `test-order-${Date.now()}`\n\t\t};\n\n\t\tconst response = await api.post('/wallet/purchase-dgt', mockPurchaseData);\n\t\tconst data = response.data;\n\n\t\tconst passed =\n\t\t\tresponse.status === 200 &&\n\t\t\tdata.success === true &&\n\t\t\tdata.data.transactionId &&\n\t\t\tdata.data.newBalance;\n\n\t\tlogResult(passed, 'Process DGT purchase', data);\n\t\treturn { passed, data };\n\t} catch (error) {\n\t\tlogResult(false, `Error: ${error.message}`, error.response?.data);\n\t\treturn { passed: false, error };\n\t}\n}\n\n/**\n * Test DGT transfer endpoint\n */\nasync function testTransferDGT() {\n\ttry {\n\t\tlogStep('Testing POST /wallet/transfer (DGT)');\n\n\t\t// To test this, you need another user's ID in the system\n\t\tconst recipientUserId = 2; // Adjust as needed\n\t\tconst transferData = {\n\t\t\ttoUserId: recipientUserId,\n\t\t\tamount: 10, // Small amount for testing\n\t\t\treason: 'API test transfer'\n\t\t};\n\n\t\tconst response = await api.post('/wallet/transfer', transferData);\n\t\tconst data = response.data;\n\n\t\tconst passed = response.status === 200 && data.success === true && data.data.transactionId;\n\n\t\tlogResult(passed, 'Transfer DGT', data);\n\t\treturn { passed, data };\n\t} catch (error) {\n\t\tlogResult(false, `Error: ${error.message}`, error.response?.data);\n\t\treturn { passed: false, error };\n\t}\n}\n\n/**\n * Test Tip endpoint\n */\nasync function testSendTip() {\n\ttry {\n\t\tlogStep('Testing POST /engagement/tip');\n\n\t\t// To test this, you need another user's ID in the system\n\t\tconst recipientUserId = 2; // Adjust as needed\n\t\tconst tipData = {\n\t\t\ttoUserId: recipientUserId,\n\t\t\tamount: 5, // Small amount for testing\n\t\t\tcurrency: 'DGT',\n\t\t\tsource: 'test',\n\t\t\treason: 'API test tip'\n\t\t};\n\n\t\tconst response = await api.post('/engagement/tip', tipData);\n\t\tconst data = response.data;\n\n\t\tconst passed = response.status === 200 && data.success === true && data.data.tipId;\n\n\t\tlogResult(passed, 'Send tip', data);\n\t\treturn { passed, data };\n\t} catch (error) {\n\t\tlogResult(false, `Error: ${error.message}`, error.response?.data);\n\t\treturn { passed: false, error };\n\t}\n}\n\n/**\n * Test Rain endpoint\n */\nasync function testSendRain() {\n\ttry {\n\t\tlogStep('Testing POST /engagement/rain');\n\n\t\tconst rainData = {\n\t\t\tamount: 20, // Small amount for testing\n\t\t\tcurrency: 'DGT',\n\t\t\teligibleUserCount: 3,\n\t\t\tchannel: 'general',\n\t\t\tmessage: 'API test rain'\n\t\t};\n\n\t\tconst response = await api.post('/engagement/rain', rainData);\n\t\tconst data = response.data;\n\n\t\tconst passed =\n\t\t\tresponse.status === 200 &&\n\t\t\tdata.success === true &&\n\t\t\tdata.data.transactionId &&\n\t\t\tArray.isArray(data.data.recipients);\n\n\t\tlogResult(passed, 'Send rain', data);\n\t\treturn { passed, data };\n\t} catch (error) {\n\t\tlogResult(false, `Error: ${error.message}`, error.response?.data);\n\t\treturn { passed: false, error };\n\t}\n}\n\n/**\n * Run all wallet tests\n */\nasync function runAllTests() {\n\tlogger.info(`${colors.fg.yellow}${colors.bright}===== STARTING WALLET API TESTS =====${colors.reset}\\n`);\n\n\t// Core wallet tests\n\tconst balanceResult = await testGetWalletBalance();\n\tconst transactionsResult = await testGetTransactionHistory();\n\tconst depositAddressResult = await testCreateDepositAddress();\n\tconst purchaseResult = await testProcessDgtPurchase();\n\tconst transferResult = await testTransferDGT();\n\n\t// Engagement tests\n\tconst tipResult = await testSendTip();\n\tconst rainResult = await testSendRain();\n\n\t// Summarize results\n\tconst allTests = [\n\t\t{ name: 'Get Wallet Balance', result: balanceResult },\n\t\t{ name: 'Get Transaction History', result: transactionsResult },\n\t\t{ name: 'Create Deposit Address', result: depositAddressResult },\n\t\t{ name: 'Process DGT Purchase', result: purchaseResult },\n\t\t{ name: 'Transfer DGT', result: transferResult },\n\t\t{ name: 'Send Tip', result: tipResult },\n\t\t{ name: 'Send Rain', result: rainResult }\n\t];\n\n\tlogger.info(`\\n${colors.fg.yellow}${colors.bright}===== TEST SUMMARY =====${colors.reset}`);\n\tallTests.forEach((test) => {\n\t\tconst statusColor = test.result.passed ? colors.fg.green : colors.fg.red;\n\t\tconst statusText = test.result.passed ? 'PASSED' : 'FAILED';\n\t\tlogger.info(`${statusColor}[${statusText}]${colors.reset} ${test.name}`);\n\t});\n\n\tconst passedCount = allTests.filter((test) => test.result.passed).length;\n\tlogger.info(`\\n${colors.fg.yellow}${passedCount}/${allTests.length} tests passed${colors.reset}\\n`);\n\n\treturn {\n\t\ttotalTests: allTests.length,\n\t\tpassedTests: passedCount,\n\t\tallTests\n\t};\n}\n\n// If file is executed directly, run the tests\nif (require.main === module) {\n\trunAllTests().catch((error) => logger.error('Test runner failed:', { error }));\n}\n\n// Export functions for external use\nexport {\n\ttestGetWalletBalance,\n\ttestGetTransactionHistory,\n\ttestCreateDepositAddress,\n\ttestProcessDgtPurchase,\n\ttestTransferDGT,\n\ttestSendTip,\n\ttestSendRain,\n\trunAllTests\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/wallet-config.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mergedConfig' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":304,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":304,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Wallet Configuration Service\n *\n * Manages wallet configuration with database-driven settings and caching.\n * Provides runtime config updates via admin panel.\n */\n\nimport { db } from '@db';\nimport { siteSettings } from '@schema';\nimport { eq } from 'drizzle-orm';\nimport type { WalletConfig } from '@shared/wallet.config';\nimport { walletConfig as defaultWalletConfig } from '@shared/wallet.config';\nimport { logger } from \"../../core/logger\";\n\n// Generate a simple mapping of wallet config paths for description purposes\nconst WALLET_CONFIG_KEYS = Object.keys(defaultWalletConfig).reduce(\n\t(acc, key) => {\n\t\tacc[key] = key;\n\t\treturn acc;\n\t},\n\t{} as Record<string, string>\n);\n\n/**\n * In-memory cache for wallet configuration\n */\nclass WalletConfigCache {\n\tprivate config: WalletConfig | null = null;\n\tprivate lastFetch: number = 0;\n\tprivate readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\n\tget(forceRefresh = false): WalletConfig | null {\n\t\tconst now = Date.now();\n\t\tif (forceRefresh || !this.config || now - this.lastFetch > this.CACHE_TTL) {\n\t\t\treturn null; // Cache miss or expired\n\t\t}\n\t\treturn this.config;\n\t}\n\n\tset(config: WalletConfig): void {\n\t\tthis.config = config;\n\t\tthis.lastFetch = Date.now();\n\t}\n\n\tinvalidate(): void {\n\t\tthis.config = null;\n\t\tthis.lastFetch = 0;\n\t}\n}\n\nconst configCache = new WalletConfigCache();\n\n/**\n * Wallet Configuration Service\n */\nexport class WalletConfigService {\n\t/**\n\t * Get current wallet configuration\n\t * Loads from cache, falls back to database, then defaults\n\t */\n\tasync getConfig(forceRefresh = false): Promise<WalletConfig> {\n\t\ttry {\n\t\t\t// Check cache first\n\t\t\tconst cached = configCache.get(forceRefresh);\n\t\t\tif (cached && !forceRefresh) {\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\t// Load from database\n\t\t\tconst config = await this.loadConfigFromDatabase();\n\n\t\t\t// Cache and return\n\t\t\tconfigCache.set(config);\n\t\t\treturn config;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error loading wallet config, using defaults:', error);\n\t\t\treturn this.getDefaultConfig();\n\t\t}\n\t}\n\n\t/**\n\t * Update a single wallet configuration setting (admin helper)\n\t */\n\tasync updateSetting(key: keyof typeof WALLET_CONFIG_KEYS, value: any): Promise<void> {\n\t\ttry {\n\t\t\tconst settingKey = WALLET_CONFIG_KEYS[key];\n\n\t\t\t// Update in database\n\t\t\tawait db\n\t\t\t\t.insert(siteSettings)\n\t\t\t\t.values({\n\t\t\t\t\tkey: key,\n\t\t\t\t\tvalue: JSON.stringify(value),\n\t\t\t\t\ttype: typeof value,\n\t\t\t\t\tdescription: `Wallet setting: ${settingKey}`,\n\t\t\t\t\tcategory: 'wallet',\n\t\t\t\t\tisPublic: false\n\t\t\t\t})\n\t\t\t\t.onConflictDoUpdate({\n\t\t\t\t\ttarget: siteSettings.key,\n\t\t\t\t\tset: {\n\t\t\t\t\t\tvalue: JSON.stringify(value),\n\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t// Invalidate cache\n\t\t\tconfigCache.invalidate();\n\n\t\t\tlogger.info(`Wallet config updated: ${key} = ${value}`);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error updating wallet config:', error);\n\t\t\tthrow new Error(`Failed to update wallet configuration: ${error.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Update multiple configuration settings at once\n\t */\n\tasync updateMultipleConfigs(updates: Record<string, any>): Promise<void> {\n\t\ttry {\n\t\t\t// Prepare batch updates\n\t\t\tconst settings = Object.entries(updates).map(([key, value]) => ({\n\t\t\t\tkey: key,\n\t\t\t\tvalue: JSON.stringify(value),\n\t\t\t\ttype: typeof value,\n\t\t\t\tdescription: `Wallet setting: ${WALLET_CONFIG_KEYS[key] || key}`,\n\t\t\t\tcategory: 'wallet',\n\t\t\t\tisPublic: false\n\t\t\t}));\n\n\t\t\t// Batch insert/update\n\t\t\tfor (const setting of settings) {\n\t\t\t\tawait db\n\t\t\t\t\t.insert(siteSettings)\n\t\t\t\t\t.values(setting)\n\t\t\t\t\t.onConflictDoUpdate({\n\t\t\t\t\t\ttarget: siteSettings.key,\n\t\t\t\t\t\tset: {\n\t\t\t\t\t\t\tvalue: setting.value,\n\t\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Invalidate cache\n\t\t\tconfigCache.invalidate();\n\n\t\t\tlogger.info(`Wallet config batch updated: ${Object.keys(updates).length} settings`);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error updating multiple wallet configs:', error);\n\t\t\tthrow new Error(`Failed to update wallet configurations: ${error.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Reset only defined wallet keys back to default (used by migration scripts)\n\t */\n\tasync resetToDefaultsPartial(): Promise<void> {\n\t\ttry {\n\t\t\t// Delete all wallet settings\n\t\t\tconst walletKeys = Object.keys(WALLET_CONFIG_KEYS);\n\t\t\tfor (const key of walletKeys) {\n\t\t\t\tawait db.delete(siteSettings).where(eq(siteSettings.key, key));\n\t\t\t}\n\n\t\t\t// Invalidate cache\n\t\t\tconfigCache.invalidate();\n\n\t\t\tlogger.info('Wallet config reset to defaults');\n\t\t} catch (error) {\n\t\t\tlogger.error('Error resetting wallet config:', error);\n\t\t\tthrow new Error(`Failed to reset wallet configuration: ${error.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get configuration with admin override capabilities\n\t */\n\tasync getConfigForAdmin(): Promise<{\n\t\tcurrent: WalletConfig;\n\t\tdefaults: WalletConfig;\n\t\toverrides: Record<string, any>;\n\t}> {\n\t\tconst current = await this.getConfig();\n\t\tconst defaults = this.getDefaultConfig();\n\t\tconst overrides = await this.getConfigOverrides();\n\n\t\treturn {\n\t\t\tcurrent,\n\t\t\tdefaults,\n\t\t\toverrides\n\t\t};\n\t}\n\n\t/**\n\t * Check if a specific feature is enabled\n\t */\n\tasync isFeatureEnabled(feature: keyof WalletConfig['features']): Promise<boolean> {\n\t\tconst config = await this.getConfig();\n\t\treturn config.features[feature];\n\t}\n\n\t/**\n\t * Get DGT conversion rate\n\t */\n\tasync getDGTConversionRate(): Promise<number> {\n\t\tconst config = await this.getConfig();\n\t\treturn config.dgt.usdToDGTRate;\n\t}\n\n\t/**\n\t * Get rate limits for a specific action\n\t */\n\tasync getRateLimit(action: keyof WalletConfig['limits']): Promise<number> {\n\t\tconst config = await this.getConfig();\n\t\treturn config.limits[action];\n\t}\n\n\t/**\n\t * Load configuration from database\n\t */\n\tprivate async loadConfigFromDatabase(): Promise<WalletConfig> {\n\t\tconst config = this.getDefaultConfig();\n\n\t\ttry {\n\t\t\t// Get all wallet settings from database\n\t\t\tconst walletKeys = Object.keys(WALLET_CONFIG_KEYS);\n\t\t\tconst settings = await db\n\t\t\t\t.select()\n\t\t\t\t.from(siteSettings)\n\t\t\t\t.where(eq(siteSettings.category, 'wallet'));\n\n\t\t\t// Apply database overrides\n\t\t\tfor (const setting of settings) {\n\t\t\t\tif (walletKeys.includes(setting.key)) {\n\t\t\t\t\tconst configPath = WALLET_CONFIG_KEYS[setting.key];\n\t\t\t\t\tconst value = JSON.parse(setting.value);\n\n\t\t\t\t\t// Set nested property using path\n\t\t\t\t\tthis.setNestedProperty(config, configPath, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('Error loading wallet settings from database:', error);\n\t\t\t// Return defaults if database load fails\n\t\t}\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * Get default configuration with environment overrides\n\t */\n\tprivate getDefaultConfig(): WalletConfig {\n\t\treturn defaultWalletConfig as unknown as WalletConfig;\n\t}\n\n\t/**\n\t * Get current config overrides from database\n\t */\n\tprivate async getConfigOverrides(): Promise<Record<string, any>> {\n\t\tconst overrides: Record<string, any> = {};\n\n\t\ttry {\n\t\t\tconst settings = await db\n\t\t\t\t.select()\n\t\t\t\t.from(siteSettings)\n\t\t\t\t.where(eq(siteSettings.category, 'wallet'));\n\n\t\t\tfor (const setting of settings) {\n\t\t\t\toverrides[setting.key] = JSON.parse(setting.value);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error('Error loading config overrides:', error);\n\t\t}\n\n\t\treturn overrides;\n\t}\n\n\t/**\n\t * Set nested property using dot notation path\n\t */\n\tprivate setNestedProperty(obj: any, path: string, value: any): void {\n\t\tconst keys = path.split('.');\n\t\tlet current = obj;\n\n\t\tfor (let i = 0; i < keys.length - 1; i++) {\n\t\t\tif (!(keys[i] in current)) {\n\t\t\t\tcurrent[keys[i]] = {};\n\t\t\t}\n\t\t\tcurrent = current[keys[i]];\n\t\t}\n\n\t\tcurrent[keys[keys.length - 1]] = value;\n\t}\n\n\t/**\n\t * Update full wallet configuration\n\t */\n\tasync updateConfig(newConfig: Partial<WalletConfig>): Promise<void> {\n\t\ttry {\n\t\t\t// Validate that the config contains valid settings\n\t\t\tconst mergedConfig = { ...defaultWalletConfig, ...newConfig };\n\n\t\t\t// Update each section\n\t\t\tif (newConfig.ccpayment) {\n\t\t\t\tawait this.updateMultipleConfigs({\n\t\t\t\t\t'ccpayment.autoSwapEnabled': newConfig.ccpayment.autoSwapEnabled,\n\t\t\t\t\t'ccpayment.autoWithdrawEnabled': newConfig.ccpayment.autoWithdrawEnabled,\n\t\t\t\t\t'ccpayment.testNetworkEnabled': newConfig.ccpayment.testNetworkEnabled,\n\t\t\t\t\t'ccpayment.rateLockEnabled': newConfig.ccpayment.rateLockEnabled\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (newConfig.features) {\n\t\t\t\tawait this.updateMultipleConfigs({\n\t\t\t\t\t'features.allowCryptoWithdrawals': newConfig.features.allowCryptoWithdrawals,\n\t\t\t\t\t'features.allowCryptoSwaps': newConfig.features.allowCryptoSwaps,\n\t\t\t\t\t'features.allowDGTSpending': newConfig.features.allowDGTSpending,\n\t\t\t\t\t'features.allowInternalTransfers': newConfig.features.allowInternalTransfers,\n\t\t\t\t\t'features.allowManualCredits': newConfig.features.allowManualCredits\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (newConfig.dgt) {\n\t\t\t\tawait this.updateMultipleConfigs({\n\t\t\t\t\t'dgt.usdPrice': newConfig.dgt.usdPrice,\n\t\t\t\t\t'dgt.usdToDGTRate': newConfig.dgt.usdToDGTRate,\n\t\t\t\t\t'dgt.minDepositUSD': newConfig.dgt.minDepositUSD,\n\t\t\t\t\t'dgt.maxDGTBalance': newConfig.dgt.maxDGTBalance\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (newConfig.limits) {\n\t\t\t\tawait this.updateMultipleConfigs({\n\t\t\t\t\t'limits.depositsPerHour': newConfig.limits.depositsPerHour,\n\t\t\t\t\t'limits.tipsPerMinute': newConfig.limits.tipsPerMinute,\n\t\t\t\t\t'limits.maxDGTTransfer': newConfig.limits.maxDGTTransfer,\n\t\t\t\t\t'limits.maxDailyCreditAmount': newConfig.limits.maxDailyCreditAmount\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlogger.info('Wallet configuration updated successfully');\n\t\t} catch (error) {\n\t\t\tlogger.error('Error updating wallet config:', error);\n\t\t\tthrow new Error(`Failed to update wallet configuration: ${error.message}`);\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const walletConfigService = new WalletConfigService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/wallet.constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/wallet.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":21,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'z' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":25,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DGT_CURRENCY' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":29,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'amount' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":587,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":587,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'authenticatedUserId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":592,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":592,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { UserId } from '@shared/types/ids';\nimport { EconomyTransformer } from '../economy/transformers/economy.transformer';\n/**\n * Wallet Controller\n *\n * [REFAC-WALLET]\n *\n * This controller handles wallet-related API requests, orchestrating\n * between DGT services and CCPayment services as needed.\n */\n\nimport type { Request, Response } from 'express';\nimport { BaseController, ValidationError, NotFoundError } from '../../core/base-controller';\nimport type { TypedRequest, ApiResponse } from '@shared/types/api.types';\nimport { logger } from '../../core/logger';\nimport { dgtService } from './dgt.service';\nimport { ccpaymentService, type CryptoBalance } from './ccpayment.service'; // Import instance and CryptoBalance type\n// import { TransactionService } from '../transactions/transaction.service'; // Ensure this is commented or removed\nimport { db } from '@db';\nimport { users, dgtPurchaseOrders, transactions, transactionTypeEnum, dgtPackages } from '@schema';\nimport { eq, desc, and, sql, SQL, asc } from 'drizzle-orm';\nimport { WalletError, ErrorCodes as WalletErrorCodes } from '../../core/errors';\nimport crypto from 'crypto';\nimport { z } from 'zod';\nimport type { OrderId } from '@shared/types/ids';\nimport { UnauthorizedError } from '../../core/errors';\n// import { validateRequest } from '../../middleware/validate'; // Ensure this is commented or removed\nimport { DGT_CURRENCY, DEFAULT_DGT_REWARD_CREATE_THREAD } from './wallet.constants';\nimport { walletService } from './wallet.service';\nimport { walletConfig } from '@shared/wallet.config';\n\n/**\n * Wallet controller for handling wallet-related requests\n */\nexport class WalletController extends BaseController {\n\t/**\n\t * Get user's combined wallet balance (DGT and crypto)\n\t */\n\tasync getBalance(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\t// Get authenticated user ID with type safety\n\t\t\tconst authUser = userService.getUserFromRequest(req);\n\t\t\tif (!authUser || !authUser.id) {\n\t\t\t\tthrow new UnauthorizedError('User not authenticated');\n\t\t\t}\n\t\t\tconst userId = authUser.id;\n\n\t\t\tlogger.info('WALLET_CONTROLLER', `Getting DGT balance for user ID: ${userId}`);\n\n\t\t\tconst dgtBalance = await dgtService.getUserBalance(userId); // Used instance dgtService\n\n\t\t\tlogger.info(\n\t\t\t\t'WALLET_CONTROLLER',\n\t\t\t\t`Successfully retrieved DGT balance: ${dgtBalance} for user ID: ${userId}`\n\t\t\t);\n\n\t\t\t// WALLET FINALIZATION ON HOLD: CCPayment integration temporarily disabled.\n\t\t\t// const [user] = await db\n\t\t\t//   .select({ ccpaymentAccountId: users.ccpaymentAccountId })\n\t\t\t//   .from(users)\n\t\t\t//   .where(eq(users.id, userId))\n\t\t\t//   .execute(); // Ensure .execute() is called\n\n\t\t\tconst cryptoBalances: CryptoBalance[] = []; // Return empty crypto balances for now, explicitly typed\n\n\t\t\t// if (user?.ccpaymentAccountId) {\n\t\t\t//   cryptoBalances = await ccpaymentService.getUserCryptoBalances(user.ccpaymentAccountId);\n\t\t\t// } else {\n\t\t\t//   const ccpaymentAccountId = await ccpaymentService.createCcPaymentWalletForUser(userId);\n\t\t\t//   await db\n\t\t\t//     .update(users)\n\t\t\t//     .set({ ccpaymentAccountId })\n\t\t\t//     .where(eq(users.id, userId))\n\t\t\t//     .execute(); // Ensure .execute() is called\n\t\t\t//   cryptoBalances = await ccpaymentService.getUserCryptoBalances(ccpaymentAccountId);\n\t\t\t// }\n\n\t\t\treturn this.success(\n\t\t\t\tres,\n\t\t\t\t{\n\t\t\t\t\tdgt: Number(dgtBalance),\n\t\t\t\t\tcrypto: cryptoBalances\n\t\t\t\t},\n\t\t\t\t'Balance retrieved successfully'\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error(\n\t\t\t\t'WALLET_CONTROLLER',\n\t\t\t\t`Error getting wallet balance: ${errorMessage}. Details: ${error instanceof Error ? error.stack : String(error)}`,\n\t\t\t\t{ stack: error instanceof Error ? error.stack : undefined, errorObj: error }\n\t\t\t);\n\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tres.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to get wallet balance',\n\t\t\t\tcode: WalletErrorCodes.UNKNOWN_ERROR\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * Get transaction history\n\t */\n\tasync getTransactionHistory(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\t// Use authenticated user ID if available, otherwise default to dev user ID 2\n\t\t\tconst authUserId = (userService.getUserFromRequest(req) as any)?.id;\n\t\t\tconst userId = authUserId || 2 as UserId; // Default to user ID 2 if no authenticated user\n\n\t\t\tconst page = parseInt(req.query.page as string) || 1;\n\t\t\tconst limit = parseInt(req.query.limit as string) || 10;\n\t\t\tconst offset = (page - 1) * limit;\n\t\t\tconst currencyFilter = req.query.currency as string;\n\t\t\tconst typeFilter = req.query.type as string;\n\n\t\t\t// Build query\n\t\t\tconst conditions: SQL[] = [eq(transactions.userId, userId)];\n\n\t\t\tif (currencyFilter) {\n\t\t\t\t// TODO: transactions table does not have a 'currency' column.\n\t\t\t\t// This filter needs to be re-evaluated or removed.\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'WALLET_CONTROLLER',\n\t\t\t\t\t`Currency filter ignored: transactions table has no currency column. Filter was: ${currencyFilter}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (typeFilter) {\n\t\t\t\tconst validTransactionTypes = transactionTypeEnum.enumValues;\n\t\t\t\tif (\n\t\t\t\t\tvalidTransactionTypes.includes(\n\t\t\t\t\t\ttypeFilter as (typeof transactionTypeEnum.enumValues)[number]\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tconditions.push(\n\t\t\t\t\t\teq(transactions.type, typeFilter as (typeof transactionTypeEnum.enumValues)[number])\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t'WALLET_CONTROLLER',\n\t\t\t\t\t\t'Invalid transaction type filter provided: %s. Ignoring filter.',\n\t\t\t\t\t\ttypeFilter\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst txHistory = await db\n\t\t\t\t.select()\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(and(...conditions))\n\t\t\t\t.orderBy(desc(transactions.createdAt))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\t// Get total count for pagination\n\t\t\tconst [countResult] = await db\n\t\t\t\t.select({ count: sql<number>`count(*)` })\n\t\t\t\t.from(transactions)\n\t\t\t\t.where(and(...conditions));\n\n\t\t\t// Transform transactions using EconomyTransformer for enhanced history view\n\t\t\tconst requestingUser = userService.getUserFromRequest(req);\n\t\t\t\n\t\t\t// Prepare filters for enhanced transaction history\n\t\t\tconst historyFilters: any = {};\n\t\t\t\n\t\t\tif (currencyFilter === 'DGT') {\n\t\t\t\thistoryFilters.categories = ['social', 'shopping', 'earning', 'system'];\n\t\t\t}\n\t\t\t\n\t\t\tif (typeFilter) {\n\t\t\t\t// Map frontend type filter to backend categories\n\t\t\t\tconst typeMap: Record<string, string[]> = {\n\t\t\t\t\t'tips': ['social'],\n\t\t\t\t\t'purchases': ['shopping'],\n\t\t\t\t\t'deposits': ['wallet'],\n\t\t\t\t\t'rewards': ['earning'],\n\t\t\t\t\t'admin': ['system']\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tif (typeMap[typeFilter]) {\n\t\t\t\t\thistoryFilters.categories = typeMap[typeFilter];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Use enhanced transaction history transformer\n\t\t\tconst { transactions: transformedTransactions, summary } = EconomyTransformer.toTransactionHistory(\n\t\t\t\ttxHistory,\n\t\t\t\trequestingUser,\n\t\t\t\thistoryFilters\n\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\ttransactions: transformedTransactions,\n\t\t\t\tsummary,\n\t\t\t\ttotal: countResult?.count || 0,\n\t\t\t\tpage,\n\t\t\t\tlimit,\n\t\t\t\tfilters: {\n\t\t\t\t\tcurrency: currencyFilter,\n\t\t\t\t\ttype: typeFilter,\n\t\t\t\t\tenhanced: true // Flag to indicate enhanced history format\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error(\n\t\t\t\t'WALLET_CONTROLLER',\n\t\t\t\t`Error getting transaction history: ${errorMessage}. Details: ${error instanceof Error ? error.stack : String(error)}`,\n\t\t\t\t{ stack: error instanceof Error ? error.stack : undefined, errorObj: error }\n\t\t\t);\n\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tres.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to get transaction history',\n\t\t\t\tcode: WalletErrorCodes.UNKNOWN_ERROR\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * Create a deposit address for crypto\n\t */\n\tasync createDepositAddress(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'WALLET_CONTROLLER',\n\t\t\t\t\t`Attempt to access createDepositAddress without authentication. Request details: path ${req.path}, ip ${req.ip}`\n\t\t\t\t);\n\t\t\t\treturn res\n\t\t\t\t\t.status(401)\n\t\t\t\t\t.json({ error: 'User not authenticated', code: WalletErrorCodes.UNAUTHORIZED });\n\t\t\t}\n\t\t\tconst userId = (userService.getUserFromRequest(req) as { id: UserId }).id; // Explicit cast after check\n\t\t\tconst { currency } = req.body;\n\n\t\t\tif (!currency) {\n\t\t\t\tres.status(400).json({\n\t\t\t\t\terror: 'Currency is required',\n\t\t\t\t\tcode: WalletErrorCodes.INVALID_REQUEST\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Check if deposits are enabled\n\t\t\tif (!walletConfig.DEPOSITS_ENABLED) {\n\t\t\t\tres.status(501).json({\n\t\t\t\t\tmessage: 'Crypto deposits are temporarily disabled.',\n\t\t\t\t\tcode: 'SERVICE_UNAVAILABLE'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ensure user has CCPayment wallet\n\t\t\tconst ccpaymentAccountId = await walletService.ensureCcPaymentWallet(userId);\n\n\t\t\t// Create deposit address\n\t\t\tconst depositAddress = await ccpaymentService.createDepositAddress(\n\t\t\t\tccpaymentAccountId,\n\t\t\t\tcurrency\n\t\t\t);\n\n\t\t\tlogger.info('WALLET_CONTROLLER', 'Created deposit address', {\n\t\t\t\tuserId,\n\t\t\t\tcurrency,\n\t\t\t\taddress: depositAddress.address\n\t\t\t});\n\n\t\t\tres.json(depositAddress);\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error(\n\t\t\t\t'WALLET_CONTROLLER',\n\t\t\t\t`Error creating deposit address: ${errorMessage}. Details: ${error instanceof Error ? error.stack : String(error)}`,\n\t\t\t\t{ stack: error instanceof Error ? error.stack : undefined, errorObj: error }\n\t\t\t);\n\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tres.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to create deposit address',\n\t\t\t\tcode: WalletErrorCodes.UNKNOWN_ERROR\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * Create a DGT purchase order\n\t */\n\tasync createDgtPurchase(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'WALLET_CONTROLLER',\n\t\t\t\t\t`Attempt to access createDgtPurchase without authentication. Request details: path ${req.path}, ip ${req.ip}`\n\t\t\t\t);\n\t\t\t\treturn res\n\t\t\t\t\t.status(401)\n\t\t\t\t\t.json({ error: 'User not authenticated', code: WalletErrorCodes.UNAUTHORIZED });\n\t\t\t}\n\t\t\tconst userId = (userService.getUserFromRequest(req) as { id: UserId }).id; // Explicit cast after check\n\t\t\tconst { dgtAmount, cryptoCurrency } = req.body;\n\n\t\t\tif (!dgtAmount || !cryptoCurrency) {\n\t\t\t\tres.status(400).json({\n\t\t\t\t\terror: 'DGT amount and crypto currency are required',\n\t\t\t\t\tcode: WalletErrorCodes.INVALID_REQUEST\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate crypto amount based on configured DGT price in USD\n\t\t\tconst cryptoAmount = parseFloat(dgtAmount) * walletConfig.DGT.PRICE_USD;\n\n\t\t\t// Generate order reference\n\t\t\tconst orderId = `dgt_${userId}_${Date.now()}`;\n\n\t\t\t// Create purchase order in database\n\t\t\tconst [purchaseOrder] = await db\n\t\t\t\t.insert(dgtPurchaseOrders)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\tdgtAmount: BigInt(Math.floor(parseFloat(dgtAmount) * 100000000)), // Convert to smallest unit\n\t\t\t\t\tcryptoAmount: cryptoAmount.toString(),\n\t\t\t\t\tcryptoCurrency,\n\t\t\t\t\tccpaymentReference: orderId,\n\t\t\t\t\tstatus: 'pending',\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Create deposit link via CCPayment\n\t\t\tconst depositUrl = await ccpaymentService.createDepositLink({\n\t\t\t\tamount: cryptoAmount,\n\t\t\t\tcurrency: cryptoCurrency,\n\t\t\t\torderId: orderId,\n\t\t\t\tproductName: `${dgtAmount} DGT Tokens`,\n\t\t\t\tredirectUrl: `${process.env.FRONTEND_URL || 'http://localhost:5173'}/wallet/purchase-success?orderId=${purchaseOrder.id}`,\n\t\t\t\tnotifyUrl: `${process.env.API_URL || 'http://localhost:5001'}/api/webhook/ccpayment`\n\t\t\t});\n\n\t\t\tlogger.info('WALLET_CONTROLLER', 'Created DGT purchase order', {\n\t\t\t\tuserId,\n\t\t\t\torderId: purchaseOrder.id,\n\t\t\t\tdgtAmount,\n\t\t\t\tcryptoAmount\n\t\t\t});\n\n\t\t\tres.json({\n\t\t\t\torderId: purchaseOrder.id,\n\t\t\t\tdepositUrl,\n\t\t\t\tdgtAmount,\n\t\t\t\tcryptoAmount,\n\t\t\t\tcryptoCurrency,\n\t\t\t\tstatus: 'pending'\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error('WALLET_CONTROLLER', `Error creating DGT purchase order: ${errorMessage}`, {\n\t\t\t\tdetails: { stack: error instanceof Error ? error.stack : undefined, errorObj: error }\n\t\t\t});\n\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tres.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to create DGT purchase order',\n\t\t\t\tcode: WalletErrorCodes.UNKNOWN_ERROR\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * Get DGT purchase order status\n\t */\n\tasync getPurchaseOrderStatus(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'Attempt to access getPurchaseOrderStatus without authentication. Request details: path %s, ip %s',\n\t\t\t\t\treq.path,\n\t\t\t\t\treq.ip\n\t\t\t\t);\n\t\t\t\treturn res\n\t\t\t\t\t.status(401)\n\t\t\t\t\t.json({ error: 'User not authenticated', code: WalletErrorCodes.UNAUTHORIZED });\n\t\t\t}\n\t\t\tconst userId = (userService.getUserFromRequest(req) as { id: UserId }).id; // Explicit cast after check\n\t\t\tconst orderId = req.params.orderId as OrderId;\n\n\t\t\tif (!orderId) {\n\t\t\t\tres.status(400).json({\n\t\t\t\t\terror: 'Invalid order ID',\n\t\t\t\t\tcode: WalletErrorCodes.INVALID_REQUEST\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get purchase order\n\t\t\tconst [purchaseOrder] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(dgtPurchaseOrders)\n\t\t\t\t.where(and(eq(dgtPurchaseOrders.id, orderId), eq(dgtPurchaseOrders.userId, userId)))\n\t\t\t\t.limit(1);\n\n\t\t\tif (!purchaseOrder) {\n\t\t\t\tres.status(404).json({\n\t\t\t\t\terror: 'Purchase order not found',\n\t\t\t\t\tcode: WalletErrorCodes.NOT_FOUND\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tres.json(purchaseOrder);\n\t\t\treturn;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error('Error getting purchase order status: %s. Details: %o', errorMessage, {\n\t\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t\t\terrorObj: error\n\t\t\t});\n\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tres.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to get purchase order status',\n\t\t\t\tcode: WalletErrorCodes.UNKNOWN_ERROR\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * Transfer DGT to another user\n\t */\n\tasync transferDgt(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'Attempt to access transferDgt without authentication. Request details: path %s, ip %s',\n\t\t\t\t\treq.path,\n\t\t\t\t\treq.ip\n\t\t\t\t);\n\t\t\t\treturn res\n\t\t\t\t\t.status(401)\n\t\t\t\t\t.json({ error: 'User not authenticated', code: WalletErrorCodes.UNAUTHORIZED });\n\t\t\t}\n\t\t\tconst userId = (userService.getUserFromRequest(req) as { id: UserId }).id; // Explicit cast after check\n\t\t\tconst { toUserId, amount, reason } = req.body;\n\n\t\t\tif (!toUserId || !amount) {\n\t\t\t\tres.status(400).json({\n\t\t\t\t\terror: 'Recipient ID and amount are required',\n\t\t\t\t\tcode: WalletErrorCodes.INVALID_REQUEST\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Transfer DGT\n\t\t\tconst result = await dgtService.transferDgt(\n\t\t\t\t// Used instance dgtService\n\t\t\t\tuserId,\n\t\t\t\ttoUserId,\n\t\t\t\tBigInt(amount),\n\t\t\t\t'TIP',\n\t\t\t\t{ reason }\n\t\t\t);\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tsenderNewBalance: Number(result.senderBalance),\n\t\t\t\trecipientNewBalance: Number(result.recipientBalance)\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error('Error transferring DGT: %s. Details: %o', errorMessage, {\n\t\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t\t\terrorObj: error\n\t\t\t});\n\n\t\t\tif (error instanceof WalletError) {\n\t\t\t\tres.status(error.httpStatus).json({\n\t\t\t\t\terror: error.message,\n\t\t\t\t\tcode: error.code\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to transfer DGT',\n\t\t\t\tcode: WalletErrorCodes.UNKNOWN_ERROR\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * Get supported cryptocurrencies\n\t */\n\tasync getSupportedCurrencies(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\t// In production, this would fetch from CCPayment API or config\n\t\t\t// For now, return a static list\n\t\t\tres.json([\n\t\t\t\t{\n\t\t\t\t\tcode: 'BTC',\n\t\t\t\t\tname: 'Bitcoin',\n\t\t\t\t\tnetworks: ['BTC'],\n\t\t\t\t\tisEnabled: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcode: 'ETH',\n\t\t\t\t\tname: 'Ethereum',\n\t\t\t\t\tnetworks: ['ETH'],\n\t\t\t\t\tisEnabled: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcode: 'USDT',\n\t\t\t\t\tname: 'Tether',\n\t\t\t\t\tnetworks: ['TRC20', 'ERC20'],\n\t\t\t\t\tisEnabled: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcode: 'USDC',\n\t\t\t\t\tname: 'USD Coin',\n\t\t\t\t\tnetworks: ['ERC20'],\n\t\t\t\t\tisEnabled: true\n\t\t\t\t}\n\t\t\t]);\n\t\t\treturn;\n\t\t} catch (error) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\t\tlogger.error('WALLET_CONTROLLER', `Error getting supported currencies: ${errorMessage}`, {\n\t\t\t\tdetails: { stack: error instanceof Error ? error.stack : undefined, errorObj: error }\n\t\t\t});\n\n\t\t\tres.status(500).json({\n\t\t\t\terror: 'Failed to get supported currencies',\n\t\t\t\tcode: WalletErrorCodes.UNKNOWN_ERROR\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t}\n\n\tasync createDgtRewardTransaction(req: Request, res: Response) {\n\t\ttry {\n\t\t\tconst {\n\t\t\t\tuserId,\n\t\t\t\tamount, // Amount will come from config or a default value\n\t\t\t\treason = 'Thread creation reward',\n\t\t\t\trelatedEntityId,\n\t\t\t\tcontext = 'create_thread'\n\t\t\t} = req.body;\n\t\t\tconst authenticatedUserId = (req as any).user?.id;\n\n\t\t\tif (!userId) {\n\t\t\t\treturn res.status(400).json({ error: 'User ID is required.' });\n\t\t\t}\n\t\t\t// entityId might be optional depending on context\n\n\t\t\t// Optional: Validate that authenticatedUserId matches userId or is an admin\n\t\t\t// if (userId !== authenticatedUserId && !(req as any).user?.isAdmin) {\n\t\t\t//   return res.status(403).json({ error: 'Forbidden: Cannot create reward transaction for another user.'});\n\t\t\t// }\n\n\t\t\t// Use a configured amount or a default. Client sends placeholder, backend decides true amount.\n\t\t\tconst dgtAmountToAward =\n\t\t\t\tNumber(process.env.DGT_REWARD_CREATE_THREAD) || DEFAULT_DGT_REWARD_CREATE_THREAD;\n\n\t\t\tif (dgtAmountToAward <= 0) {\n\t\t\t\tlogger.info(\n\t\t\t\t\t'DGT_CONTROLLER',\n\t\t\t\t\t`DGT reward for '${context}' is zero or negative. No transaction created for user ${userId}.`\n\t\t\t\t);\n\t\t\t\treturn res.status(200).json({ dgtAwarded: 0, message: 'DGT reward for action is zero.' });\n\t\t\t}\n\n\t\t\t// Use dgtService to handle the DGT addition and transaction logging\n\t\t\t// The dgtService.addDgt method should internally handle:\n\t\t\t// 1. Updating users.dgtWalletBalance\n\t\t\t// 2. Inserting into the transactionsSchema table\n\t\t\tconst newBalance = await dgtService.addDgt(\n\t\t\t\tuserId as UserId,\n\t\t\t\tBigInt(dgtAmountToAward),\n\t\t\t\t'REWARD', // DgtTransactionType\n\t\t\t\t{\n\t\t\t\t\treason,\n\t\t\t\t\trelatedEntityId,\n\t\t\t\t\tcontext,\n\t\t\t\t\tsource: 'system_reward'\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tres.status(200).json({\n\t\t\t\tdgtAwarded: dgtAmountToAward,\n\t\t\t\tnewBalance: newBalance.toString() // dgtService returns bigint\n\t\t\t});\n\t\t} catch (err: any) {\n\t\t\tlogger.error(\n\t\t\t\t'DGT_CONTROLLER',\n\t\t\t\t`Error in createDgtRewardTransaction for context '${req.body.context}':`,\n\t\t\t\terr\n\t\t\t);\n\t\t\tres.status(500).json({ error: err.message || 'Server error creating DGT transaction.' });\n\t\t}\n\t}\n\n\tasync listPackages(_req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tconst packages = await db\n\t\t\t\t.select()\n\t\t\t\t.from(dgtPackages)\n\t\t\t\t.where(eq(dgtPackages.isActive, true))\n\t\t\t\t.orderBy(asc(dgtPackages.sortOrder), asc(dgtPackages.id));\n\t\t\tres.json(packages);\n\t\t} catch (error) {\n\t\t\tlogger.error('WALLET_CONTROLLER', 'Error listing DGT packages', error);\n\t\t\tres.status(500).json({ error: 'Failed to list packages' });\n\t\t}\n\t}\n\n\tasync createPurchaseOrder(req: Request, res: Response): Promise<void> {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req))\n\t\t\t\treturn res.status(401).json({ error: 'Unauthenticated' });\n\t\t\tconst userId = (userService.getUserFromRequest(req) as { id: UserId }).id;\n\t\t\tconst { packageId, cryptoCurrency = 'USDT' } = req.body;\n\n\t\t\tif (!packageId) return res.status(400).json({ error: 'packageId is required' });\n\n\t\t\tconst [pkg] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(dgtPackages)\n\t\t\t\t.where(eq(dgtPackages.id, packageId));\n\t\t\tif (!pkg || !pkg.isActive) return res.status(404).json({ error: 'Package not found' });\n\n\t\t\t// Generate merchant order id\n\t\t\tconst merchantOrderId = `pkg_${pkg.id}_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;\n\n\t\t\t// Create CCPayment deposit link\n\t\t\tconst depositUrl = await ccpaymentService.createDepositLink({\n\t\t\t\tamount: Number(pkg.usdPrice),\n\t\t\t\tcurrency: cryptoCurrency,\n\t\t\t\torderId: merchantOrderId,\n\t\t\t\tproductName: pkg.name,\n\t\t\t\tredirectUrl: process.env.CCPAYMENT_REDIRECT_URL || 'https://degentalk.com/wallet',\n\t\t\t\tnotifyUrl: process.env.CCPAYMENT_NOTIFY_URL || 'https://degentalk.com/api/ccpayment/webhook'\n\t\t\t});\n\n\t\t\t// Insert purchase order\n\t\t\tconst [order] = await db\n\t\t\t\t.insert(dgtPurchaseOrders)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\tdgtAmountRequested: pkg.dgtAmount,\n\t\t\t\t\tcryptoAmountExpected: pkg.usdPrice,\n\t\t\t\t\tcryptoCurrencyExpected: cryptoCurrency,\n\t\t\t\t\tccpaymentReference: merchantOrderId,\n\t\t\t\t\tstatus: 'pending'\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\tres.status(201).json({ order, depositUrl });\n\t\t} catch (error) {\n\t\t\tlogger.error('WALLET_CONTROLLER', 'Error creating purchase order', error);\n\t\t\tres.status(500).json({ error: 'Failed to create purchase order' });\n\t\t}\n\t}\n}\n\n// Export a singleton instance\nexport const walletController = new WalletController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/wallet.dev.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/wallet.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/wallet.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'wallets' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport {\n\tcryptoWallets,\n\tdepositRecords,\n\twithdrawalRecords,\n\tinternalTransfers,\n\tswapRecords,\n\tsupportedTokens,\n\twallets\n} from '@schema';\nimport { eq, and, desc, or } from 'drizzle-orm';\nimport { CCPaymentService } from './ccpayment.service';\nimport { UserManagementService } from './user-management.service';\nimport { walletConfigService } from './wallet-config.service';\nimport { dgtService } from './dgt.service';\nimport type { CoinId, ActionId, UserId, DgtAmount, UsdAmount } from '@shared/types/ids';\nimport { logger } from \"../../core/logger\";\nimport { EconomyTransformer } from '../economy/transformers/economy.transformer';\n\n/**\n * High-level Wallet Service\n *\n * Provides wallet operations for Degentalk users, abstracting away CCPayment complexity.\n */\nexport class WalletService {\n\tprivate ccpaymentService: CCPaymentService;\n\tprivate userManagementService: UserManagementService;\n\n\tconstructor() {\n\t\tthis.ccpaymentService = new CCPaymentService();\n\t\tthis.userManagementService = new UserManagementService();\n\t}\n\n\t/**\n\t * Get user's wallet balances (includes DGT and crypto)\n\t */\n\tasync getUserBalances(userId: UserId): Promise<{\n\t\tdgt: {\n\t\t\tbalance: number;\n\t\t\tlastTransactionAt: Date | null;\n\t\t};\n\t\tcrypto: Array<{\n\t\t\tcoinId: CoinId;\n\t\t\tcoinSymbol: string;\n\t\t\tchain: string;\n\t\t\tbalance: string;\n\t\t\tfrozenBalance: string;\n\t\t\taddress: string;\n\t\t}>;\n\t}> {\n\t\ttry {\n\t\t\t// Get DGT balance (always available)\n\t\t\tconst dgtBalance = await dgtService.getDGTBalance(userId);\n\n\t\t\t// Get crypto balances (if user has CCPayment account)\n\t\t\tconst cryptoBalances = [];\n\t\t\tconst ccpaymentUserId = await this.userManagementService.getCCPaymentUserId(userId);\n\n\t\t\tif (ccpaymentUserId) {\n\t\t\t\t// Get user's wallets from database\n\t\t\t\tconst userWallets = await db\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(cryptoWallets)\n\t\t\t\t\t.where(eq(cryptoWallets.userId, userId));\n\n\t\t\t\t// Get balances from CCPayment for each wallet\n\t\t\t\tfor (const wallet of userWallets) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst balance = await this.ccpaymentService.getBalance({\n\t\t\t\t\t\t\tuid: ccpaymentUserId,\n\t\t\t\t\t\t\tcoinId: wallet.coinId\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tcryptoBalances.push({\n\t\t\t\t\t\t\tcoinId: wallet.coinId,\n\t\t\t\t\t\t\tcoinSymbol: wallet.coinSymbol,\n\t\t\t\t\t\t\tchain: wallet.chain,\n\t\t\t\t\t\t\tbalance: balance.balance,\n\t\t\t\t\t\t\tfrozenBalance: balance.frozenBalance,\n\t\t\t\t\t\t\taddress: wallet.address\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogger.error(`Error getting balance for ${wallet.coinSymbol}:`, error);\n\t\t\t\t\t\t// Include wallet with zero balance if API call fails\n\t\t\t\t\t\tcryptoBalances.push({\n\t\t\t\t\t\t\tcoinId: wallet.coinId,\n\t\t\t\t\t\t\tcoinSymbol: wallet.coinSymbol,\n\t\t\t\t\t\t\tchain: wallet.chain,\n\t\t\t\t\t\t\tbalance: '0',\n\t\t\t\t\t\t\tfrozenBalance: '0',\n\t\t\t\t\t\t\taddress: wallet.address\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Transform DGT balance for consistent response format\n\t\t\tconst transformedDgtBalance = dgtBalance.balance as number;\n\n\t\t\treturn {\n\t\t\t\tdgt: {\n\t\t\t\t\tbalance: transformedDgtBalance,\n\t\t\t\t\tlastTransactionAt: dgtBalance.lastTransactionAt\n\t\t\t\t},\n\t\t\t\tcrypto: cryptoBalances\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting user balances:', error);\n\t\t\tthrow new Error('Failed to retrieve wallet balances');\n\t\t}\n\t}\n\n\t/**\n\t * Get user's deposit addresses\n\t */\n\tasync getUserDepositAddresses(userId: UserId): Promise<\n\t\tArray<{\n\t\t\tcoinId: CoinId;\n\t\t\tcoinSymbol: string;\n\t\t\tchain: string;\n\t\t\taddress: string;\n\t\t\tmemo?: string;\n\t\t}>\n\t> {\n\t\ttry {\n\t\t\tawait this.userManagementService.ensureUserWallets(userId);\n\n\t\t\tconst wallets = await db.select().from(cryptoWallets).where(eq(cryptoWallets.userId, userId));\n\n\t\t\treturn wallets.map((wallet) => ({\n\t\t\t\tcoinId: wallet.coinId,\n\t\t\t\tcoinSymbol: wallet.coinSymbol,\n\t\t\t\tchain: wallet.chain,\n\t\t\t\taddress: wallet.address,\n\t\t\t\tmemo: wallet.memo || undefined\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting deposit addresses:', error);\n\t\t\tthrow new Error('Failed to retrieve deposit addresses');\n\t\t}\n\t}\n\n\t/**\n\t * Initiate withdrawal to blockchain\n\t */\n\tasync withdrawToBlockchain(\n\t\tuserId: UserId,\n\t\tparams: {\n\t\t\tcoinId: CoinId;\n\t\t\tamount: string;\n\t\t\ttoAddress: string;\n\t\t\tmemo?: string;\n\t\t}\n\t): Promise<string> {\n\t\ttry {\n\t\t\t// Check if crypto withdrawals are allowed\n\t\t\tconst config = await walletConfigService.getConfig();\n\t\t\tif (!config.features.allowCryptoWithdrawals) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Crypto withdrawals are currently disabled. Please use DGT for transactions.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst ccpaymentUserId = await this.userManagementService.getOrCreateCCPaymentUser(userId);\n\n\t\t\tconst recordId = await this.ccpaymentService.withdrawToBlockchain({\n\t\t\t\tuid: ccpaymentUserId,\n\t\t\t\tcoinId: params.coinId,\n\t\t\t\tamount: params.amount,\n\t\t\t\ttoAddress: params.toAddress,\n\t\t\t\tmemo: params.memo\n\t\t\t});\n\n\t\t\t// Store withdrawal record\n\t\t\tawait db.insert(withdrawalRecords).values({\n\t\t\t\tuserId: userId,\n\t\t\t\trecordId: recordId,\n\t\t\t\tcoinId: params.coinId,\n\t\t\t\tcoinSymbol: '', // Will be populated by webhook\n\t\t\t\tchain: '', // Will be populated by webhook\n\t\t\t\tamount: params.amount,\n\t\t\t\ttoAddress: params.toAddress,\n\t\t\t\ttoMemo: params.memo,\n\t\t\t\twithdrawType: 'blockchain',\n\t\t\t\tstatus: 'Processing'\n\t\t\t});\n\n\t\t\treturn recordId;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error initiating blockchain withdrawal:', error);\n\t\t\tthrow new Error('Failed to initiate withdrawal');\n\t\t}\n\t}\n\n\t/**\n\t * Transfer to another CCPayment user (internal transfer)\n\t */\n\tasync transferToUser(\n\t\tfromUserId: UserId,\n\t\tparams: {\n\t\t\ttoUserId: UserId;\n\t\t\tcoinId: CoinId;\n\t\t\tamount: string;\n\t\t\tnote?: string;\n\t\t}\n\t): Promise<string> {\n\t\ttry {\n\t\t\t// Check if internal transfers are allowed\n\t\t\tconst config = await walletConfigService.getConfig();\n\t\t\tif (!config.features.allowInternalTransfers) {\n\t\t\t\tthrow new Error('Internal transfers are currently disabled.');\n\t\t\t}\n\n\t\t\tconst fromCCPaymentUserId =\n\t\t\t\tawait this.userManagementService.getOrCreateCCPaymentUser(fromUserId);\n\t\t\tconst toCCPaymentUserId = await this.userManagementService.getOrCreateCCPaymentUser(\n\t\t\t\tparams.toUserId\n\t\t\t);\n\n\t\t\tconst recordId = await this.ccpaymentService.internalTransfer({\n\t\t\t\tfromUid: fromCCPaymentUserId,\n\t\t\t\ttoUid: toCCPaymentUserId,\n\t\t\t\tcoinId: params.coinId,\n\t\t\t\tamount: params.amount\n\t\t\t});\n\n\t\t\t// Store transfer record\n\t\t\tawait db.insert(internalTransfers).values({\n\t\t\t\tfromUserId: fromUserId,\n\t\t\t\ttoUserId: params.toUserId,\n\t\t\t\trecordId: recordId,\n\t\t\t\tcoinId: params.coinId,\n\t\t\t\tcoinSymbol: '', // Will be populated by webhook\n\t\t\t\tamount: params.amount,\n\t\t\t\tnote: params.note,\n\t\t\t\tstatus: 'Processing'\n\t\t\t});\n\n\t\t\treturn recordId;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error initiating internal transfer:', error);\n\t\t\tthrow new Error('Failed to transfer funds');\n\t\t}\n\t}\n\n\t/**\n\t * Swap cryptocurrencies\n\t */\n\tasync swapCrypto(\n\t\tuserId: UserId,\n\t\tparams: {\n\t\t\tfromCoinId: CoinId;\n\t\t\ttoCoinId: CoinId;\n\t\t\tfromAmount: string;\n\t\t}\n\t): Promise<string> {\n\t\ttry {\n\t\t\t// Check if crypto swaps are allowed\n\t\t\tconst config = await walletConfigService.getConfig();\n\t\t\tif (!config.features.allowCryptoSwaps) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Crypto swaps are currently disabled. All deposits are automatically converted to DGT.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst ccpaymentUserId = await this.userManagementService.getOrCreateCCPaymentUser(userId);\n\n\t\t\tconst recordId = await this.ccpaymentService.swap({\n\t\t\t\tuid: ccpaymentUserId,\n\t\t\t\tfromCoinId: params.fromCoinId,\n\t\t\t\ttoCoinId: params.toCoinId,\n\t\t\t\tfromAmount: params.fromAmount\n\t\t\t});\n\n\t\t\t// Store swap record\n\t\t\tawait db.insert(swapRecords).values({\n\t\t\t\tuserId: userId,\n\t\t\t\trecordId: recordId,\n\t\t\t\tfromCoinId: params.fromCoinId,\n\t\t\t\tfromCoinSymbol: '', // Will be populated by webhook\n\t\t\t\tfromAmount: params.fromAmount,\n\t\t\t\ttoCoinId: params.toCoinId,\n\t\t\t\ttoCoinSymbol: '', // Will be populated by webhook\n\t\t\t\ttoAmount: '0', // Will be populated by webhook\n\t\t\t\tstatus: 'Processing'\n\t\t\t});\n\n\t\t\treturn recordId;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error initiating swap:', error);\n\t\t\tthrow new Error('Failed to swap cryptocurrencies');\n\t\t}\n\t}\n\n\t/**\n\t * Get user's transaction history\n\t */\n\tasync getUserTransactionHistory(\n\t\tuserId: UserId,\n\t\tparams?: {\n\t\t\ttype?: 'deposit' | 'withdrawal' | 'transfer' | 'swap';\n\t\t\tlimit?: number;\n\t\t\toffset?: number;\n\t\t}\n\t): Promise<{\n\t\tdeposits: any[];\n\t\twithdrawals: any[];\n\t\ttransfers: any[];\n\t\tswaps: any[];\n\t}> {\n\t\ttry {\n\t\t\tconst limit = params?.limit || 50;\n\t\t\tconst offset = params?.offset || 0;\n\n\t\t\tconst [deposits, withdrawals, transfers, swaps] = await Promise.all([\n\t\t\t\t// Get deposits\n\t\t\t\t!params?.type || params.type === 'deposit'\n\t\t\t\t\t? db\n\t\t\t\t\t\t\t.select()\n\t\t\t\t\t\t\t.from(depositRecords)\n\t\t\t\t\t\t\t.where(eq(depositRecords.userId, userId))\n\t\t\t\t\t\t\t.orderBy(desc(depositRecords.createdAt))\n\t\t\t\t\t\t\t.limit(limit)\n\t\t\t\t\t\t\t.offset(offset)\n\t\t\t\t\t: [],\n\n\t\t\t\t// Get withdrawals\n\t\t\t\t!params?.type || params.type === 'withdrawal'\n\t\t\t\t\t? db\n\t\t\t\t\t\t\t.select()\n\t\t\t\t\t\t\t.from(withdrawalRecords)\n\t\t\t\t\t\t\t.where(eq(withdrawalRecords.userId, userId))\n\t\t\t\t\t\t\t.orderBy(desc(withdrawalRecords.createdAt))\n\t\t\t\t\t\t\t.limit(limit)\n\t\t\t\t\t\t\t.offset(offset)\n\t\t\t\t\t: [],\n\n\t\t\t\t// Get transfers (both sent and received)\n\t\t\t\t!params?.type || params.type === 'transfer'\n\t\t\t\t\t? db\n\t\t\t\t\t\t\t.select()\n\t\t\t\t\t\t\t.from(internalTransfers)\n\t\t\t\t\t\t\t.where(\n\t\t\t\t\t\t\t\tor(eq(internalTransfers.fromUserId, userId), eq(internalTransfers.toUserId, userId))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.orderBy(desc(internalTransfers.createdAt))\n\t\t\t\t\t\t\t.limit(limit)\n\t\t\t\t\t\t\t.offset(offset)\n\t\t\t\t\t: [],\n\n\t\t\t\t// Get swaps\n\t\t\t\t!params?.type || params.type === 'swap'\n\t\t\t\t\t? db\n\t\t\t\t\t\t\t.select()\n\t\t\t\t\t\t\t.from(swapRecords)\n\t\t\t\t\t\t\t.where(eq(swapRecords.userId, userId))\n\t\t\t\t\t\t\t.orderBy(desc(swapRecords.createdAt))\n\t\t\t\t\t\t\t.limit(limit)\n\t\t\t\t\t\t\t.offset(offset)\n\t\t\t\t\t: []\n\t\t\t]);\n\n\t\t\treturn {\n\t\t\t\tdeposits,\n\t\t\t\twithdrawals,\n\t\t\t\ttransfers,\n\t\t\t\tswaps\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting transaction history:', error);\n\t\t\tthrow new Error('Failed to retrieve transaction history');\n\t\t}\n\t}\n\n\t/**\n\t * Transfer DGT between users\n\t */\n\tasync transferDGT(\n\t\tfromUserId: UserId,\n\t\tparams: {\n\t\t\ttoUserId: UserId;\n\t\t\tamount: number;\n\t\t\tnote?: string;\n\t\t}\n\t): Promise<{\n\t\ttransactionId: ActionId;\n\t\tfromBalance: number;\n\t\ttoBalance: number;\n\t\ttransferId: string;\n\t}> {\n\t\ttry {\n\t\t\t// Check if DGT transfers are allowed\n\t\t\tconst config = await walletConfigService.getConfig();\n\t\t\tif (!config.features.allowInternalTransfers) {\n\t\t\t\tthrow new Error('DGT transfers are currently disabled.');\n\t\t\t}\n\n\t\t\treturn await dgtService.transferDGT(fromUserId, params.toUserId, params.amount, params.note);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error transferring DGT:', error);\n\t\t\tthrow new Error(`Failed to transfer DGT: ${error.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get DGT transaction history\n\t */\n\tasync getDGTHistory(\n\t\tuserId: UserId,\n\t\toptions?: {\n\t\t\tlimit?: number;\n\t\t\toffset?: number;\n\t\t\ttype?: string;\n\t\t}\n\t): Promise<any[]> {\n\t\ttry {\n\t\t\treturn await dgtService.getDGTHistory(userId, options);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting DGT history:', error);\n\t\t\tthrow new Error('Failed to retrieve DGT transaction history');\n\t\t}\n\t}\n\n\t/**\n\t * Get wallet configuration (for frontend feature gates)\n\t */\n\tasync getWalletConfig(): Promise<{\n\t\tfeatures: {\n\t\t\tallowCryptoWithdrawals: boolean;\n\t\t\tallowCryptoSwaps: boolean;\n\t\t\tallowDGTSpending: boolean;\n\t\t\tallowInternalTransfers: boolean;\n\t\t};\n\t\tdgt: {\n\t\t\tusdPrice: number;\n\t\t\tminDepositUSD: number;\n\t\t\tmaxDGTBalance: number;\n\t\t};\n\t\tlimits: {\n\t\t\tmaxDGTTransfer: number;\n\t\t};\n\t}> {\n\t\ttry {\n\t\t\tconst config = await walletConfigService.getConfig();\n\n\t\t\t// Return only public configuration (hide sensitive settings)\n\t\t\treturn {\n\t\t\t\tfeatures: {\n\t\t\t\t\tallowCryptoWithdrawals: config.features.allowCryptoWithdrawals,\n\t\t\t\t\tallowCryptoSwaps: config.features.allowCryptoSwaps,\n\t\t\t\t\tallowDGTSpending: config.features.allowDGTSpending,\n\t\t\t\t\tallowInternalTransfers: config.features.allowInternalTransfers\n\t\t\t\t},\n\t\t\t\tdgt: {\n\t\t\t\t\tusdPrice: config.dgt.usdPrice,\n\t\t\t\t\tminDepositUSD: config.dgt.minDepositUSD,\n\t\t\t\t\tmaxDGTBalance: config.dgt.maxDGTBalance\n\t\t\t\t},\n\t\t\t\tlimits: {\n\t\t\t\t\tmaxDGTTransfer: config.limits.maxDGTTransfer\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting wallet config:', error);\n\t\t\tthrow new Error('Failed to retrieve wallet configuration');\n\t\t}\n\t}\n\n\t/**\n\t * Get supported cryptocurrencies\n\t */\n\tasync getSupportedCryptocurrencies(): Promise<\n\t\tArray<{\n\t\t\tcoinId: CoinId;\n\t\t\tcoinSymbol: string;\n\t\t\tcoinName: string;\n\t\t\tchain: string;\n\t\t\tcontract?: string;\n\t\t\tdecimals: number;\n\t\t\tminDepositAmount?: string;\n\t\t\tminWithdrawAmount?: string;\n\t\t\twithdrawFee?: string;\n\t\t\tsupportsDeposit: boolean;\n\t\t\tsupportsWithdraw: boolean;\n\t\t\tsupportsSwap: boolean;\n\t\t\ticonUrl?: string;\n\t\t}>\n\t> {\n\t\ttry {\n\t\t\t// First try to get from local database\n\t\t\tconst localTokens = await db\n\t\t\t\t.select()\n\t\t\t\t.from(supportedTokens)\n\t\t\t\t.where(eq(supportedTokens.isActive, true));\n\n\t\t\tif (localTokens.length > 0) {\n\t\t\t\treturn localTokens.map((token) => ({\n\t\t\t\t\tcoinId: token.coinId,\n\t\t\t\t\tcoinSymbol: token.coinSymbol,\n\t\t\t\t\tcoinName: token.coinName,\n\t\t\t\t\tchain: token.chain,\n\t\t\t\t\tcontract: token.contract || undefined,\n\t\t\t\t\tdecimals: token.decimals,\n\t\t\t\t\tminDepositAmount: token.minDepositAmount || undefined,\n\t\t\t\t\tminWithdrawAmount: token.minWithdrawAmount || undefined,\n\t\t\t\t\twithdrawFee: token.withdrawFee || undefined,\n\t\t\t\t\tsupportsDeposit: token.supportsDeposit,\n\t\t\t\t\tsupportsWithdraw: token.supportsWithdraw,\n\t\t\t\t\tsupportsSwap: token.supportsSwap,\n\t\t\t\t\ticonUrl: token.iconUrl || undefined\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// Fallback to CCPayment API\n\t\t\tconst apiTokens = await this.ccpaymentService.getSupportedCoins();\n\t\t\treturn apiTokens.map((token) => ({\n\t\t\t\tcoinId: token.coinId,\n\t\t\t\tcoinSymbol: token.coinSymbol,\n\t\t\t\tcoinName: token.coinName,\n\t\t\t\tchain: token.chain,\n\t\t\t\tcontract: token.contract,\n\t\t\t\tdecimals: token.decimals || 18,\n\t\t\t\tsupportsDeposit: true,\n\t\t\t\tsupportsWithdraw: true,\n\t\t\t\tsupportsSwap: true\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tlogger.error('Error getting supported cryptocurrencies:', error);\n\t\t\tthrow new Error('Failed to retrieve supported cryptocurrencies');\n\t\t}\n\t}\n\n\t/**\n\t * Ensure CCPayment wallet exists for user (used by auth controller)\n\t */\n\tasync ensureCcPaymentWallet(userId: UserId): Promise<string> {\n\t\ttry {\n\t\t\treturn await this.userManagementService.getOrCreateCCPaymentUser(userId);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error ensuring CCPayment wallet:', error);\n\t\t\tthrow new Error('Failed to ensure CCPayment wallet');\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const walletService = new WalletService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/wallet.test.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/wallet.test.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/wallet.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/webhook.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'coinId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":241,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":241,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'amount' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":244,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":244,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'toAddress' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":248,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":248,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'coinId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":325,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":325,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'amount' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":327,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":327,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fromCoinId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":400,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":400,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fromAmount' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":402,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":402,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'toCoinId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":404,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":404,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport {\n\twebhookEvents,\n\tdepositRecords,\n\twithdrawalRecords,\n\tinternalTransfers,\n\tswapRecords,\n\tccpaymentUsers\n} from '@schema';\nimport { eq, and } from 'drizzle-orm';\nimport crypto from 'crypto';\nimport { walletConfigService } from './wallet-config.service';\nimport { dgtService } from './dgt.service';\nimport { logger } from \"../../core/logger\";\n\n/**\n * Enhanced Webhook Service for CCPayment Integration\n *\n * Handles webhook events from CCPayment and updates the appropriate wallet transaction records.\n */\nexport class WebhookService {\n\t/**\n\t * Verify webhook signature from CCPayment\n\t */\n\tverifyWebhookSignature(\n\t\tpayload: any,\n\t\tsignature: string,\n\t\ttimestamp: string,\n\t\tappSecret: string\n\t): boolean {\n\t\ttry {\n\t\t\t// CCPayment webhook signature verification\n\t\t\tconst payloadString = JSON.stringify(payload);\n\t\t\tconst stringToSign = timestamp + payloadString;\n\t\t\tconst expectedSignature = crypto\n\t\t\t\t.createHmac('sha256', appSecret)\n\t\t\t\t.update(stringToSign)\n\t\t\t\t.digest('hex');\n\n\t\t\treturn signature === expectedSignature;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error verifying webhook signature:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Process incoming webhook event\n\t */\n\tasync processWebhookEvent(\n\t\tpayload: any,\n\t\tsignature: string\n\t): Promise<{\n\t\tsuccess: boolean;\n\t\tmessage: string;\n\t}> {\n\t\ttry {\n\t\t\t// Generate unique webhook ID\n\t\t\tconst webhookId = `webhook_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n\t\t\t// Store webhook event for auditing\n\t\t\tawait db.insert(webhookEvents).values({\n\t\t\t\twebhookId: webhookId,\n\t\t\t\teventType: payload.eventType || 'unknown',\n\t\t\t\tstatus: 'received',\n\t\t\t\trawPayload: JSON.stringify(payload),\n\t\t\t\tsignature: signature,\n\t\t\t\tisProcessed: false,\n\t\t\t\tretryCount: '0'\n\t\t\t});\n\n\t\t\t// Process based on event type\n\t\t\tlet result: { success: boolean; message: string };\n\n\t\t\tswitch (payload.eventType) {\n\t\t\t\tcase 'deposit':\n\t\t\t\t\tresult = await this.handleDepositWebhook(payload, webhookId);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'withdraw':\n\t\t\t\t\tresult = await this.handleWithdrawalWebhook(payload, webhookId);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'internal_transfer':\n\t\t\t\t\tresult = await this.handleInternalTransferWebhook(payload, webhookId);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'swap':\n\t\t\t\t\tresult = await this.handleSwapWebhook(payload, webhookId);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tresult = {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tmessage: `Unknown event type: ${payload.eventType}`\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Update webhook event status\n\t\t\tawait db\n\t\t\t\t.update(webhookEvents)\n\t\t\t\t.set({\n\t\t\t\t\tstatus: result.success ? 'processed' : 'failed',\n\t\t\t\t\tisProcessed: result.success,\n\t\t\t\t\tprocessedAt: new Date(),\n\t\t\t\t\tprocessingError: result.success ? null : result.message\n\t\t\t\t})\n\t\t\t\t.where(eq(webhookEvents.webhookId, webhookId));\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error processing webhook event:', error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Processing error: ${error instanceof Error ? error.message : 'Unknown error'}`\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Handle deposit webhook events\n\t */\n\tprivate async handleDepositWebhook(\n\t\tpayload: any,\n\t\twebhookId: string\n\t): Promise<{\n\t\tsuccess: boolean;\n\t\tmessage: string;\n\t}> {\n\t\ttry {\n\t\t\tconst {\n\t\t\t\trecordId,\n\t\t\t\tuid,\n\t\t\t\tcoinId,\n\t\t\t\tcoinSymbol,\n\t\t\t\tchain,\n\t\t\t\tamount,\n\t\t\t\tserviceFee,\n\t\t\t\tcoinUSDPrice,\n\t\t\t\tfromAddress,\n\t\t\t\ttoAddress,\n\t\t\t\ttxId,\n\t\t\t\tstatus,\n\t\t\t\tisFlaggedRisky\n\t\t\t} = payload;\n\n\t\t\t// Find Degentalk user from CCPayment UID\n\t\t\tconst userMapping = await db\n\t\t\t\t.select()\n\t\t\t\t.from(ccpaymentUsers)\n\t\t\t\t.where(eq(ccpaymentUsers.ccpaymentUserId, uid))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userMapping.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: `No user mapping found for CCPayment UID: ${uid}`\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst userId = userMapping[0].userId;\n\n\t\t\t// Check if deposit record already exists\n\t\t\tconst existingRecord = await db\n\t\t\t\t.select()\n\t\t\t\t.from(depositRecords)\n\t\t\t\t.where(eq(depositRecords.recordId, recordId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (existingRecord.length > 0) {\n\t\t\t\t// Update existing record\n\t\t\t\tawait db\n\t\t\t\t\t.update(depositRecords)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tstatus: status,\n\t\t\t\t\t\tserviceFee: serviceFee || existingRecord[0].serviceFee,\n\t\t\t\t\t\tcoinUSDPrice: coinUSDPrice || existingRecord[0].coinUSDPrice,\n\t\t\t\t\t\tfromAddress: fromAddress || existingRecord[0].fromAddress,\n\t\t\t\t\t\ttxId: txId || existingRecord[0].txId,\n\t\t\t\t\t\tisFlaggedRisky: isFlaggedRisky || existingRecord[0].isFlaggedRisky,\n\t\t\t\t\t\tarrivedAt: status === 'Success' ? new Date() : existingRecord[0].arrivedAt\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(depositRecords.recordId, recordId));\n\t\t\t} else {\n\t\t\t\t// Create new deposit record\n\t\t\t\tawait db.insert(depositRecords).values({\n\t\t\t\t\tuserId: userId,\n\t\t\t\t\trecordId: recordId,\n\t\t\t\t\tcoinId: coinId,\n\t\t\t\t\tcoinSymbol: coinSymbol,\n\t\t\t\t\tchain: chain,\n\t\t\t\t\tamount: amount,\n\t\t\t\t\tserviceFee: serviceFee,\n\t\t\t\t\tcoinUSDPrice: coinUSDPrice,\n\t\t\t\t\tfromAddress: fromAddress,\n\t\t\t\t\ttoAddress: toAddress,\n\t\t\t\t\ttxId: txId,\n\t\t\t\t\tstatus: status,\n\t\t\t\t\tisFlaggedRisky: isFlaggedRisky || false,\n\t\t\t\t\tarrivedAt: status === 'Success' ? new Date() : null\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Handle DGT conversion for successful deposits\n\t\t\tif (status === 'Success') {\n\t\t\t\tawait this.processDGTConversion(userId, recordId, amount, coinSymbol, coinUSDPrice);\n\t\t\t}\n\n\t\t\t// Update webhook event with related record info\n\t\t\tawait db\n\t\t\t\t.update(webhookEvents)\n\t\t\t\t.set({\n\t\t\t\t\trelatedRecordType: 'deposit',\n\t\t\t\t\trelatedRecordId: recordId\n\t\t\t\t})\n\t\t\t\t.where(eq(webhookEvents.webhookId, webhookId));\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Deposit ${recordId} processed successfully`\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error handling deposit webhook:', error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Deposit processing error: ${error instanceof Error ? error.message : 'Unknown error'}`\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Handle withdrawal webhook events\n\t */\n\tprivate async handleWithdrawalWebhook(\n\t\tpayload: any,\n\t\twebhookId: string\n\t): Promise<{\n\t\tsuccess: boolean;\n\t\tmessage: string;\n\t}> {\n\t\ttry {\n\t\t\tconst {\n\t\t\t\trecordId,\n\t\t\t\tuid,\n\t\t\t\tcoinId,\n\t\t\t\tcoinSymbol,\n\t\t\t\tchain,\n\t\t\t\tamount,\n\t\t\t\tserviceFee,\n\t\t\t\tcoinUSDPrice,\n\t\t\t\tfromAddress,\n\t\t\t\ttoAddress,\n\t\t\t\ttxId,\n\t\t\t\tstatus,\n\t\t\t\tfailureReason,\n\t\t\t\tisFlaggedRisky\n\t\t\t} = payload;\n\n\t\t\t// Find Degentalk user from CCPayment UID\n\t\t\tconst userMapping = await db\n\t\t\t\t.select()\n\t\t\t\t.from(ccpaymentUsers)\n\t\t\t\t.where(eq(ccpaymentUsers.ccpaymentUserId, uid))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userMapping.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: `No user mapping found for CCPayment UID: ${uid}`\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst userId = userMapping[0].userId;\n\n\t\t\t// Update withdrawal record\n\t\t\tawait db\n\t\t\t\t.update(withdrawalRecords)\n\t\t\t\t.set({\n\t\t\t\t\tcoinSymbol: coinSymbol,\n\t\t\t\t\tchain: chain,\n\t\t\t\t\tserviceFee: serviceFee,\n\t\t\t\t\tcoinUSDPrice: coinUSDPrice,\n\t\t\t\t\tfromAddress: fromAddress,\n\t\t\t\t\ttxId: txId,\n\t\t\t\t\tstatus: status,\n\t\t\t\t\tfailureReason: failureReason,\n\t\t\t\t\tisFlaggedRisky: isFlaggedRisky || false,\n\t\t\t\t\tprocessedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(and(eq(withdrawalRecords.recordId, recordId), eq(withdrawalRecords.userId, userId)));\n\n\t\t\t// Update webhook event with related record info\n\t\t\tawait db\n\t\t\t\t.update(webhookEvents)\n\t\t\t\t.set({\n\t\t\t\t\trelatedRecordType: 'withdrawal',\n\t\t\t\t\trelatedRecordId: recordId\n\t\t\t\t})\n\t\t\t\t.where(eq(webhookEvents.webhookId, webhookId));\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Withdrawal ${recordId} processed successfully`\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error handling withdrawal webhook:', error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Withdrawal processing error: ${error instanceof Error ? error.message : 'Unknown error'}`\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Handle internal transfer webhook events\n\t */\n\tprivate async handleInternalTransferWebhook(\n\t\tpayload: any,\n\t\twebhookId: string\n\t): Promise<{\n\t\tsuccess: boolean;\n\t\tmessage: string;\n\t}> {\n\t\ttry {\n\t\t\tconst {\n\t\t\t\trecordId,\n\t\t\t\tfromUid,\n\t\t\t\ttoUid,\n\t\t\t\tcoinId,\n\t\t\t\tcoinSymbol,\n\t\t\t\tamount,\n\t\t\t\tserviceFee,\n\t\t\t\tcoinUSDPrice,\n\t\t\t\tstatus,\n\t\t\t\tfailureReason\n\t\t\t} = payload;\n\n\t\t\t// Find Degentalk users from CCPayment UIDs\n\t\t\tconst [fromUserMapping, toUserMapping] = await Promise.all([\n\t\t\t\tdb\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(ccpaymentUsers)\n\t\t\t\t\t.where(eq(ccpaymentUsers.ccpaymentUserId, fromUid))\n\t\t\t\t\t.limit(1),\n\t\t\t\tdb.select().from(ccpaymentUsers).where(eq(ccpaymentUsers.ccpaymentUserId, toUid)).limit(1)\n\t\t\t]);\n\n\t\t\tif (fromUserMapping.length === 0 || toUserMapping.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: `User mapping not found for UIDs: ${fromUid}, ${toUid}`\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Update internal transfer record\n\t\t\tawait db\n\t\t\t\t.update(internalTransfers)\n\t\t\t\t.set({\n\t\t\t\t\tcoinSymbol: coinSymbol,\n\t\t\t\t\tserviceFee: serviceFee,\n\t\t\t\t\tcoinUSDPrice: coinUSDPrice,\n\t\t\t\t\tstatus: status,\n\t\t\t\t\tfailureReason: failureReason,\n\t\t\t\t\tprocessedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(internalTransfers.recordId, recordId));\n\n\t\t\t// Update webhook event with related record info\n\t\t\tawait db\n\t\t\t\t.update(webhookEvents)\n\t\t\t\t.set({\n\t\t\t\t\trelatedRecordType: 'transfer',\n\t\t\t\t\trelatedRecordId: recordId\n\t\t\t\t})\n\t\t\t\t.where(eq(webhookEvents.webhookId, webhookId));\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Internal transfer ${recordId} processed successfully`\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error handling internal transfer webhook:', error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Internal transfer processing error: ${error instanceof Error ? error.message : 'Unknown error'}`\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Handle swap webhook events\n\t */\n\tprivate async handleSwapWebhook(\n\t\tpayload: any,\n\t\twebhookId: string\n\t): Promise<{\n\t\tsuccess: boolean;\n\t\tmessage: string;\n\t}> {\n\t\ttry {\n\t\t\tconst {\n\t\t\t\trecordId,\n\t\t\t\tuid,\n\t\t\t\tfromCoinId,\n\t\t\t\tfromCoinSymbol,\n\t\t\t\tfromAmount,\n\t\t\t\tfromCoinUSDPrice,\n\t\t\t\ttoCoinId,\n\t\t\t\ttoCoinSymbol,\n\t\t\t\ttoAmount,\n\t\t\t\ttoCoinUSDPrice,\n\t\t\t\texchangeRate,\n\t\t\t\tserviceFee,\n\t\t\t\tstatus,\n\t\t\t\tfailureReason\n\t\t\t} = payload;\n\n\t\t\t// Find Degentalk user from CCPayment UID\n\t\t\tconst userMapping = await db\n\t\t\t\t.select()\n\t\t\t\t.from(ccpaymentUsers)\n\t\t\t\t.where(eq(ccpaymentUsers.ccpaymentUserId, uid))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userMapping.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: `No user mapping found for CCPayment UID: ${uid}`\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst userId = userMapping[0].userId;\n\n\t\t\t// Update swap record\n\t\t\tawait db\n\t\t\t\t.update(swapRecords)\n\t\t\t\t.set({\n\t\t\t\t\tfromCoinSymbol: fromCoinSymbol,\n\t\t\t\t\tfromCoinUSDPrice: fromCoinUSDPrice,\n\t\t\t\t\ttoCoinSymbol: toCoinSymbol,\n\t\t\t\t\ttoAmount: toAmount,\n\t\t\t\t\ttoCoinUSDPrice: toCoinUSDPrice,\n\t\t\t\t\texchangeRate: exchangeRate,\n\t\t\t\t\tserviceFee: serviceFee,\n\t\t\t\t\tstatus: status,\n\t\t\t\t\tfailureReason: failureReason,\n\t\t\t\t\tprocessedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(and(eq(swapRecords.recordId, recordId), eq(swapRecords.userId, userId)));\n\n\t\t\t// Update webhook event with related record info\n\t\t\tawait db\n\t\t\t\t.update(webhookEvents)\n\t\t\t\t.set({\n\t\t\t\t\trelatedRecordType: 'swap',\n\t\t\t\t\trelatedRecordId: recordId\n\t\t\t\t})\n\t\t\t\t.where(eq(webhookEvents.webhookId, webhookId));\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: `Swap ${recordId} processed successfully`\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('Error handling swap webhook:', error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Swap processing error: ${error instanceof Error ? error.message : 'Unknown error'}`\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Retry failed webhook processing\n\t */\n\tasync retryFailedWebhook(webhookId: string): Promise<{\n\t\tsuccess: boolean;\n\t\tmessage: string;\n\t}> {\n\t\ttry {\n\t\t\tconst webhookEvent = await db\n\t\t\t\t.select()\n\t\t\t\t.from(webhookEvents)\n\t\t\t\t.where(eq(webhookEvents.webhookId, webhookId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (webhookEvent.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Webhook event not found'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst event = webhookEvent[0];\n\t\t\tconst payload = JSON.parse(event.rawPayload);\n\n\t\t\t// Increment retry count\n\t\t\tconst newRetryCount = (parseInt(event.retryCount) + 1).toString();\n\t\t\tawait db\n\t\t\t\t.update(webhookEvents)\n\t\t\t\t.set({\n\t\t\t\t\tretryCount: newRetryCount,\n\t\t\t\t\tstatus: 'processing'\n\t\t\t\t})\n\t\t\t\t.where(eq(webhookEvents.webhookId, webhookId));\n\n\t\t\t// Reprocess the event\n\t\t\tconst result = await this.processWebhookEvent(payload, event.signature || '');\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error('Error retrying webhook:', error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Retry error: ${error instanceof Error ? error.message : 'Unknown error'}`\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Process DGT conversion for successful deposits\n\t */\n\tprivate async processDGTConversion(\n\t\tuserId: string,\n\t\trecordId: string,\n\t\tdepositAmount: string,\n\t\toriginalToken: string,\n\t\tcoinUSDPrice: string\n\t): Promise<void> {\n\t\ttry {\n\t\t\tconst config = await walletConfigService.getConfig();\n\n\t\t\t// Check if auto-conversion is enabled\n\t\t\tif (!config.ccpayment.autoSwapEnabled) {\n\t\t\t\tlogger.info(`DGT auto-conversion disabled for deposit ${recordId}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate USDT amount from deposit\n\t\t\t// CCPayment automatically swaps to USDT, so we use the USD value\n\t\t\tconst usdValue = parseFloat(depositAmount) * parseFloat(coinUSDPrice);\n\t\t\tconst usdtAmount = usdValue; // USDT is pegged 1:1 to USD\n\n\t\t\t// Check minimum deposit threshold\n\t\t\tif (usdtAmount < config.dgt.minDepositUSD) {\n\t\t\t\tlogger.info(`Deposit ${recordId} below minimum threshold: $${usdtAmount} < $${config.dgt.minDepositUSD}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate DGT amount using configured rate\n\t\t\tconst dgtAmount = usdtAmount * config.dgt.usdToDGTRate;\n\n\t\t\t// Update deposit record with DGT conversion details\n\t\t\tawait db\n\t\t\t\t.update(depositRecords)\n\t\t\t\t.set({\n\t\t\t\t\tusdtAmount: usdtAmount.toString(),\n\t\t\t\t\tdgtAmount: dgtAmount.toString(),\n\t\t\t\t\tconversionRate: config.dgt.usdToDGTRate.toString(),\n\t\t\t\t\toriginalToken: originalToken\n\t\t\t\t})\n\t\t\t\t.where(eq(depositRecords.recordId, recordId));\n\n\t\t\t// Credit DGT to user's account\n\t\t\tawait dgtService.creditDGT(userId, dgtAmount, {\n\t\t\t\tsource: 'crypto_deposit',\n\t\t\t\toriginalToken: originalToken,\n\t\t\t\tusdtAmount: usdtAmount.toString(),\n\t\t\t\tdepositRecordId: recordId,\n\t\t\t\treason: `Crypto deposit conversion: ${depositAmount} ${originalToken} → ${dgtAmount} DGT`\n\t\t\t});\n\n\t\t\tlogger.info(`DGT conversion completed: ${depositAmount} ${originalToken} → ${dgtAmount} DGT for user ${userId}`);\n\t\t} catch (error) {\n\t\t\tlogger.error(`Error processing DGT conversion for deposit ${recordId}:`, error);\n\n\t\t\t// Update deposit record with conversion error\n\t\t\tawait db\n\t\t\t\t.update(depositRecords)\n\t\t\t\t.set({\n\t\t\t\t\toriginalToken: originalToken\n\t\t\t\t\t// Mark conversion as failed in a way that can be retried later\n\t\t\t\t})\n\t\t\t\t.where(eq(depositRecords.recordId, recordId));\n\n\t\t\t// Don't throw error - deposit should still be marked as successful\n\t\t\t// Conversion can be retried manually by admin if needed\n\t\t}\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/wallet/withdrawal.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'walletService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ccpaymentService' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transactions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":15,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\nimport type { UserId, EntityId } from '@shared/types/ids';\n/**\n * Withdrawal Controller\n *\n * Handles withdrawal requests for users converting DGT to crypto\n */\n\nimport type { Request, Response, NextFunction } from 'express';\nimport { logger } from '../../core/logger';\nimport { walletService } from './wallet.service';\nimport { dgtService } from './dgt.service';\nimport { ccpaymentService } from './ccpayment.service';\nimport { db } from '@db';\nimport { withdrawalRequests, users, transactions, withdrawalStatusEnum } from '@schema';\nimport { eq, and, desc, sql } from 'drizzle-orm';\nimport { WalletError, ErrorCodes } from '../../core/errors';\nimport { walletConfig } from '@shared/wallet.config';\nimport { z } from 'zod';\n\n// Validation schemas\nconst createWithdrawalSchema = z.object({\n\tamount: z.number().positive().min(walletConfig.LIMITS.MIN_WITHDRAWAL_USD),\n\tcurrency: z.enum(['USDT', 'BTC', 'ETH']),\n\tnetwork: z.string().optional(),\n\taddress: z.string().min(10).max(255),\n\tnotes: z.string().max(500).optional()\n});\n\nconst processWithdrawalSchema = z.object({\n\taction: z.enum(['approve', 'reject']),\n\tadminNotes: z.string().max(500).optional()\n});\n\nexport class WithdrawalController {\n\t/**\n\t * Create a withdrawal request\n\t */\n\tasync createWithdrawalRequest(req: Request, res: Response, next: NextFunction) {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)) {\n\t\t\t\treturn res.status(401).json({ error: 'User not authenticated' });\n\t\t\t}\n\n\t\t\tconst userId = (userService.getUserFromRequest(req) as { id: UserId }).id;\n\n\t\t\t// Check if withdrawals are enabled\n\t\t\tif (!walletConfig.WITHDRAWALS_ENABLED) {\n\t\t\t\treturn res.status(503).json({\n\t\t\t\t\terror: 'Withdrawals are temporarily disabled',\n\t\t\t\t\tcode: 'SERVICE_UNAVAILABLE'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Validate request body\n\t\t\tconst { amount, currency, network, address, notes } = createWithdrawalSchema.parse(req.body);\n\n\t\t\t// Check user level requirement\n\t\t\tconst [user] = await db\n\t\t\t\t.select({ level: users.level })\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\tif (!user || user.level < walletConfig.REQUIREMENTS.MIN_LEVEL_TO_WITHDRAW) {\n\t\t\t\treturn res.status(403).json({\n\t\t\t\t\terror: `Level ${walletConfig.REQUIREMENTS.MIN_LEVEL_TO_WITHDRAW} required to withdraw`,\n\t\t\t\t\tcode: 'INSUFFICIENT_LEVEL'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Check withdrawal limits\n\t\t\tif (\n\t\t\t\tamount < walletConfig.LIMITS.MIN_WITHDRAWAL_USD ||\n\t\t\t\tamount > walletConfig.LIMITS.MAX_WITHDRAWAL_USD\n\t\t\t) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\terror: `Withdrawal amount must be between $${walletConfig.LIMITS.MIN_WITHDRAWAL_USD} and $${walletConfig.LIMITS.MAX_WITHDRAWAL_USD}`,\n\t\t\t\t\tcode: 'INVALID_AMOUNT'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Check daily limit\n\t\t\tconst twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);\n\t\t\tconst [dailyTotal] = await db\n\t\t\t\t.select({\n\t\t\t\t\ttotal: sql<number>`COALESCE(SUM(${withdrawalRequests.amount}), 0)`\n\t\t\t\t})\n\t\t\t\t.from(withdrawalRequests)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(withdrawalRequests.userId, userId),\n\t\t\t\t\t\tsql`${withdrawalRequests.createdAt} > ${twentyFourHoursAgo}`,\n\t\t\t\t\t\teq(withdrawalRequests.status, 'approved')\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tif (dailyTotal && dailyTotal.total + amount > walletConfig.LIMITS.DAILY_WITHDRAWAL_LIMIT) {\n\t\t\t\treturn res.status(429).json({\n\t\t\t\t\terror: `Daily withdrawal limit of $${walletConfig.LIMITS.DAILY_WITHDRAWAL_LIMIT} exceeded`,\n\t\t\t\t\tcode: 'DAILY_LIMIT_EXCEEDED',\n\t\t\t\t\tremainingLimit: Math.max(0, walletConfig.LIMITS.DAILY_WITHDRAWAL_LIMIT - dailyTotal.total)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Calculate DGT amount needed (including fees)\n\t\t\tconst withdrawalFeePercent = walletConfig.FEES.WITHDRAWAL_FEE_PERCENT / 100;\n\t\t\tconst flatFee = walletConfig.FEES.WITHDRAWAL_FLAT_FEE_USD;\n\t\t\tconst totalFeeUSD = amount * withdrawalFeePercent + flatFee;\n\t\t\tconst totalAmountUSD = amount + totalFeeUSD;\n\t\t\tconst dgtAmountNeeded = BigInt(\n\t\t\t\tMath.ceil((totalAmountUSD / walletConfig.DGT.PRICE_USD) * 100000000)\n\t\t\t);\n\n\t\t\t// Check DGT balance\n\t\t\tconst dgtBalance = await dgtService.getUserBalance(userId);\n\t\t\tif (dgtBalance < dgtAmountNeeded) {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\terror: 'Insufficient DGT balance',\n\t\t\t\t\tcode: 'INSUFFICIENT_BALANCE',\n\t\t\t\t\trequired: Number(dgtAmountNeeded) / 100000000,\n\t\t\t\t\tavailable: Number(dgtBalance) / 100000000\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Create withdrawal request\n\t\t\tconst [withdrawalRequest] = await db\n\t\t\t\t.insert(withdrawalRequests)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\tamount: Math.floor(amount * 100), // Store in cents\n\t\t\t\t\twalletAddress: address,\n\t\t\t\t\tprocessingFee: Math.floor(totalFeeUSD * 100), // Store in cents\n\t\t\t\t\trequestNotes: notes,\n\t\t\t\t\tstatus: 'pending'\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Deduct DGT from user's balance (hold in escrow)\n\t\t\tawait dgtService.deductDGT(\n\t\t\t\tuserId,\n\t\t\t\tdgtAmountNeeded,\n\t\t\t\t'WITHDRAWAL',\n\t\t\t\t`Withdrawal request #${withdrawalRequest.id}`,\n\t\t\t\t{ withdrawalRequestId: withdrawalRequest.id }\n\t\t\t);\n\n\t\t\tlogger.info('WithdrawalController', 'Withdrawal request created', {\n\t\t\t\tuserId,\n\t\t\t\trequestId: withdrawalRequest.id,\n\t\t\t\tamount,\n\t\t\t\tcurrency,\n\t\t\t\tdgtDeducted: Number(dgtAmountNeeded) / 100000000\n\t\t\t});\n\n\t\t\tres.json({\n\t\t\t\tsuccess: true,\n\t\t\t\twithdrawalRequest: {\n\t\t\t\t\tid: withdrawalRequest.id,\n\t\t\t\t\tamount,\n\t\t\t\t\tcurrency,\n\t\t\t\t\tnetwork: network || 'default',\n\t\t\t\t\taddress,\n\t\t\t\t\tfee: totalFeeUSD,\n\t\t\t\t\tstatus: 'pending',\n\t\t\t\t\tcreatedAt: withdrawalRequest.createdAt\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({ error: 'Invalid request', details: error.errors });\n\t\t\t}\n\t\t\tlogger.error('WithdrawalController', 'Error creating withdrawal request', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tuserId: userService.getUserFromRequest(req)?.id\n\t\t\t});\n\t\t\tnext(error);\n\t\t}\n\t}\n\n\t/**\n\t * Get user's withdrawal history\n\t */\n\tasync getWithdrawalHistory(req: Request, res: Response, next: NextFunction) {\n\t\ttry {\n\t\t\tif (!userService.getUserFromRequest(req)) {\n\t\t\t\treturn res.status(401).json({ error: 'User not authenticated' });\n\t\t\t}\n\n\t\t\tconst userId = (userService.getUserFromRequest(req) as { id: UserId }).id;\n\t\t\tconst page = parseInt(req.query.page as string) || 1;\n\t\t\tconst limit = parseInt(req.query.limit as string) || 10;\n\t\t\tconst offset = (page - 1) * limit;\n\n\t\t\tconst withdrawals = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: withdrawalRequests.id,\n\t\t\t\t\tamount: withdrawalRequests.amount,\n\t\t\t\t\tstatus: withdrawalRequests.status,\n\t\t\t\t\twalletAddress: withdrawalRequests.walletAddress,\n\t\t\t\t\tprocessingFee: withdrawalRequests.processingFee,\n\t\t\t\t\trequestNotes: withdrawalRequests.requestNotes,\n\t\t\t\t\tadminNotes: withdrawalRequests.adminNotes,\n\t\t\t\t\tcreatedAt: withdrawalRequests.createdAt,\n\t\t\t\t\tfulfilledAt: withdrawalRequests.fulfilledAt\n\t\t\t\t})\n\t\t\t\t.from(withdrawalRequests)\n\t\t\t\t.where(eq(withdrawalRequests.userId, userId))\n\t\t\t\t.orderBy(desc(withdrawalRequests.createdAt))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\t// Get total count\n\t\t\tconst [countResult] = await db\n\t\t\t\t.select({ count: sql<number>`COUNT(*)` })\n\t\t\t\t.from(withdrawalRequests)\n\t\t\t\t.where(eq(withdrawalRequests.userId, userId));\n\n\t\t\tres.json({\n\t\t\t\twithdrawals: withdrawals.map((w) => ({\n\t\t\t\t\t...w,\n\t\t\t\t\tamount: w.amount / 100, // Convert from cents\n\t\t\t\t\tprocessingFee: w.processingFee / 100\n\t\t\t\t})),\n\t\t\t\tpagination: {\n\t\t\t\t\tpage,\n\t\t\t\t\tlimit,\n\t\t\t\t\ttotal: countResult?.count || 0,\n\t\t\t\t\tpages: Math.ceil((countResult?.count || 0) / limit)\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('WithdrawalController', 'Error getting withdrawal history', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tuserId: userService.getUserFromRequest(req)?.id\n\t\t\t});\n\t\t\tnext(error);\n\t\t}\n\t}\n\n\t/**\n\t * Admin: Get all withdrawal requests\n\t */\n\tasync getAllWithdrawalRequests(req: Request, res: Response, next: NextFunction) {\n\t\ttry {\n\t\t\tconst status = req.query.status as (typeof withdrawalStatusEnum.enumValues)[number];\n\t\t\tconst page = parseInt(req.query.page as string) || 1;\n\t\t\tconst limit = parseInt(req.query.limit as string) || 20;\n\t\t\tconst offset = (page - 1) * limit;\n\n\t\t\tconst conditions = [];\n\t\t\tif (status && withdrawalStatusEnum.enumValues.includes(status)) {\n\t\t\t\tconditions.push(eq(withdrawalRequests.status, status));\n\t\t\t}\n\n\t\t\tconst withdrawals = await db\n\t\t\t\t.select({\n\t\t\t\t\tid: withdrawalRequests.id,\n\t\t\t\t\tuserId: withdrawalRequests.userId,\n\t\t\t\t\tusername: users.username,\n\t\t\t\t\temail: users.email,\n\t\t\t\t\tamount: withdrawalRequests.amount,\n\t\t\t\t\tstatus: withdrawalRequests.status,\n\t\t\t\t\twalletAddress: withdrawalRequests.walletAddress,\n\t\t\t\t\tprocessingFee: withdrawalRequests.processingFee,\n\t\t\t\t\trequestNotes: withdrawalRequests.requestNotes,\n\t\t\t\t\tadminNotes: withdrawalRequests.adminNotes,\n\t\t\t\t\tcreatedAt: withdrawalRequests.createdAt,\n\t\t\t\t\tfulfilledAt: withdrawalRequests.fulfilledAt\n\t\t\t\t})\n\t\t\t\t.from(withdrawalRequests)\n\t\t\t\t.leftJoin(users, eq(withdrawalRequests.userId, users.id))\n\t\t\t\t.where(conditions.length > 0 ? and(...conditions) : undefined)\n\t\t\t\t.orderBy(desc(withdrawalRequests.createdAt))\n\t\t\t\t.limit(limit)\n\t\t\t\t.offset(offset);\n\n\t\t\t// Get total count\n\t\t\tconst [countResult] = await db\n\t\t\t\t.select({ count: sql<number>`COUNT(*)` })\n\t\t\t\t.from(withdrawalRequests)\n\t\t\t\t.where(conditions.length > 0 ? and(...conditions) : undefined);\n\n\t\t\tres.json({\n\t\t\t\twithdrawals: withdrawals.map((w) => ({\n\t\t\t\t\t...w,\n\t\t\t\t\tamount: w.amount / 100, // Convert from cents\n\t\t\t\t\tprocessingFee: w.processingFee / 100\n\t\t\t\t})),\n\t\t\t\tpagination: {\n\t\t\t\t\tpage,\n\t\t\t\t\tlimit,\n\t\t\t\t\ttotal: countResult?.count || 0,\n\t\t\t\t\tpages: Math.ceil((countResult?.count || 0) / limit)\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('WithdrawalController', 'Error getting all withdrawal requests', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error)\n\t\t\t});\n\t\t\tnext(error);\n\t\t}\n\t}\n\n\t/**\n\t * Admin: Process withdrawal request (approve/reject)\n\t */\n\tasync processWithdrawalRequest(req: Request, res: Response, next: NextFunction) {\n\t\ttry {\n\t\t\tconst adminId = (userService.getUserFromRequest(req) as { id: UserId }).id;\n\t\t\tconst requestId = req.params.requestId as EntityId;\n\t\t\tconst { action, adminNotes } = processWithdrawalSchema.parse(req.body);\n\n\t\t\t// Get withdrawal request\n\t\t\tconst [withdrawalRequest] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(withdrawalRequests)\n\t\t\t\t.where(eq(withdrawalRequests.id, requestId));\n\n\t\t\tif (!withdrawalRequest) {\n\t\t\t\treturn res.status(404).json({ error: 'Withdrawal request not found' });\n\t\t\t}\n\n\t\t\tif (withdrawalRequest.status !== 'pending') {\n\t\t\t\treturn res.status(400).json({\n\t\t\t\t\terror: 'Only pending requests can be processed',\n\t\t\t\t\tcurrentStatus: withdrawalRequest.status\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (action === 'approve') {\n\t\t\t\t// TODO: Implement actual withdrawal via CCPayment\n\t\t\t\t// For now, we'll just update the status\n\n\t\t\t\tawait db\n\t\t\t\t\t.update(withdrawalRequests)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tstatus: 'approved',\n\t\t\t\t\t\tadminNotes,\n\t\t\t\t\t\tprocessedBy: adminId,\n\t\t\t\t\t\tfulfilledAt: new Date(),\n\t\t\t\t\t\tprocessed: true\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(withdrawalRequests.id, requestId));\n\n\t\t\t\tlogger.info('WithdrawalController', 'Withdrawal request approved', {\n\t\t\t\t\trequestId,\n\t\t\t\t\tadminId,\n\t\t\t\t\tamount: withdrawalRequest.amount / 100\n\t\t\t\t});\n\n\t\t\t\tres.json({\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tmessage: 'Withdrawal request approved',\n\t\t\t\t\trequestId\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Reject and refund DGT\n\t\t\t\tawait db\n\t\t\t\t\t.update(withdrawalRequests)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tstatus: 'rejected',\n\t\t\t\t\t\tadminNotes,\n\t\t\t\t\t\tprocessedBy: adminId,\n\t\t\t\t\t\tprocessed: true\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(withdrawalRequests.id, requestId));\n\n\t\t\t\t// Calculate DGT to refund\n\t\t\t\tconst totalAmountUSD = (withdrawalRequest.amount + withdrawalRequest.processingFee) / 100;\n\t\t\t\tconst dgtToRefund = BigInt(\n\t\t\t\t\tMath.ceil((totalAmountUSD / walletConfig.DGT.PRICE_USD) * 100000000)\n\t\t\t\t);\n\n\t\t\t\t// Refund DGT to user\n\t\t\t\tawait dgtService.addDGT(\n\t\t\t\t\twithdrawalRequest.userId,\n\t\t\t\t\tdgtToRefund,\n\t\t\t\t\t'WITHDRAWAL_REFUND',\n\t\t\t\t\t`Refund for rejected withdrawal #${requestId}`,\n\t\t\t\t\t{ withdrawalRequestId: requestId }\n\t\t\t\t);\n\n\t\t\t\tlogger.info('WithdrawalController', 'Withdrawal request rejected', {\n\t\t\t\t\trequestId,\n\t\t\t\t\tadminId,\n\t\t\t\t\tdgtRefunded: Number(dgtToRefund) / 100000000\n\t\t\t\t});\n\n\t\t\t\tres.json({\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tmessage: 'Withdrawal request rejected and DGT refunded',\n\t\t\t\t\trequestId\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (error instanceof z.ZodError) {\n\t\t\t\treturn res.status(400).json({ error: 'Invalid request', details: error.errors });\n\t\t\t}\n\t\t\tlogger.error('WithdrawalController', 'Error processing withdrawal request', {\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\trequestId: req.params.requestId\n\t\t\t});\n\t\t\tnext(error);\n\t\t}\n\t}\n}\n\nexport const withdrawalController = new WithdrawalController();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/xp/events/xp.events.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpEvent' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":110,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":110,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'username' is defined but never used.","line":140,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":140,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'levelUpEvent' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":268,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":268,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpEvent' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":372,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":372,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * XP Event Handlers\n *\n * Centralized event handlers for XP-related actions in the system.\n * This separates event logic from service logic for better modularity.\n */\n\nimport { db } from '@db';\nimport {\n\tusers,\n\tlevels,\n\tbadges,\n\ttitles,\n\tuserBadges,\n\tuserTitles,\n\tnotifications,\n\txpAdjustmentLogs\n} from '@schema';\nimport { eq, desc } from 'drizzle-orm';\nimport { logger } from '../../../core/logger';\nimport { dgtService } from '../../wallet/dgt.service';\nimport { PgTransaction } from 'drizzle-orm/pg-core';\nimport type { UserId } from '@shared/types';\n\n// Re-export event types from the main events file\nimport { XpGainEvent, XpLossEvent, LevelUpEvent } from '../xp.events';\nexport { XpGainEvent, XpLossEvent, LevelUpEvent };\n\n/**\n * Handle XP award event\n * Central function to process XP gain and trigger appropriate side effects\n */\nexport async function handleXpAward(\n\tuserId: UserId,\n\tamount: number,\n\tsource: string,\n\treason?: string\n): Promise<{\n\toldXp: number;\n\tnewXp: number;\n\toldLevel: number;\n\tnewLevel: number;\n\tleveledUp: boolean;\n}> {\n\tlogger.info('XP_EVENTS', `Awarding ${amount} XP to user ${userId} for ${source}`);\n\n\ttry {\n\t\t// Start transaction for atomic operations\n\t\treturn await db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Get current user state\n\t\t\tconst userResult = await tx\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\txp: users.xp,\n\t\t\t\t\tlevel: users.level,\n\t\t\t\t\tusername: users.username\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userResult.length === 0) {\n\t\t\t\tthrow new Error(`User ${userId} not found`);\n\t\t\t}\n\n\t\t\tconst user = userResult[0];\n\t\t\tconst oldXp = user.xp;\n\t\t\tconst oldLevel = user.level;\n\t\t\tconst newXp = oldXp + amount;\n\n\t\t\t// Update user's XP\n\t\t\tawait tx\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\txp: newXp,\n\t\t\t\t\tlastXpGainDate: new Date(),\n\t\t\t\t\tdailyXpGained: db.sql`COALESCE(daily_xp_gained, 0) + ${amount}`\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\t// Log the XP adjustment\n\t\t\tawait tx.insert(xpAdjustmentLogs).values({\n\t\t\t\tuserId,\n\t\t\t\tadminId: 1, // System user ID\n\t\t\t\tadjustmentType: 'add',\n\t\t\t\tamount,\n\t\t\t\treason: `${reason || source} (${source})`,\n\t\t\t\toldXp,\n\t\t\t\tnewXp\n\t\t\t});\n\n\t\t\t// Calculate new level based on XP\n\t\t\tconst levelsData = await tx\n\t\t\t\t.select()\n\t\t\t\t.from(levels)\n\t\t\t\t.where(db.sql`min_xp <= ${newXp}`)\n\t\t\t\t.orderBy(desc(levels.level))\n\t\t\t\t.limit(1);\n\n\t\t\t// If no levels data found, use default level 1\n\t\t\tconst newLevel = levelsData.length > 0 ? levelsData[0].level : 1;\n\t\t\tconst leveledUp = newLevel > oldLevel;\n\n\t\t\t// If level up occurred, handle it\n\t\t\tif (leveledUp) {\n\t\t\t\tawait handleLevelUp(tx, userId, oldLevel, newLevel, user.username);\n\t\t\t}\n\n\t\t\t// Create an XP gain event (for event listeners)\n\t\t\tconst xpEvent = new XpGainEvent(userId, amount, source);\n\n\t\t\t// Return the results\n\t\t\treturn {\n\t\t\t\toldXp,\n\t\t\t\tnewXp,\n\t\t\t\toldLevel,\n\t\t\t\tnewLevel,\n\t\t\t\tleveledUp\n\t\t\t};\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_EVENTS',\n\t\t\t'Error handling XP award:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tthrow error;\n\t}\n}\n\n/**\n * Handle user level up\n * Process rewards and notifications when a user levels up\n */\nexport async function handleLevelUp(\n\ttx: any, // Transaction context\n\tuserId: UserId,\n\toldLevel: number,\n\tnewLevel: number,\n\tusername?: string\n): Promise<{\n\trewards: {\n\t\tdgt?: number;\n\t\ttitle?: string;\n\t\tbadge?: string;\n\t};\n}> {\n\tlogger.info('XP_EVENTS', `User ${userId} leveled up from ${oldLevel} to ${newLevel}`);\n\n\ttry {\n\t\t// Update user's level\n\t\tawait tx.update(users).set({ level: newLevel }).where(eq(users.id, userId));\n\n\t\t// Get level data for rewards\n\t\tconst levelData = await tx.select().from(levels).where(eq(levels.level, newLevel)).limit(1);\n\n\t\tif (levelData.length === 0) {\n\t\t\tthrow new Error(`Level ${newLevel} not found`);\n\t\t}\n\n\t\tconst rewards: { dgt?: number; title?: string; badge?: string } = {};\n\n\t\t// Process DGT reward\n\t\tif (levelData[0].rewardDgt && levelData[0].rewardDgt > 0) {\n\t\t\trewards.dgt = levelData[0].rewardDgt;\n\n\t\t\t// Award DGT to user wallet using dgtService\n\t\t\tawait dgtService.addDgt(\n\t\t\t\tuserId,\n\t\t\t\tBigInt(levelData[0].rewardDgt), // Ensure amount is BigInt\n\t\t\t\t'REWARD', // DgtTransactionType\n\t\t\t\t{\n\t\t\t\t\treason: 'level_up_reward',\n\t\t\t\t\tsource: `level:${newLevel}`,\n\t\t\t\t\tlevelAchieved: newLevel\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t// Process title reward\n\t\tif (levelData[0].rewardTitleId) {\n\t\t\tconst titleResult = await tx\n\t\t\t\t.select()\n\t\t\t\t.from(titles)\n\t\t\t\t.where(eq(titles.id, levelData[0].rewardTitleId as number))\n\t\t\t\t.limit(1);\n\n\t\t\tif (titleResult.length > 0) {\n\t\t\t\tconst title = titleResult[0];\n\n\t\t\t\t// Check if user already has this title\n\t\t\t\tconst existingTitle = await tx\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(userTitles)\n\t\t\t\t\t.where(eq(userTitles.userId, userId), eq(userTitles.titleId, title.id))\n\t\t\t\t\t.limit(1);\n\n\t\t\t\t// Award title if user doesn't have it\n\t\t\t\tif (existingTitle.length === 0) {\n\t\t\t\t\tawait tx.insert(userTitles).values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\ttitleId: title.id,\n\t\t\t\t\t\tawardedAt: new Date()\n\t\t\t\t\t});\n\n\t\t\t\t\trewards.title = title.name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Process badge reward\n\t\tif (levelData[0].rewardBadgeId) {\n\t\t\tconst badgeResult = await tx\n\t\t\t\t.select()\n\t\t\t\t.from(badges)\n\t\t\t\t.where(eq(badges.id, levelData[0].rewardBadgeId as number))\n\t\t\t\t.limit(1);\n\n\t\t\tif (badgeResult.length > 0) {\n\t\t\t\tconst badge = badgeResult[0];\n\n\t\t\t\t// Check if user already has this badge\n\t\t\t\tconst existingBadge = await tx\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(userBadges)\n\t\t\t\t\t.where(eq(userBadges.userId, userId), eq(userBadges.badgeId, badge.id))\n\t\t\t\t\t.limit(1);\n\n\t\t\t\t// Award badge if user doesn't have it\n\t\t\t\tif (existingBadge.length === 0) {\n\t\t\t\t\tawait tx.insert(userBadges).values({\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tbadgeId: badge.id,\n\t\t\t\t\t\tawardedAt: new Date()\n\t\t\t\t\t});\n\n\t\t\t\t\trewards.badge = badge.name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create notification for user\n\t\tconst rewardText = [\n\t\t\trewards.dgt ? `${rewards.dgt} DGT` : '',\n\t\t\trewards.title ? `\"${rewards.title}\" title` : '',\n\t\t\trewards.badge ? `\"${rewards.badge}\" badge` : ''\n\t\t]\n\t\t\t.filter(Boolean)\n\t\t\t.join(', ');\n\n\t\tconst notificationMessage = rewardText\n\t\t\t? `Congratulations! You've reached level ${newLevel} and received ${rewardText}!`\n\t\t\t: `Congratulations! You've reached level ${newLevel}!`;\n\n\t\tawait tx.insert(notifications).values({\n\t\t\tuserId,\n\t\t\ttype: 'achievement',\n\t\t\ttitle: 'Level Up!',\n\t\t\tbody: notificationMessage,\n\t\t\tdata: {\n\t\t\t\toldLevel,\n\t\t\t\tnewLevel,\n\t\t\t\trewards\n\t\t\t}\n\t\t});\n\n\t\t// Create a LevelUp event (for event listeners)\n\t\tconst levelUpEvent = new LevelUpEvent(userId, oldLevel, newLevel, 0);\n\n\t\treturn { rewards };\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_EVENTS',\n\t\t\t`Error handling level up for user ${userId}:`,\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tthrow error;\n\t}\n}\n\n/**\n * Handle XP loss\n * Process logic when a user loses XP (admin adjustment, penalty, etc.)\n */\nexport async function handleXpLoss(\n\tuserId: UserId,\n\tamount: number,\n\treason: string\n): Promise<{\n\toldXp: number;\n\tnewXp: number;\n\tlevelChanged: boolean;\n\tnewLevel: number;\n}> {\n\tlogger.info('XP_EVENTS', `Removing ${amount} XP from user ${userId} for ${reason}`);\n\n\ttry {\n\t\treturn await db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Get current user state\n\t\t\tconst userResult = await tx\n\t\t\t\t.select({\n\t\t\t\t\tid: users.id,\n\t\t\t\t\txp: users.xp,\n\t\t\t\t\tlevel: users.level\n\t\t\t\t})\n\t\t\t\t.from(users)\n\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t.limit(1);\n\n\t\t\tif (userResult.length === 0) {\n\t\t\t\tthrow new Error(`User ${userId} not found`);\n\t\t\t}\n\n\t\t\tconst user = userResult[0];\n\t\t\tconst oldXp = user.xp;\n\t\t\tconst oldLevel = user.level;\n\n\t\t\t// Ensure XP doesn't go negative\n\t\t\tconst amountToRemove = Math.min(amount, oldXp);\n\t\t\tconst newXp = oldXp - amountToRemove;\n\n\t\t\t// Update user's XP\n\t\t\tawait tx\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\txp: newXp\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\t// Log the XP adjustment\n\t\t\tawait tx.insert(xpAdjustmentLogs).values({\n\t\t\t\tuserId,\n\t\t\t\tadminId: 1, // System user ID\n\t\t\t\tadjustmentType: 'subtract',\n\t\t\t\tamount: amountToRemove,\n\t\t\t\treason,\n\t\t\t\toldXp,\n\t\t\t\tnewXp\n\t\t\t});\n\n\t\t\t// Calculate new level based on XP\n\t\t\tconst levelsData = await tx\n\t\t\t\t.select()\n\t\t\t\t.from(levels)\n\t\t\t\t.where(db.sql`min_xp <= ${newXp}`)\n\t\t\t\t.orderBy(desc(levels.level))\n\t\t\t\t.limit(1);\n\n\t\t\t// If no levels data found, use default level 1\n\t\t\tconst newLevel = levelsData.length > 0 ? levelsData[0].level : 1;\n\t\t\tconst levelChanged = newLevel < oldLevel;\n\n\t\t\t// If level changed, update user's level\n\t\t\tif (levelChanged) {\n\t\t\t\tawait tx.update(users).set({ level: newLevel }).where(eq(users.id, userId));\n\n\t\t\t\t// Create notification for level change\n\t\t\t\tawait tx.insert(notifications).values({\n\t\t\t\t\tuserId,\n\t\t\t\t\ttype: 'info',\n\t\t\t\t\ttitle: 'Level Changed',\n\t\t\t\t\tbody: `Your level has changed from ${oldLevel} to ${newLevel} due to an XP adjustment.`,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\toldLevel,\n\t\t\t\t\t\tnewLevel,\n\t\t\t\t\t\treason\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Create an XP loss event (for event listeners)\n\t\t\tconst xpEvent = new XpLossEvent(userId, amountToRemove, reason);\n\n\t\t\treturn {\n\t\t\t\toldXp,\n\t\t\t\tnewXp,\n\t\t\t\tlevelChanged,\n\t\t\t\tnewLevel\n\t\t\t};\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'XP_EVENTS',\n\t\t\t'Error handling XP loss:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tthrow error;\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/xp/xp-actions-schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/xp/xp-actions.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eq' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'XP_ACTION' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getXpActions' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'loadXpActionsFromDb' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":5,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '@db';\nimport { xpActionSettings } from '@schema';\nimport { eq } from 'drizzle-orm';\nimport { logger } from '../../core/logger';\nimport { XP_ACTION, getXpActions, loadXpActionsFromDb } from '../xp-actions';\n\n/**\n * Get all XP action settings\n */\nexport async function getAllXpActionSettings() {\n\ttry {\n\t\treturn await db.select().from(xpActionSettings);\n\t} catch (error) {\n\t\tlogger.error('Error getting XP action settings:', error);\n\t\tthrow error;\n\t}\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/xp/xp-actions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * XP Actions Registry\n *\n * This module defines all actions that can award XP in the system.\n * These actions are used by the XP service to grant XP to users.\n */\n\nimport { xpActionSettings, users } from '@schema';\nimport { eq, and, sql } from 'drizzle-orm';\nimport { db } from '@db';\n// Removed unused imports from xp-actions-schema\nimport { logger } from '../../core/logger';\n\n/**\n * Enum of all possible XP-granting actions in the system\n */\nexport enum XP_ACTION {\n\tPOST_CREATED = 'post_created',\n\tTHREAD_CREATED = 'thread_created',\n\tRECEIVED_LIKE = 'received_like',\n\tDAILY_LOGIN = 'daily_login',\n\tUSER_MENTIONED = 'user_mentioned',\n\tREPLY_RECEIVED = 'reply_received',\n\tPROFILE_COMPLETED = 'profile_completed',\n\tFRAME_EQUIPPED = 'frame_equipped'\n}\n\n/**\n * Configuration for an XP action\n */\nexport interface XpActionConfig {\n\tkey: XP_ACTION | string;\n\tbaseValue: number;\n\tdescription: string;\n\tmaxPerDay?: number;\n\tcooldownSeconds?: number;\n\tenabled?: boolean;\n}\n\n/**\n * Default XP action configurations\n *\n * These are used as fallbacks if database values aren't available\n * They're also used to seed the database initially\n */\nexport const DEFAULT_XP_ACTIONS: Record<XP_ACTION, XpActionConfig> = {\n\t[XP_ACTION.POST_CREATED]: {\n\t\tkey: XP_ACTION.POST_CREATED,\n\t\tbaseValue: 10,\n\t\tdescription: 'Created a post',\n\t\tmaxPerDay: 100\n\t},\n\t[XP_ACTION.THREAD_CREATED]: {\n\t\tkey: XP_ACTION.THREAD_CREATED,\n\t\tbaseValue: 30,\n\t\tdescription: 'Started a thread'\n\t},\n\t[XP_ACTION.RECEIVED_LIKE]: {\n\t\tkey: XP_ACTION.RECEIVED_LIKE,\n\t\tbaseValue: 5,\n\t\tdescription: 'Received a like',\n\t\tmaxPerDay: 50\n\t},\n\t[XP_ACTION.DAILY_LOGIN]: {\n\t\tkey: XP_ACTION.DAILY_LOGIN,\n\t\tbaseValue: 5,\n\t\tdescription: 'Daily login bonus',\n\t\tcooldownSeconds: 86400 // 24 hours\n\t},\n\t[XP_ACTION.USER_MENTIONED]: {\n\t\tkey: XP_ACTION.USER_MENTIONED,\n\t\tbaseValue: 2,\n\t\tdescription: 'Mentioned another user',\n\t\tmaxPerDay: 20\n\t},\n\t[XP_ACTION.REPLY_RECEIVED]: {\n\t\tkey: XP_ACTION.REPLY_RECEIVED,\n\t\tbaseValue: 3,\n\t\tdescription: 'Received a reply to post',\n\t\tmaxPerDay: 50\n\t},\n\t[XP_ACTION.PROFILE_COMPLETED]: {\n\t\tkey: XP_ACTION.PROFILE_COMPLETED,\n\t\tbaseValue: 50,\n\t\tdescription: 'Completed user profile',\n\t\tcooldownSeconds: 604800 // One-time bonus (1 week cooldown as safety)\n\t},\n\t[XP_ACTION.FRAME_EQUIPPED]: {\n\t\tkey: XP_ACTION.FRAME_EQUIPPED,\n\t\tbaseValue: 5,\n\t\tdescription: 'Equipped an avatar frame'\n\t}\n};\n\n// Cache for XP actions\nlet xpActionsCache: Record<string, XpActionConfig> | null = null;\nlet cacheLastUpdated: number = 0;\nconst CACHE_TTL = 60 * 1000; // 1 minute\n\n/**\n * Load XP action configurations from the database\n * Includes caching to reduce database queries\n */\nexport async function loadXpActionsFromDb(\n\tforceRefresh = false\n): Promise<Record<string, XpActionConfig>> {\n\tconst now = Date.now();\n\n\t// Return from cache if it's still valid and no force refresh requested\n\tif (xpActionsCache && !forceRefresh && now - cacheLastUpdated < CACHE_TTL) {\n\t\treturn xpActionsCache;\n\t}\n\n\ttry {\n\t\t// Get all enabled XP actions from database\n\t\tconst actions = await db\n\t\t\t.select()\n\t\t\t.from(xpActionSettings)\n\t\t\t.where(eq(xpActionSettings.enabled, true));\n\n\t\t// If no actions found in database, use defaults\n\t\tif (!actions || actions.length === 0) {\n\t\t\tlogger.warn('XP_ACTIONS', 'No XP actions found in database, using defaults');\n\t\t\txpActionsCache = DEFAULT_XP_ACTIONS;\n\t\t\tcacheLastUpdated = now;\n\t\t\treturn DEFAULT_XP_ACTIONS;\n\t\t}\n\n\t\t// Convert to the expected format\n\t\tconst map: Record<string, XpActionConfig> = {};\n\t\tactions.forEach((action) => {\n\t\t\tmap[action.action] = {\n\t\t\t\tkey: action.action,\n\t\t\t\tbaseValue: action.baseValue,\n\t\t\t\tdescription: action.description,\n\t\t\t\tmaxPerDay: action.maxPerDay || undefined,\n\t\t\t\tcooldownSeconds: action.cooldownSec || undefined,\n\t\t\t\tenabled: true\n\t\t\t};\n\t\t});\n\n\t\t// Update cache\n\t\txpActionsCache = map;\n\t\tcacheLastUpdated = now;\n\n\t\treturn map;\n\t} catch (error) {\n\t\t// On error, log and fall back to defaults\n\t\tlogger.error(\n\t\t\t'XP_ACTIONS',\n\t\t\t'Error loading XP actions from database:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\treturn DEFAULT_XP_ACTIONS;\n\t}\n}\n\n/**\n * Get all configured XP actions\n */\nexport async function getXpActions(): Promise<Record<string, XpActionConfig>> {\n\treturn loadXpActionsFromDb();\n}\n\n/**\n * Get an XP action configuration\n */\nexport async function getXpAction(key: XP_ACTION | string): Promise<XpActionConfig | null> {\n\tconst actions = await loadXpActionsFromDb();\n\tconst action = actions[key];\n\n\tif (!action) {\n\t\tlogger.warn('XP_ACTIONS', `Unknown XP action requested: ${key}`);\n\t\treturn null;\n\t}\n\n\treturn action;\n}\n\n/**\n * Get the base XP value for an action\n */\nexport async function getXpValueForAction(key: XP_ACTION | string): Promise<number> {\n\tconst action = await getXpAction(key);\n\treturn action ? action.baseValue : 0;\n}\n\n/**\n * Legacy synchronous functions for backward compatibility\n * These will be deprecated in favor of the async versions above\n */\n\n// Backwards compatibility for code not yet updated to async\nexport const XP_ACTIONS = DEFAULT_XP_ACTIONS;\n\n// Legacy sync methods - to be deprecated\nexport function getXpActionSync(key: XP_ACTION): XpActionConfig | null {\n\tconst action = XP_ACTIONS[key];\n\tif (!action) {\n\t\tlogger.warn('XP_ACTIONS', `Unknown XP action requested (sync): ${key}`);\n\t\treturn null;\n\t}\n\treturn action;\n}\n\nexport function getXpValueForActionSync(key: XP_ACTION): number {\n\tconst action = getXpActionSync(key);\n\treturn action ? action.baseValue : 0;\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/xp/xp.admin.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAuthenticated' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAdmin' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":9,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * XP Admin Routes\n *\n * API endpoints for admin-specific XP system management\n */\n\nimport { Router } from 'express';\nimport * as adminXpController from './xp.controller';\nimport { isAuthenticated, isAdmin } from '../auth/middleware/auth.middleware';\nimport { asyncHandler } from '../../core/errors';\n\nconst router = Router();\n\n// XP adjustments\nrouter.post('/adjust', asyncHandler(adminXpController.adjustUserXp));\nrouter.get('/adjust/history/:userId', asyncHandler(adminXpController.getXpAdjustmentHistory));\n\n// XP actions\nrouter.get('/actions', asyncHandler(adminXpController.getAllXpActions));\nrouter.post('/actions', asyncHandler(adminXpController.createXpAction));\nrouter.put('/actions/:actionKey', asyncHandler(adminXpController.updateXpAction));\nrouter.delete('/actions/:actionKey', asyncHandler(adminXpController.deleteXpAction));\n\n// Levels\nrouter.get('/levels', asyncHandler(adminXpController.getAllLevels));\nrouter.post('/levels', asyncHandler(adminXpController.createLevel));\nrouter.put('/levels/:level', asyncHandler(adminXpController.updateLevel));\nrouter.delete('/levels/:level', asyncHandler(adminXpController.deleteLevel));\n\n// Badges\nrouter.get('/badges', asyncHandler(adminXpController.getAllBadges));\nrouter.post('/badges', asyncHandler(adminXpController.createBadge));\nrouter.put('/badges/:id', asyncHandler(adminXpController.updateBadge));\nrouter.delete('/badges/:id', asyncHandler(adminXpController.deleteBadge));\n\n// Titles\nrouter.get('/titles', asyncHandler(adminXpController.getAllTitles));\nrouter.post('/titles', asyncHandler(adminXpController.createTitle));\nrouter.put('/titles/:id', asyncHandler(adminXpController.updateTitle));\nrouter.delete('/titles/:id', asyncHandler(adminXpController.deleteTitle));\n\n// Stats and metrics\nrouter.get('/stats', asyncHandler(adminXpController.getXpSystemStats));\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/xp/xp.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":17,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpAdjustmentLogs' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":17,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'levels' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":17,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'authenticatedUserId' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":247,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":247,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { userService } from '@server/src/core/services/user.service';\n/**\n * XP Controller\n *\n * Handles API endpoints for XP-related functionality\n */\n\nimport type { Request, Response, NextFunction } from 'express';\nimport { xpService } from './xp.service'; // Changed from XpService to xpService instance\n// import { XpActionLogService } from './xp-action-log.service'; // Removed as not found and not used\n// import { xpAdjustmentLog } from '@schema'; // Removed as unused\nimport { logger } from '../../core/logger';\nimport { XP_ACTION } from './xp-actions';\nimport { db } from '@db';\nimport { xpActionLogs } from './xp-actions-schema';\nimport { desc, eq, and, gte, sql } from 'drizzle-orm';\nimport { xpActionSettings, users, xpAdjustmentLogs, levels } from '@schema'; // Adjusted path\nimport { handleXpAward } from './events/xp.events'; // Assuming this handles level ups and logging\nimport { isValidId } from '@shared/utils/id';\n// import { z } from 'zod'; // Removed as unused\n// import { x } from 'drizzle-orm/select-builder/select'; // Removed as unused\n\n/**\n * Award XP to a user for a specific action (test endpoint)\n */\nexport const awardXpForAction = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst { userId, action, metadata } = req.body;\n\n\t\tif (!userId || !action) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: 'Missing required parameters. userId and action are required.'\n\t\t\t});\n\t\t}\n\n\t\t// Ensure action is valid\n\t\tif (!Object.values(XP_ACTION).includes(action as XP_ACTION)) {\n\t\t\treturn res.status(400).json({\n\t\t\t\tmessage: `Invalid action. Must be one of: ${Object.values(XP_ACTION).join(', ')}`\n\t\t\t});\n\t\t}\n\n\t\tlogger.info('Awarding XP for action (via API)', JSON.stringify({ userId, action, metadata }));\n\n\t\t// Call the service to award XP\n\t\tconst result = await xpService.awardXp(userId, action as XP_ACTION, metadata);\n\n\t\tif (!result) {\n\t\t\treturn res.status(429).json({\n\t\t\t\tmessage: 'Could not award XP. You may have reached a limit for this action.'\n\t\t\t});\n\t\t}\n\n\t\tres.status(200).json({\n\t\t\tmessage: 'XP awarded successfully',\n\t\t\tresult\n\t\t});\n\t} catch (error: any) {\n\t\t// Keep error as any for now, specific handling below\n\t\tlogger.error(\n\t\t\t'Error awarding XP for action:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tif (error.message && error.message.includes('not found')) {\n\t\t\t// This check might need adjustment if error is not Error instance\n\t\t\treturn res.status(404).json({ message: error.message });\n\t\t}\n\t\tnext(error);\n\t}\n};\n\n/**\n * Get information about a user's XP\n */\nexport const getUserXpInfo = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\tconst userId = req.params.userId;\n\n\t\tif (!userId) {\n\t\t\treturn res.status(400).json({ message: 'User ID is required' });\n\t\t}\n\n\t\tconst xpInfo = await xpService.getUserXpInfo(userId);\n\n\t\tres.status(200).json(xpInfo);\n\t} catch (error: any) {\n\t\t// Keep error as any for now\n\t\tlogger.error(\n\t\t\t'Error getting user XP info:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tif (error.message && error.message.includes('not found')) {\n\t\t\t// This check might need adjustment\n\t\t\treturn res.status(404).json({ message: error.message });\n\t\t}\n\t\tnext(error);\n\t}\n};\n\n/**\n * Get all available XP actions and their values\n */\nexport const getXpActions = async (req: Request, res: Response) => {\n\ttry {\n\t\t// Dynamically import to avoid issues if xp-actions itself has problems during initial load\n\t\tconst xpActionsModule = await import('./xp-actions');\n\t\tres.status(200).json({\n\t\t\tactions: Object.values(xpActionsModule.XP_ACTION) // Use the imported module\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'Error getting XP actions:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tres.status(500).json({ message: 'Error retrieving XP actions' });\n\t}\n};\n\n/**\n * Get XP action logs for a user\n *\n * Supports filtering by date range and action type\n */\nexport const getUserXpLogs = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// Get user ID from params or from authenticated user\n\t\tconst paramUserId = req.params.userId;\n\t\tconst authUserId = (userService.getUserFromRequest(req) as any)?.id; // Added type assertion\n\n\t\t// If not admin and trying to access someone else's logs, reject\n\t\tconst isOwnLogs = paramUserId === authUserId;\n\t\tconst isAdmin = (userService.getUserFromRequest(req) as any)?.role === 'admin'; // Added type assertion\n\n\t\tif (!isOwnLogs && !isAdmin) {\n\t\t\treturn res.status(403).json({\n\t\t\t\tmessage: 'You can only access your own XP logs'\n\t\t\t});\n\t\t}\n\n\t\tconst userIdToQuery = paramUserId || authUserId;\n\n\t\tif (!userIdToQuery) {\n\t\t\treturn res.status(400).json({ message: 'User ID is required' });\n\t\t}\n\n\t\t// Parse query parameters\n\t\tconst limit = req.query.limit ? Number(req.query.limit) : 50;\n\t\tconst offset = req.query.offset ? Number(req.query.offset) : 0;\n\t\tconst action = req.query.action as string;\n\n\t\t// Date filters\n\t\tconst startDate = req.query.startDate ? new Date(req.query.startDate as string) : undefined;\n\t\tconst endDate = req.query.endDate ? new Date(req.query.endDate as string) : undefined;\n\t\tconst period = req.query.period as string; // 'today', 'week', 'month'\n\n\t\t// Build the query filters\n\t\tconst filters = [eq(xpActionLogs.userId, userIdToQuery)];\n\n\t\t// Add action filter if specified\n\t\tif (action) {\n\t\t\tfilters.push(eq(xpActionLogs.action, action));\n\t\t}\n\n\t\t// Add date range filters if specified\n\t\tif (startDate) {\n\t\t\tfilters.push(gte(xpActionLogs.createdAt, startDate));\n\t\t}\n\n\t\tif (endDate) {\n\t\t\tfilters.push(sql`${xpActionLogs.createdAt} <= ${endDate}`);\n\t\t}\n\n\t\t// Handle period shortcuts\n\t\tif (period) {\n\t\t\tconst now = new Date();\n\t\t\tlet periodStartDate: Date | null = null; // Initialize to null\n\n\t\t\tswitch (period) {\n\t\t\t\tcase 'today':\n\t\t\t\t\tperiodStartDate = new Date(now.setHours(0, 0, 0, 0));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'week':\n\t\t\t\t\tperiodStartDate = new Date(now);\n\t\t\t\t\tperiodStartDate.setDate(now.getDate() - now.getDay());\n\t\t\t\t\tperiodStartDate.setHours(0, 0, 0, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'month':\n\t\t\t\t\tperiodStartDate = new Date(now.getFullYear(), now.getMonth(), 1);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// If period is invalid, periodStartDate remains null (or explicitly set it again)\n\t\t\t\t\tperiodStartDate = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (periodStartDate !== null) {\n\t\t\t\t// Explicitly check for non-null\n\t\t\t\tfilters.push(gte(xpActionLogs.createdAt, periodStartDate));\n\t\t\t}\n\t\t}\n\n\t\t// Execute the query with all filters\n\t\tconst logs = await db\n\t\t\t.select()\n\t\t\t.from(xpActionLogs)\n\t\t\t.where(and(...filters))\n\t\t\t.orderBy(desc(xpActionLogs.createdAt))\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\n\t\t// Get total count for pagination\n\t\tconst countResult = await db\n\t\t\t.select({ count: sql<number>`count(*)` }) // Added type assertion for sql count\n\t\t\t.from(xpActionLogs)\n\t\t\t.where(and(...filters));\n\n\t\tconst totalCount = Number(countResult[0]?.count || 0);\n\n\t\t// Format the response\n\t\tres.status(200).json({\n\t\t\tlogs,\n\t\t\tpagination: {\n\t\t\t\ttotal: totalCount,\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\thasMore: offset + logs.length < totalCount\n\t\t\t},\n\t\t\tfilters: {\n\t\t\t\taction,\n\t\t\t\tperiod,\n\t\t\t\tstartDate: startDate?.toISOString() || null, // Send ISO string or null\n\t\t\t\tendDate: endDate?.toISOString() || null // Send ISO string or null\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlogger.error(\n\t\t\t'Error getting user XP logs:',\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tnext(error);\n\t}\n};\n\nexport const awardActionXp = async (req: Request, res: Response) => {\n\ttry {\n\t\tconst { userId, action, entityId } = req.body;\n\t\tconst authenticatedUserId = (req as any).user?.id;\n\n\t\tif (!userId || !action || !isValidId(userId)) {\n\t\t\t// entityId can be optional for some actions\n\t\t\treturn res.status(400).json({ error: 'Missing or invalid required parameters (userId, action).' });\n\t\t}\n\n\t\t// Optional: Validate that authenticatedUserId matches userId or is an admin if they differ\n\t\t// if (userId !== authenticatedUserId && !(req as any).user?.isAdmin) {\n\t\t//   return res.status(403).json({ error: 'Forbidden: Cannot award XP for another user.'});\n\t\t// }\n\n\t\tconst [setting] = await db\n\t\t\t.select()\n\t\t\t.from(xpActionSettings)\n\t\t\t.where(eq(xpActionSettings.action, action));\n\n\t\tif (!setting || !setting.enabled) {\n\t\t\tlogger.warn('XP_CONTROLLER', `XP action '${action}' not found or not enabled.`);\n\t\t\t// Return a success to not break client flow, but award 0 XP\n\t\t\treturn res\n\t\t\t\t.status(200)\n\t\t\t\t.json({ xpAwarded: 0, message: 'XP action not configured or disabled.' });\n\t\t}\n\n\t\tconst xpToAward = setting.baseValue;\n\t\tif (xpToAward <= 0) {\n\t\t\treturn res\n\t\t\t\t.status(200)\n\t\t\t\t.json({ xpAwarded: 0, message: 'XP amount for action is zero or negative.' });\n\t\t}\n\n\t\t// Use the centralized event handler for awarding XP\n\t\t// This will handle XP update, logging, and level ups\n\t\tconst { newXp, leveledUp, newLevel } = await handleXpAward(\n\t\t\tuserId,\n\t\t\txpToAward,\n\t\t\taction, // source\n\t\t\t`${action} for entity #${entityId}` // reason for the log\n\t\t);\n\n\t\tres.status(200).json({\n\t\t\txpAwarded: xpToAward,\n\t\t\tnewTotalXp: newXp,\n\t\t\tleveledUp,\n\t\t\tcurrentLevel: newLevel\n\t\t});\n\t} catch (err: any) {\n\t\tlogger.error('XP_CONTROLLER', `Error in awardActionXp for action '${req.body.action}':`, err);\n\t\tres.status(500).json({ error: err.message || 'Server error awarding XP.' });\n\t}\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/xp/xp.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/xp/xp.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/domains/xp/xp.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'titles' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":11,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'badges' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":12,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userBadges' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":13,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userTitles' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":14,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":21,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xpActionLimits' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":27,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleLevelUp' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":29,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MAX_XP_PER_DAY' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":33,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MAX_TIP_XP_PER_DAY' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":33,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'skipLevelCheck' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":63,"column":4,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'skipTriggers' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":64,"column":4,"nodeType":"Identifier","messageId":"unusedVar","endLine":64,"endColumn":16},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":83,"column":6,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":91,"endColumn":17},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":97,"column":6,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":97,"endColumn":32},{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":98,"column":6,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":98,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":430,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":430,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'action' is defined but never used.","line":430,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":430,"endColumn":68}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Core XP Service\n *\n * Central service for managing user XP, levels, and related functionality.\n * This service is used by both admin and public-facing features.\n */\n\nimport {\n\tusers,\n\tlevels,\n\ttitles,\n\tbadges,\n\tuserBadges,\n\tuserTitles,\n\txpAdjustmentLogs,\n\tuserRoles,\n\troles as rolesTable,\n\tforumStructure\n} from '@schema';\nimport type { UserId } from '@shared/types';\nimport { eq, sql, and, desc, gte, lt, asc, gt, count } from 'drizzle-orm';\nimport { db } from '@db';\nimport { MissionsService } from '../missions/missions.service';\nimport { logger } from '../../core/logger';\nimport { getXpAction, XP_ACTION } from './xp-actions';\nimport { LevelUpEvent, XpGainEvent, XpLossEvent } from './xp.events';\nimport { xpActionLogs, xpActionLimits } from './xp-actions-schema';\n// Import the centralized event handlers\nimport { handleXpAward, handleXpLoss, handleLevelUp } from './events/xp.events';\nimport { economyConfig, sanitizeMultiplier } from '@shared/economy/economy.config';\nimport type { AdminId, ForumId, UserId } from '@shared/types';\n\nconst { MAX_XP_PER_DAY, MAX_TIP_XP_PER_DAY } = economyConfig;\n\nexport class XpService {\n\t/**\n\t * Update a user's XP and handle level recalculation\n\t *\n\t * @param userId - User ID to update\n\t * @param amount - Amount to add, subtract, or set\n\t * @param adjustmentType - How to modify XP ('add', 'subtract', or 'set')\n\t * @param options - Additional options\n\t * @returns Object with old and new XP values and level information\n\t */\n\tasync updateUserXp(\n\t\tuserId: UserId,\n\t\tamount: number,\n\t\tadjustmentType: 'add' | 'subtract' | 'set' = 'add',\n\t\toptions: {\n\t\t\treason?: string;\n\t\t\tadminId?: AdminId;\n\t\t\tlogAdjustment?: boolean;\n\t\t\tskipLevelCheck?: boolean;\n\t\t\tskipTriggers?: boolean;\n\t\t} = {}\n\t) {\n\t\tlogger.info('Updating user XP', { userId, amount, adjustmentType, options });\n\n\t\tconst {\n\t\t\treason = 'System adjustment',\n\t\t\tadminId,\n\t\t\tlogAdjustment = true,\n\t\t\tskipLevelCheck = false,\n\t\t\tskipTriggers = false\n\t\t} = options;\n\n\t\t// Use the dedicated handlers based on adjustment type\n\t\ttry {\n\t\t\tlet result;\n\n\t\t\tswitch (adjustmentType) {\n\t\t\t\tcase 'add':\n\t\t\t\t\t// Use handleXpAward for 'add' operations\n\t\t\t\t\tresult = await handleXpAward(userId, amount, 'ADMIN_ADJUSTMENT', reason);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'subtract':\n\t\t\t\t\t// Use handleXpLoss for 'subtract' operations\n\t\t\t\t\tresult = await handleXpLoss(userId, amount, reason);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'set':\n\t\t\t\t\t// For 'set' operations, we need to:\n\t\t\t\t\t// 1. Get current XP\n\t\t\t\t\tconst userArray = await db\n\t\t\t\t\t\t.select({\n\t\t\t\t\t\t\tid: users.id,\n\t\t\t\t\t\t\txp: users.xp,\n\t\t\t\t\t\t\tlevel: users.level\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.from(users)\n\t\t\t\t\t\t.where(eq(users.id, userId))\n\t\t\t\t\t\t.limit(1);\n\n\t\t\t\t\tif (userArray.length === 0) {\n\t\t\t\t\t\tthrow new Error(`User with ID ${userId} not found.`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst user = userArray[0];\n\t\t\t\t\tconst oldXp = user.xp;\n\n\t\t\t\t\t// 2. Determine if we should add or subtract\n\t\t\t\t\tif (amount > oldXp) {\n\t\t\t\t\t\tconst addAmount = amount - oldXp;\n\t\t\t\t\t\tresult = await handleXpAward(userId, addAmount, 'ADMIN_ADJUSTMENT', `Set to ${amount}`);\n\t\t\t\t\t} else if (amount < oldXp) {\n\t\t\t\t\t\tconst subtractAmount = oldXp - amount;\n\t\t\t\t\t\tresult = await handleXpLoss(userId, subtractAmount, `Set to ${amount}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No change needed\n\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\toldXp,\n\t\t\t\t\t\t\tnewXp: oldXp,\n\t\t\t\t\t\t\toldLevel: user.level,\n\t\t\t\t\t\t\tnewLevel: user.level,\n\t\t\t\t\t\t\tleveledUp: false,\n\t\t\t\t\t\t\tlevelChanged: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid adjustment type: ${adjustmentType}`);\n\t\t\t}\n\n\t\t\t// If we have an admin ID and need to log separately\n\t\t\tif (logAdjustment && adminId) {\n\t\t\t\tawait this.logXpAdjustment(\n\t\t\t\t\tuserId,\n\t\t\t\t\tadminId,\n\t\t\t\t\tadjustmentType,\n\t\t\t\t\tamount,\n\t\t\t\t\treason,\n\t\t\t\t\tresult.oldXp,\n\t\t\t\t\tresult.newXp\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tuserId,\n\t\t\t\toldXp: result.oldXp,\n\t\t\t\tnewXp: result.newXp,\n\t\t\t\txpChange: result.newXp - result.oldXp,\n\t\t\t\toldLevel: result.oldLevel,\n\t\t\t\tnewLevel: result.newLevel,\n\t\t\t\tlevelChanged: result.leveledUp\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error('XP_SERVICE', 'Error in updateUserXp:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Log an XP adjustment for auditing purposes\n\t */\n\tprivate async logXpAdjustment(\n\t\tuserId: UserId,\n\t\tadminId: AdminId,\n\t\tadjustmentType: string,\n\t\tamount: number,\n\t\treason: string,\n\t\toldXp: number,\n\t\tnewXp: number\n\t) {\n\t\ttry {\n\t\t\tawait db.insert(xpAdjustmentLogs).values({\n\t\t\t\tuserId,\n\t\t\t\tadminId,\n\t\t\t\tadjustmentType,\n\t\t\t\tamount,\n\t\t\t\treason,\n\t\t\t\toldXp,\n\t\t\t\tnewXp,\n\t\t\t\tcreatedAt: new Date()\n\t\t\t});\n\n\t\t\tlogger.info('XP_SERVICE', 'XP adjustment logged successfully', {\n\t\t\t\tuserId,\n\t\t\t\tadminId,\n\t\t\t\tadjustmentType,\n\t\t\t\tamount\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlogger.error('XP_SERVICE', 'Error logging XP adjustment:', error);\n\t\t\t// Don't throw - just log the error and continue\n\t\t}\n\t}\n\n\t/**\n\t * Get level information for a specific level\n\t */\n\tasync getLevel(levelNumber: number) {\n\t\tconst levelData = await db.select().from(levels).where(eq(levels.level, levelNumber)).limit(1);\n\n\t\treturn levelData[0] || null;\n\t}\n\n\t/**\n\t * Get all levels in ascending order\n\t */\n\tasync getAllLevels() {\n\t\treturn db.select().from(levels).orderBy(asc(levels.level));\n\t}\n\n\t/**\n\t * Get user XP information\n\t */\n\tasync getUserXpInfo(userId: UserId) {\n\t\tconst userArray = await db\n\t\t\t.select({\n\t\t\t\tid: users.id,\n\t\t\t\txp: users.xp,\n\t\t\t\tlevel: users.level,\n\t\t\t\tusername: users.username\n\t\t\t})\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, userId))\n\t\t\t.limit(1);\n\n\t\tif (userArray.length === 0) {\n\t\t\tthrow new Error(`User with ID ${userId} not found.`);\n\t\t}\n\n\t\tconst user = userArray[0];\n\n\t\t// Get current level details\n\t\tconst currentLevelData = await this.getLevel(user.level);\n\n\t\t// Get next level details\n\t\tconst nextLevelData = await db\n\t\t\t.select()\n\t\t\t.from(levels)\n\t\t\t.where(gt(levels.level, user.level))\n\t\t\t.orderBy(asc(levels.level))\n\t\t\t.limit(1);\n\n\t\tconst nextLevel = nextLevelData.length > 0 ? nextLevelData[0] : null;\n\n\t\t// Calculate XP needed for next level\n\t\tconst xpForNextLevel = nextLevel ? nextLevel.minXp - user.xp : 0;\n\n\t\treturn {\n\t\t\tuserId: user.id,\n\t\t\tusername: user.username,\n\t\t\tcurrentXp: user.xp,\n\t\t\tcurrentLevel: user.level,\n\t\t\tcurrentLevelData,\n\t\t\tnextLevel: nextLevel?.level || null,\n\t\t\tnextLevelData: nextLevel || null,\n\t\t\txpForNextLevel,\n\t\t\tprogress: nextLevel\n\t\t\t\t? (user.xp - currentLevelData.minXp) / (nextLevel.minXp - currentLevelData.minXp)\n\t\t\t\t: 1\n\t\t};\n\t}\n\n\t/**\n\t * Award XP to a user for completing an action\n\t *\n\t * @param userId User ID to award XP to\n\t * @param action The action that grants XP\n\t * @param metadata Optional metadata about the action\n\t * @returns Result of the XP update operation\n\t */\n\tasync awardXp(userId: UserId, action: XP_ACTION, metadata?: any) {\n\t\treturn this.awardXpWithContext(userId, action, metadata);\n\t}\n\n\t/**\n\t * Award XP to a user for completing an action with forum context\n\t *\n\t * @param userId User ID to award XP to\n\t * @param action The action that grants XP\n\t * @param metadata Optional metadata about the action\n\t * @param forumId Optional forum ID for forum-specific multipliers\n\t * @returns Result of the XP update operation\n\t */\n\tasync awardXpWithContext(userId: UserId, action: XP_ACTION, metadata?: any, forumId?: ForumId) {\n\t\ttry {\n\t\t\tconst canReceive = await this.checkActionLimits(userId, action);\n\n\t\t\tif (!canReceive) {\n\t\t\t\tlogger.info('XP_SERVICE', `XP not awarded due to limits: ${action}`, { userId, action });\n\t\t\t\treturn; // Do not award XP if limits are hit\n\t\t\t}\n\n\t\t\tconst actionConfig = await getXpAction(action);\n\n\t\t\tif (!actionConfig || !actionConfig.enabled) {\n\t\t\t\tlogger.warn('XP_SERVICE', `Unknown or disabled XP action attempted: ${action}`, {\n\t\t\t\t\tuserId,\n\t\t\t\t\taction\n\t\t\t\t});\n\t\t\t\treturn; // Do not award for unknown or disabled actions\n\t\t\t}\n\n\t\t\t// Get multipliers\n\t\t\tconst roleMultiplier = await this.getUserRoleMultiplier(userId);\n\t\t\tconst forumMultiplier = forumId ? await this.getForumMultiplier(forumId) : 1.0;\n\n\t\t\t// Apply multiplier protection\n\t\t\tconst multiplierResult = sanitizeMultiplier(roleMultiplier, forumMultiplier, {\n\t\t\t\tuserId,\n\t\t\t\tforumId,\n\t\t\t\taction\n\t\t\t});\n\n\t\t\t// Calculate final XP amount\n\t\t\tconst baseXp = actionConfig.baseValue;\n\t\t\tconst finalXp = Math.floor(baseXp * multiplierResult.finalMultiplier);\n\n\t\t\t// Log multiplier violations if any\n\t\t\tif (multiplierResult.wasCapped) {\n\t\t\t\tlogger.warn('XP_SERVICE', 'XP multiplier was capped', {\n\t\t\t\t\tuserId,\n\t\t\t\t\tforumId,\n\t\t\t\t\taction,\n\t\t\t\t\tbaseXp,\n\t\t\t\t\toriginalMultiplier: multiplierResult.originalMultiplier,\n\t\t\t\t\tfinalMultiplier: multiplierResult.finalMultiplier,\n\t\t\t\t\tviolations: multiplierResult.violations\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Log the action with final XP amount\n\t\t\tawait this.logXpAction(userId, action, finalXp, {\n\t\t\t\t...metadata,\n\t\t\t\tbaseXp,\n\t\t\t\troleMultiplier,\n\t\t\t\tforumMultiplier,\n\t\t\t\tfinalMultiplier: multiplierResult.finalMultiplier,\n\t\t\t\twasCapped: multiplierResult.wasCapped\n\t\t\t});\n\n\t\t\t// Update user XP\n\t\t\tconst result = await this.updateUserXp(userId, finalXp, 'add', {\n\t\t\t\treason: `Action: ${action} (${finalXp}XP = ${baseXp} * ${multiplierResult.finalMultiplier.toFixed(2)})`,\n\t\t\t\tskipLevelCheck: false,\n\t\t\t\tskipTriggers: false\n\t\t\t});\n\n\t\t\t// Update action limits after successful award\n\t\t\tawait this.updateActionLimits(userId, action);\n\n\t\t\tlogger.info('XP_SERVICE', `Awarding XP for action: ${action}`, {\n\t\t\t\tuserId,\n\t\t\t\taction,\n\t\t\t\tbaseXp,\n\t\t\t\tfinalXp,\n\t\t\t\tmultiplierUsed: multiplierResult.finalMultiplier,\n\t\t\t\tforumId,\n\t\t\t\tmetadata\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlogger.error('XP_SERVICE', `Error awarding XP for action ${action}:`, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Check if a user can receive XP for a given action based on limits (daily max, cooldown)\n\t */\n\tprivate async checkActionLimits(userId: UserId, action: XP_ACTION): Promise<boolean> {\n\t\ttry {\n\t\t\tconst actionConfig = await getXpAction(action);\n\n\t\t\tif (!actionConfig || !actionConfig.enabled) {\n\t\t\t\t// If action is not configured or disabled, no limits apply (or maybe always allow?)\n\t\t\t\t// For now, assuming if it's not configured, limits don't block\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst now = new Date();\n\n\t\t\t// Check daily max limit\n\t\t\tif (actionConfig.maxPerDay !== undefined) {\n\t\t\t\tconst startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n\t\t\t\tconst endOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\n\n\t\t\t\tconst [dailyCountResult] = await db\n\t\t\t\t\t.select({ count: count() })\n\t\t\t\t\t.from(xpActionLogs)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(xpActionLogs.userId, userId),\n\t\t\t\t\t\t\teq(xpActionLogs.action, action),\n\t\t\t\t\t\t\tgte(xpActionLogs.createdAt, startOfDay),\n\t\t\t\t\t\t\tlt(xpActionLogs.createdAt, endOfDay)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\tif (dailyCountResult && dailyCountResult.count >= actionConfig.maxPerDay) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t'XP_SERVICE',\n\t\t\t\t\t\t`Daily limit reached for XP action ${action} for user ${userId}`\n\t\t\t\t\t);\n\t\t\t\t\treturn false; // Daily limit reached\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check cooldown\n\t\t\tif (actionConfig.cooldownSeconds !== undefined && actionConfig.cooldownSeconds > 0) {\n\t\t\t\tconst [lastAction] = await db\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(xpActionLogs)\n\t\t\t\t\t.where(and(eq(xpActionLogs.userId, userId), eq(xpActionLogs.action, action)))\n\t\t\t\t\t.orderBy(desc(xpActionLogs.createdAt))\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tif (lastAction) {\n\t\t\t\t\tconst timeSinceLastAward =\n\t\t\t\t\t\t(now.getTime() - new Date(lastAction.createdAt).getTime()) / 1000;\n\t\t\t\t\tif (timeSinceLastAward < actionConfig.cooldownSeconds) {\n\t\t\t\t\t\tlogger.warn('XP_SERVICE', `Cooldown active for XP action ${action} for user ${userId}`);\n\t\t\t\t\t\treturn false; // Cooldown active\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true; // No limits hit\n\t\t} catch (error) {\n\t\t\tlogger.error('XP_SERVICE', `Error checking action limits for action ${action}:`, error);\n\t\t\treturn false; // Assume limits block on error\n\t\t}\n\t}\n\n\t/**\n\t * Update action limits for a user after an XP award\n\t */\n\tprivate async updateActionLimits(userId: UserId, action: XP_ACTION): Promise<void> {\n\t\t// This method is a placeholder and currently does nothing as limits are log-based.\n\t\t// private async updateActionLimits(userId: UserId, action: XP_ACTION): Promise<void> {\n\t\t//   const actionConfig = await getXpAction(action); // Use getXpAction\n\t\t//\n\t\t//   if (!actionConfig || !actionConfig.enabled) {\n\t\t//     return; // No limits to update if action is not configured or disabled\n\t\t//   }\n\t\t//\n\t\t//   // Currently, limits are based on logs, so no explicit update is needed here.\n\t\t//   // This method is a placeholder for future limit mechanisms (e.g., per-action counters).\n\t\t// }\n\t}\n\n\t/**\n\t * Log an XP action for auditing and limit tracking\n\t */\n\tprivate async logXpAction(\n\t\tuserId: UserId,\n\t\taction: XP_ACTION,\n\t\tamount: number,\n\t\tmetadata?: any\n\t): Promise<void> {\n\t\ttry {\n\t\t\tawait db.insert(xpActionLogs).values({\n\t\t\t\tuserId,\n\t\t\t\taction,\n\t\t\t\tamount,\n\t\t\t\tmetadata,\n\t\t\t\tcreatedAt: new Date()\n\t\t\t});\n\n\t\t\tlogger.info('XP_SERVICE', `XP Action Logged: ${action}`, { userId, action, amount });\n\t\t} catch (error) {\n\t\t\tlogger.error('XP_SERVICE', 'Error logging XP action:', error);\n\t\t\t// Don't throw - just log the error and continue\n\t\t}\n\t}\n\n\t/**\n\t * Get action limits for a user\n\t *\n\t * @param userId User ID\n\t * @param action The action key\n\t * @returns Object with limit information or null if no limits\n\t */\n\tasync getActionLimitsForUser(\n\t\tuserId: UserId,\n\t\taction: XP_ACTION\n\t): Promise<{\n\t\tdailyLimit: number | null;\n\t\tdailyCount: number;\n\t\tisOnCooldown: boolean;\n\t\tcooldownSeconds: number | null;\n\t\tcooldownRemaining: number;\n\t\ttimeSinceLastAward: number | null;\n\t\tcanReceive: boolean;\n\t} | null> {\n\t\ttry {\n\t\t\tconst actionConfig = await getXpAction(action);\n\n\t\t\tif (!actionConfig || !actionConfig.enabled) {\n\t\t\t\treturn null; // No limits defined for this action\n\t\t\t}\n\n\t\t\tconst now = new Date();\n\t\t\tlet dailyCount = 0;\n\t\t\tlet timeSinceLastAward = -1; // Use -1 to indicate no previous award\n\t\t\tlet onCooldown = false;\n\t\t\tlet cooldownRemaining = 0;\n\n\t\t\t// Check daily count\n\t\t\tif (actionConfig.maxPerDay !== undefined) {\n\t\t\t\tconst startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n\t\t\t\tconst endOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\n\n\t\t\t\tconst [dailyCountResult] = await db\n\t\t\t\t\t.select({ count: count() })\n\t\t\t\t\t.from(xpActionLogs)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(xpActionLogs.userId, userId),\n\t\t\t\t\t\t\teq(xpActionLogs.action, action),\n\t\t\t\t\t\t\tgte(xpActionLogs.createdAt, startOfDay),\n\t\t\t\t\t\t\tlt(xpActionLogs.createdAt, endOfDay)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\tdailyCount = dailyCountResult?.count || 0;\n\t\t\t}\n\n\t\t\t// Check cooldown\n\t\t\tif (actionConfig.cooldownSeconds !== undefined && actionConfig.cooldownSeconds > 0) {\n\t\t\t\tconst [lastAction] = await db\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(xpActionLogs)\n\t\t\t\t\t.where(and(eq(xpActionLogs.userId, userId), eq(xpActionLogs.action, action)))\n\t\t\t\t\t.orderBy(desc(xpActionLogs.createdAt))\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tif (lastAction) {\n\t\t\t\t\ttimeSinceLastAward = (now.getTime() - new Date(lastAction.createdAt).getTime()) / 1000;\n\t\t\t\t\tonCooldown = timeSinceLastAward < actionConfig.cooldownSeconds;\n\t\t\t\t\tcooldownRemaining = onCooldown\n\t\t\t\t\t\t? Math.ceil(actionConfig.cooldownSeconds - timeSinceLastAward)\n\t\t\t\t\t\t: 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdailyLimit: actionConfig.maxPerDay || null,\n\t\t\t\tdailyCount,\n\t\t\t\tisOnCooldown: onCooldown,\n\t\t\t\tcooldownSeconds: actionConfig.cooldownSeconds || null,\n\t\t\t\tcooldownRemaining,\n\t\t\t\ttimeSinceLastAward: timeSinceLastAward >= 0 ? timeSinceLastAward : null,\n\t\t\t\tcanReceive:\n\t\t\t\t\t!onCooldown &&\n\t\t\t\t\t(actionConfig.maxPerDay === undefined || dailyCount < actionConfig.maxPerDay)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlogger.error(\n\t\t\t\t'XP_SERVICE',\n\t\t\t\t`Error getting action limits for user ${userId} action ${action}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t\treturn null; // Return null on error\n\t\t}\n\t}\n\n\t/**\n\t * Get the effective XP multiplier for a user based on their roles.\n\t * If the user has multiple roles, the highest multiplier is applied.\n\t * If the user has no roles with a multiplier > 0, a default of 1 is returned.\n\t */\n\tprivate async getUserRoleMultiplier(userId: UserId): Promise<number> {\n\t\ttry {\n\t\t\tconst roleMultipliers = await db\n\t\t\t\t.select({ multiplier: rolesTable.xpMultiplier })\n\t\t\t\t.from(userRoles)\n\t\t\t\t.innerJoin(rolesTable, eq(userRoles.roleId, rolesTable.id))\n\t\t\t\t.where(eq(userRoles.userId, userId));\n\n\t\t\tif (roleMultipliers.length === 0) return 1;\n\n\t\t\t// Return the highest multiplier the user has\n\t\t\tconst maxMultiplier = Math.max(...roleMultipliers.map((r) => r.multiplier ?? 1));\n\t\t\treturn maxMultiplier > 0 ? maxMultiplier : 1;\n\t\t} catch (error) {\n\t\t\tlogger.error('XP_SERVICE', `Error fetching role XP multiplier for user ${userId}:`, error);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/**\n\t * Get the XP multiplier for a specific forum\n\t */\n\tprivate async getForumMultiplier(forumId: ForumId): Promise<number> {\n\t\ttry {\n\t\t\tconst [forum] = await db\n\t\t\t\t.select({ xpMultiplier: forumStructure.xpMultiplier })\n\t\t\t\t.from(forumStructure)\n\t\t\t\t.where(eq(forumStructure.id, forumId))\n\t\t\t\t.limit(1);\n\n\t\t\treturn forum?.xpMultiplier ?? 1.0;\n\t\t} catch (error) {\n\t\t\tlogger.error('XP_SERVICE', `Error fetching forum XP multiplier for forum ${forumId}:`, error);\n\t\t\treturn 1.0;\n\t\t}\n\t}\n}\n\nexport const xpService = new XpService();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/lib/db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/middleware/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/middleware/authenticate.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getAuthenticatedUser' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":30}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":14,"column":2,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":22,"endColumn":3,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport { db } from '../core/db';\nimport { users } from '@schema';\nimport { eq } from 'drizzle-orm';\nimport type { GroupId, UserId } from '@shared/types/ids';\nimport { getAuthenticatedUser } from \"@server/src/core/utils/auth.helpers\";\nimport { logger } from \"../core/logger\";\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n// Extend Express Request type to include user\ndeclare global {\n\tnamespace Express {\n\t\tinterface User {\n\t\t\tid: UserId;\n\t\t\trole: string;\n\t\t\tusername: string;\n\t\t\temail: string;\n\t\t\tgroupId?: GroupId | undefined;\n\t\t}\n\t}\n}\n\n/**\n * Authentication middleware\n * Validates JWT token and attaches user to request\n */\nexport const authenticate = async (req: Request, res: Response, next: NextFunction) => {\n\ttry {\n\t\t// Get token from header\n\t\tconst authHeader = req.headers.authorization;\n\t\tconst token = authHeader && authHeader.split(' ')[1];\n\n\t\tif (!token) {\n\t\t\treturn res.status(401).json({ error: 'Access denied. No token provided.' });\n\t\t}\n\n\t\t// Verify token\n\t\tconst decoded = jwt.verify(token, process.env.JWT_SECRET as string) as any;\n\n\t\t// Get user from database\n\t\tconst user = await db.query.users.findFirst({\n\t\t\twhere: eq(users.id, decoded.userId),\n\t\t\tcolumns: {\n\t\t\t\tid: true,\n\t\t\t\tusername: true,\n\t\t\t\temail: true,\n\t\t\t\trole: true,\n\t\t\t\tisActive: true,\n\t\t\t\tisBanned: true\n\t\t\t}\n\t\t});\n\n\t\tif (!user) {\n\t\t\treturn res.status(401).json({ error: 'User not found' });\n\t\t}\n\n\t\tif (!user.isActive || user.isBanned) {\n\t\t\treturn res.status(403).json({ error: 'Account is inactive or banned' });\n\t\t}\n\n\t\t// Attach user to request\n\t\t(req as any).user = {\n\t\t\tid: user.id,\n\t\t\tusername: user.username,\n\t\t\temail: user.email,\n\t\t\trole: user.role as string\n\t\t};\n\n\t\tnext();\n\t} catch (error) {\n\t\tif ((error as any).name === 'TokenExpiredError') {\n\t\t\treturn res.status(401).json({ error: 'Token expired' });\n\t\t}\n\n\t\tlogger.error('Authentication error:', error);\n\t\treturn res.status(401).json({ error: 'Invalid token' });\n\t}\n};\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/middleware/dev-security.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/middleware/mission-progress.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/middleware/subscription-permissions.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":18,"column":2,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":22,"endColumn":3,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/middleware/trace.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/middleware/transform-response.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/middleware/validate-request.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/middleware/validate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/routes/api/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/routes/api/store/avatar-frames.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'z' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Router } from 'express';\nimport { avatarFrameStoreService } from '../../domains/cosmetics/avatarFrameStore.service';\nimport { isAuthenticated } from '../../domains/auth/middleware/auth.middleware';\nimport { frameEquipService } from '../../domains/cosmetics/frameEquip.service';\nimport { dgtService } from '../../domains/wallet/dgt.service';\nimport { userService } from '../../core/services/user.service';\nimport { db } from '@db';\nimport { products, avatarFrames } from '@schema';\nimport { eq } from 'drizzle-orm';\nimport { z } from 'zod';\nimport type { FrameId } from '@shared/types';\nimport { CosmeticsTransformer } from '../../../domains/shop/transformers/cosmetics.transformer';\nimport { logger } from \"../../../core/logger\";\n\nconst router = Router();\n\n// GET /api/store/avatar-frames\nrouter.get('/', async (_req, res) => {\n\ttry {\n\t\tconst frames = await avatarFrameStoreService.listAvailableFrames();\n\n\t\t// Transform raw DB rows → public DTOs (security-first)\n\t\tconst transformed = frames.map((frame: any) =>\n\t\t\tCosmeticsTransformer.toPublicCosmetic(frame)\n\t\t);\n\n\t\treturn res.json(transformed);\n\t} catch (error) {\n\t\tlogger.error('Failed to fetch store avatar frames', error);\n\t\treturn res.status(500).json({ error: 'Failed to fetch avatar frames' });\n\t}\n});\n\n// POST /api/store/avatar-frames/:id/purchase\nrouter.post('/:id/purchase', isAuthenticated, async (req, res) => {\n\tconst authUser = userService.getUserFromRequest(req);\n\tif (!authUser) return res.status(401).json({ error: 'Not authenticated' });\n\tconst userId = String(authUser.id);\n\tconst frameId = req.params.id as FrameId;\n\n\ttry {\n\t\t// Fetch frame product with price\n\t\tconst [row] = await db\n\t\t\t.select({ price: products.price, productId: products.id })\n\t\t\t.from(products)\n\t\t\t.innerJoin(avatarFrames, eq(products.frameId, avatarFrames.id))\n\t\t\t.where(eq(avatarFrames.id, frameId))\n\t\t\t.limit(1);\n\n\t\tif (!row) {\n\t\t\treturn res.status(404).json({ error: 'Frame not found' });\n\t\t}\n\n\t\tconst price = row.price ?? 0;\n\n\t\tif (price > 0) {\n\t\t\tawait dgtService.deductDGT(userId, price, 'shop_purchase', undefined, {\n\t\t\t\tshopItemId: row.productId.toString()\n\t\t\t} as any);\n\t\t}\n\n\t\tawait frameEquipService.grantOwnership(userId, frameId, 'shop');\n\t\treturn res.status(200).json({ success: true, price });\n\t} catch (error) {\n\t\tlogger.error('Purchase avatar frame failed', error);\n\t\treturn res.status(500).json({ error: 'Purchase failed' });\n\t}\n});\n\n// POST /api/users/me/frames/:id/equip route is defined in separate router below\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/routes/api/ui.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/routes/api/user/frames.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/routes/dev.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/utils/auth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request } from 'express';\nimport { userService } from '@server/src/core/services/user.service';\nimport { logger } from '@server/src/core/logger'; // Using central logger\n\n/**\n * @deprecated Use userService.getUserFromRequest() instead\n * This utility is maintained for backward compatibility only.\n *\n * Retrieves the user ID from the request object using the centralized userService.\n *\n * @param req - The Express request object.\n * @returns The user ID as a number, or undefined if not found.\n */\nexport function getUserIdFromRequest(req: Request): number | undefined {\n\tconst authUser = userService.getUserFromRequest(req);\n\treturn authUser?.id;\n}\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/utils/db-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/utils/economy-loader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/src/utils/environment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/storage.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'threadTags' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":7,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tags' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":8,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":6},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'contentEditStatusEnum' is defined but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":55,"column":2,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'environment' is assigned a value but never used. Allowed unused vars must match /^[A-Z][A-Za-z0-9]+$/u.","line":78,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":78,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TransactionId, UserId } from '@shared/types';\nimport {\n\tusers,\n\tposts,\n\tthreads,\n\tforumStructure,\n\tthreadTags,\n\ttags,\n\tpostReactions,\n\tsystemNotifications as notifications,\n\tcustomEmojis,\n\tuserGroups,\n\tconversations,\n\tconversationParticipants,\n\tmessages,\n\tmessageReads,\n\tproducts,\n\tproductCategories,\n\torders,\n\torderItems,\n\tinventoryTransactions,\n\tuserInventory,\n\tthreadDrafts,\n\tthreadFeaturePermissions,\n\tsiteSettings,\n\tforumRules,\n\tuserRulesAgreements,\n\tverificationTokens,\n\ttype User,\n\ttype InsertUser,\n\ttype Thread,\n\ttype InsertThread,\n\ttype Post,\n\ttype InsertPost,\n\ttype ForumStructureNode,\n\ttype NewForumStructureNode,\n\ttype CustomEmoji,\n\ttype InsertCustomEmoji,\n\ttype Notification,\n\ttype Product,\n\ttype Order,\n\ttype Conversation,\n\ttype ConversationParticipant,\n\ttype Message,\n\ttype MessageRead,\n\ttype UserInventoryItem,\n\ttype InsertUserInventoryItem,\n\ttype ThreadDraft,\n\ttype InsertThreadDraft,\n\ttype SiteSetting,\n\ttype InsertSiteSetting,\n\ttype ForumRule,\n\ttype InsertForumRule,\n\ttype UserRulesAgreement,\n\tcontentEditStatusEnum\n} from '@schema';\nimport { db, pool } from '@db';\nimport { and, eq, desc, sql, count, isNull, not, inArray, ne, lte } from 'drizzle-orm';\nimport type {\n\tForumStructureWithStats,\n\tThreadWithUser,\n\tPostWithUser\n} from '../db/types/forum.types.ts';\nimport type { UserPluginData } from '../db/types/user.types.ts';\nimport type { EmojiWithAvailability } from '../db/types/emoji.types.ts';\nimport session from 'express-session';\nimport connectPGSink from 'connect-pg-simple';\nimport { randomBytes, scrypt } from 'crypto';\nimport { promisify } from 'util';\nimport { xpCloutService } from './services/xp-clout-service';\nimport { logger, LogLevel, LogAction } from './src/core/logger';\nimport { PgTransaction } from 'drizzle-orm/pg-core';\nimport { ConversationId, ProductId, GroupId, StructureId, ThreadId, PostId, EmojiId, CategoryId } from \"@shared/types\";\n\n// import multerS3 from \"multer-s3\"; // Removed as not a dependency\n// import { S3Client } from \"@aws-sdk/client-s3\"; // Removed as not a dependency\n\nconst environment = process.env.NODE_ENV || 'development';\n\nconst PGStore = connectPGSink(session);\n\n// Define Store type\ntype SessionStore = connectPGSink.PGStore;\n\nexport interface IStorage {\n\t// User methods\n\tgetUser(id: Id<'id'> | string): Promise<User | undefined>;\n\tgetUserByUsername(username: string): Promise<User | undefined>;\n\tgetUserByEmail(email: string): Promise<User | undefined>;\n\tcreateUser(user: InsertUser): Promise<User>;\n\tupdateUser(id: Id<'id'>, userData: Partial<User>): Promise<User>;\n\tgetUsersInGroup(groupId: GroupId): Promise<User[]>;\n\thashPassword(password: string): Promise<string>;\n\n\t// Staff and groups methods\n\tgetUserGroups(): Promise<(typeof userGroups.$inferSelect)[]>;\n\tgetUserGroup(id: Id<'id'>): Promise<typeof userGroups.$inferSelect | undefined>;\n\tcreateUserGroup(group: typeof userGroups.$inferInsert): Promise<typeof userGroups.$inferSelect>;\n\tupdateUserGroup(\n\t\tid: Id<'id'>,\n\t\tdata: Partial<typeof userGroups.$inferSelect>\n\t): Promise<typeof userGroups.$inferSelect>;\n\tdeleteUserGroup(id: Id<'id'>): Promise<void>;\n\n\t// Forum rules methods\n\tgetForumRules(section?: string, status?: string): Promise<ForumRule[]>;\n\tgetForumRule(id: Id<'id'>): Promise<ForumRule | undefined>;\n\tcreateForumRule(rule: InsertForumRule & { createdBy?: UserId }): Promise<ForumRule>;\n\tupdateForumRule(\n\t\tid: Id<'id'>,\n\t\trule: Partial<ForumRule> & { updatedBy?: number }\n\t): Promise<ForumRule>;\n\tdeleteForumRule(id: Id<'id'>): Promise<void>;\n\tgetUserRuleAgreements(userId: UserId): Promise<UserRulesAgreement[]>;\n\tagreeToRule(userId: UserId, ruleId: Id<'rule'>, versionHash: string): Promise<void>;\n\n\t// Forum structure methods\n\tgetStructures(): Promise<ForumStructureWithStats[]>;\n\tgetStructure(id: Id<'id'>): Promise<ForumStructureWithStats | undefined>;\n\tgetStructureBySlug(slug: string): Promise<ForumStructureWithStats | undefined>;\n\tcreateStructure(structure: NewForumStructureNode): Promise<ForumStructureNode>;\n\n\t// Thread methods\n\tgetThreads(\n\t\tstructureId?: StructureId,\n\t\tlimit?: number,\n\t\toffset?: number,\n\t\tsortBy?: string\n\t): Promise<ThreadWithUser[]>;\n\tgetThread(id: Id<'id'>): Promise<ThreadWithUser | undefined>;\n\tgetThreadBySlug(slug: string): Promise<ThreadWithUser | undefined>;\n\tcreateThread(thread: InsertThread & { userId: UserId }): Promise<Thread>;\n\tincrementThreadViewCount(id: Id<'id'>): Promise<void>;\n\n\t// Thread draft methods\n\tgetDraft(id: Id<'id'>): Promise<ThreadDraft | undefined>;\n\tgetDraftsByUser(userId: UserId, structureId?: StructureId): Promise<ThreadDraft[]>;\n\tsaveDraft(draft: InsertThreadDraft): Promise<ThreadDraft>;\n\tupdateDraft(id: Id<'id'>, data: Partial<ThreadDraft>): Promise<ThreadDraft>;\n\tdeleteDraft(id: Id<'id'>): Promise<void>;\n\tpublishDraft(id: Id<'id'>): Promise<Thread>;\n\n\t// Thread feature permissions methods\n\tgetThreadFeaturePermissions(): Promise<(typeof threadFeaturePermissions.$inferSelect)[]>;\n\tgetThreadFeaturePermissionsForUser(userId: UserId): Promise<Record<string, boolean>>;\n\n\t// Post methods\n\tgetPosts(threadId: ThreadId, limit?: number, offset?: number): Promise<PostWithUser[]>;\n\tgetPost(id: Id<'id'>): Promise<PostWithUser | undefined>;\n\tcreatePost(post: InsertPost & { userId: UserId; isFirstPost?: boolean }): Promise<Post>;\n\tupdatePost(id: Id<'id'>, postData: Partial<Post> & { editorId: UserId }): Promise<Post>;\n\tdeletePost(id: Id<'id'>): Promise<void>;\n\n\t// Reaction methods\n\taddReaction(userId: UserId, postId: PostId, reaction: string): Promise<void>;\n\tremoveReaction(userId: UserId, postId: PostId, reaction: string): Promise<void>;\n\n\t// Notification methods\n\tgetNotifications(userId: UserId, limit?: number, offset?: number): Promise<Notification[]>;\n\tmarkNotificationAsRead(id: Id<'id'>): Promise<void>;\n\n\t// Custom emoji methods\n\tgetEmojis(category?: string): Promise<CustomEmoji[]>;\n\tgetEmoji(id: Id<'id'>): Promise<CustomEmoji | undefined>;\n\tcreateEmoji(emoji: InsertCustomEmoji): Promise<CustomEmoji>;\n\tupdateEmoji(id: Id<'id'>, emoji: Partial<CustomEmoji>): Promise<CustomEmoji>;\n\tdeleteEmoji(id: Id<'id'>): Promise<void>;\n\tgetAvailableEmojisForUser(userId: UserId): Promise<EmojiWithAvailability[]>;\n\tunlockEmojiForUser(userId: UserId, emojiId: EmojiId): Promise<void>;\n\n\t// Shop and products methods\n\tgetProducts(category?: string): Promise<Product[]>;\n\tgetProduct(id: Id<'id'>): Promise<Product | undefined>;\n\tcreateProduct(product: typeof products.$inferInsert): Promise<Product>;\n\tupdateProduct(id: Id<'id'>, data: Partial<Product>): Promise<Product>;\n\tdeleteProduct(id: Id<'id'>): Promise<void>;\n\tpurchaseProduct(userId: UserId, productId: ProductId, quantity?: number): Promise<Order>;\n\n\t// Messaging system\n\tgetConversations(\n\t\tuserId: UserId\n\t): Promise<(Conversation & { participants: ConversationParticipant[] })[]>;\n\tgetConversation(id: Id<'id'>): Promise<Conversation | undefined>;\n\tcreateConversation(data: {\n\t\ttitle?: string;\n\t\tisGroup: boolean;\n\t\tcreatedBy: UserId;\n\t\tparticipants: UserId[];\n\t}): Promise<Conversation>;\n\tgetMessages(\n\t\tconversationId: ConversationId,\n\t\tlimit?: number,\n\t\toffset?: number\n\t): Promise<(Message & { sender: User })[]>;\n\tsendMessage(data: {\n\t\tconversationId: ConversationId;\n\t\tsenderId: UserId;\n\t\tcontent: string;\n\t\tattachmentUrl?: string;\n\t\tattachmentType?: string;\n\t}): Promise<Message>;\n\tmarkMessagesAsRead(conversationId: ConversationId, userId: UserId): Promise<void>;\n\n\t// XP engine methods\n\taddUserXp(userId: UserId, amount: number, path?: string): Promise<void>;\n\tgetUserPathXp(userId: UserId, path?: string): Promise<Record<string, number>>;\n\trecalculateUserPathMultipliers(userId: UserId): Promise<Record<string, number>>;\n\n\t// User inventory methods\n\tgetUserInventory(userId: UserId): Promise<UserInventoryItem[]>;\n\tcheckUserOwnsProduct(userId: UserId, productId: ProductId): Promise<boolean>;\n\taddProductToUserInventory(item: InsertUserInventoryItem): Promise<UserInventoryItem>;\n\tupdateUserInventoryItem(\n\t\tuserId: UserId,\n\t\tproductId: ProductId,\n\t\tupdates: Partial<UserInventoryItem>\n\t): Promise<UserInventoryItem | undefined>;\n\tcreateInventoryTransaction(data: {\n\t\tuserId: UserId;\n\t\tproductId: ProductId;\n\t\ttransactionType: string;\n\t\tamount: number;\n\t\tcurrency: string;\n\t\tcurrencyAmount: number;\n\t\tstatus?: string;\n\t\tmetadata?: Record<string, any>;\n\t}): Promise<typeof inventoryTransactions.$inferSelect>;\n\n\t// Session store\n\tsessionStore: SessionStore;\n\n\t// Site settings methods\n\tgetSiteSettings(): Promise<SiteSetting[]>;\n\tgetSiteSetting(key: string): Promise<SiteSetting | undefined>;\n\tsetSiteSetting(\n\t\tkey: string,\n\t\tvalue: string,\n\t\tvalueType?: string,\n\t\tgroup?: string,\n\t\tdescription?: string,\n\t\tisPublic?: boolean\n\t): Promise<SiteSetting>;\n\tgetPublicSiteSettings(): Promise<Record<string, any>>;\n}\n\nexport class DatabaseStorage implements IStorage {\n\tsessionStore: SessionStore;\n\n\tconstructor() {\n\t\tthis.sessionStore = new PGStore({\n\t\t\tpool: pool,\n\t\t\ttableName: 'user_sessions',\n\t\t\tcreateTableIfMissing: true\n\t\t});\n\t\tlogger.info(\n\t\t\t'DATABASE',\n\t\t\t\"🐘 PostgreSQL session store initialized (using table name 'user_sessions').\"\n\t\t);\n\t}\n\n\t// User methods\n\tasync getUser(id: Id<'id'> | string): Promise<User | undefined> {\n\t\tlogger.info('🔍 getUser called with ID:', id, 'type:', typeof id);\n\n\t\ttry {\n\t\t\t// Handle both numeric and UUID string IDs\n\t\t\tconst [user] = await db.select().from(users).where(eq(users.id, id));\n\n\t\t\tif (user) {\n\t\t\t\tlogger.info('✅ Drizzle ORM result for user:', JSON.stringify(user, null, 2));\n\t\t\t\treturn user;\n\t\t\t} else {\n\t\t\t\tlogger.info('❌ Drizzle ORM: No user found with ID:', id);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.warn('❌ Error fetching user with Drizzle ORM, trying direct SQL', err);\n\t\t}\n\n\t\t// Try with user_id column as fallback with proper column mapping\n\t\ttry {\n\t\t\t// For development mode, try a direct SQL query to bypass schema mismatches\n\t\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\t\tconst result = await db.execute(sql`\n          SELECT \n            user_id as id,\n            username,\n            email,\n            password_hash as password,\n            bio,\n            signature,\n            avatar_url as avatarUrl,\n            active_avatar_url as activeAvatarUrl, \n            profile_banner_url as profileBannerUrl,\n            primary_role_id as primaryRoleId,\n            discord_handle as discordHandle,\n            twitter_handle as twitterHandle,\n            website,\n            telegram_handle as telegramHandle,\n            is_active as isActive,\n            is_verified as isVerified,\n            is_deleted as isDeleted, \n            is_banned as isBanned,\n            is_shadowbanned as isShadowbanned,\n            subscribed_to_newsletter as subscribedToNewsletter,\n            last_seen_at as lastSeenAt,\n            created_at as createdAt,\n            last_login as lastLogin,\n            referrer_id as referrerId,\n            referral_level as referralLevel,\n            xp,\n            level,\n            clout,\n            active_title_id as activeTitleId,\n            active_badge_id as activeBadgeId,\n            dgt_balance as dgtBalance,\n            reputation,\n            total_posts as totalPosts, \n            total_threads as totalThreads,\n            total_likes as totalLikes,\n            total_tips as totalTips,\n            is_staff as isStaff,\n            is_moderator as isModerator,\n            is_admin as isAdmin,\n            role,\n            wallet_address as walletAddress,\n            group_id as groupId\n          FROM users WHERE user_id = ${id} LIMIT 1\n        `);\n\n\t\t\t\tif (result.rows && result.rows.length > 0) {\n\t\t\t\t\tconst rawUser = result.rows[0] as any;\n\t\t\t\t\tlogger.info('SQL query result for user:', JSON.stringify(rawUser, null, 2));\n\n\t\t\t\t\t// Manually map the raw database row to the expected User object\n\t\t\t\t\tconst user: User = {\n\t\t\t\t\t\tid: rawUser.user_id,\n\t\t\t\t\t\tusername: rawUser.username,\n\t\t\t\t\t\temail: rawUser.email,\n\t\t\t\t\t\tpassword: rawUser.password_hash,\n\t\t\t\t\t\tbio: rawUser.bio,\n\t\t\t\t\t\tsignature: rawUser.signature,\n\t\t\t\t\t\tavatarUrl: rawUser.avatar_url,\n\t\t\t\t\t\tactiveAvatarUrl: rawUser.active_avatar_url,\n\t\t\t\t\t\tprofileBannerUrl: rawUser.profile_banner_url,\n\t\t\t\t\t\tprimaryRoleId: rawUser.primary_role_id,\n\t\t\t\t\t\tdiscordHandle: rawUser.discord_handle,\n\t\t\t\t\t\ttwitterHandle: rawUser.twitter_handle,\n\t\t\t\t\t\twebsite: rawUser.website,\n\t\t\t\t\t\ttelegramHandle: rawUser.telegram_handle,\n\t\t\t\t\t\tisActive: rawUser.is_active,\n\t\t\t\t\t\tisVerified: rawUser.is_verified,\n\t\t\t\t\t\tisDeleted: rawUser.is_deleted,\n\t\t\t\t\t\tisBanned: rawUser.is_banned,\n\t\t\t\t\t\tisShadowbanned: rawUser.is_shadowbanned,\n\t\t\t\t\t\tsubscribedToNewsletter: rawUser.subscribed_to_newsletter,\n\t\t\t\t\t\tlastSeenAt: rawUser.last_seen_at,\n\t\t\t\t\t\tcreatedAt: rawUser.created_at,\n\t\t\t\t\t\tlastLogin: rawUser.last_login,\n\t\t\t\t\t\treferrerId: rawUser.referrer_id,\n\t\t\t\t\t\treferralLevel: rawUser.referral_level,\n\t\t\t\t\t\txp: rawUser.xp,\n\t\t\t\t\t\tlevel: rawUser.level,\n\t\t\t\t\t\tclout: rawUser.clout,\n\t\t\t\t\t\tactiveTitleId: rawUser.active_title_id,\n\t\t\t\t\t\tactiveBadgeId: rawUser.active_badge_id,\n\t\t\t\t\t\tdgtBalance: rawUser.dgt_balance,\n\t\t\t\t\t\treputation: rawUser.reputation,\n\t\t\t\t\t\ttotalPosts: rawUser.total_posts,\n\t\t\t\t\t\ttotalThreads: rawUser.total_threads,\n\t\t\t\t\t\ttotalLikes: rawUser.total_likes,\n\t\t\t\t\t\ttotalTips: rawUser.total_tips,\n\t\t\t\t\t\tisStaff: rawUser.is_staff,\n\t\t\t\t\t\tisModerator: rawUser.is_moderator,\n\t\t\t\t\t\tisAdmin: rawUser.is_admin,\n\t\t\t\t\t\trole: rawUser.role,\n\t\t\t\t\t\twalletAddress: rawUser.wallet_address,\n\t\t\t\t\t\tgroupId: rawUser.group_id\n\t\t\t\t\t} as any;\n\n\t\t\t\t\treturn user;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.warn('Direct SQL query for user failed', err);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tasync storeVerificationToken(userId: UserId, token: string): Promise<void> {\n\t\t// Create a verification token that expires in 24 hours\n\t\tconst expiresAt = new Date();\n\t\texpiresAt.setHours(expiresAt.getHours() + 24);\n\n\t\ttry {\n\t\t\t// First check if there's an existing token for this user and delete it\n\t\t\tawait db.delete(verificationTokens).where(eq(verificationTokens.userId, userId));\n\n\t\t\t// Then create a new token\n\t\t\tawait db.insert(verificationTokens).values({\n\t\t\t\tuserId,\n\t\t\t\ttoken,\n\t\t\t\texpiresAt,\n\t\t\t\tcreatedAt: new Date()\n\t\t\t});\n\n\t\t\tlogger.info(`Verification token stored for user ${userId}, expires at ${expiresAt}`);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error storing verification token:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getUserByUsername(username: string): Promise<User | undefined> {\n\t\ttry {\n\t\t\t// First try with ORM approach\n\t\t\tconst [user] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(users)\n\t\t\t\t.where(and(eq(users.username, username), eq(users.isDeleted, false)));\n\n\t\t\tif (user) return user;\n\t\t} catch (err) {\n\t\t\tlogger.warn('Error fetching user by username with ORM, falling back to SQL', err);\n\t\t}\n\n\t\t// Fall back to direct SQL query in development mode\n\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\ttry {\n\t\t\t\tconst result = await db.execute(sql`\n          SELECT * FROM users \n          WHERE username = ${username} \n          AND (is_deleted = false OR is_deleted IS NULL)\n          LIMIT 1\n        `);\n\n\t\t\t\tif (result.rows && result.rows.length > 0) {\n\t\t\t\t\treturn result.rows[0] as any as User;\n\t\t\t\t}\n\t\t\t} catch (sqlErr) {\n\t\t\t\tlogger.warn('Direct SQL query for user by username failed', sqlErr);\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tasync getUserByEmail(email: string): Promise<User | undefined> {\n\t\ttry {\n\t\t\t// First try with ORM approach\n\t\t\tconst [user] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(users)\n\t\t\t\t.where(and(eq(users.email, email), eq(users.isDeleted, false)));\n\n\t\t\tif (user) return user;\n\t\t} catch (err) {\n\t\t\tlogger.warn('Error fetching user by email with ORM, falling back to SQL', err);\n\t\t}\n\n\t\t// Fall back to direct SQL query in development mode\n\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\ttry {\n\t\t\t\tconst result = await db.execute(sql`\n          SELECT * FROM users \n          WHERE email = ${email} \n          AND (is_deleted = false OR is_deleted IS NULL)\n          LIMIT 1\n        `);\n\n\t\t\t\tif (result.rows && result.rows.length > 0) {\n\t\t\t\t\treturn result.rows[0] as any as User;\n\t\t\t\t}\n\t\t\t} catch (sqlErr) {\n\t\t\t\tlogger.warn('Direct SQL query for user by email failed', sqlErr);\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tasync hashPassword(password: string): Promise<string> {\n\t\tconst scryptAsync = promisify(scrypt);\n\t\tconst salt = randomBytes(16).toString('hex');\n\t\tconst buf = (await scryptAsync(password, salt, 64)) as Buffer;\n\t\treturn `${buf.toString('hex')}.${salt}`;\n\t}\n\n\tasync createUser(insertUser: InsertUser): Promise<User> {\n\t\tconst [user] = await db.insert(users).values(insertUser).returning();\n\t\treturn user;\n\t}\n\n\tasync updateUser(id: Id<'id'>, userData: Partial<User>): Promise<User> {\n\t\tconst [updatedUser] = await db\n\t\t\t.update(users)\n\t\t\t.set({\n\t\t\t\t...userData,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(users.id, id))\n\t\t\t.returning();\n\n\t\treturn updatedUser;\n\t}\n\n\t// Forum category methods\n\tasync getStructures(): Promise<ForumStructureWithStats[]> {\n\t\tconst structures = await db\n\t\t\t.select({\n\t\t\t\t...forumStructure,\n\t\t\t\tthreadCount: count(threads.id).as('thread_count')\n\t\t\t})\n\t\t\t.from(forumStructure)\n\t\t\t.leftJoin(threads, eq(forumStructure.id, threads.structureId))\n\t\t\t.groupBy(forumStructure.id)\n\t\t\t.orderBy(forumStructure.position);\n\n\t\t// Convert to ForumStructureWithStats type\n\t\tconst structuresWithStats: ForumStructureWithStats[] = structures.map((structure) => ({\n\t\t\t...structure,\n\t\t\tthreadCount: Number(structure.threadCount) || 0,\n\t\t\tpostCount: 0, // We'll update this with a separate query\n\t\t\tchildStructures: [] as ForumStructureWithStats[], // Initialize children array\n\t\t\tcanHaveThreads: structure.type === 'forum'\n\t\t}));\n\n\t\t// Create a map for quick lookup\n\t\tconst structureMap = new Map<number, ForumStructureWithStats>();\n\t\tstructuresWithStats.forEach((structure) => {\n\t\t\tstructureMap.set(structure.id, structure);\n\t\t});\n\n\t\t// Organize into parent-child hierarchy\n\t\tconst rootStructures: ForumStructureWithStats[] = [];\n\n\t\t// Populate children arrays\n\t\tstructuresWithStats.forEach((structure) => {\n\t\t\tif (structure.parentId === null) {\n\t\t\t\t// This is a root structure (zone)\n\t\t\t\trootStructures.push(structure);\n\t\t\t} else {\n\t\t\t\t// This is a child structure (forum)\n\t\t\t\tconst parent = structureMap.get(structure.parentId);\n\t\t\t\tif (parent) {\n\t\t\t\t\t// Add it to its parent's children array if parent exists\n\t\t\t\t\t(parent.childStructures || (parent.childStructures = [])).push(structure);\n\t\t\t\t} else {\n\t\t\t\t\t// If parent doesn't exist, treat as root structure\n\t\t\t\t\trootStructures.push(structure);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// For the API endpoint, we want a flat structure with all structures\n\t\treturn structuresWithStats;\n\t}\n\n\tasync getStructure(id: Id<'id'>): Promise<ForumStructureWithStats | undefined> {\n\t\tconst [structure] = await db\n\t\t\t.select({\n\t\t\t\t...forumStructure,\n\t\t\t\tthreadCount: count(threads.id).as('thread_count')\n\t\t\t})\n\t\t\t.from(forumStructure)\n\t\t\t.leftJoin(threads, eq(forumStructure.id, threads.structureId))\n\t\t\t.where(eq(forumStructure.id, id))\n\t\t\t.groupBy(forumStructure.id);\n\n\t\tif (!structure) return undefined;\n\n\t\treturn {\n\t\t\t...structure,\n\t\t\tthreadCount: Number(structure.threadCount) || 0,\n\t\t\tpostCount: 0, // We'll update this with a separate query\n\t\t\tcanHaveThreads: structure.type === 'forum'\n\t\t};\n\t}\n\n\tasync getStructureBySlug(slug: string): Promise<ForumStructureWithStats | undefined> {\n\t\tconst [structure] = await db\n\t\t\t.select({\n\t\t\t\t...forumStructure,\n\t\t\t\tthreadCount: count(threads.id).as('thread_count')\n\t\t\t})\n\t\t\t.from(forumStructure)\n\t\t\t.leftJoin(threads, eq(forumStructure.id, threads.structureId))\n\t\t\t.where(eq(forumStructure.slug, slug))\n\t\t\t.groupBy(forumStructure.id);\n\n\t\tif (!structure) return undefined;\n\n\t\treturn {\n\t\t\t...structure,\n\t\t\tthreadCount: Number(structure.threadCount) || 0,\n\t\t\tpostCount: 0, // We'll update this with a separate query\n\t\t\tcanHaveThreads: structure.type === 'forum'\n\t\t};\n\t}\n\n\tasync createStructure(structure: NewForumStructureNode): Promise<ForumStructureNode> {\n\t\tconst [newStructure] = await db\n\t\t\t.insert(forumStructure)\n\t\t\t.values({\n\t\t\t\t...structure,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.returning();\n\t\treturn newStructure;\n\t}\n\n\t// Thread methods\n\tasync getThreads(\n\t\tcategoryId?: CategoryId,\n\t\tlimit = 20,\n\t\toffset = 0,\n\t\tsortBy = 'latest'\n\t): Promise<ThreadWithUser[]> {\n\t\tlet query = db\n\t\t\t.select({\n\t\t\t\t...threads,\n\t\t\t\tuser: users,\n\t\t\t\tpostCount: sql<number>`${threads.postCount}`\n\t\t\t\t// Ensure other relevant fields for sorting are selected if not already part of ...threads\n\t\t\t\t// For example, viewCount and lastPostAt are already in the threads schema\n\t\t\t})\n\t\t\t.from(threads)\n\t\t\t.innerJoin(users, eq(threads.userId, users.id))\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(threads.isHidden, false),\n\t\t\t\t\t...(categoryId ? [eq(threads.categoryId, categoryId)] : [])\n\t\t\t\t)\n\t\t\t)\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\n\t\t// Apply sorting based on sortBy parameter\n\t\tswitch (sortBy) {\n\t\t\tcase 'popular':\n\t\t\t\tquery = query.orderBy(\n\t\t\t\t\tdesc(threads.isSticky),\n\t\t\t\t\tdesc(threads.viewCount),\n\t\t\t\t\tdesc(threads.createdAt)\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'replies':\n\t\t\t\tquery = query.orderBy(\n\t\t\t\t\tdesc(threads.isSticky),\n\t\t\t\t\tdesc(threads.postCount),\n\t\t\t\t\tdesc(threads.createdAt)\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'recent': // Recently active by last post time\n\t\t\t\tquery = query.orderBy(\n\t\t\t\t\tdesc(threads.isSticky),\n\t\t\t\t\tdesc(threads.lastPostAt),\n\t\t\t\t\tdesc(threads.createdAt)\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'latest':\n\t\t\tdefault:\n\t\t\t\tquery = query.orderBy(desc(threads.isSticky), desc(threads.createdAt));\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn query;\n\t}\n\n\tasync getThread(id: Id<'id'>): Promise<ThreadWithUser | undefined> {\n\t\tconst [thread] = await db\n\t\t\t.select({\n\t\t\t\t...threads,\n\t\t\t\tuser: users,\n\t\t\t\tpostCount: sql<number>`${threads.postCount}`\n\t\t\t})\n\t\t\t.from(threads)\n\t\t\t.innerJoin(users, eq(threads.userId, users.id))\n\t\t\t.where(eq(threads.id, id));\n\n\t\treturn thread;\n\t}\n\n\tasync getThreadBySlug(slug: string): Promise<ThreadWithUser | undefined> {\n\t\tconst [thread] = await db\n\t\t\t.select({\n\t\t\t\t...threads,\n\t\t\t\tuser: users,\n\t\t\t\tpostCount: sql<number>`${threads.postCount}`\n\t\t\t})\n\t\t\t.from(threads)\n\t\t\t.innerJoin(users, eq(threads.userId, users.id))\n\t\t\t.where(eq(threads.slug, slug));\n\n\t\treturn thread;\n\t}\n\n\tasync createThread(thread: InsertThread & { userId: UserId }): Promise<Thread> {\n\t\t// Create a URL-friendly slug from the title\n\t\tconst slug = thread.title\n\t\t\t.toLowerCase()\n\t\t\t.replace(/[^\\w\\s]/g, '')\n\t\t\t.replace(/\\s+/g, '-');\n\n\t\tconst [newThread] = await db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Create the thread\n\t\t\tconst [createdThread] = await tx\n\t\t\t\t.insert(threads)\n\t\t\t\t.values({\n\t\t\t\t\ttitle: thread.title,\n\t\t\t\t\tslug: `${slug}-${Date.now()}`, // Ensure uniqueness\n\t\t\t\t\tstructureId: thread.structureId,\n\t\t\t\t\tuserId: thread.userId,\n\t\t\t\t\tprefixId: thread.prefixId,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Create the first post\n\t\t\tconst [firstPost] = await tx\n\t\t\t\t.insert(posts)\n\t\t\t\t.values({\n\t\t\t\t\tthreadId: createdThread.id,\n\t\t\t\t\tuserId: thread.userId,\n\t\t\t\t\tcontent: thread.content,\n\t\t\t\t\tisFirstPost: true,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Update thread with first post info\n\t\t\tconst [updatedThread] = await tx\n\t\t\t\t.update(threads)\n\t\t\t\t.set({\n\t\t\t\t\tlastPostId: firstPost.id,\n\t\t\t\t\tlastPostAt: firstPost.createdAt,\n\t\t\t\t\tpostCount: 1\n\t\t\t\t})\n\t\t\t\t.where(eq(threads.id, createdThread.id))\n\t\t\t\t.returning();\n\n\t\t\treturn [updatedThread];\n\t\t});\n\n\t\treturn newThread;\n\t}\n\n\tasync incrementThreadViewCount(id: Id<'id'>): Promise<void> {\n\t\tawait db\n\t\t\t.update(threads)\n\t\t\t.set({\n\t\t\t\tviewCount: sql`${threads.viewCount} + 1`\n\t\t\t})\n\t\t\t.where(eq(threads.id, id));\n\t}\n\n\t// Thread draft methods\n\tasync getDraft(id: Id<'id'>): Promise<ThreadDraft | undefined> {\n\t\tconst [draft] = await db.select().from(threadDrafts).where(eq(threadDrafts.id, id));\n\n\t\treturn draft;\n\t}\n\n\tasync getDraftsByUser(userId: UserId, structureId?: StructureId): Promise<ThreadDraft[]> {\n\t\tconst query = db\n\t\t\t.select()\n\t\t\t.from(threadDrafts)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(threadDrafts.userId, userId),\n\t\t\t\t\teq(threadDrafts.isPublished, false),\n\t\t\t\t\t...(structureId ? [eq(threadDrafts.structureId, structureId)] : [])\n\t\t\t\t)\n\t\t\t)\n\t\t\t.orderBy(desc(threadDrafts.lastSavedAt));\n\n\t\treturn query;\n\t}\n\n\tasync saveDraft(draft: InsertThreadDraft): Promise<ThreadDraft> {\n\t\tconst [newDraft] = await db\n\t\t\t.insert(threadDrafts)\n\t\t\t.values({\n\t\t\t\t...draft,\n\t\t\t\tlastSavedAt: new Date(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn newDraft;\n\t}\n\n\tasync updateDraft(id: Id<'id'>, data: Partial<ThreadDraft>): Promise<ThreadDraft> {\n\t\tconst [updatedDraft] = await db\n\t\t\t.update(threadDrafts)\n\t\t\t.set({\n\t\t\t\t...data,\n\t\t\t\tlastSavedAt: new Date(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(threadDrafts.id, id))\n\t\t\t.returning();\n\n\t\treturn updatedDraft;\n\t}\n\n\tasync deleteDraft(id: Id<'id'>): Promise<void> {\n\t\tawait db.delete(threadDrafts).where(eq(threadDrafts.id, id));\n\t}\n\n\tasync publishDraft(id: Id<'id'>): Promise<Thread> {\n\t\treturn db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Get the draft\n\t\t\tconst [draft] = await tx.select().from(threadDrafts).where(eq(threadDrafts.id, id));\n\n\t\t\tif (!draft) {\n\t\t\t\tthrow new Error('Draft not found');\n\t\t\t}\n\n\t\t\t// Create a URL-friendly slug from the title\n\t\t\tconst slug = draft.title\n\t\t\t\t? draft.title\n\t\t\t\t\t\t.toLowerCase()\n\t\t\t\t\t\t.replace(/[^\\w\\s]/g, '')\n\t\t\t\t\t\t.replace(/\\s+/g, '-')\n\t\t\t\t: `thread-${Date.now()}`;\n\n\t\t\t// Create the thread\n\t\t\tconst [thread] = await tx\n\t\t\t\t.insert(threads)\n\t\t\t\t.values({\n\t\t\t\t\ttitle: draft.title || 'Untitled Thread',\n\t\t\t\t\tslug: `${slug}-${Date.now()}`, // Ensure uniqueness\n\t\t\t\t\tcategoryId: draft.categoryId,\n\t\t\t\t\tuserId: draft.userId,\n\t\t\t\t\tprefixId: draft.prefixId || null,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Create the first post\n\t\t\tconst [firstPost] = await tx\n\t\t\t\t.insert(posts)\n\t\t\t\t.values({\n\t\t\t\t\tthreadId: thread.id,\n\t\t\t\t\tuserId: draft.userId,\n\t\t\t\t\tcontent: draft.content || '',\n\t\t\t\t\tcontentHtml: draft.contentHtml,\n\t\t\t\t\tisFirstPost: true,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Update thread with first post info\n\t\t\tconst [updatedThread] = await tx\n\t\t\t\t.update(threads)\n\t\t\t\t.set({\n\t\t\t\t\tlastPostId: firstPost.id,\n\t\t\t\t\tlastPostAt: firstPost.createdAt,\n\t\t\t\t\tpostCount: 1\n\t\t\t\t})\n\t\t\t\t.where(eq(threads.id, thread.id))\n\t\t\t\t.returning();\n\n\t\t\t// Mark the draft as published\n\t\t\tawait tx\n\t\t\t\t.update(threadDrafts)\n\t\t\t\t.set({\n\t\t\t\t\tisPublished: true,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(threadDrafts.id, id));\n\n\t\t\treturn updatedThread;\n\t\t});\n\t}\n\n\t// Thread feature permissions methods\n\tasync getThreadFeaturePermissions(): Promise<(typeof threadFeaturePermissions.$inferSelect)[]> {\n\t\treturn db.select().from(threadFeaturePermissions).orderBy(threadFeaturePermissions.featureName);\n\t}\n\n\tasync getThreadFeaturePermissionsForUser(userId: UserId): Promise<Record<string, boolean>> {\n\t\t// Get the user to check their level and role\n\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\n\t\tif (!user) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Get all thread feature permissions\n\t\tconst permissions = await db.select().from(threadFeaturePermissions);\n\n\t\t// Convert to Record<string, boolean>\n\t\tconst result: Record<string, boolean> = {};\n\n\t\tfor (const perm of permissions) {\n\t\t\t// Check if the user meets the level requirement\n\t\t\tconst meetsLevelRequirement = user.level >= perm.minLevel;\n\n\t\t\t// Check if the user has a role that can bypass level requirements\n\t\t\tconst canBypassLevelReq = (perm.bypassRoles || []).includes(user.role || 'user');\n\n\t\t\t// User can use the feature if they meet level requirements or can bypass\n\t\t\tresult[perm.featureName] = meetsLevelRequirement || canBypassLevelReq;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// Post methods\n\tasync getPosts(threadId: ThreadId, limit = 20, offset = 0): Promise<PostWithUser[]> {\n\t\treturn db\n\t\t\t.select({\n\t\t\t\t...posts,\n\t\t\t\tuser: users\n\t\t\t})\n\t\t\t.from(posts)\n\t\t\t.innerJoin(users, eq(posts.userId, users.id))\n\t\t\t.where(and(eq(posts.threadId, threadId), eq(posts.isHidden, false)))\n\t\t\t.orderBy(posts.createdAt)\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\t}\n\n\tasync getPost(id: Id<'id'>): Promise<PostWithUser | undefined> {\n\t\tconst [post] = await db\n\t\t\t.select({\n\t\t\t\t...posts,\n\t\t\t\tuser: users\n\t\t\t})\n\t\t\t.from(posts)\n\t\t\t.innerJoin(users, eq(posts.userId, users.id))\n\t\t\t.where(eq(posts.id, id));\n\n\t\treturn post;\n\t}\n\n\tasync createPost(post: InsertPost & { userId: UserId; isFirstPost?: boolean }): Promise<Post> {\n\t\tconst [newPost] = await db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Create the post\n\t\t\tconst [createdPost] = await tx\n\t\t\t\t.insert(posts)\n\t\t\t\t.values({\n\t\t\t\t\tthreadId: post.threadId,\n\t\t\t\t\tuserId: post.userId,\n\t\t\t\t\tcontent: post.content,\n\t\t\t\t\treplyToPostId: post.replyToPostId,\n\t\t\t\t\tisFirstPost: post.isFirstPost || false,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Update thread with last post info and increment post count\n\t\t\tawait tx\n\t\t\t\t.update(threads)\n\t\t\t\t.set({\n\t\t\t\t\tlastPostId: createdPost.id,\n\t\t\t\t\tlastPostAt: createdPost.createdAt,\n\t\t\t\t\tpostCount: sql`${threads.postCount} + 1`,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(threads.id, post.threadId));\n\n\t\t\treturn [createdPost];\n\t\t});\n\n\t\treturn newPost;\n\t}\n\n\tasync updatePost(id: Id<'id'>, postData: Partial<Post> & { editorId: UserId }): Promise<Post> {\n\t\tconst { editorId, ...updateData } = postData;\n\n\t\tconst [updatedPost] = await db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Get the post first to check permissions and get the thread ID\n\t\t\tconst [existingPost] = await tx.select().from(posts).where(eq(posts.id, id));\n\n\t\t\tif (!existingPost) {\n\t\t\t\tthrow new Error('Post not found');\n\t\t\t}\n\n\t\t\t// Update the post\n\t\t\tconst [post] = await tx\n\t\t\t\t.update(posts)\n\t\t\t\t.set({\n\t\t\t\t\t...updateData,\n\t\t\t\t\tisEdited: true,\n\t\t\t\t\teditedAt: new Date(),\n\t\t\t\t\teditedBy: editorId,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(posts.id, id))\n\t\t\t\t.returning();\n\n\t\t\t// Update thread lastUpdatedAt if this is the last post\n\t\t\tconst [thread] = await tx.select().from(threads).where(eq(threads.id, existingPost.threadId));\n\n\t\t\tif (thread && thread.lastPostId === id) {\n\t\t\t\tawait tx\n\t\t\t\t\t.update(threads)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(threads.id, existingPost.threadId));\n\t\t\t}\n\n\t\t\treturn [post];\n\t\t});\n\n\t\treturn updatedPost;\n\t}\n\n\tasync deletePost(id: Id<'id'>): Promise<void> {\n\t\tawait db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Get the post first to check permissions and get thread info\n\t\t\tconst [post] = await tx.select().from(posts).where(eq(posts.id, id));\n\n\t\t\tif (!post) {\n\t\t\t\tthrow new Error('Post not found');\n\t\t\t}\n\n\t\t\t// Check if this is the first post of a thread\n\t\t\tif (post.isFirstPost) {\n\t\t\t\tthrow new Error('Cannot delete the first post of a thread. Delete the thread instead.');\n\t\t\t}\n\n\t\t\t// Soft delete the post (set isHidden = true)\n\t\t\tawait tx\n\t\t\t\t.update(posts)\n\t\t\t\t.set({\n\t\t\t\t\tisHidden: true,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(posts.id, id));\n\n\t\t\t// Decrement thread post count\n\t\t\tawait tx\n\t\t\t\t.update(threads)\n\t\t\t\t.set({\n\t\t\t\t\tpostCount: sql`${threads.postCount} - 1`,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(threads.id, post.threadId));\n\n\t\t\t// If this was the last post, update thread's lastPostId to the previous post\n\t\t\tconst [thread] = await tx.select().from(threads).where(eq(threads.id, post.threadId));\n\n\t\t\tif (thread && thread.lastPostId === id) {\n\t\t\t\t// Find the previous post\n\t\t\t\tconst [previousPost] = await tx\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(posts)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(eq(posts.threadId, post.threadId), eq(posts.isHidden, false), not(eq(posts.id, id)))\n\t\t\t\t\t)\n\t\t\t\t\t.orderBy(desc(posts.createdAt))\n\t\t\t\t\t.limit(1);\n\n\t\t\t\tif (previousPost) {\n\t\t\t\t\tawait tx\n\t\t\t\t\t\t.update(threads)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tlastPostId: previousPost.id,\n\t\t\t\t\t\t\tlastPostAt: previousPost.createdAt\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(eq(threads.id, post.threadId));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// Reaction methods\n\tasync addReaction(userId: UserId, postId: PostId, reaction: string): Promise<void> {\n\t\tawait db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Add reaction\n\t\t\tawait tx\n\t\t\t\t.insert(postReactions)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\tpostId,\n\t\t\t\t\treaction: reaction as any, // Type cast as we're validating before this call\n\t\t\t\t\tcreatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.onConflictDoNothing();\n\n\t\t\t// Update post like count if it's a like reaction\n\t\t\tif (reaction === 'like') {\n\t\t\t\tawait tx\n\t\t\t\t\t.update(posts)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tlikeCount: sql`${posts.likeCount} + 1`\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(posts.id, postId));\n\t\t\t}\n\n\t\t\t// --- XP/Clout Award Logic ---\n\t\t\t// Fetch post to get author\n\t\t\tconst [post] = await tx.select().from(posts).where(eq(posts.id, postId));\n\t\t\tif (post && post.userId !== userId) {\n\t\t\t\tconst actionKey = `REACTION_RECEIVE_${reaction.toUpperCase()}`;\n\t\t\t\ttry {\n\t\t\t\t\tawait xpCloutService.awardPoints(post.userId, actionKey);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlogger.error('XpCloutService', `Error awarding points for reaction:`, err);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// --- End XP/Clout Award Logic ---\n\t\t});\n\t}\n\n\tasync removeReaction(userId: UserId, postId: PostId, reaction: string): Promise<void> {\n\t\tawait db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Remove reaction\n\t\t\tconst deleteResult = await tx.delete(postReactions).where(\n\t\t\t\tand(\n\t\t\t\t\teq(postReactions.userId, userId),\n\t\t\t\t\teq(postReactions.postId, postId),\n\t\t\t\t\teq(postReactions.reaction, reaction as any) // Type cast as we're validating before this call\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// Update post like count if it's a like reaction\n\t\t\tif (reaction === 'like') {\n\t\t\t\tawait tx\n\t\t\t\t\t.update(posts)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tlikeCount: sql`${posts.likeCount} - 1`\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(posts.id, postId));\n\t\t\t}\n\n\t\t\t// --- XP/Clout Subtraction Logic ---\n\t\t\t// Fetch post to get author\n\t\t\tconst [post] = await tx.select().from(posts).where(eq(posts.id, postId));\n\t\t\tif (deleteResult.rowCount > 0 && post && post.userId !== userId) {\n\t\t\t\tconst actionKey = `REACTION_RECEIVE_${reaction.toUpperCase()}`;\n\t\t\t\tconst values = await xpCloutService.getActionValues(actionKey);\n\t\t\t\tif (values) {\n\t\t\t\t\t// Fetch current XP/Clout to avoid going below zero\n\t\t\t\t\tconst [author] = await tx.select().from(users).where(eq(users.id, post.userId));\n\t\t\t\t\tconst xpToRemove = Math.min(values.xpValue, author?.xp || 0);\n\t\t\t\t\tconst cloutToRemove = Math.min(values.cloutValue, author?.clout || 0);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait tx\n\t\t\t\t\t\t\t.update(users)\n\t\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\t\txp: sql`${users.xp} - ${xpToRemove}`,\n\t\t\t\t\t\t\t\tclout: sql`${users.clout} - ${cloutToRemove}`,\n\t\t\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.where(eq(users.id, post.userId));\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t'XpCloutService',\n\t\t\t\t\t\t\t`Subtracted ${xpToRemove} XP and ${cloutToRemove} Clout from user ${post.userId} for reaction removal ${actionKey}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch (updateError) {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t'XpCloutService',\n\t\t\t\t\t\t\t`Error subtracting points from user ${post.userId}:`,\n\t\t\t\t\t\t\tupdateError\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// --- End XP/Clout Subtraction Logic ---\n\t\t});\n\t}\n\n\t// Notification methods\n\tasync getNotifications(userId: UserId, limit = 20, offset = 0): Promise<Notification[]> {\n\t\treturn db\n\t\t\t.select()\n\t\t\t.from(notifications)\n\t\t\t.where(eq(notifications.userId, userId))\n\t\t\t.orderBy(desc(notifications.createdAt))\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\t}\n\n\tasync markNotificationAsRead(id: Id<'id'>): Promise<void> {\n\t\tawait db\n\t\t\t.update(notifications)\n\t\t\t.set({\n\t\t\t\tisRead: true,\n\t\t\t\treadAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(notifications.id, id));\n\t}\n\n\t// Custom emoji methods\n\tasync getEmojis(category?: string): Promise<CustomEmoji[]> {\n\t\tlet query = db.select().from(customEmojis).where(eq(customEmojis.isDeleted, false));\n\n\t\tif (category) {\n\t\t\tquery = query.where(eq(customEmojis.category, category));\n\t\t}\n\n\t\treturn query.orderBy(customEmojis.name);\n\t}\n\n\tasync getEmoji(id: Id<'id'>): Promise<CustomEmoji | undefined> {\n\t\tconst [emoji] = await db\n\t\t\t.select()\n\t\t\t.from(customEmojis)\n\t\t\t.where(and(eq(customEmojis.id, id), eq(customEmojis.isDeleted, false)));\n\n\t\treturn emoji;\n\t}\n\n\tasync createEmoji(emoji: InsertCustomEmoji): Promise<CustomEmoji> {\n\t\tconst [newEmoji] = await db\n\t\t\t.insert(customEmojis)\n\t\t\t.values({\n\t\t\t\t...emoji,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn newEmoji;\n\t}\n\n\tasync updateEmoji(id: Id<'id'>, emoji: Partial<CustomEmoji>): Promise<CustomEmoji> {\n\t\tconst [updatedEmoji] = await db\n\t\t\t.update(customEmojis)\n\t\t\t.set({\n\t\t\t\t...emoji,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(customEmojis.id, id))\n\t\t\t.returning();\n\n\t\treturn updatedEmoji;\n\t}\n\n\tasync deleteEmoji(id: Id<'id'>): Promise<void> {\n\t\tawait db\n\t\t\t.update(customEmojis)\n\t\t\t.set({\n\t\t\t\tisDeleted: true,\n\t\t\t\tdeletedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(customEmojis.id, id));\n\t}\n\n\tasync getAvailableEmojisForUser(userId: UserId): Promise<EmojiWithAvailability[]> {\n\t\t// Get user first to check their unlocked emojis\n\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\t\tif (!user) {\n\t\t\tthrow new Error('User not found');\n\t\t}\n\n\t\t// Get all emojis\n\t\tconst allEmojis = await db.select().from(customEmojis).where(eq(customEmojis.isDeleted, false));\n\n\t\t// Get user's unlocked emojis from direct table field\n\t\tconst unlockedEmojiIds = user.unlockedEmojis || [];\n\n\t\t// Determine emoji availability based on unlock conditions\n\t\treturn allEmojis.map((emoji) => {\n\t\t\tlet isAvailable = false;\n\t\t\tlet unlockRequirement = '';\n\n\t\t\t// Check if emoji is free for all\n\t\t\tif (!emoji.isLocked || emoji.unlockType === 'free') {\n\t\t\t\tisAvailable = true;\n\t\t\t}\n\t\t\t// Check if user has already unlocked this emoji\n\t\t\telse if (unlockedEmojiIds.includes(emoji.id)) {\n\t\t\t\tisAvailable = true;\n\t\t\t}\n\t\t\t// Otherwise set unlock requirements text\n\t\t\telse {\n\t\t\t\tif (emoji.unlockType === 'path_xp') {\n\t\t\t\t\tconst pathName = emoji.requiredPath || 'unknown';\n\t\t\t\t\tunlockRequirement = `Requires ${emoji.requiredPathXP} XP in ${pathName} path`;\n\t\t\t\t} else if (emoji.unlockType === 'shop') {\n\t\t\t\t\tunlockRequirement = 'Available in the shop';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...emoji,\n\t\t\t\tisAvailable,\n\t\t\t\tunlockRequirement: isAvailable ? undefined : unlockRequirement\n\t\t\t};\n\t\t});\n\t}\n\n\tasync unlockEmojiForUser(userId: UserId, emojiId: EmojiId): Promise<void> {\n\t\t// Get user and emoji\n\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\t\tconst [emoji] = await db.select().from(customEmojis).where(eq(customEmojis.id, emojiId));\n\n\t\tif (!user || !emoji) {\n\t\t\tthrow new Error('User or emoji not found');\n\t\t}\n\n\t\tif (!emoji.isLocked) {\n\t\t\treturn; // Emoji is already unlocked for all users\n\t\t}\n\n\t\t// Check if user already has this emoji unlocked\n\t\tconst unlockedEmojis = user.unlockedEmojis || [];\n\t\tif (unlockedEmojis.includes(emojiId)) {\n\t\t\treturn; // User already has this emoji\n\t\t}\n\n\t\t// Add emoji to user's unlocked emojis list\n\t\tawait db\n\t\t\t.update(users)\n\t\t\t.set({\n\t\t\t\tunlockedEmojis: [...unlockedEmojis, emojiId],\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(users.id, userId));\n\t}\n\n\t// Staff Groups methods\n\tasync getUsersInGroup(groupId: GroupId): Promise<User[]> {\n\t\treturn db.select().from(users).where(eq(users.groupId, groupId));\n\t}\n\n\tasync getUserGroups(): Promise<(typeof userGroups.$inferSelect)[]> {\n\t\treturn db.select().from(userGroups).orderBy(userGroups.staffPriority);\n\t}\n\n\tasync getUserGroup(id: Id<'id'>): Promise<typeof userGroups.$inferSelect | undefined> {\n\t\tconst [group] = await db.select().from(userGroups).where(eq(userGroups.id, id));\n\t\treturn group;\n\t}\n\n\t// Forum rules methods\n\tasync getForumRules(section?: string, status?: string): Promise<ForumRule[]> {\n\t\tlet query = db.select().from(forumRules).orderBy(forumRules.position);\n\n\t\tif (section) {\n\t\t\tquery = query.where(eq(forumRules.section, section));\n\t\t}\n\n\t\tif (status) {\n\t\t\tquery = query.where(eq(forumRules.status, status as any));\n\t\t} else {\n\t\t\t// Default to published rules only if no status specified\n\t\t\tquery = query.where(eq(forumRules.status, 'published'));\n\t\t}\n\n\t\tconst rules = await query;\n\t\treturn rules;\n\t}\n\n\tasync getForumRule(id: Id<'id'>): Promise<ForumRule | undefined> {\n\t\tconst [rule] = await db.select().from(forumRules).where(eq(forumRules.id, id));\n\t\treturn rule;\n\t}\n\n\tasync createForumRule(rule: InsertForumRule & { createdBy?: UserId }): Promise<ForumRule> {\n\t\t// Generate content hash for version tracking\n\t\tconst versionHash = Buffer.from(rule.content).toString('base64').substring(0, 20);\n\n\t\tconst [newRule] = await db\n\t\t\t.insert(forumRules)\n\t\t\t.values({\n\t\t\t\t...rule,\n\t\t\t\tlastAgreedVersionHash: versionHash,\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn newRule;\n\t}\n\n\tasync updateForumRule(\n\t\tid: Id<'id'>,\n\t\trule: Partial<ForumRule> & { updatedBy?: number }\n\t): Promise<ForumRule> {\n\t\t// If content is being updated, generate a new version hash\n\t\tlet versionHash = undefined;\n\t\tif (rule.content) {\n\t\t\tversionHash = Buffer.from(rule.content).toString('base64').substring(0, 20);\n\t\t}\n\n\t\tconst [updatedRule] = await db\n\t\t\t.update(forumRules)\n\t\t\t.set({\n\t\t\t\t...rule,\n\t\t\t\t...(versionHash ? { lastAgreedVersionHash: versionHash } : {}),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(forumRules.id, id))\n\t\t\t.returning();\n\n\t\treturn updatedRule;\n\t}\n\n\tasync deleteForumRule(id: Id<'id'>): Promise<void> {\n\t\tawait db.delete(forumRules).where(eq(forumRules.id, id));\n\t}\n\n\tasync getUserRuleAgreements(userId: UserId): Promise<UserRulesAgreement[]> {\n\t\tconst agreements = await db\n\t\t\t.select()\n\t\t\t.from(userRulesAgreements)\n\t\t\t.where(eq(userRulesAgreements.userId, userId));\n\t\treturn agreements;\n\t}\n\n\tasync agreeToRule(userId: UserId, ruleId: Id<'rule'>, versionHash: string): Promise<void> {\n\t\t// Check if the user has already agreed to this rule\n\t\tconst [existingAgreement] = await db\n\t\t\t.select()\n\t\t\t.from(userRulesAgreements)\n\t\t\t.where(and(eq(userRulesAgreements.userId, userId), eq(userRulesAgreements.ruleId, ruleId)));\n\n\t\tif (existingAgreement) {\n\t\t\t// Update the existing agreement with the new version hash\n\t\t\tawait db\n\t\t\t\t.update(userRulesAgreements)\n\t\t\t\t.set({\n\t\t\t\t\tversionHash,\n\t\t\t\t\tagreedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(and(eq(userRulesAgreements.userId, userId), eq(userRulesAgreements.ruleId, ruleId)));\n\t\t} else {\n\t\t\t// Create a new agreement\n\t\t\tawait db.insert(userRulesAgreements).values({\n\t\t\t\tuserId,\n\t\t\t\truleId,\n\t\t\t\tversionHash,\n\t\t\t\tagreedAt: new Date()\n\t\t\t});\n\t\t}\n\t}\n\n\t// Site settings methods\n\tasync getSiteSettings(): Promise<SiteSetting[]> {\n\t\treturn db.select().from(siteSettings);\n\t}\n\n\tasync getSiteSetting(key: string): Promise<SiteSetting | undefined> {\n\t\tconst [setting] = await db.select().from(siteSettings).where(eq(siteSettings.key, key));\n\t\treturn setting;\n\t}\n\n\tasync setSiteSetting(\n\t\tkey: string,\n\t\tvalue: string,\n\t\tvalueType: string = 'string',\n\t\tgroup: string = 'general',\n\t\tdescription: string = '',\n\t\tisPublic: boolean = false\n\t): Promise<SiteSetting> {\n\t\t// Check if setting exists\n\t\tconst existingSetting = await this.getSiteSetting(key);\n\n\t\tif (existingSetting) {\n\t\t\t// Update existing setting\n\t\t\tconst [updatedSetting] = await db\n\t\t\t\t.update(siteSettings)\n\t\t\t\t.set({\n\t\t\t\t\tvalue,\n\t\t\t\t\tvalueType,\n\t\t\t\t\tgroup,\n\t\t\t\t\tdescription,\n\t\t\t\t\tisPublic,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(siteSettings.key, key))\n\t\t\t\t.returning();\n\n\t\t\treturn updatedSetting;\n\t\t} else {\n\t\t\t// Create new setting\n\t\t\tconst [newSetting] = await db\n\t\t\t\t.insert(siteSettings)\n\t\t\t\t.values({\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue,\n\t\t\t\t\tvalueType,\n\t\t\t\t\tgroup,\n\t\t\t\t\tdescription,\n\t\t\t\t\tisPublic,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\treturn newSetting;\n\t\t}\n\t}\n\n\tasync getPublicSiteSettings(): Promise<Record<string, any>> {\n\t\tconst settings = await db.select().from(siteSettings).where(eq(siteSettings.isPublic, true));\n\n\t\t// Convert to a key-value object\n\t\tconst result: Record<string, any> = {};\n\n\t\tsettings.forEach((setting) => {\n\t\t\t// Convert value based on valueType\n\t\t\tlet parsedValue = setting.value;\n\n\t\t\tswitch (setting.valueType) {\n\t\t\t\tcase 'number':\n\t\t\t\t\tparsedValue = Number(setting.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'boolean':\n\t\t\t\t\tparsedValue = setting.value === 'true';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'json':\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparsedValue = JSON.parse(setting.value || '{}');\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogger.error(`Error parsing JSON for setting ${setting.key}:`, error);\n\t\t\t\t\t\tparsedValue = {};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult[setting.key] = parsedValue;\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tasync createUserGroup(\n\t\tgroup: typeof userGroups.$inferInsert\n\t): Promise<typeof userGroups.$inferSelect> {\n\t\tconst [newGroup] = await db\n\t\t\t.insert(userGroups)\n\t\t\t.values({\n\t\t\t\t...group,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn newGroup;\n\t}\n\n\tasync updateUserGroup(\n\t\tid: Id<'id'>,\n\t\tdata: Partial<typeof userGroups.$inferSelect>\n\t): Promise<typeof userGroups.$inferSelect> {\n\t\tconst [updatedGroup] = await db\n\t\t\t.update(userGroups)\n\t\t\t.set({\n\t\t\t\t...data,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(userGroups.id, id))\n\t\t\t.returning();\n\n\t\treturn updatedGroup;\n\t}\n\n\tasync deleteUserGroup(id: Id<'id'>): Promise<void> {\n\t\t// Check if it's a default group\n\t\tconst [group] = await db.select().from(userGroups).where(eq(userGroups.id, id));\n\t\tif (group && group.isDefault) {\n\t\t\tthrow new Error('Cannot delete a default user group');\n\t\t}\n\n\t\t// Reset users in this group to the default group\n\t\tconst [defaultGroup] = await db.select().from(userGroups).where(eq(userGroups.isDefault, true));\n\n\t\tif (defaultGroup) {\n\t\t\tawait db.update(users).set({ groupId: defaultGroup.id }).where(eq(users.groupId, id));\n\t\t}\n\n\t\t// Delete the group\n\t\tawait db.delete(userGroups).where(eq(userGroups.id, id));\n\t}\n\n\t// Shop and products methods\n\tasync getProducts(category?: string): Promise<Product[]> {\n\t\t// Use specific columns to avoid issues with schema changes\n\t\tlet query = db\n\t\t\t.select({\n\t\t\t\tid: products.id,\n\t\t\t\tname: products.name,\n\t\t\t\tdescription: products.description,\n\t\t\t\tprice: products.price,\n\t\t\t\tpointsPrice: products.pointsPrice,\n\t\t\t\tstock: products.stock,\n\t\t\t\tisDeleted: products.isDeleted,\n\t\t\t\tcategoryId: products.categoryId,\n\t\t\t\tavailableFrom: products.availableFrom,\n\t\t\t\tavailableUntil: products.availableUntil,\n\t\t\t\tstockLimit: products.stockLimit,\n\t\t\t\tstatus: products.status,\n\t\t\t\tfeaturedUntil: products.featuredUntil,\n\t\t\t\tpromotionLabel: products.promotionLabel,\n\t\t\t\tmetadata: products.metadata\n\t\t\t})\n\t\t\t.from(products)\n\t\t\t.where(eq(products.isDeleted, false));\n\n\t\tif (category) {\n\t\t\tconst [categoryObj] = await db\n\t\t\t\t.select()\n\t\t\t\t.from(productCategories)\n\t\t\t\t.where(eq(productCategories.name, category));\n\n\t\t\tif (categoryObj) {\n\t\t\t\tquery = query.where(eq(products.categoryId, categoryObj.id));\n\t\t\t}\n\t\t}\n\n\t\treturn query.orderBy(products.name);\n\t}\n\n\tasync getProduct(id: Id<'id'>): Promise<Product | undefined> {\n\t\tconst [product] = await db\n\t\t\t.select({\n\t\t\t\tid: products.id,\n\t\t\t\tname: products.name,\n\t\t\t\tdescription: products.description,\n\t\t\t\tprice: products.price,\n\t\t\t\tpointsPrice: products.pointsPrice,\n\t\t\t\tstock: products.stock,\n\t\t\t\tisDeleted: products.isDeleted,\n\t\t\t\tcategoryId: products.categoryId,\n\t\t\t\tavailableFrom: products.availableFrom,\n\t\t\t\tavailableUntil: products.availableUntil,\n\t\t\t\tstockLimit: products.stockLimit,\n\t\t\t\tstatus: products.status,\n\t\t\t\tfeaturedUntil: products.featuredUntil,\n\t\t\t\tpromotionLabel: products.promotionLabel,\n\t\t\t\tmetadata: products.metadata\n\t\t\t})\n\t\t\t.from(products)\n\t\t\t.where(and(eq(products.id, id), eq(products.isDeleted, false)));\n\n\t\treturn product;\n\t}\n\n\tasync createProduct(product: typeof products.$inferInsert): Promise<Product> {\n\t\tconst [newProduct] = await db\n\t\t\t.insert(products)\n\t\t\t.values({\n\t\t\t\t...product,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn newProduct;\n\t}\n\n\tasync updateProduct(id: Id<'id'>, data: Partial<Product>): Promise<Product> {\n\t\tconst [updatedProduct] = await db\n\t\t\t.update(products)\n\t\t\t.set({\n\t\t\t\t...data,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(products.id, id))\n\t\t\t.returning();\n\n\t\treturn updatedProduct;\n\t}\n\n\tasync deleteProduct(id: Id<'id'>): Promise<void> {\n\t\tawait db\n\t\t\t.update(products)\n\t\t\t.set({\n\t\t\t\tisDeleted: true,\n\t\t\t\tdeletedAt: new Date()\n\t\t\t})\n\t\t\t.where(eq(products.id, id));\n\t}\n\n\tasync purchaseProduct(userId: UserId, productId: ProductId, quantity: number = 1): Promise<Order> {\n\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\t\tconst [product] = await db.select().from(products).where(eq(products.id, productId));\n\n\t\tif (!user || !product) {\n\t\t\tthrow new Error('User or product not found');\n\t\t}\n\n\t\tif (product.stock !== null && product.stock < quantity) {\n\t\t\tthrow new Error('Not enough product in stock');\n\t\t}\n\n\t\tconst totalPrice = product.price * quantity;\n\n\t\tif (user.dgtWalletBalance < totalPrice) {\n\t\t\tthrow new Error('Insufficient wallet balance');\n\t\t}\n\n\t\treturn db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Deduct from wallet\n\t\t\tawait tx\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\tdgtWalletBalance: user.dgtWalletBalance - totalPrice,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\t// Update stock if needed\n\t\t\tif (product.stock !== null) {\n\t\t\t\tawait tx\n\t\t\t\t\t.update(products)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tstock: product.stock - quantity,\n\t\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(products.id, productId));\n\t\t\t}\n\n\t\t\t// Create order\n\t\t\tconst [order] = await tx\n\t\t\t\t.insert(orders)\n\t\t\t\t.values({\n\t\t\t\t\tuserId,\n\t\t\t\t\tstatus: 'completed',\n\t\t\t\t\ttotalAmount: totalPrice,\n\t\t\t\t\tpaymentMethod: 'wallet',\n\t\t\t\t\tnotes: `Purchase of ${quantity} x ${product.name}`,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Create order item\n\t\t\tawait tx.insert(orderItems).values({\n\t\t\t\torderId: order.id,\n\t\t\t\tproductId,\n\t\t\t\tquantity,\n\t\t\t\tprice: product.price,\n\t\t\t\tdiscount: 0\n\t\t\t});\n\n\t\t\t// Record inventory transaction\n\t\t\tawait tx.insert(inventoryTransactions).values({\n\t\t\t\tproductId,\n\t\t\t\ttype: 'sale',\n\t\t\t\tquantity: -quantity,\n\t\t\t\treference: `Order #${order.id}`,\n\t\t\t\tcreatedBy: userId\n\t\t\t});\n\n\t\t\t// Process plugin rewards if any\n\t\t\tif (product.pluginReward) {\n\t\t\t\t// Process emoji unlocks\n\t\t\t\tif (product.pluginReward.emojiUnlocks) {\n\t\t\t\t\tconst emojiIds = product.pluginReward.emojiUnlocks;\n\t\t\t\t\tconst currentUnlocks = user.unlockedEmojis || [];\n\n\t\t\t\t\tawait tx\n\t\t\t\t\t\t.update(users)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tunlockedEmojis: [...new Set([...currentUnlocks, ...emojiIds])]\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(eq(users.id, userId));\n\t\t\t\t}\n\n\t\t\t\t// Process badge unlocks\n\t\t\t\tif (product.pluginReward.badgeUnlocks) {\n\t\t\t\t\tconst badgeIds = product.pluginReward.badgeUnlocks;\n\t\t\t\t\tconst currentUnlocks = user.unlockedBadges || [];\n\n\t\t\t\t\tawait tx\n\t\t\t\t\t\t.update(users)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tunlockedBadges: [...new Set([...currentUnlocks, ...badgeIds])]\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(eq(users.id, userId));\n\t\t\t\t}\n\n\t\t\t\t// Process title unlocks\n\t\t\t\tif (product.pluginReward.titleUnlocks) {\n\t\t\t\t\tconst titleIds = product.pluginReward.titleUnlocks;\n\t\t\t\t\tconst currentUnlocks = user.unlockedTitles || [];\n\n\t\t\t\t\tawait tx\n\t\t\t\t\t\t.update(users)\n\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\tunlockedTitles: [...new Set([...currentUnlocks, ...titleIds])]\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.where(eq(users.id, userId));\n\t\t\t\t}\n\n\t\t\t\t// Process XP rewards\n\t\t\t\tif (product.pluginReward.xpGrant) {\n\t\t\t\t\tconst xpAmount = product.pluginReward.xpGrant.amount || 0;\n\t\t\t\t\tconst pathId = product.pluginReward.xpGrant.pathId;\n\n\t\t\t\t\tif (xpAmount > 0) {\n\t\t\t\t\t\tawait this.addUserXp(userId, xpAmount, pathId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn order;\n\t\t});\n\t}\n\n\t// Messaging system methods\n\tasync getConversations(\n\t\tuserId: UserId\n\t): Promise<(Conversation & { participants: ConversationParticipant[] })[]> {\n\t\t// Get all conversations where user is a participant\n\t\tconst userConversations = await db\n\t\t\t.select({ conversationId: conversationParticipants.conversationId })\n\t\t\t.from(conversationParticipants)\n\t\t\t.where(\n\t\t\t\tand(\n\t\t\t\t\teq(conversationParticipants.userId, userId),\n\t\t\t\t\teq(conversationParticipants.isActive, true)\n\t\t\t\t)\n\t\t\t);\n\n\t\tconst conversationIds = userConversations.map((c) => c.conversationId);\n\n\t\tif (conversationIds.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Get conversation details with participants\n\t\tconst result = await db\n\t\t\t.select({\n\t\t\t\tconversation: conversations,\n\t\t\t\tparticipant: conversationParticipants,\n\t\t\t\tparticipantUser: users\n\t\t\t})\n\t\t\t.from(conversations)\n\t\t\t.innerJoin(\n\t\t\t\tconversationParticipants,\n\t\t\t\teq(conversations.id, conversationParticipants.conversationId)\n\t\t\t)\n\t\t\t.innerJoin(users, eq(conversationParticipants.userId, users.id))\n\t\t\t.where(inArray(conversations.id, conversationIds))\n\t\t\t.orderBy(desc(conversations.lastMessageAt));\n\n\t\t// Group by conversation\n\t\tconst conversationsMap = new Map<\n\t\t\tnumber,\n\t\t\tConversation & { participants: ConversationParticipant[] }\n\t\t>();\n\n\t\tfor (const row of result) {\n\t\t\tif (!conversationsMap.has(row.conversation.id)) {\n\t\t\t\tconversationsMap.set(row.conversation.id, {\n\t\t\t\t\t...row.conversation,\n\t\t\t\t\tparticipants: []\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst convo = conversationsMap.get(row.conversation.id)!;\n\t\t\tconvo.participants.push({\n\t\t\t\t...row.participant,\n\t\t\t\tuser: row.participantUser\n\t\t\t} as unknown as ConversationParticipant);\n\t\t}\n\n\t\treturn Array.from(conversationsMap.values());\n\t}\n\n\tasync getConversation(id: Id<'id'>): Promise<Conversation | undefined> {\n\t\tconst [conversation] = await db.select().from(conversations).where(eq(conversations.id, id));\n\t\treturn conversation;\n\t}\n\n\tasync createConversation(data: {\n\t\ttitle?: string;\n\t\tisGroup: boolean;\n\t\tcreatedBy: UserId;\n\t\tparticipants: UserId[];\n\t}): Promise<Conversation> {\n\t\treturn db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Create the conversation\n\t\t\tconst [conversation] = await tx\n\t\t\t\t.insert(conversations)\n\t\t\t\t.values({\n\t\t\t\t\ttitle: data.title,\n\t\t\t\t\tisGroup: data.isGroup,\n\t\t\t\t\tcreatedBy: data.createdBy,\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\tlastMessageAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Add participants\n\t\t\tconst uniqueParticipants = [...new Set([data.createdBy, ...data.participants])];\n\n\t\t\tfor (const userId of uniqueParticipants) {\n\t\t\t\tawait tx.insert(conversationParticipants).values({\n\t\t\t\t\tconversationId: conversation.id,\n\t\t\t\t\tuserId,\n\t\t\t\t\tisAdmin: userId === data.createdBy,\n\t\t\t\t\tlastReadAt: new Date()\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Create system message about conversation creation\n\t\t\tif (data.isGroup) {\n\t\t\t\tawait tx.insert(messages).values({\n\t\t\t\t\tconversationId: conversation.id,\n\t\t\t\t\tsenderId: data.createdBy,\n\t\t\t\t\tcontent: 'Created this group conversation',\n\t\t\t\t\tsystemMessageType: 'group_created'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn conversation;\n\t\t});\n\t}\n\n\tasync getMessages(\n\t\tconversationId: ConversationId,\n\t\tlimit = 20,\n\t\toffset = 0\n\t): Promise<(Message & { sender: User })[]> {\n\t\treturn db\n\t\t\t.select({\n\t\t\t\t...messages,\n\t\t\t\tsender: users\n\t\t\t})\n\t\t\t.from(messages)\n\t\t\t.innerJoin(users, eq(messages.senderId, users.id))\n\t\t\t.where(and(eq(messages.conversationId, conversationId), eq(messages.isDeleted, false)))\n\t\t\t.orderBy(desc(messages.createdAt))\n\t\t\t.limit(limit)\n\t\t\t.offset(offset);\n\t}\n\n\tasync sendMessage(data: {\n\t\tconversationId: ConversationId;\n\t\tsenderId: UserId;\n\t\tcontent: string;\n\t\tattachmentUrl?: string;\n\t\tattachmentType?: string;\n\t}): Promise<Message> {\n\t\treturn db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Create the message\n\t\t\tconst [message] = await tx\n\t\t\t\t.insert(messages)\n\t\t\t\t.values({\n\t\t\t\t\tconversationId: data.conversationId,\n\t\t\t\t\tsenderId: data.senderId,\n\t\t\t\t\tcontent: data.content,\n\t\t\t\t\tattachmentUrl: data.attachmentUrl,\n\t\t\t\t\tattachmentType: data.attachmentType\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\t// Update conversation last message timestamp\n\t\t\tawait tx\n\t\t\t\t.update(conversations)\n\t\t\t\t.set({\n\t\t\t\t\tlastMessageAt: message.createdAt,\n\t\t\t\t\tupdatedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(eq(conversations.id, data.conversationId));\n\n\t\t\t// Mark as read for the sender\n\t\t\tawait tx.insert(messageReads).values({\n\t\t\t\tmessageId: message.id,\n\t\t\t\tuserId: data.senderId\n\t\t\t});\n\n\t\t\t// Create notifications for other participants\n\t\t\tconst participants = await tx\n\t\t\t\t.select()\n\t\t\t\t.from(conversationParticipants)\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(conversationParticipants.conversationId, data.conversationId),\n\t\t\t\t\t\tne(conversationParticipants.userId, data.senderId),\n\t\t\t\t\t\teq(conversationParticipants.isActive, true),\n\t\t\t\t\t\teq(conversationParticipants.isMuted, false)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tconst [sender] = await tx.select().from(users).where(eq(users.id, data.senderId));\n\t\t\tconst [conversation] = await tx\n\t\t\t\t.select()\n\t\t\t\t.from(conversations)\n\t\t\t\t.where(eq(conversations.id, data.conversationId));\n\n\t\t\tfor (const participant of participants) {\n\t\t\t\tawait tx.insert(notifications).values({\n\t\t\t\t\tuserId: participant.userId,\n\t\t\t\t\ttype: 'private_message',\n\t\t\t\t\ttitle: conversation.isGroup\n\t\t\t\t\t\t? `New message in ${conversation.title || 'group conversation'}`\n\t\t\t\t\t\t: `New message from ${sender.username}`,\n\t\t\t\t\tbody: data.content.substring(0, 100) + (data.content.length > 100 ? '...' : ''),\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tconversationId: data.conversationId,\n\t\t\t\t\t\tmessageId: message.id,\n\t\t\t\t\t\tsenderId: data.senderId\n\t\t\t\t\t},\n\t\t\t\t\tisRead: false\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn message;\n\t\t});\n\t}\n\n\tasync markMessagesAsRead(conversationId: ConversationId, userId: UserId): Promise<void> {\n\t\tawait db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Get unread messages\n\t\t\tconst unreadMessages = await tx\n\t\t\t\t.select()\n\t\t\t\t.from(messages)\n\t\t\t\t.leftJoin(\n\t\t\t\t\tmessageReads,\n\t\t\t\t\tand(eq(messages.id, messageReads.messageId), eq(messageReads.userId, userId))\n\t\t\t\t)\n\t\t\t\t.where(and(eq(messages.conversationId, conversationId), isNull(messageReads.messageId)));\n\n\t\t\t// Mark each as read\n\t\t\tfor (const message of unreadMessages) {\n\t\t\t\tawait tx\n\t\t\t\t\t.insert(messageReads)\n\t\t\t\t\t.values({\n\t\t\t\t\t\tmessageId: message.id,\n\t\t\t\t\t\tuserId\n\t\t\t\t\t})\n\t\t\t\t\t.onConflictDoNothing();\n\t\t\t}\n\n\t\t\t// Update participant's last read timestamp\n\t\t\tawait tx\n\t\t\t\t.update(conversationParticipants)\n\t\t\t\t.set({\n\t\t\t\t\tlastReadAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(\n\t\t\t\t\tand(\n\t\t\t\t\t\teq(conversationParticipants.conversationId, conversationId),\n\t\t\t\t\t\teq(conversationParticipants.userId, userId)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t});\n\t}\n\n\t// XP engine methods\n\tasync addUserXp(userId: UserId, amount: number, path?: string): Promise<void> {\n\t\tif (amount <= 0) return;\n\n\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\t\tif (!user) {\n\t\t\tthrow new Error('User not found');\n\t\t}\n\n\t\tawait db.transaction(async (tx: PgTransaction<any, any, any>) => {\n\t\t\t// Update global XP\n\t\t\tawait tx\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\txp: user.xp + amount\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\t// Update path-specific XP if a path is specified\n\t\t\tif (path) {\n\t\t\t\tconst pathXp = user.pathXp || {};\n\t\t\t\tconst currentPathXp = pathXp[path] || 0;\n\t\t\t\tconst multiplier = (user.pathMultipliers || {})[path] || 1;\n\t\t\t\tconst adjustedAmount = Math.floor(amount * multiplier);\n\n\t\t\t\t// Update path XP\n\t\t\t\tconst newPathXp = {\n\t\t\t\t\t...pathXp,\n\t\t\t\t\t[path]: currentPathXp + adjustedAmount\n\t\t\t\t};\n\n\t\t\t\tawait tx\n\t\t\t\t\t.update(users)\n\t\t\t\t\t.set({\n\t\t\t\t\t\tpathXp: newPathXp\n\t\t\t\t\t})\n\t\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\t\t// Check if user has reached path XP milestones for multiplier updates\n\t\t\t\tawait this.recalculateUserPathMultipliers(userId);\n\n\t\t\t\t// For Category-based XP gain, check for and unlock any eligible emojis\n\t\t\t\tconst emojiUnlocks = await tx\n\t\t\t\t\t.select()\n\t\t\t\t\t.from(customEmojis)\n\t\t\t\t\t.where(\n\t\t\t\t\t\tand(\n\t\t\t\t\t\t\teq(customEmojis.isLocked, true),\n\t\t\t\t\t\t\teq(customEmojis.unlockType, 'path_xp'),\n\t\t\t\t\t\t\teq(customEmojis.requiredPath, path),\n\t\t\t\t\t\t\tlte(customEmojis.requiredPathXP, newPathXp[path])\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\tif (emojiUnlocks.length > 0) {\n\t\t\t\t\tconst currentUnlocks = user.unlockedEmojis || [];\n\t\t\t\t\tconst newUnlocks = emojiUnlocks\n\t\t\t\t\t\t.map((emoji) => emoji.id)\n\t\t\t\t\t\t.filter((id) => !currentUnlocks.includes(id));\n\n\t\t\t\t\tif (newUnlocks.length > 0) {\n\t\t\t\t\t\tawait tx\n\t\t\t\t\t\t\t.update(users)\n\t\t\t\t\t\t\t.set({\n\t\t\t\t\t\t\t\tunlockedEmojis: [...currentUnlocks, ...newUnlocks]\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\t\t\t\t// Create notifications for unlocked emojis\n\t\t\t\t\t\tfor (const emojiId of newUnlocks) {\n\t\t\t\t\t\t\tconst emoji = emojiUnlocks.find((e) => e.id === emojiId);\n\t\t\t\t\t\t\tif (emoji) {\n\t\t\t\t\t\t\t\tawait tx.insert(notifications).values({\n\t\t\t\t\t\t\t\t\tuserId,\n\t\t\t\t\t\t\t\t\ttype: 'achievement',\n\t\t\t\t\t\t\t\t\ttitle: `New Emoji Unlocked: ${emoji.name}`,\n\t\t\t\t\t\t\t\t\tbody: `You've unlocked the ${emoji.name} emoji by reaching ${newPathXp[path]} XP in the ${path} path!`,\n\t\t\t\t\t\t\t\t\tdata: { emojiId },\n\t\t\t\t\t\t\t\t\tisRead: false\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tasync getUserPathXp(userId: UserId, path?: string): Promise<Record<string, number>> {\n\t\tconst [user] = await db\n\t\t\t.select({\n\t\t\t\tpathXp: users.pathXp\n\t\t\t})\n\t\t\t.from(users)\n\t\t\t.where(eq(users.id, userId));\n\n\t\tif (!user) {\n\t\t\tthrow new Error('User not found');\n\t\t}\n\n\t\tconst pathXp = user.pathXp || {};\n\n\t\tif (path) {\n\t\t\treturn { [path]: pathXp[path] || 0 };\n\t\t}\n\n\t\treturn pathXp;\n\t}\n\n\tasync recalculateUserPathMultipliers(userId: UserId): Promise<Record<string, number>> {\n\t\tconst [user] = await db.select().from(users).where(eq(users.id, userId));\n\t\tif (!user) {\n\t\t\tthrow new Error('User not found');\n\t\t}\n\n\t\tconst pathXp = user.pathXp || {};\n\t\tconst currentMultipliers = user.pathMultipliers || {};\n\t\tconst newMultipliers = { ...currentMultipliers };\n\t\tlet multiplierChanged = false;\n\n\t\t// Apply multiplier rules - example rule: 1.2x multiplier at 1000 XP\n\t\tObject.entries(pathXp).forEach(([path, xp]) => {\n\t\t\t// Define multiplier thresholds and values\n\t\t\tlet newMultiplier = 1; // Default multiplier\n\n\t\t\tif (xp >= 5000) {\n\t\t\t\tnewMultiplier = 1.5; // 1.5x multiplier at 5000 XP\n\t\t\t} else if (xp >= 2500) {\n\t\t\t\tnewMultiplier = 1.3; // 1.3x multiplier at 2500 XP\n\t\t\t} else if (xp >= 1000) {\n\t\t\t\tnewMultiplier = 1.2; // 1.2x multiplier at 1000 XP\n\t\t\t}\n\n\t\t\tif (newMultiplier !== (currentMultipliers[path] || 1)) {\n\t\t\t\tnewMultipliers[path] = newMultiplier;\n\t\t\t\tmultiplierChanged = true;\n\t\t\t}\n\t\t});\n\n\t\tif (multiplierChanged) {\n\t\t\tawait db\n\t\t\t\t.update(users)\n\t\t\t\t.set({\n\t\t\t\t\tpathMultipliers: newMultipliers\n\t\t\t\t})\n\t\t\t\t.where(eq(users.id, userId));\n\n\t\t\t// Create notification for multiplier change\n\t\t\tconst changedPaths = Object.entries(newMultipliers)\n\t\t\t\t.filter(([path, multiplier]) => multiplier !== (currentMultipliers[path] || 1))\n\t\t\t\t.map(([path, multiplier]) => ({ path, multiplier }));\n\n\t\t\tfor (const { path, multiplier } of changedPaths) {\n\t\t\t\tawait db.insert(notifications).values({\n\t\t\t\t\tuserId,\n\t\t\t\t\ttype: 'achievement',\n\t\t\t\t\ttitle: `XP Multiplier Increased for ${path}`,\n\t\t\t\t\tbody: `You now earn ${multiplier}x XP in the ${path} path!`,\n\t\t\t\t\tdata: { path, multiplier },\n\t\t\t\t\tisRead: false\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn newMultipliers;\n\t}\n\n\t// User inventory methods\n\tasync getUserInventory(userId: UserId): Promise<UserInventoryItem[]> {\n\t\t// Select only the fields that actually exist in the database\n\t\tconst inventoryItems = await db\n\t\t\t.select({\n\t\t\t\tid: userInventory.id,\n\t\t\t\tuserId: userInventory.userId,\n\t\t\t\tproductId: userInventory.productId,\n\t\t\t\tquantity: userInventory.quantity,\n\t\t\t\tisEquipped: userInventory.isEquipped,\n\t\t\t\tacquiredAt: userInventory.acquiredAt,\n\t\t\t\texpiresAt: userInventory.expiresAt,\n\t\t\t\tlastUsedAt: userInventory.lastUsedAt,\n\t\t\t\ttransactionId: userInventory.transactionId,\n\t\t\t\tmetadata: userInventory.metadata\n\t\t\t})\n\t\t\t.from(userInventory)\n\t\t\t.where(eq(userInventory.userId, userId))\n\t\t\t.orderBy(userInventory.acquiredAt);\n\n\t\treturn inventoryItems;\n\t}\n\n\tasync checkUserOwnsProduct(userId: UserId, productId: ProductId): Promise<boolean> {\n\t\tconst [item] = await db\n\t\t\t.select({\n\t\t\t\tid: userInventory.id\n\t\t\t})\n\t\t\t.from(userInventory)\n\t\t\t.where(and(eq(userInventory.userId, userId), eq(userInventory.productId, productId)));\n\n\t\treturn !!item;\n\t}\n\n\tasync addProductToUserInventory(item: InsertUserInventoryItem): Promise<UserInventoryItem> {\n\t\t// First record the transaction if not already provided\n\t\tlet transactionId: TransactionId | null = null;\n\n\t\tif (item.transactionId === undefined) {\n\t\t\t// Create transaction record if not provided\n\t\t\tconst [transaction] = await db\n\t\t\t\t.insert(inventoryTransactions)\n\t\t\t\t.values({\n\t\t\t\t\tuserId: item.userId,\n\t\t\t\t\tproductId: item.productId,\n\t\t\t\t\ttransactionType: 'PURCHASE',\n\t\t\t\t\tamount: item.quantity || 1,\n\t\t\t\t\tcurrency: 'DGT',\n\t\t\t\t\tcurrencyAmount: 0, // This will be updated if price info is available\n\t\t\t\t\tstatus: 'completed'\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\ttransactionId = transaction.id;\n\t\t} else {\n\t\t\ttransactionId = item.transactionId;\n\t\t}\n\n\t\t// Check if the user already owns this product\n\t\tconst existingItem = await this.checkUserOwnsProduct(item.userId, item.productId);\n\n\t\tif (existingItem) {\n\t\t\t// Update existing inventory item\n\t\t\tconst [updatedItem] = await db\n\t\t\t\t.update(userInventory)\n\t\t\t\t.set({\n\t\t\t\t\tquantity: sql`${userInventory.quantity} + ${item.quantity || 1}`,\n\t\t\t\t\tlastUsedAt: new Date()\n\t\t\t\t})\n\t\t\t\t.where(\n\t\t\t\t\tand(eq(userInventory.userId, item.userId), eq(userInventory.productId, item.productId))\n\t\t\t\t)\n\t\t\t\t.returning();\n\n\t\t\treturn updatedItem;\n\t\t} else {\n\t\t\t// Insert new inventory item\n\t\t\tconst [inventoryItem] = await db\n\t\t\t\t.insert(userInventory)\n\t\t\t\t.values({\n\t\t\t\t\t...item,\n\t\t\t\t\ttransactionId,\n\t\t\t\t\tacquiredAt: new Date()\n\t\t\t\t})\n\t\t\t\t.returning();\n\n\t\t\treturn inventoryItem;\n\t\t}\n\t}\n\n\tasync updateUserInventoryItem(\n\t\tuserId: UserId,\n\t\tproductId: ProductId,\n\t\tupdates: Partial<UserInventoryItem>\n\t): Promise<UserInventoryItem | undefined> {\n\t\tconst [updatedItem] = await db\n\t\t\t.update(userInventory)\n\t\t\t.set(updates)\n\t\t\t.where(and(eq(userInventory.userId, userId), eq(userInventory.productId, productId)))\n\t\t\t.returning();\n\n\t\treturn updatedItem;\n\t}\n\n\tasync getInventoryTransactions(\n\t\tuserId: UserId\n\t): Promise<(typeof inventoryTransactions.$inferSelect)[]> {\n\t\treturn db\n\t\t\t.select()\n\t\t\t.from(inventoryTransactions)\n\t\t\t.where(eq(inventoryTransactions.userId, userId))\n\t\t\t.orderBy(desc(inventoryTransactions.createdAt));\n\t}\n\n\tasync createInventoryTransaction(data: {\n\t\tuserId: UserId;\n\t\tproductId: ProductId;\n\t\ttransactionType: string;\n\t\tamount: number;\n\t\tcurrency: string;\n\t\tcurrencyAmount: number;\n\t\tstatus?: string;\n\t\tmetadata?: Record<string, any>;\n\t}): Promise<typeof inventoryTransactions.$inferSelect> {\n\t\tconst [transaction] = await db\n\t\t\t.insert(inventoryTransactions)\n\t\t\t.values({\n\t\t\t\tuserId: data.userId,\n\t\t\t\tproductId: data.productId,\n\t\t\t\ttransactionType: data.transactionType,\n\t\t\t\tamount: data.amount,\n\t\t\t\tcurrency: data.currency,\n\t\t\t\tcurrencyAmount: data.currencyAmount,\n\t\t\t\tstatus: data.status || 'completed',\n\t\t\t\tmetadata: data.metadata || {},\n\t\t\t\tcreatedAt: new Date()\n\t\t\t})\n\t\t\t.returning();\n\n\t\treturn transaction;\n\t}\n}\n\nexport const storage = new DatabaseStorage();\n","usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]},{"filePath":"/Users/gnarcotic/Degentalk/server/vite.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]}]}]